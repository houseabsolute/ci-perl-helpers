#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Carp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP';
  package Carp;
  
  { use 5.006; }
  use strict;
  use warnings;
  BEGIN {
      # Very old versions of warnings.pm load Carp.  This can go wrong due
      # to the circular dependency.  If warnings is invoked before Carp,
      # then warnings starts by loading Carp, then Carp (above) tries to
      # invoke warnings, and gets nothing because warnings is in the process
      # of loading and hasn't defined its import method yet.  If we were
      # only turning on warnings ("use warnings" above) this wouldn't be too
      # bad, because Carp would just gets the state of the -w switch and so
      # might not get some warnings that it wanted.  The real problem is
      # that we then want to turn off Unicode warnings, but "no warnings
      # 'utf8'" won't be effective if we're in this circular-dependency
      # situation.  So, if warnings.pm is an affected version, we turn
      # off all warnings ourselves by directly setting ${^WARNING_BITS}.
      # On unaffected versions, we turn off just Unicode warnings, via
      # the proper API.
      if(!defined($warnings::VERSION) || eval($warnings::VERSION) < 1.06) {
  	${^WARNING_BITS} = "";
      } else {
  	"warnings"->unimport("utf8");
      }
  }
  
  sub _fetch_sub { # fetch sub without autovivifying
      my($pack, $sub) = @_;
      $pack .= '::';
      # only works with top-level packages
      return unless exists($::{$pack});
      for ($::{$pack}) {
  	return unless ref \$_ eq 'GLOB' && *$_{HASH} && exists $$_{$sub};
  	for ($$_{$sub}) {
  	    return ref \$_ eq 'GLOB' ? *$_{CODE} : undef
  	}
      }
  }
  
  # UTF8_REGEXP_PROBLEM is a compile-time constant indicating whether Carp
  # must avoid applying a regular expression to an upgraded (is_utf8)
  # string.  There are multiple problems, on different Perl versions,
  # that require this to be avoided.  All versions prior to 5.13.8 will
  # load utf8_heavy.pl for the swash system, even if the regexp doesn't
  # use character classes.  Perl 5.6 and Perls [5.11.2, 5.13.11) exhibit
  # specific problems when Carp is being invoked in the aftermath of a
  # syntax error.
  BEGIN {
      if("$]" < 5.013011) {
  	*UTF8_REGEXP_PROBLEM = sub () { 1 };
      } else {
  	*UTF8_REGEXP_PROBLEM = sub () { 0 };
      }
  }
  
  # is_utf8() is essentially the utf8::is_utf8() function, which indicates
  # whether a string is represented in the upgraded form (using UTF-8
  # internally).  As utf8::is_utf8() is only available from Perl 5.8
  # onwards, extra effort is required here to make it work on Perl 5.6.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'is_utf8')) {
  	*is_utf8 = $sub;
      } else {
  	# black magic for perl 5.6
  	*is_utf8 = sub { unpack("C", "\xaa".$_[0]) != 170 };
      }
  }
  
  # The downgrade() function defined here is to be used for attempts to
  # downgrade where it is acceptable to fail.  It must be called with a
  # second argument that is a true value.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'downgrade')) {
  	*downgrade = \&{"utf8::downgrade"};
      } else {
  	*downgrade = sub {
  	    my $r = "";
  	    my $l = length($_[0]);
  	    for(my $i = 0; $i != $l; $i++) {
  		my $o = ord(substr($_[0], $i, 1));
  		return if $o > 255;
  		$r .= chr($o);
  	    }
  	    $_[0] = $r;
  	};
      }
  }
  
  # is_safe_printable_codepoint() indicates whether a character, specified
  # by integer codepoint, is OK to output literally in a trace.  Generally
  # this is if it is a printable character in the ancestral character set
  # (ASCII or EBCDIC).  This is used on some Perls in situations where a
  # regexp can't be used.
  BEGIN {
      *is_safe_printable_codepoint =
  	"$]" >= 5.007_003 ?
  	    eval(q(sub ($) {
  		my $u = utf8::native_to_unicode($_[0]);
  		$u >= 0x20 && $u <= 0x7e;
  	    }))
  	: ord("A") == 65 ?
  	    sub ($) { $_[0] >= 0x20 && $_[0] <= 0x7e }
  	:
  	    sub ($) {
  		# Early EBCDIC
  		# 3 EBCDIC code pages supported then;  all controls but one
  		# are the code points below SPACE.  The other one is 0x5F on
  		# POSIX-BC; FF on the other two.
  		# FIXME: there are plenty of unprintable codepoints other
  		# than those that this code and the comment above identifies
  		# as "controls".
  		$_[0] >= ord(" ") && $_[0] <= 0xff &&
  		    $_[0] != (ord ("^") == 106 ? 0x5f : 0xff);
  	    }
  	;
  }
  
  sub _univ_mod_loaded {
      return 0 unless exists($::{"UNIVERSAL::"});
      for ($::{"UNIVERSAL::"}) {
  	return 0 unless ref \$_ eq "GLOB" && *$_{HASH} && exists $$_{"$_[0]::"};
  	for ($$_{"$_[0]::"}) {
  	    return 0 unless ref \$_ eq "GLOB" && *$_{HASH} && exists $$_{"VERSION"};
  	    for ($$_{"VERSION"}) {
  		return 0 unless ref \$_ eq "GLOB";
  		return ${*$_{SCALAR}};
  	    }
  	}
      }
  }
  
  # _maybe_isa() is usually the UNIVERSAL::isa function.  We have to avoid
  # the latter if the UNIVERSAL::isa module has been loaded, to avoid infi-
  # nite recursion; in that case _maybe_isa simply returns true.
  my $isa;
  BEGIN {
      if (_univ_mod_loaded('isa')) {
          *_maybe_isa = sub { 1 }
      }
      else {
          # Since we have already done the check, record $isa for use below
          # when defining _StrVal.
          *_maybe_isa = $isa = _fetch_sub(UNIVERSAL => "isa");
      }
  }
  
  
  # We need an overload::StrVal or equivalent function, but we must avoid
  # loading any modules on demand, as Carp is used from __DIE__ handlers and
  # may be invoked after a syntax error.
  # We can copy recent implementations of overload::StrVal and use
  # overloading.pm, which is the fastest implementation, so long as
  # overloading is available.  If it is not available, we use our own pure-
  # Perl StrVal.  We never actually use overload::StrVal, for various rea-
  # sons described below.
  # overload versions are as follows:
  #     undef-1.00 (up to perl 5.8.0)   uses bless (avoid!)
  #     1.01-1.17  (perl 5.8.1 to 5.14) uses Scalar::Util
  #     1.18+      (perl 5.16+)         uses overloading
  # The ancient 'bless' implementation (that inspires our pure-Perl version)
  # blesses unblessed references and must be avoided.  Those using
  # Scalar::Util use refaddr, possibly the pure-Perl implementation, which
  # has the same blessing bug, and must be avoided.  Also, Scalar::Util is
  # loaded on demand.  Since we avoid the Scalar::Util implementations, we
  # end up having to implement our own overloading.pm-based version for perl
  # 5.10.1 to 5.14.  Since it also works just as well in more recent ver-
  # sions, we use it there, too.
  BEGIN {
      if (eval { require "overloading.pm" }) {
          *_StrVal = eval 'sub { no overloading; "$_[0]" }'
      }
      else {
          # Work around the UNIVERSAL::can/isa modules to avoid recursion.
  
          # _mycan is either UNIVERSAL::can, or, in the presence of an
          # override, overload::mycan.
          *_mycan = _univ_mod_loaded('can')
              ? do { require "overload.pm"; _fetch_sub overload => 'mycan' }
              : \&UNIVERSAL::can;
  
          # _blessed is either UNIVERAL::isa(...), or, in the presence of an
          # override, a hideous, but fairly reliable, workaround.
          *_blessed = $isa
              ? sub { &$isa($_[0], "UNIVERSAL") }
              : sub {
                  my $probe = "UNIVERSAL::Carp_probe_" . rand;
                  no strict 'refs';
                  local *$probe = sub { "unlikely string" };
                  local $@;
                  local $SIG{__DIE__} = sub{};
                  (eval { $_[0]->$probe } || '') eq 'unlikely string'
                };
  
          *_StrVal = sub {
              my $pack = ref $_[0];
              # Perl's overload mechanism uses the presence of a special
              # "method" named "((" or "()" to signal it is in effect.
              # This test seeks to see if it has been set up.  "((" post-
              # dates overloading.pm, so we can skip it.
              return "$_[0]" unless _mycan($pack, "()");
              # Even at this point, the invocant may not be blessed, so
              # check for that.
              return "$_[0]" if not _blessed($_[0]);
              bless $_[0], "Carp";
              my $str = "$_[0]";
              bless $_[0], $pack;
              $pack . substr $str, index $str, "=";
          }
      }
  }
  
  
  our $VERSION = '1.50';
  $VERSION =~ tr/_//d;
  
  our $MaxEvalLen = 0;
  our $Verbose    = 0;
  our $CarpLevel  = 0;
  our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
  our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
  our $RefArgFormatter = undef; # allow caller to format reference arguments
  
  require Exporter;
  our @ISA       = ('Exporter');
  our @EXPORT    = qw(confess croak carp);
  our @EXPORT_OK = qw(cluck verbose longmess shortmess);
  our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
  
  # The members of %Internal are packages that are internal to perl.
  # Carp will not report errors from within these packages if it
  # can.  The members of %CarpInternal are internal to Perl's warning
  # system.  Carp will not report errors from within these packages
  # either, and will not report calls *to* these packages for carp and
  # croak.  They replace $CarpLevel, which is deprecated.    The
  # $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
  # text and function arguments should be formatted when printed.
  
  our %CarpInternal;
  our %Internal;
  
  # disable these by default, so they can live w/o require Carp
  $CarpInternal{Carp}++;
  $CarpInternal{warnings}++;
  $Internal{Exporter}++;
  $Internal{'Exporter::Heavy'}++;
  
  # if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
  # then the following method will be called by the Exporter which knows
  # to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
  # 'verbose'.
  
  sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
  
  sub _cgc {
      no strict 'refs';
      return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
      return;
  }
  
  sub longmess {
      local($!, $^E);
      # Icky backwards compatibility wrapper. :-(
      #
      # The story is that the original implementation hard-coded the
      # number of call levels to go back, so calls to longmess were off
      # by one.  Other code began calling longmess and expecting this
      # behaviour, so the replacement has to emulate that behaviour.
      my $cgc = _cgc();
      my $call_pack = $cgc ? $cgc->() : caller();
      if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
          return longmess_heavy(@_);
      }
      else {
          local $CarpLevel = $CarpLevel + 1;
          return longmess_heavy(@_);
      }
  }
  
  our @CARP_NOT;
  
  sub shortmess {
      local($!, $^E);
      my $cgc = _cgc();
  
      # Icky backwards compatibility wrapper. :-(
      local @CARP_NOT = $cgc ? $cgc->() : caller();
      shortmess_heavy(@_);
  }
  
  sub croak   { die shortmess @_ }
  sub confess { die longmess @_ }
  sub carp    { warn shortmess @_ }
  sub cluck   { warn longmess @_ }
  
  BEGIN {
      if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
  	    ("$]" >= 5.012005 && "$]" < 5.013)) {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
      } else {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
      }
  }
  
  sub caller_info {
      my $i = shift(@_) + 1;
      my %call_info;
      my $cgc = _cgc();
      {
  	# Some things override caller() but forget to implement the
  	# @DB::args part of it, which we need.  We check for this by
  	# pre-populating @DB::args with a sentinel which no-one else
  	# has the address of, so that we can detect whether @DB::args
  	# has been properly populated.  However, on earlier versions
  	# of perl this check tickles a bug in CORE::caller() which
  	# leaks memory.  So we only check on fixed perls.
          @DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
          package DB;
          @call_info{
              qw(pack file line sub has_args wantarray evaltext is_require) }
              = $cgc ? $cgc->($i) : caller($i);
      }
  
      unless ( defined $call_info{file} ) {
          return ();
      }
  
      my $sub_name = Carp::get_subname( \%call_info );
      if ( $call_info{has_args} ) {
          # Guard our serialization of the stack from stack refcounting bugs
          # NOTE this is NOT a complete solution, we cannot 100% guard against
          # these bugs.  However in many cases Perl *is* capable of detecting
          # them and throws an error when it does.  Unfortunately serializing
          # the arguments on the stack is a perfect way of finding these bugs,
          # even when they would not affect normal program flow that did not
          # poke around inside the stack.  Inside of Carp.pm it makes little
          # sense reporting these bugs, as Carp's job is to report the callers
          # errors, not the ones it might happen to tickle while doing so.
          # See: https://rt.perl.org/Public/Bug/Display.html?id=131046
          # and: https://rt.perl.org/Public/Bug/Display.html?id=52610
          # for more details and discussion. - Yves
          my @args = map {
                  my $arg;
                  local $@= $@;
                  eval {
                      $arg = $_;
                      1;
                  } or do {
                      $arg = '** argument not available anymore **';
                  };
                  $arg;
              } @DB::args;
          if (CALLER_OVERRIDE_CHECK_OK && @args == 1
              && ref $args[0] eq ref \$i
              && $args[0] == \$i ) {
              @args = ();    # Don't let anyone see the address of $i
              local $@;
              my $where = eval {
                  my $func    = $cgc or return '';
                  my $gv      =
                      (_fetch_sub B => 'svref_2object' or return '')
                          ->($func)->GV;
                  my $package = $gv->STASH->NAME;
                  my $subname = $gv->NAME;
                  return unless defined $package && defined $subname;
  
                  # returning CORE::GLOBAL::caller isn't useful for tracing the cause:
                  return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
                  " in &${package}::$subname";
              } || '';
              @args
                  = "** Incomplete caller override detected$where; \@DB::args were not set **";
          }
          else {
              my $overflow;
              if ( $MaxArgNums and @args > $MaxArgNums )
              {    # More than we want to show?
                  $#args = $MaxArgNums - 1;
                  $overflow = 1;
              }
  
              @args = map { Carp::format_arg($_) } @args;
  
              if ($overflow) {
                  push @args, '...';
              }
          }
  
          # Push the args onto the subroutine
          $sub_name .= '(' . join( ', ', @args ) . ')';
      }
      $call_info{sub_name} = $sub_name;
      return wantarray() ? %call_info : \%call_info;
  }
  
  # Transform an argument to a function into a string.
  our $in_recurse;
  sub format_arg {
      my $arg = shift;
  
      if ( my $pack= ref($arg) ) {
  
           # legitimate, let's not leak it.
          if (!$in_recurse && _maybe_isa( $arg, 'UNIVERSAL' ) &&
  	    do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg->can('CARP_TRACE') }
              })
          {
              return $arg->CARP_TRACE();
          }
          elsif (!$in_recurse &&
  	       defined($RefArgFormatter) &&
  	       do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg = $RefArgFormatter->($arg); 1}
                  })
          {
              return $arg;
          }
          else
          {
              # Argument may be blessed into a class with overloading, and so
              # might have an overloaded stringification.  We don't want to
              # risk getting the overloaded stringification, so we need to
              # use _StrVal, our overload::StrVal()-equivalent.
              return _StrVal $arg;
          }
      }
      return "undef" if !defined($arg);
      downgrade($arg, 1);
      return $arg if !(UTF8_REGEXP_PROBLEM && is_utf8($arg)) &&
  	    $arg =~ /\A-?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\z/;
      my $suffix = "";
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...";
      }
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $c = substr($arg, $i, 1);
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  	    if($c eq "\"" || $c eq "\\" || $c eq "\$" || $c eq "\@") {
  		substr $arg, $i, 0, "\\";
  		next;
  	    }
  	    my $o = ord($c);
  	    substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		unless is_safe_printable_codepoint($o);
  	}
      } else {
  	$arg =~ s/([\"\\\$\@])/\\$1/g;
          # This is all the ASCII printables spelled-out.  It is portable to all
          # Perl versions and platforms (such as EBCDIC).  There are other more
          # compact ways to do this, but may not work everywhere every version.
          $arg =~ s/([^ !"#\$\%\&'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      return "\"".$arg."\"".$suffix;
  }
  
  sub Regexp::CARP_TRACE {
      my $arg = "$_[0]";
      downgrade($arg, 1);
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $o = ord(substr($arg, $i, 1));
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  	    substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		unless is_safe_printable_codepoint($o);
  	}
      } else {
          # See comment in format_arg() about this same regex.
          $arg =~ s/([^ !"#\$\%\&'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      my $suffix = "";
      if($arg =~ /\A\(\?\^?([a-z]*)(?:-[a-z]*)?:(.*)\)\z/s) {
  	($suffix, $arg) = ($1, $2);
      }
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...".$suffix;
      }
      return "qr($arg)$suffix";
  }
  
  # Takes an inheritance cache and a package and returns
  # an anon hash of known inheritances and anon array of
  # inheritances which consequences have not been figured
  # for.
  sub get_status {
      my $cache = shift;
      my $pkg   = shift;
      $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
      return @{ $cache->{$pkg} };
  }
  
  # Takes the info from caller() and figures out the name of
  # the sub/require/eval
  sub get_subname {
      my $info = shift;
      if ( defined( $info->{evaltext} ) ) {
          my $eval = $info->{evaltext};
          if ( $info->{is_require} ) {
              return "require $eval";
          }
          else {
              $eval =~ s/([\\\'])/\\$1/g;
              return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
          }
      }
  
      # this can happen on older perls when the sub (or the stash containing it)
      # has been deleted
      if ( !defined( $info->{sub} ) ) {
          return '__ANON__::__ANON__';
      }
  
      return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
  }
  
  # Figures out what call (from the point of view of the caller)
  # the long error backtrace should start at.
  sub long_error_loc {
      my $i;
      my $lvl = $CarpLevel;
      {
          ++$i;
          my $cgc = _cgc();
          my @caller = $cgc ? $cgc->($i) : caller($i);
          my $pkg = $caller[0];
          unless ( defined($pkg) ) {
  
              # This *shouldn't* happen.
              if (%Internal) {
                  local %Internal;
                  $i = long_error_loc();
                  last;
              }
              elsif (defined $caller[2]) {
                  # this can happen when the stash has been deleted
                  # in that case, just assume that it's a reasonable place to
                  # stop (the file and line data will still be intact in any
                  # case) - the only issue is that we can't detect if the
                  # deleted package was internal (so don't do that then)
                  # -doy
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 2;
              }
          }
          redo if $CarpInternal{$pkg};
          redo unless 0 > --$lvl;
          redo if $Internal{$pkg};
      }
      return $i - 1;
  }
  
  sub longmess_heavy {
      if ( ref( $_[0] ) ) {   # don't break references as exceptions
          return wantarray ? @_ : $_[0];
      }
      my $i = long_error_loc();
      return ret_backtrace( $i, @_ );
  }
  
  BEGIN {
      if("$]" >= 5.017004) {
          # The LAST_FH constant is a reference to the variable.
          $Carp::{LAST_FH} = \eval '\${^LAST_FH}';
      } else {
          eval '*LAST_FH = sub () { 0 }';
      }
  }
  
  # Returns a full stack backtrace starting from where it is
  # told.
  sub ret_backtrace {
      my ( $i, @error ) = @_;
      my $mess;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      $mess = "$err at $i{file} line $i{line}$tid_msg";
      if( $. ) {
        # Use ${^LAST_FH} if available.
        if (LAST_FH) {
          if (${+LAST_FH}) {
              $mess .= sprintf ", <%s> %s %d",
                                *${+LAST_FH}{NAME},
                                ($/ eq "\n" ? "line" : "chunk"), $.
          }
        }
        else {
          local $@ = '';
          local $SIG{__DIE__};
          eval {
              CORE::die;
          };
          if($@ =~ /^Died at .*(, <.*?> (?:line|chunk) \d+).$/ ) {
              $mess .= $1;
          }
        }
      }
      $mess .= "\.\n";
  
      while ( my %i = caller_info( ++$i ) ) {
          $mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
      }
  
      return $mess;
  }
  
  sub ret_summary {
      my ( $i, @error ) = @_;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      return "$err at $i{file} line $i{line}$tid_msg\.\n";
  }
  
  sub short_error_loc {
      # You have to create your (hash)ref out here, rather than defaulting it
      # inside trusts *on a lexical*, as you want it to persist across calls.
      # (You can default it on $_[2], but that gets messy)
      my $cache = {};
      my $i     = 1;
      my $lvl   = $CarpLevel;
      {
          my $cgc = _cgc();
          my $called = $cgc ? $cgc->($i) : caller($i);
          $i++;
          my $caller = $cgc ? $cgc->($i) : caller($i);
  
          if (!defined($caller)) {
              my @caller = $cgc ? $cgc->($i) : caller($i);
              if (@caller) {
                  # if there's no package but there is other caller info, then
                  # the package has been deleted - treat this as a valid package
                  # in this case
                  redo if defined($called) && $CarpInternal{$called};
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 0;
              }
          }
          redo if $Internal{$caller};
          redo if $CarpInternal{$caller};
          redo if $CarpInternal{$called};
          redo if trusts( $called, $caller, $cache );
          redo if trusts( $caller, $called, $cache );
          redo unless 0 > --$lvl;
      }
      return $i - 1;
  }
  
  sub shortmess_heavy {
      return longmess_heavy(@_) if $Verbose;
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = short_error_loc();
      if ($i) {
          ret_summary( $i, @_ );
      }
      else {
          longmess_heavy(@_);
      }
  }
  
  # If a string is too long, trims it with ...
  sub str_len_trim {
      my $str = shift;
      my $max = shift || 0;
      if ( 2 < $max and $max < length($str) ) {
          substr( $str, $max - 3 ) = '...';
      }
      return $str;
  }
  
  # Takes two packages and an optional cache.  Says whether the
  # first inherits from the second.
  #
  # Recursive versions of this have to work to avoid certain
  # possible endless loops, and when following long chains of
  # inheritance are less efficient.
  sub trusts {
      my $child  = shift;
      my $parent = shift;
      my $cache  = shift;
      my ( $known, $partial ) = get_status( $cache, $child );
  
      # Figure out consequences until we have an answer
      while ( @$partial and not exists $known->{$parent} ) {
          my $anc = shift @$partial;
          next if exists $known->{$anc};
          $known->{$anc}++;
          my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
          my @found = keys %$anc_knows;
          @$known{@found} = ();
          push @$partial, @$anc_partial;
      }
      return exists $known->{$parent};
  }
  
  # Takes a package and gives a list of those trusted directly
  sub trusts_directly {
      my $class = shift;
      no strict 'refs';
      my $stash = \%{"$class\::"};
      for my $var (qw/ CARP_NOT ISA /) {
          # Don't try using the variable until we know it exists,
          # to avoid polluting the caller's namespace.
          if ( $stash->{$var} && ref \$stash->{$var} eq 'GLOB'
            && *{$stash->{$var}}{ARRAY} && @{$stash->{$var}} ) {
             return @{$stash->{$var}}
          }
      }
      return;
  }
  
  if(!defined($warnings::VERSION) ||
  	do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
      # Very old versions of warnings.pm import from Carp.  This can go
      # wrong due to the circular dependency.  If Carp is invoked before
      # warnings, then Carp starts by loading warnings, then warnings
      # tries to import from Carp, and gets nothing because Carp is in
      # the process of loading and hasn't defined its import method yet.
      # So we work around that by manually exporting to warnings here.
      no strict "refs";
      *{"warnings::$_"} = \&$_ foreach @EXPORT;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Carp - alternative warn and die for modules
  
  =head1 SYNOPSIS
  
      use Carp;
  
      # warn user (from perspective of caller)
      carp "string trimmed to 80 chars";
  
      # die of errors (from perspective of caller)
      croak "We're outta here!";
  
      # die of errors with stack backtrace
      confess "not implemented";
  
      # cluck, longmess and shortmess not exported by default
      use Carp qw(cluck longmess shortmess);
      cluck "This is how we got here!"; # warn with stack backtrace
      $long_message   = longmess( "message from cluck() or confess()" );
      $short_message  = shortmess( "message from carp() or croak()" );
  
  =head1 DESCRIPTION
  
  The Carp routines are useful in your own modules because
  they act like C<die()> or C<warn()>, but with a message which is more
  likely to be useful to a user of your module.  In the case of
  C<cluck()> and C<confess()>, that context is a summary of every
  call in the call-stack; C<longmess()> returns the contents of the error
  message.
  
  For a shorter message you can use C<carp()> or C<croak()> which report the
  error as being from where your module was called.  C<shortmess()> returns the
  contents of this error message.  There is no guarantee that that is where the
  error was, but it is a good educated guess.
  
  C<Carp> takes care not to clobber the status variables C<$!> and C<$^E>
  in the course of assembling its error messages.  This means that a
  C<$SIG{__DIE__}> or C<$SIG{__WARN__}> handler can capture the error
  information held in those variables, if it is required to augment the
  error message, and if the code calling C<Carp> left useful values there.
  Of course, C<Carp> can't guarantee the latter.
  
  You can also alter the way the output and logic of C<Carp> works, by
  changing some global variables in the C<Carp> namespace. See the
  section on C<GLOBAL VARIABLES> below.
  
  Here is a more complete description of how C<carp> and C<croak> work.
  What they do is search the call-stack for a function call stack where
  they have not been told that there shouldn't be an error.  If every
  call is marked safe, they give up and give a full stack backtrace
  instead.  In other words they presume that the first likely looking
  potential suspect is guilty.  Their rules for telling whether
  a call shouldn't generate errors work as follows:
  
  =over 4
  
  =item 1.
  
  Any call from a package to itself is safe.
  
  =item 2.
  
  Packages claim that there won't be errors on calls to or from
  packages explicitly marked as safe by inclusion in C<@CARP_NOT>, or
  (if that array is empty) C<@ISA>.  The ability to override what
  @ISA says is new in 5.8.
  
  =item 3.
  
  The trust in item 2 is transitive.  If A trusts B, and B
  trusts C, then A trusts C.  So if you do not override C<@ISA>
  with C<@CARP_NOT>, then this trust relationship is identical to,
  "inherits from".
  
  =item 4.
  
  Any call from an internal Perl module is safe.  (Nothing keeps
  user modules from marking themselves as internal to Perl, but
  this practice is discouraged.)
  
  =item 5.
  
  Any call to Perl's warning system (eg Carp itself) is safe.
  (This rule is what keeps it from reporting the error at the
  point where you call C<carp> or C<croak>.)
  
  =item 6.
  
  C<$Carp::CarpLevel> can be set to skip a fixed number of additional
  call levels.  Using this is not recommended because it is very
  difficult to get it to behave correctly.
  
  =back
  
  =head2 Forcing a Stack Trace
  
  As a debugging aid, you can force Carp to treat a croak as a confess
  and a carp as a cluck across I<all> modules. In other words, force a
  detailed stack trace to be given.  This can be very helpful when trying
  to understand why, or from where, a warning or error is being generated.
  
  This feature is enabled by 'importing' the non-existent symbol
  'verbose'. You would typically enable it by saying
  
      perl -MCarp=verbose script.pl
  
  or by including the string C<-MCarp=verbose> in the PERL5OPT
  environment variable.
  
  Alternately, you can set the global variable C<$Carp::Verbose> to true.
  See the C<GLOBAL VARIABLES> section below.
  
  =head2 Stack Trace formatting
  
  At each stack level, the subroutine's name is displayed along with
  its parameters.  For simple scalars, this is sufficient.  For complex
  data types, such as objects and other references, this can simply
  display C<'HASH(0x1ab36d8)'>.
  
  Carp gives two ways to control this.
  
  =over 4
  
  =item 1.
  
  For objects, a method, C<CARP_TRACE>, will be called, if it exists.  If
  this method doesn't exist, or it recurses into C<Carp>, or it otherwise
  throws an exception, this is skipped, and Carp moves on to the next option,
  otherwise checking stops and the string returned is used.  It is recommended
  that the object's type is part of the string to make debugging easier.
  
  =item 2.
  
  For any type of reference, C<$Carp::RefArgFormatter> is checked (see below).
  This variable is expected to be a code reference, and the current parameter
  is passed in.  If this function doesn't exist (the variable is undef), or
  it recurses into C<Carp>, or it otherwise throws an exception, this is
  skipped, and Carp moves on to the next option, otherwise checking stops
  and the string returned is used.
  
  =item 3.
  
  Otherwise, if neither C<CARP_TRACE> nor C<$Carp::RefArgFormatter> is
  available, stringify the value ignoring any overloading.
  
  =back
  
  =head1 GLOBAL VARIABLES
  
  =head2 $Carp::MaxEvalLen
  
  This variable determines how many characters of a string-eval are to
  be shown in the output. Use a value of C<0> to show all text.
  
  Defaults to C<0>.
  
  =head2 $Carp::MaxArgLen
  
  This variable determines how many characters of each argument to a
  function to print. Use a value of C<0> to show the full length of the
  argument.
  
  Defaults to C<64>.
  
  =head2 $Carp::MaxArgNums
  
  This variable determines how many arguments to each function to show.
  Use a false value to show all arguments to a function call.  To suppress all
  arguments, use C<-1> or C<'0 but true'>.
  
  Defaults to C<8>.
  
  =head2 $Carp::Verbose
  
  This variable makes C<carp()> and C<croak()> generate stack backtraces
  just like C<cluck()> and C<confess()>.  This is how C<use Carp 'verbose'>
  is implemented internally.
  
  Defaults to C<0>.
  
  =head2 $Carp::RefArgFormatter
  
  This variable sets a general argument formatter to display references.
  Plain scalars and objects that implement C<CARP_TRACE> will not go through
  this formatter.  Calling C<Carp> from within this function is not supported.
  
  local $Carp::RefArgFormatter = sub {
      require Data::Dumper;
      Data::Dumper::Dump($_[0]); # not necessarily safe
  };
  
  =head2 @CARP_NOT
  
  This variable, I<in your package>, says which packages are I<not> to be
  considered as the location of an error. The C<carp()> and C<cluck()>
  functions will skip over callers when reporting where an error occurred.
  
  NB: This variable must be in the package's symbol table, thus:
  
      # These work
      our @CARP_NOT; # file scope
      use vars qw(@CARP_NOT); # package scope
      @My::Package::CARP_NOT = ... ; # explicit package variable
  
      # These don't work
      sub xyz { ... @CARP_NOT = ... } # w/o declarations above
      my @CARP_NOT; # even at top-level
  
  Example of use:
  
      package My::Carping::Package;
      use Carp;
      our @CARP_NOT;
      sub bar     { .... or _error('Wrong input') }
      sub _error  {
          # temporary control of where'ness, __PACKAGE__ is implicit
          local @CARP_NOT = qw(My::Friendly::Caller);
          carp(@_)
      }
  
  This would make C<Carp> report the error as coming from a caller not
  in C<My::Carping::Package>, nor from C<My::Friendly::Caller>.
  
  Also read the L</DESCRIPTION> section above, about how C<Carp> decides
  where the error is reported from.
  
  Use C<@CARP_NOT>, instead of C<$Carp::CarpLevel>.
  
  Overrides C<Carp>'s use of C<@ISA>.
  
  =head2 %Carp::Internal
  
  This says what packages are internal to Perl.  C<Carp> will never
  report an error as being from a line in a package that is internal to
  Perl.  For example:
  
      $Carp::Internal{ (__PACKAGE__) }++;
      # time passes...
      sub foo { ... or confess("whatever") };
  
  would give a full stack backtrace starting from the first caller
  outside of __PACKAGE__.  (Unless that package was also internal to
  Perl.)
  
  =head2 %Carp::CarpInternal
  
  This says which packages are internal to Perl's warning system.  For
  generating a full stack backtrace this is the same as being internal
  to Perl, the stack backtrace will not start inside packages that are
  listed in C<%Carp::CarpInternal>.  But it is slightly different for
  the summary message generated by C<carp> or C<croak>.  There errors
  will not be reported on any lines that are calling packages in
  C<%Carp::CarpInternal>.
  
  For example C<Carp> itself is listed in C<%Carp::CarpInternal>.
  Therefore the full stack backtrace from C<confess> will not start
  inside of C<Carp>, and the short message from calling C<croak> is
  not placed on the line where C<croak> was called.
  
  =head2 $Carp::CarpLevel
  
  This variable determines how many additional call frames are to be
  skipped that would not otherwise be when reporting where an error
  occurred on a call to one of C<Carp>'s functions.  It is fairly easy
  to count these call frames on calls that generate a full stack
  backtrace.  However it is much harder to do this accounting for calls
  that generate a short message.  Usually people skip too many call
  frames.  If they are lucky they skip enough that C<Carp> goes all of
  the way through the call stack, realizes that something is wrong, and
  then generates a full stack backtrace.  If they are unlucky then the
  error is reported from somewhere misleading very high in the call
  stack.
  
  Therefore it is best to avoid C<$Carp::CarpLevel>.  Instead use
  C<@CARP_NOT>, C<%Carp::Internal> and C<%Carp::CarpInternal>.
  
  Defaults to C<0>.
  
  =head1 BUGS
  
  The Carp routines don't handle exception objects currently.
  If called with a first argument that is a reference, they simply
  call die() or warn(), as appropriate.
  
  =head1 SEE ALSO
  
  L<Carp::Always>,
  L<Carp::Clan>
  
  =head1 CONTRIBUTING
  
  L<Carp> is maintained by the perl 5 porters as part of the core perl 5
  version control repository. Please see the L<perlhack> perldoc for how to
  submit patches and contribute to it.
  
  =head1 AUTHOR
  
  The Carp module first appeared in Larry Wall's perl 5.000 distribution.
  Since then it has been modified by several of the perl 5 porters.
  Andrew Main (Zefram) <zefram@fysh.org> divested Carp into an independent
  distribution.
  
  =head1 COPYRIGHT
  
  Copyright (C) 1994-2013 Larry Wall
  
  Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
CARP

$fatpacked{"Carp/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_HEAVY';
  package Carp::Heavy;
  
  use Carp ();
  
  our $VERSION = '1.50';
  $VERSION =~ tr/_//d;
  
  # Carp::Heavy was merged into Carp in version 1.12.  Any mismatched versions
  # after this point are not significant and can be ignored.
  if(($Carp::VERSION || 0) < 1.12) {
  	my $cv = defined($Carp::VERSION) ? $Carp::VERSION : "undef";
  	die "Version mismatch between Carp $cv ($INC{q(Carp.pm)}) and Carp::Heavy $VERSION ($INC{q(Carp/Heavy.pm)}).  Did you alter \@INC after Carp was loaded?\n";
  }
  
  1;
  
  # Most of the machinery of Carp used to be here.
  # It has been moved in Carp.pm now, but this placeholder remains for
  # the benefit of modules that like to preload Carp::Heavy directly.
  # This must load Carp, because some modules rely on the historical
  # behaviour of Carp::Heavy loading Carp.
CARP_HEAVY

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;
  
  use strict;
  use Exporter 5.57 'import';
  use vars qw($VERSION @EXPORT_OK);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '0.4';
  @EXPORT_OK = qw(list_packages);
  
  =pod
  
  =head1 NAME
  
  Devel::InnerPackage - find all the inner packages of a package
  
  =head1 SYNOPSIS
  
      use Foo::Bar;
      use Devel::InnerPackage qw(list_packages);
  
      my @inner_packages = list_packages('Foo::Bar');
  
  
  =head1 DESCRIPTION
  
  
  Given a file like this
  
  
      package Foo::Bar;
  
      sub foo {}
  
  
      package Foo::Bar::Quux;
  
      sub quux {}
  
      package Foo::Bar::Quirka;
  
      sub quirka {}
  
      1;
  
  then
  
      list_packages('Foo::Bar');
  
  will return
  
      Foo::Bar::Quux
      Foo::Bar::Quirka
  
  =head1 METHODS
  
  =head2 list_packages <package name>
  
  Return a list of all inner packages of that package.
  
  =cut
  
  sub list_packages {
              my $pack = shift; $pack .= "::" unless $pack =~ m!::$!;
  
              no strict 'refs';
              my @packs;
              my @stuff = grep !/^(main|)::$/, keys %{$pack};
              for my $cand (grep /::$/, @stuff)
              {
                  $cand =~ s!::$!!;
                  my @children = list_packages($pack.$cand);
      
                  push @packs, "$pack$cand" unless $cand =~ /^::/ ||
                      !__PACKAGE__->_loaded($pack.$cand); # or @children;
                  push @packs, @children;
              }
              return grep {$_ !~ /::(::ISA::CACHE|SUPER)/} @packs;
  }
  
  ### XXX this is an inlining of the Class-Inspector->loaded()
  ### method, but inlined to remove the dependency.
  sub _loaded {
         my ($class, $name) = @_;
  
          no strict 'refs';
  
         # Handle by far the two most common cases
         # This is very fast and handles 99% of cases.
         return 1 if defined ${"${name}::VERSION"};
         return 1 if @{"${name}::ISA"};
  
         # Are there any symbol table entries other than other namespaces
         foreach ( keys %{"${name}::"} ) {
                 next if substr($_, -2, 2) eq '::';
                 return 1 if defined &{"${name}::$_"};
         }
  
         # No functions, and it doesn't have a version, and isn't anything.
         # As an absolute last resort, check for an entry in %INC
         my $filename = join( '/', split /(?:'|::)/, $name ) . '.pm';
         return 1 if defined $INC{$filename};
  
         '';
  }
  
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2005 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =cut 
  
  
  
  
  
  1;
DEVEL_INNERPACKAGE

$fatpacked{"Devel/PatchPerl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL';
  package Devel::PatchPerl;
  $Devel::PatchPerl::VERSION = '1.78';
  # ABSTRACT: Patch perl source a la Devel::PPPort's buildperl.pl
  
  use strict;
  use warnings;
  use File::pushd qw[pushd];
  use File::Spec;
  use IO::File;
  use Devel::PatchPerl::Hints qw[hint_file];
  use MIME::Base64 qw[decode_base64];
  use Module::Pluggable search_path => ['Devel::PatchPerl::Plugin'];
  use vars qw[@ISA @EXPORT_OK];
  
  use constant CERTIFIED => 5.031004; # Anything less than this
  
  @ISA       = qw(Exporter);
  @EXPORT_OK = qw(patch_source);
  
  my $patch_exe = _can_run('gpatch') || _can_run('patch');
  
  my @patch = (
    {
      perl => [
                qw/
                  5.005
                /,
              ],
      subs => [
                [ \&_patch_5_005, 1 ],
              ],
    },
    {
      perl => [
                qw/
                  5.005_01
                /,
              ],
      subs => [
                [ \&_patch_5_005_01, 1 ],
              ],
    },
    {
      perl => [
                qw/
                  5.005_02
                /,
              ],
      subs => [
                [ \&_patch_5_005_02, 1 ],
              ],
    },
    {
      perl => [
                qr/^5\.00[2345]/,
                qw/
                  5.001n
                /,
              ],
      subs => [
                [ \&_patch_handy, 1 ],
              ],
    },
    {
      perl => [
                qw/
                  5.005
                  5.005_01
                  5.005_02
                  5.005_03
                  5.005_04
                /,
              ],
      subs => [
                [ \&_replace_makedepend, 1 ],
              ],
    },
    {
      perl => [
                qr/^5\.00[01234]/,
                qw/
                  5.005
                  5.005_01
                  5.005_02
                  5.005_03
                /,
              ],
      subs => [
                [ \&_patch_db, 1 ],
              ],
    },
    {
      perl => [
                qr/^5\.6\.[1-2]$/,
                qr/^5\.7\.[0-1]$/,
              ],
      subs => [
                [ \&_patch_makefile_sh_phony ],
              ],
    },
    {
      perl => [
              qw/
                  5.6.0
                  5.6.1
                  5.7.0
                  5.7.1
                  5.7.2
                  5.7.3
                  5.8.0
              /,
              ],
      subs => [
                [ \&_patch_db, 3 ],
              ],
    },
    {
      perl => [
                qr/^5\.004_0[1234]$/,
              ],
      subs => [
                [ \&_patch_doio ],
              ],
    },
    {
      perl => [
                qw/
                  5.005
                  5.005_01
                  5.005_02
                /,
              ],
      subs => [
                [ \&_patch_sysv, old_format => 1 ],
              ],
    },
    {
      perl => [
                qw/
                  5.005_03
                  5.005_04
                /,
                qr/^5\.6\.[0-2]$/,
                qr/^5\.7\.[0-3]$/,
                qr/^5\.8\.[0-8]$/,
                qr/^5\.9\.[0-5]$/
              ],
      subs => [
                [ \&_patch_sysv, old_format => 0 ],
              ],
    },
    {
      perl => [
                qr/^5\.004_05$/,
                qr/^5\.005(?:_0[1-4])?$/,
                qr/^5\.6\.[01]$/,
              ],
      subs => [
                [ \&_patch_configure ],
                [ \&_patch_makedepend_lc ],
              ],
    },
    {
      perl => [
                qr/^5\.6\.[0-2]$/,
              ],
      subs => [
                [ \&_patch_conf_gconvert ],
                [ \&_patch_sort_N ],
              ],
    },
    {
      perl => [
                '5.8.0',
              ],
      subs => [
                [ \&_patch_makedepend_lc ],
              ],
    },
    {
      perl => [
                qr/.*/,
              ],
      subs => [
                [ \&_patch_conf_solaris ],
                [ \&_patch_bitrig ],
                [ \&_patch_hints ],
                [ \&_patch_patchlevel ],
                [ \&_patch_develpatchperlversion ],
                [ \&_patch_errno_gcc5 ],
                [ \&_patch_conf_fwrapv ],
                [ \&_patch_utils_h2ph ],
                [ \&_patch_lib_h2ph ],
              ],
    },
    {
      perl => [
                qr/^5\.6\.[0-2]$/,
                qr/^5\.7\.[0-3]$/,
                qr/^5\.8\.[0-8]$/,
              ],
      subs => [
                [ \&_patch_makedepend_SH ],
              ],
    },
    {
      perl => [
                qr/^5\.1[0-2]/,
              ],
      subs => [
                [ \&_patch_archive_tar_tests ],
                [ \&_patch_odbm_file_hints_linux ],
              ],
    },
    {
      perl => [
                qr/^5.1([24].\d+|0.1)/,
              ],
      subs => [
                [ \&_patch_make_ext_pl ],
              ],
    },
    {
      perl => [ qr/^5\.8\.9$/, ],
      subs => [ [ \&_patch_589_perlio_c ], ],
    },
    {
      perl => [ qr/^5\.8\.[89]$/ ],
      subs => [ [ \&_patch_hsplit_rehash_58 ] ],
    },
    {
      perl => [
                qr/^5\.10\.1$/,
                qr/^5\.12\.5$/,
              ],
      subs => [ [ \&_patch_hsplit_rehash_510 ] ],
    },
    {
      perl => [
                qr/^5\.18\.0$/,
              ],
      subs => [ [ \&_patch_regmatch_pointer_5180 ] ],
    },
    {
      perl => [
                qr/^5\.20\.0$/,
              ],
      subs => [ [ \&_patch_cow_speed ] ],
    },
    {
      perl => [
                qr/^5\.6\.[012]$/,
                qr/^5\.8\.[89]$/,
                qr/^5\.10\.[01]$/,
              ],
      subs => [ [ \&_patch_preprocess_options ] ],
    },
    {
      perl => [
                qr/^5\.18\.3$/,
              ],
      subs => [ [ \&_patch_5183_metajson ] ],
    },
    {
      perl => [
                qr/^5\.24\.[01]$/,
              ],
      subs => [ [ \&_patch_time_hires ] ],
    },
    {
      perl => [
                qr/^5\.24\.3$/,
                qr/^5\.25\.(?:[4-9]|10)$/,
                qr/^5\.26\.[01]$/,
                qr/^5\.27\.[0-4]$/,
              ],
      subs => [ [ \&_patch_fp_class_denorm ] ],
    },
  );
  
  sub patch_source {
    my $vers = shift;
    $vers = shift if eval { $vers->isa(__PACKAGE__) };
    my $source = shift || '.';
    if ( !$vers ) {
      $vers = _determine_version($source);
      if ( $vers ) {
        warn "Auto-guessed '$vers'\n";
      }
      else {
        die "You didn't provide a perl version and I don't appear to be in a perl source tree\n";
      }
    }
    if ( _norm_ver( $vers ) >= CERTIFIED ) {
        warn "Nothing to do '$vers' is fine\n";
        return;
    }
    $source = File::Spec->rel2abs($source);
    {
      my $dir = pushd( $source );
      for my $p ( grep { _is( $_->{perl}, $vers ) } @patch ) {
         for my $s (@{$p->{subs}}) {
           my($sub, @args) = @$s;
           push @args, $vers unless scalar @args;
           $sub->(@args);
         }
      }
      _process_plugin( version => $vers, source => $source, patchexe => $patch_exe );
    }
  }
  
  sub _process_plugin {
    my %args = @_;
    return unless my $possible = $ENV{PERL5_PATCHPERL_PLUGIN};
    my ($plugin) = grep { $possible eq $_ or /\Q$possible\E$/ } __PACKAGE__->plugins;
    unless ( $plugin ) {
      warn "# You specified a plugin '", $ENV{PERL5_PATCHPERL_PLUGIN},
           "' that isn't installed, just thought you might be interested.\n";
      return;
    }
    {
      local $@;
      eval "require $plugin";
      if ($@) {
        die "# I tried to load '", $ENV{PERL5_PATCHPERL_PLUGIN},
            "' but it didn't work out. Here is what happened '$@'\n";
      }
    }
    {
      local $@;
      eval {
        $plugin->patchperl(
          %args,
        );
      };
      if ($@) {
        warn "# Warnings from the plugin: '$@'\n";
      }
    }
    return 1;
  }
  
  sub _can_run {
      my $command = shift;
  
      # a lot of VMS executables have a symbol defined
      # check those first
      if ( $^O eq 'VMS' ) {
          require VMS::DCLsym;
          my $syms = VMS::DCLsym->new;
          return $command if scalar $syms->getsym( uc $command );
      }
  
      require File::Spec;
      require ExtUtils::MakeMaker;
  
      my @possibles;
  
      if( File::Spec->file_name_is_absolute($command) ) {
          return MM->maybe_command($command);
  
      } else {
          for my $dir (
              File::Spec->path,
              File::Spec->curdir
          ) {
              next if ! $dir || ! -d $dir;
              my $abs = File::Spec->catfile( $^O eq 'MSWin32' ? Win32::GetShortPathName( $dir ) : $dir, $command);
              push @possibles, $abs if $abs = MM->maybe_command($abs);
          }
      }
      return @possibles if wantarray;
      return shift @possibles;
  }
  
  sub _is
  {
    my($s1, $s2) = @_;
  
    defined $s1 != defined $s2 and return 0;
  
    ref $s2 and ($s1, $s2) = ($s2, $s1);
  
    if (ref $s1) {
      if (ref $s1 eq 'ARRAY') {
        _is($_, $s2) and return 1 for @$s1;
        return 0;
      }
      return $s2 =~ $s1;
    }
  
    return $s1 eq $s2;
  }
  
  sub _patch_b64 {
    my($base64) = @_;
    my $patch = decode_base64( $base64 );
    _patch( $patch );
  }
  
  sub _patch
  {
    my($patch) = @_;
    my %mode;
    for my $file ($patch =~ /^\+{3}\s+(\S+)/gm) {
      print "patching $file\n";
      # some filesystems (e.g., Lustre) will kill this process if there
      # is an attempt to write to a file that is 0444, so make these
      # files writable for the duration of the patch
      if (-r $file and not -w _) {
        my $mode = (stat $file)[2];
        $mode{$file} = $mode; # save for chmod back
        chmod $mode | 0200, $file;
      }
    }
    my $diff = 'tmp.diff';
    _write_or_die($diff, $patch);
    die "No patch utility found\n" unless $patch_exe;
    local $ENV{PATCH_GET} = 0; # I can't reproduce this at all, but meh.
    _run_or_die("$patch_exe -f -s -p0 <$diff");
    unlink $diff or die "unlink $diff: $!\n";
    # put back ro to 0444
    for my $file (sort keys %mode) {
      chmod $mode{$file}, $file;
    }
  }
  
  sub _write_or_die
  {
    my($file, $data) = @_;
    my $fh = IO::File->new(">$file") or die "$file: $!\n";
    $fh->print($data);
  }
  
  sub _run_or_die
  {
    # print "[running @_]\n";
    die unless system( @_ ) == 0;
  }
  
  sub determine_version {
    my $src = shift;
    $src = shift if eval { $src->isa(__PACKAGE__) };
    $src = '.' unless $src;
    _determine_version($src);
  }
  
  sub _determine_version {
    my ($source) = @_;
    my $patchlevel_h = File::Spec->catfile($source, 'patchlevel.h');
    return unless -e $patchlevel_h;
    my $version;
    {
      my %defines;
      open my $fh, '<', $patchlevel_h;
      my @vers;
      while (<$fh>) {
        chomp;
        next unless /^#define/;
        my ($foo,$bar) = ( split /\s+/ )[1,2];
        $defines{$foo} = $bar;
      }
      if ( my @wotsits = grep { defined $defines{$_} } qw(PERL_REVISION PERL_VERSION PERL_SUBVERSION) ) {
        $version = join '.', map { $defines{$_} } @wotsits;
      }
      elsif ( my @watsits = grep { defined $defines{$_} } qw(PATCHLEVEL SUBVERSION) ) {
        $version = sprintf '5.%03d_%02d', map { $defines{$_} } @watsits;
      }
      else {
        return;
      }
    }
    return $version;
  }
  
  # adapted from patchlevel.h for use with perls that predate it
  sub _patch_patchlevel {
    return if -d '.git';
    my $dpv = $Devel::PatchPerl::VERSION || "(unreleased)";
    open my $plin, "patchlevel.h" or die "Couldn't open patchlevel.h : $!";
    open my $plout, ">patchlevel.new" or die "Couldn't write on patchlevel.new : $!";
    my $seen=0;
    while (<$plin>) {
        if (/\t,NULL/ and $seen) {
          print {$plout} qq{\t,"Devel::PatchPerl $dpv"\n};
        }
        $seen++ if /local_patches\[\]/;
        print {$plout} $_;
    }
    close $plout or die "Couldn't close filehandle writing to patchlevel.new : $!";
    close $plin or die "Couldn't close filehandle reading from patchlevel.h : $!";
    unlink "patchlevel.bak" or warn "Couldn't unlink patchlevel.bak : $!"
      if -e "patchlevel.bak";
    rename "patchlevel.h", "patchlevel.bak" or
      die "Couldn't rename patchlevel.h to patchlevel.bak : $!";
    rename "patchlevel.new", "patchlevel.h" or
      die "Couldn't rename patchlevel.new to patchlevel.h : $!";
  }
  
  sub _patch_hints {
    my @os;
    push @os, $^O;
    push @os, 'linux' if $^O eq 'gnukfreebsd'; # kfreebsd uses linux hints
    foreach my $os ( @os ) {
      return unless my ($file,$data) = hint_file( $os );
      my $path = File::Spec->catfile( 'hints', $file );
      if ( -e $path ) {
        chmod 0644, $path or die "$!\n";
      }
      open my $fh, '>', $path or die "$!\n";
      print $fh $data;
      close $fh;
    }
    return 1;
  }
  
  sub _patch_db
  {
    my $ver = shift;
    for my $file ('ext/DB_File/DB_File.xs', 'Configure') {
      print "patching $file\n";
      _run_or_die($^X, '-pi.bak', '-e', "s/<db.h>/<db$ver\\/db.h>/", $file);
      unlink "$file.bak" if -e "$file.bak";
    }
  }
  
  sub _patch_doio
  {
    _patch(<<'END');
  --- doio.c.org  2004-06-07 23:14:45.000000000 +0200
  +++ doio.c  2003-11-04 08:03:03.000000000 +0100
  @@ -75,6 +75,16 @@
   #  endif
   #endif
  
  +#if _SEM_SEMUN_UNDEFINED
  +union semun
  +{
  +  int val;
  +  struct semid_ds *buf;
  +  unsigned short int *array;
  +  struct seminfo *__buf;
  +};
  +#endif
  +
   bool
   do_open(gv,name,len,as_raw,rawmode,rawperm,supplied_fp)
   GV *gv;
  END
  }
  
  sub _patch_sysv
  {
    my %opt = @_;
  
    # check if patching is required
    return if $^O ne 'linux' or -f '/usr/include/asm/page.h';
  
    if ($opt{old_format}) {
      _patch(<<'END');
  --- ext/IPC/SysV/SysV.xs.org  1998-07-20 10:20:07.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-12 10:51:06.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #include <sys/ipc.h>
   #ifdef HAS_MSG
  END
    }
    else {
      _patch(<<'END');
  --- ext/IPC/SysV/SysV.xs.org  2007-08-11 00:12:46.000000000 +0200
  +++ ext/IPC/SysV/SysV.xs  2007-08-11 00:10:51.000000000 +0200
  @@ -3,9 +3,6 @@
   #include "XSUB.h"
   
   #include <sys/types.h>
  -#ifdef __linux__
  -#   include <asm/page.h>
  -#endif
   #if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
   #ifndef HAS_SEM
   #   include <sys/ipc.h>
  END
    }
  }
  
  sub _patch_configure
  {
    _patch(<<'END');
  --- Configure
  +++ Configure
  @@ -3380,6 +3380,18 @@
   test "X$gfpthkeep" != Xy && gfpth=""
   EOSC
   
  +# gcc 3.1 complains about adding -Idirectories that it already knows about,
  +# so we will take those off from locincpth.
  +case "$gccversion" in
  +3*)
  +    echo "main(){}">try.c
  +    for incdir in `$cc -v -c try.c 2>&1 | \
  +       sed '1,/^#include <\.\.\.>/d;/^End of search list/,$d;s/^ //'` ; do
  +       locincpth=`echo $locincpth | sed s!$incdir!!`
  +    done
  +    $rm -f try try.*
  +esac
  +
   : What should the include directory be ?
   echo " "
   $echo $n "Hmm...  $c"
  END
  }
  
  sub _patch_makedepend_lc
  {
    _patch(<<'END');
  --- makedepend.SH
  +++ makedepend.SH
  @@ -58,6 +58,10 @@ case $PERL_CONFIG_SH in
         ;;
   esac
   
  +# Avoid localized gcc/cc messages
  +LC_ALL=C
  +export LC_ALL
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  END
  }
  
  
  sub _patch_makedepend_SH
  {
    my $perl = shift;
    SWITCH: {
    # If 5.6.0
      if ( $perl eq '5.6.0' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2000-03-02 18:12:26.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:13:37.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,22 +140,45 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
       if [ "$osname" = os390 -a "$file" = perly.c ]; then
           $echo '#endif' >>UU/$file.c
       fi
  -    $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  -    $sed \
  -	-e '1d' \
  -	-e '/^#.*<stdin>/d' \
  -	-e '/^#.*"-"/d' \
  -	-e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  -	-e 's/^[	 ]*#[	 ]*line/#/' \
  -	-e '/^# *[0-9][0-9]* *[".\/]/!d' \
  -	-e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  -	-e 's|: \./|: |' \
  -	-e 's|\.c\.c|.c|' $uwinfix | \
  -    $uniq | $sort | $uniq >> .deptmp
  +
  +    if [ "$osname" = os390 ]; then
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $sed \
  +    	    -e '/^#.*<stdin>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +	    -e 's|\.c\.c|.c|' $uwinfix | \
  +        $uniq | $sort | $uniq >> .deptmp
  +    else
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
  +        $sed \
  +	    -e '1d' \
  +	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
  +	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
  +	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  +	    -e 's/^[	 ]*#[	 ]*line/#/' \
  +	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  +	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  +	    -e 's|: \./|: |' \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
  +        $uniq | $sort | $uniq >> .deptmp
  +    fi
   done
   
   $sed <$mf >$mf.new -e '1,/^# AUTOMATICALLY/!d'
  @@ -177,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -208,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.6.1
      if ( $perl eq '5.6.1' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2001-03-19 07:33:17.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:14:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.6.2
      if ( $perl eq '5.6.2' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2003-07-30 23:46:59.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:15:47.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -63,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -72,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -104,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -139,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -156,21 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  -	    -e '/^#.*<builtin>/d' \
  -	    -e '/^#.*<built-in>/d' \
  -	    -e '/^#.*<command line>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -204,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -235,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.0
      if ( $perl eq '5.7.0' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2000-08-13 19:35:04.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:47:14.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,25 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				uwinfix=
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -130,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -147,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -192,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -223,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.1
      if ( $perl eq '5.7.1' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2001-03-11 16:30:08.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:44:54.000000000 +0100
  @@ -1,5 +1,5 @@
   #! /bin/sh
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -29,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -37,7 +44,7 @@
   
   export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
   
  -case $CONFIGDOTSH in
  +case $PERL_CONFIG_SH in
   '')
   	if test -f config.sh; then TOP=.;
   	elif test -f ../config.sh; then TOP=..;
  @@ -51,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -58,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -67,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -99,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -134,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -151,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -196,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -227,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.2
      if ( $perl eq '5.7.2' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2001-07-09 15:11:05.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:45:32.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -103,29 +114,20 @@
   	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
   for file in `$cat .clist`; do
   # for file in `cat /dev/null`; do
  -	if [ "$osname" = uwin ]; then
  -		uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g"
  -	else
  -		if [ "$osname" = os2 ]; then
  -			uwinfix="-e s,\\\\\\\\,/,g"
  -		else
  -			if [ "$archname" = cygwin ]; then
  -				uwinfix="-e s,\\\\\\\\,/,g"
  -			else
  -				if [ "$osname" = posix-bc ]; then
  -					uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/"
  -				else
  -					uwinfix=
  -				fi
  -			fi
  -		fi
  -	fi
  +    case "$osname" in
  +    uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
  +    os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
  +    posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
  +    vos)      uwinfix="-e s/\#/\\\#/" ;;
  +    *)        uwinfix="" ;;
  +    esac
       case "$file" in
       *.c) filebase=`basename $file .c` ;;
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -138,10 +140,12 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
  -        if [ "$file" = perly.c ]; then
  -            $echo '#endif' >>UU/$file.c
  -        fi
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
       	    -e '/^#.*<stdin>/d' \
  @@ -155,18 +159,24 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
  +            -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
  +            -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
  +	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
   	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -200,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -231,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.7.3
      if ( $perl eq '5.7.3' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2002-03-05 01:10:22.000000000 +0000
  +++ makedepend.SH	2010-09-01 10:46:13.000000000 +0100
  @@ -18,10 +18,6 @@
   */*) cd `expr X$0 : 'X\(.*\)/'` ;;
   esac
   
  -case "$osname" in
  -amigaos) cat=/bin/cat ;; # must be absolute
  -esac
  -
   echo "Extracting makedepend (with variable substitutions)"
   rm -f makedepend
   $spitshell >makedepend <<!GROK!THIS!
  @@ -33,6 +29,13 @@
   !GROK!THIS!
   $spitshell >>makedepend <<'!NO!SUBS!'
   
  +if test -d .depending; then
  +	echo "$0: Already running, exiting."
  +	exit 0
  +fi
  +
  +mkdir .depending
  +
   # This script should be called with 
   #     sh ./makedepend MAKE=$(MAKE)
   case "$1" in 
  @@ -55,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -62,6 +70,10 @@
   PATH=".$path_sep..$path_sep$PATH"
   export PATH
   
  +case "$osname" in
  +amigaos) cat=/bin/cat ;; # must be absolute
  +esac
  +
   $cat /dev/null >.deptmp
   $rm -f *.c.c c/*.c.c
   if test -f Makefile; then
  @@ -71,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -116,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -129,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -143,13 +159,16 @@
   	    -e 's|\.c\.c|.c|' $uwinfix | \
           $uniq | $sort | $uniq >> .deptmp
       else
  -        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c 2>&1 |
  +        $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
           $sed \
   	    -e '1d' \
   	    -e '/^#.*<stdin>/d' \
               -e '/^#.*<builtin>/d' \
  +            -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -157,7 +176,7 @@
   	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
   	    -e 's|: \./|: |' \
  -	    -e 's|\.c\.c|.c|' $uwinfix | \
  +           -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
           $uniq | $sort | $uniq >> .deptmp
       fi
   done
  @@ -191,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  @@ -222,7 +245,8 @@
   $cp $mf.new $mf
   $rm $mf.new
   $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  -$rm -rf .deptmp UU .shlist .clist .hlist .hsed
  +$rm -rf .deptmp UU .shlist .clist .hlist .hsed .cout .cerr
  +rmdir .depending
   
   !NO!SUBS!
   $eunicefix makedepend
  BADGER
    last SWITCH;
    }
    # If 5.8.0
      if ( $perl eq '5.8.0' ) {
    _patch(<<'BADGER');
  --- makedepend.SH.org	2002-07-09 15:06:42.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:16:37.000000000 +0100
  @@ -58,6 +58,11 @@
   	;;
   esac
   
  +# Avoid localized gcc messages
  +case "$ccname" in
  +    gcc) LC_ALL=C ; export LC_ALL ;;
  +esac
  +
   # We need .. when we are in the x2p directory if we are using the
   # cppstdin wrapper script.
   # Put .. and . first so that we pick up the present cppstdin, not
  @@ -78,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -123,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -136,6 +140,11 @@
   	-e 's|\\$||' \
   	-e p \
   	-e '}' ) >UU/$file.c
  +
  +    if [ "$osname" = os390 -a "$file" = perly.c ]; then
  +        $echo '#endif' >>UU/$file.c
  +    fi
  +
       if [ "$osname" = os390 ]; then
           $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
           $sed \
  @@ -157,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -199,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
    last SWITCH;
    }
    # If 5.8.[12345678]
    _patch(<<'BADGER');
  --- makedepend.SH.org	2003-06-05 19:11:10.000000000 +0100
  +++ makedepend.SH	2010-09-01 10:24:39.000000000 +0100
  @@ -83,7 +83,6 @@
       # to be out of date.  I don't know if OS/2 has touch, so do this:
       case "$osname" in
       os2) ;;
  -    netbsd) ;;
       *) $touch $firstmakefile ;;
       esac
   fi
  @@ -128,7 +127,7 @@
       *.y) filebase=`basename $file .y` ;;
       esac
       case "$file" in
  -    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
  +    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
       *)   finc= ;;
       esac
       $echo "Finding dependencies for $filebase$_o."
  @@ -167,7 +166,9 @@
               -e '/^#.*<builtin>/d' \
               -e '/^#.*<built-in>/d' \
               -e '/^#.*<command line>/d' \
  +            -e '/^#.*<command-line>/d' \
   	    -e '/^#.*"-"/d' \
  +	    -e '/^#.*"\/.*\/"/d' \
   	    -e '/: file path prefix .* never used$/d' \
   	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
   	    -e 's/^[	 ]*#[	 ]*line/#/' \
  @@ -209,6 +210,10 @@
       $echo "Updating $mf..."
       $echo "# If this runs make out of memory, delete /usr/include lines." \
   	>> $mf.new
  +    if [ "$osname" = vos ]; then
  +        $sed 's|.incl.c|.h|' .deptmp >.deptmp.vos
  +        mv -f .deptmp.vos .deptmp
  +    fi
       $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
          >>$mf.new
   else
  BADGER
    }
  }
  
  sub _patch_conf_gconvert
  {
    my $perl = shift;
    _patch(<<'END');
  --- Configure
  +++ Configure
  @@ -7851,6 +7851,21 @@ int main()
   	Gconvert((DOUBLETYPE)0.1, 8, 0, buf);
   	checkit("0.1", buf);
   
  +	Gconvert((DOUBLETYPE)0.01, 8, 0, buf);
  +	checkit("0.01", buf);
  +
  +	Gconvert((DOUBLETYPE)0.001, 8, 0, buf);
  +	checkit("0.001", buf);
  +
  +	Gconvert((DOUBLETYPE)0.0001, 8, 0, buf);
  +	checkit("0.0001", buf);
  +
  +	Gconvert((DOUBLETYPE)0.00009, 8, 0, buf);
  +	if (strlen(buf) > 5)
  +	    checkit("9e-005", buf); /* for Microsoft ?? */
  +	else
  +	    checkit("9e-05", buf);
  +
   	Gconvert((DOUBLETYPE)1.0, 8, 0, buf); 
   	checkit("1", buf);
   
  @@ -7889,6 +7904,19 @@ int main()
   	Gconvert((DOUBLETYPE)123.456, 8, 0, buf); 
   	checkit("123.456", buf);
   
  +	/* Testing of 1e+129 in bigintpm.t must not get extra '.' here. */
  +	Gconvert((DOUBLETYPE)1e34, 8, 0, buf);
  +	/* 34 should be enough to scare even long double
  +	 * places into using the e notation. */
  +	if (strlen(buf) > 5)
  +	    checkit("1e+034", buf); /* for Microsoft */
  +	else
  +	    checkit("1e+34", buf);
  +
  +	/* For Perl, if you add additional tests here, also add them to
  +	 * t/base/num.t for benefit of platforms not using Configure or
  +	 * overriding d_Gconvert */
  +
   	exit(0);
   }
   EOP
  END
  }
  
  sub _patch_sort_N {
    system($^X, '-pi.bak', '-e', 's!\$sort \-n \+1!(\$sort -n -k 2 2>/dev/null || \$sort -n +1)!', 'Configure');
  }
  
  sub _patch_archive_tar_tests
  {
    my $perl = shift;
    if ($perl =~ /^5\.10/) {
      _patch(<<'END');
  --- lib/Archive/Tar/t/02_methods.t
  +++ lib/Archive/Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
    }
    else {
      _patch(<<'END');
  --- cpan/Archive-Tar/t/02_methods.t
  +++ cpan/Archive-Tar/t/02_methods.t
  @@ -70,6 +70,20 @@ my $LONG_FILE = qq[directory/really-really-really-really-really-really-really-re
   my $TOO_LONG    =   ($^O eq 'MSWin32' or $^O eq 'cygwin' or $^O eq 'VMS')
                       && length( cwd(). $LONG_FILE ) > 247;
   
  +if(!$TOO_LONG) {
  +    my $alt = File::Spec->catfile( cwd(), $LONG_FILE);
  +    eval 'mkpath([$alt]);';
  +    if($@)
  +    {
  +        $TOO_LONG = 1;
  +    }
  +    else
  +    {
  +        $@ = '';
  +        my $base = File::Spec->catfile( cwd(), 'directory');
  +        rmtree $base;
  +    }
  +}
   ### warn if we are going to skip long file names
   if ($TOO_LONG) {
       diag("No long filename support - long filename extraction disabled") if ! $ENV{PERL_CORE};
  END
    }
  }
  
  sub _patch_odbm_file_hints_linux
  {
      _patch(<<'END');
  --- ext/ODBM_File/hints/linux.pl
  +++ ext/ODBM_File/hints/linux.pl
  @@ -1,8 +1,8 @@
   # uses GDBM dbm compatibility feature - at least on SuSE 8.0
   $self->{LIBS} = ['-lgdbm'];
   
  -# Debian/Ubuntu have /usr/lib/libgdbm_compat.so.3* but not this file,
  +# Debian/Ubuntu have libgdbm_compat.so but not this file,
   # so linking may fail
  -if (-e '/usr/lib/libgdbm_compat.so' or -e '/usr/lib64/libgdbm_compat.so') {
  -    $self->{LIBS}->[0] .= ' -lgdbm_compat';
  +foreach (split / /, $Config{libpth}) {
  +    $self->{LIBS}->[0] .= ' -lgdbm_compat' if -e $_.'/libgdbm_compat.so';
   }
  END
  }
  
  sub _patch_make_ext_pl
  {
    _patch(<<'END');
  --- make_ext.pl
  +++ make_ext.pl
  @@ -377,6 +377,10 @@ WriteMakefile(
   EOM
   	    close $fh or die "Can't close Makefile.PL: $!";
   	}
  +  eval {
  +    my $ftime = time - 4;
  +    utime $ftime, $ftime, 'Makefile.PL';
  +  };
   	print "\nRunning Makefile.PL in $ext_dir\n";
   
   	# Presumably this can be simplified
  END
  }
  
  sub _patch_589_perlio_c
  {
    _patch(<<'END');
  --- perlio.c
  +++ perlio.c
  @@ -2323,6 +2323,12 @@ PerlIO_init(pTHX)
   {
       /* MUTEX_INIT(&PL_perlio_mutex) is done in PERL_SYS_INIT3(). */
       PERL_UNUSED_CONTEXT;
  +    /*
  +     * No, for backwards compatibility (before PERL_SYS_INIT3 changed to be
  +     * defined as a separate function call), we need to call
  +     * MUTEX_INIT(&PL_perlio_mutex) (via the PERLIO_INIT macro).
  +     */
  +    PERLIO_INIT;
   }
   
   void
  END
  }
  
  # http://perl5.git.perl.org/perl.git/commit/2674b61957c26a4924831d5110afa454ae7ae5a6
  sub _patch_hsplit_rehash_58
  {
    my $perl = shift;
  
    my $patch = <<'END';
  --- hv.c
  +++ hv.c
  @@ -31,7 +31,8 @@ holds the key and hash value.
   #define PERL_HASH_INTERNAL_ACCESS
   #include "perl.h"
   
  -#define HV_MAX_LENGTH_BEFORE_SPLIT 14
  +#define HV_MAX_LENGTH_BEFORE_REHASH 14
  +#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
   
   STATIC void
   S_more_he(pTHX)
  @@ -705,23 +706,8 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!counter) {				/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
   	    hsplit(hv);
  -	} else if(!HvREHASH(hv)) {
  -	    U32 n_links = 1;
  -
  -	    while ((counter = HeNEXT(counter)))
  -		n_links++;
  -
  -	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
  -		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
  -		   bucket splits on a rehashed hash, as we're not going to
  -		   split it again, and if someone is lucky (evil) enough to
  -		   get all the keys in one list they could exhaust our memory
  -		   as we repeatedly double the number of buckets on every
  -		   entry. Linear search feels a less worse thing to do.  */
  -		hsplit(hv);
  -	    }
   	}
       }
   
  @@ -1048,7 +1034,7 @@ S_hsplit(pTHX_ HV *hv)
   
   
       /* Pick your policy for "hashing isn't working" here:  */
  -    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
  +    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
   	|| HvREHASH(hv)) {
   	return;
       }
  @@ -1966,8 +1952,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!next) {			/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
  -		hsplit(PL_strtab);
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
  +            hsplit(PL_strtab);
   	}
       }
   
  --- t/op/hash.t
  +++ t/op/hash.t
  @@ -39,22 +39,36 @@ use constant THRESHOLD => 14;
   use constant START     => "a";
   
   # some initial hash data
  -my %h2 = map {$_ => 1} 'a'..'cc';
  +my %h2;
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
   
       # the minimum of bits required to mount the attack on a hash
       my $min_bits = log(THRESHOLD)/log(2);
  -
       # if the hash has already been populated with a significant amount
       # of entries the number of mask bits can be higher
       my $keys = scalar keys %$hr;
  -- 
  1.7.4.1
  
  END
  
    if ($perl =~ qr/^5\.8\.8$/) {
      $patch =~ s/non-pathological/non-pathalogical/;
      $patch =~ s/triggering/triggerring/;
    }
    _patch($patch);
  }
  
  # http://perl5.git.perl.org/perl.git/commit/f14269908e5f8b4cab4b55643d7dd9de577e7918
  # http://perl5.git.perl.org/perl.git/commit/9d83adcdf9ab3c1ac7d54d76f3944e57278f0e70
  sub _patch_hsplit_rehash_510 {
    _patch(<<'END');
  --- ext/Hash-Util-FieldHash/t/10_hash.t
  +++ ext/Hash-Util-FieldHash/t/10_hash.t
  @@ -46,15 +46,29 @@ use constant START     => "a";
   
   # some initial hash data
   fieldhash my %h2;
  -%h2 = map {$_ => 1} 'a'..'cc';
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
  --- hv.c
  +++ hv.c
  @@ -35,7 +35,8 @@ holds the key and hash value.
   #define PERL_HASH_INTERNAL_ACCESS
   #include "perl.h"
   
  -#define HV_MAX_LENGTH_BEFORE_SPLIT 14
  +#define HV_MAX_LENGTH_BEFORE_REHASH 14
  +#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) /* HvTOTALKEYS(hv) > HvMAX(hv) */
   
   static const char S_strtab_error[]
       = "Cannot modify shared string table in hv_%s";
  @@ -818,23 +819,8 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!counter) {				/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
   	    hsplit(hv);
  -	} else if(!HvREHASH(hv)) {
  -	    U32 n_links = 1;
  -
  -	    while ((counter = HeNEXT(counter)))
  -		n_links++;
  -
  -	    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {
  -		/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit
  -		   bucket splits on a rehashed hash, as we're not going to
  -		   split it again, and if someone is lucky (evil) enough to
  -		   get all the keys in one list they could exhaust our memory
  -		   as we repeatedly double the number of buckets on every
  -		   entry. Linear search feels a less worse thing to do.  */
  -		hsplit(hv);
  -	    }
   	}
       }
   
  @@ -1180,7 +1166,7 @@ S_hsplit(pTHX_ HV *hv)
   
   
       /* Pick your policy for "hashing isn't working" here:  */
  -    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT /* split worked?  */
  +    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH /* split worked?  */
   	|| HvREHASH(hv)) {
   	return;
       }
  @@ -2506,8 +2492,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)
   	xhv->xhv_keys++; /* HvTOTALKEYS(hv)++ */
   	if (!next) {			/* initial entry? */
   	    xhv->xhv_fill++; /* HvFILL(hv)++ */
  -	} else if (xhv->xhv_keys > (IV)xhv->xhv_max /* HvKEYS(hv) > HvMAX(hv) */) {
  -		hsplit(PL_strtab);
  +	} else if ( SHOULD_DO_HSPLIT(xhv) ) {
  +            hsplit(PL_strtab);
   	}
       }
   
  diff --git a/t/op/hash.t b/t/op/hash.t
  index 9bde518..45eb782 100644
  --- t/op/hash.t
  +++ t/op/hash.t
  @@ -39,22 +39,36 @@ use constant THRESHOLD => 14;
   use constant START     => "a";
   
   # some initial hash data
  -my %h2 = map {$_ => 1} 'a'..'cc';
  +my %h2;
  +my $counter= "a";
  +$h2{$counter++}++ while $counter ne 'cd';
   
   ok (!Internals::HvREHASH(%h2), 
       "starting with pre-populated non-pathological hash (rehash flag if off)");
   
   my @keys = get_keys(\%h2);
  +my $buckets= buckets(\%h2);
   $h2{$_}++ for @keys;
  +$h2{$counter++}++ while buckets(\%h2) == $buckets; # force a split
   ok (Internals::HvREHASH(%h2), 
  -    scalar(@keys) . " colliding into the same bucket keys are triggering rehash");
  +    scalar(@keys) . " colliding into the same bucket keys are triggering rehash after split");
  +
  +# returns the number of buckets in a hash
  +sub buckets {
  +    my $hr = shift;
  +    my $keys_buckets= scalar(%$hr);
  +    if ($keys_buckets=~m!/([0-9]+)\z!) {
  +        return 0+$1;
  +    } else {
  +        return 8;
  +    }
  +}
   
   sub get_keys {
       my $hr = shift;
   
       # the minimum of bits required to mount the attack on a hash
       my $min_bits = log(THRESHOLD)/log(2);
  -
       # if the hash has already been populated with a significant amount
       # of entries the number of mask bits can be higher
       my $keys = scalar keys %$hr;
  -- 
  1.7.4.1
  
  
  END
  }
  
  sub _patch_bitrig {
    return unless $^O eq 'bitrig';
    my $perlver = shift;
    my $num = _norm_ver( $perlver );
    return unless $num < 5.019004;
    unless ( $num < 5.00800 ) {
    _patch(<<'BOOGLE');
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -3312,6 +3312,9 @@ EOM
   			;;
   		next*) osname=next ;;
   		nonstop-ux) osname=nonstopux ;;
  +		bitrig) osname=bitrig
  +			osvers="$3"
  +			;;
   		openbsd) osname=openbsd
                   	osvers="$3"
                   	;;
  BOOGLE
    }
    if ( $num < 5.008009 ) {
    _patch(<<'BITRIGM1');
  diff --git a/Makefile.SH b/Makefile.SH
  index 17298fa..ecaa8ac 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -77,7 +77,7 @@ true)
   	sunos*)
   		linklibperl="-lperl"
   		;;
  -	netbsd*|freebsd[234]*|openbsd*)
  +	netbsd*|freebsd[234]*|openbsd*|bitrig*)
   		linklibperl="-L. -lperl"
   		;;
   	interix*)
  BITRIGM1
    }
    else {
    _patch(<<'BITRIGMX');
  diff --git a/Makefile.SH b/Makefile.SH
  index 17298fa..ecaa8ac 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -77,7 +77,7 @@ true)
   	sunos*)
   		linklibperl="-lperl"
   		;;
  -	netbsd*|freebsd[234]*|openbsd*|dragonfly*)
  +	netbsd*|freebsd[234]*|openbsd*|dragonfly*|bitrig*)
   		linklibperl="-L. -lperl"
   		;;
   	interix*)
  BITRIGMX
    }
    if ( $num < 5.008001 ) {
      # NOOP
    }
    elsif ( $num < 5.008007 ) {
      _patch(<<'BITRIGC3');
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure	Thu Aug 22 23:20:14 2013
  +++ Configure	Thu Aug 22 23:20:35 2013
  @@ -7855,7 +7855,7 @@
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd)
  +	freebsd|netbsd|openbsd|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf)
  BITRIGC3
    }
    elsif ( $num < 5.008009 ) {
      _patch(<<'BITRIGC2');
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure	Thu Aug 22 22:56:04 2013
  +++ Configure	Thu Aug 22 22:56:25 2013
  @@ -7892,7 +7892,7 @@
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd|interix)
  +	freebsd|netbsd|openbsd|interix|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGC2
    }
    elsif ( $num < 5.013000 ) {
      _patch(<<'BITRIGC1');
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -8328,7 +8331,7 @@ if "$useshrplib"; then
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|netbsd|openbsd|interix|dragonfly)
  +	freebsd|netbsd|openbsd|interix|dragonfly|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGC1
    }
    else {
      _patch(<<'BITRIGCX');
  diff --git a/Configure b/Configure
  index 19bed50..e4e4075 100755
  --- Configure
  +++ Configure
  @@ -8328,7 +8331,7 @@ if "$useshrplib"; then
   	solaris)
   		xxx="-R $shrpdir"
   		;;
  -	freebsd|mirbsd|netbsd|openbsd|interix|dragonfly)
  +	freebsd|mirbsd|netbsd|openbsd|interix|dragonfly|bitrig)
   		xxx="-Wl,-R$shrpdir"
   		;;
   	bsdos|linux|irix*|dec_osf|gnu*)
  BITRIGCX
    }
  }
  
  sub _patch_conf_solaris {
    return unless $^O eq 'solaris';
    my $perlver = shift;
    my $num = _norm_ver( $perlver );
    return unless $num < 5.018000;
    _patch(<<'BUBBLE');
  diff --git a/Configure b/Configure
  index ff511d3..30ab78a 100755
  --- Configure
  +++ Configure
  @@ -8048,7 +8048,20 @@ EOM
   			      ;;
   			linux|irix*|gnu*)  dflt="-shared $optimize" ;;
   			next)  dflt='none' ;;
  -			solaris) dflt='-G' ;;
  +			solaris) # See [perl #66604].  On Solaris 11, gcc -m64 on amd64
  +				# appears not to understand -G.  gcc versions at
  +				# least as old as 3.4.3 support -shared, so just
  +				# use that with Solaris 11 and later, but keep
  +				# the old behavior for older Solaris versions.
  +				case "$gccversion" in
  +					'') dflt='-G' ;;
  +					*)	case "$osvers" in
  +							2.?|2.10) dflt='-G' ;;
  +							*) dflt='-shared' ;;
  +						esac
  +						;;
  +				esac
  +				;;
   			sunos) dflt='-assert nodefinitions' ;;
   			svr4*|esix*|nonstopux) dflt="-G $ldflags" ;;
   	        *)     dflt='none' ;;
  BUBBLE
  }
  
  #commit 4149c7198d9b78d861df289cce40dd865cab57e7
  sub _patch_regmatch_pointer_5180 {
    _patch(<<'BOBBLE');
  diff --git a/regexec.c b/regexec.c
  index bc38839..b865b46 100644
  --- regexec.c
  +++ regexec.c
  @@ -6662,7 +6662,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
       scan = *startposp;
       if (max == REG_INFTY)
   	max = I32_MAX;
  -    else if (! utf8_target && scan + max < loceol)
  +    else if (! utf8_target && loceol - scan > max)
   	loceol = scan + max;
   
       /* Here, for the case of a non-UTF-8 target we have adjusted <loceol> down
  @@ -6711,7 +6711,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
   	    scan = loceol;
   	break;
       case CANY:  /* Move <scan> forward <max> bytes, unless goes off end */
  -        if (utf8_target && scan + max < loceol) {
  +        if (utf8_target && loceol - scan > max) {
   
               /* <loceol> hadn't been adjusted in the UTF-8 case */
               scan +=  max;
  @@ -6730,7 +6730,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
            * can use UTF8_IS_INVARIANT() even if the pattern isn't UTF-8, as it's
            * true iff it doesn't matter if the argument is in UTF-8 or not */
           if (UTF8_IS_INVARIANT(c) || (! utf8_target && ! is_utf8_pat)) {
  -            if (utf8_target && scan + max < loceol) {
  +            if (utf8_target && loceol - scan > max) {
                   /* We didn't adjust <loceol> because is UTF-8, but ok to do so,
                    * since here, to match at all, 1 char == 1 byte */
                   loceol = scan + max;
  @@ -6910,7 +6910,7 @@ S_regrepeat(pTHX_ regexp *prog, char **startposp, const regnode *p,
           /* FALLTHROUGH */
   
       case POSIXA:
  -        if (utf8_target && scan + max < loceol) {
  +        if (utf8_target && loceol - scan > max) {
   
               /* We didn't adjust <loceol> at the beginning of this routine
                * because is UTF-8, but it is actually ok to do so, since here, to
  diff --git a/t/re/pat_rt_report.t b/t/re/pat_rt_report.t
  index 2244fdf..9a9b5f5 100644
  --- t/re/pat_rt_report.t
  +++ t/re/pat_rt_report.t
  @@ -22,7 +22,7 @@ BEGIN {
   }
   
   
  -plan tests => 2530;  # Update this when adding/deleting tests.
  +plan tests => 2532;  # Update this when adding/deleting tests.
   
   run_tests() unless caller;
   
  @@ -1158,6 +1158,21 @@ EOP
               '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$\'|,"\n"',
               "c\n", {}, '$\' first mentioned after match');
       }
  +
  +    {
  +	# [perl #118175] threaded perl-5.18.0 fails pat_rt_report_thr.t
  +	# this tests some related failures
  +	#
  +	# The tests in the block *only* fail when run on 32-bit systems
  +	# with a malloc that allocates above the 2GB line.  On the system
  +	# in the report above that only happened in a thread.
  +	my $s = "\x{1ff}" . "f" x 32;
  +	ok($s =~ /\x{1ff}[[:alpha:]]+/gca, "POSIXA pointer wrap");
  +
  +	# this one segfaulted under the conditions above
  +	# of course, CANY is evil, maybe it should crash
  +	ok($s =~ /.\C+/, "CANY pointer wrap");
  +    }
   } # End of sub run_tests
   
   1;
  BOBBLE
  }
  
  sub _patch_makefile_sh_phony {
    _patch(<<'END');
  diff --git a/Makefile.SH b/Makefile.SH
  index ac5ade4..8e66603 100755
  --- Makefile.SH
  +++ Makefile.SH
  @@ -295,6 +295,30 @@ obj = $(obj1) $(obj2) $(obj3) $(ARCHOBJS)
   # EMBEDDING is on by default, and MULTIPLICITY doesn't work.
   #
  
  +.PHONY: all compile translators utilities \
  +       FORCE \
  +       preplibrary \
  +       install install-strip install-all install-verbose install-silent \
  +       no-install install.perl install.man installman install.html installhtml \
  +       check_byacc run_byacc \
  +       regen_headers regen_pods regen_all \
  +       clean _tidy _mopup _cleaner1 _cleaner2 \
  +       realclean _realcleaner clobber _clobber \
  +       distclean veryclean _verycleaner \
  +       lint \
  +       depend \
  +       test check test_prep _test_prep \
  +       test_tty test-tty _test_tty test_notty test-notty _test_notty \
  +       utest ucheck test.utf8 check.utf8 \
  +       test.third check.third utest.third ucheck.third test_notty.third \
  +       test.deparse test_notty.deparse \
  +       minitest \
  +       ok okfile oknack okfilenack nok nokfile noknack nokfilenack \
  +       clist hlist shlist pllist \
  +       distcheck \
  +       elc \
  +       etags ctags tags
  +
   lintflags = -hbvxac
  
   .c$(OBJ_EXT):
  END
  }
  
  sub _patch_cow_speed {
    _patch(<<'COWSAY');
  diff --git a/sv.c b/sv.c
  index 06c0b83..ac1d972 100644
  --- sv.c
  +++ sv.c
  @@ -1574,14 +1574,19 @@ Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
           newlen++;
   #endif
   
  +#if defined(PERL_USE_MALLOC_SIZE) && defined(Perl_safesysmalloc_size)
  +#define PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
  +#endif
  +
       if (newlen > SvLEN(sv)) {		/* need more room? */
   	STRLEN minlen = SvCUR(sv);
   	minlen += (minlen >> PERL_STRLEN_EXPAND_SHIFT) + 10;
   	if (newlen < minlen)
   	    newlen = minlen;
  -#ifndef Perl_safesysmalloc_size
  -        if (SvLEN(sv))
  +#ifndef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
  +        if (SvLEN(sv)) {
               newlen = PERL_STRLEN_ROUNDUP(newlen);
  +        }
   #endif
   	if (SvLEN(sv) && s) {
   	    s = (char*)saferealloc(s, newlen);
  @@ -1593,7 +1598,7 @@ Perl_sv_grow(pTHX_ SV *const sv, STRLEN newlen)
   	    }
   	}
   	SvPV_set(sv, s);
  -#ifdef Perl_safesysmalloc_size
  +#ifdef PERL_UNWARANTED_CHUMMINESS_WITH_MALLOC
   	/* Do this here, do it once, do it right, and then we will never get
   	   called back into sv_grow() unless there really is some growing
   	   needed.  */
  COWSAY
  }
  
  sub _patch_preprocess_options {
    my $perl = shift;
  
    if ($perl =~ /^5\.(?:8|10)\./) {
      _patch(<<'END');
  diff --git a/perl.c b/perl.c
  index 82e5538..b9e02fe 100644
  --- perl.c
  +++ perl.c
  @@ -3758,7 +3758,7 @@ S_open_script(pTHX_ const char *scriptname, bool dosearch, SV *sv,
   #       ifdef VMS
               cpp_discard_flag = "";
   #       else
  -            cpp_discard_flag = "-C";
  +            cpp_discard_flag = "-C -ffreestanding";
   #       endif
   
   #       ifdef OS2
  END
    } elsif ($perl =~ /^5\.6\./) {
      _patch(<<'END');
  diff --git a/perl.c b/perl.c
  index 623f9be..014d318 100644
  --- perl.c
  +++ perl.c
  @@ -2631,7 +2631,7 @@ sed %s -e \"/^[^#]/b\" \
    -e '/^#[ 	]*undef[ 	]/b' \
    -e '/^#[ 	]*endif/b' \
    -e 's/^[ 	]*#.*//' \
  - %s | %"SVf" -C %"SVf" %s",
  + %s | %"SVf" -C -ffreestanding %"SVf" %s",
   #  endif
   #ifdef LOC_SED
   	  LOC_SED,
  END
    }
  }
  
  sub _patch_5183_metajson {
  _patch(<<'DOGSAY');
  diff --git a/META.json b/META.json
  index 64caea7..200e324 100644
  --- META.json
  +++ META.json
  @@ -118,7 +118,7 @@
            "TestInit.pm"
         ]
      },
  -   "release_status" : "testing",
  +   "release_status" : "stable",
      "resources" : {
         "bugtracker" : {
            "web" : "http://rt.perl.org/perlbug/"
  DOGSAY
  }
  
  sub _patch_handy {
    _patch(<<'END');
  --- handy.h
  +++ handy.h
  @@ -43,12 +43,10 @@
      this file first, then you will have to manually set -DHAS_BOOL in 
      your command line to avoid a conflict.
   */
  -#ifdef _G_HAVE_BOOL
  -# if _G_HAVE_BOOL
  +#ifdef __GNUG__
   #  ifndef HAS_BOOL
   #   define HAS_BOOL 1
   #  endif
  -# endif
   #endif
   
   /* The NeXT dynamic loader headers will not build with the bool macro
  END
  }
  
  sub _replace_makedepend {
    # Replace makedepend with blead's version
    _write_or_die('makedepend.SH', <<'END');
  #! /bin/sh
  case $PERL_CONFIG_SH in
  '')
  	if test -f config.sh; then TOP=.;
  	elif test -f ../config.sh; then TOP=..;
  	elif test -f ../../config.sh; then TOP=../..;
  	elif test -f ../../../config.sh; then TOP=../../..;
  	elif test -f ../../../../config.sh; then TOP=../../../..;
  	else
  		echo "Can't find config.sh."; exit 1
  	fi
  	. $TOP/config.sh
  	;;
  esac
  : This forces SH files to create target in same directory as SH file.
  : This is so that make depend always knows where to find SH derivatives.
  case "$0" in
  */*) cd `expr X$0 : 'X\(.*\)/'` ;;
  esac
  
  echo "Extracting makedepend (with variable substitutions)"
  rm -f makedepend
  $spitshell >makedepend <<!GROK!THIS!
  $startsh
  # makedepend.SH
  #
  MAKE=$make
  trnl='$trnl'
  !GROK!THIS!
  $spitshell >>makedepend <<'!NO!SUBS!'
  
  if test -d .depending; then
  	echo "$0: Already running, exiting."
  	exit 0
  fi
  
  mkdir .depending
  
  # This script should be called with 
  #     sh ./makedepend MAKE=$(MAKE)
  case "$1" in 
  	MAKE=*) eval $1; shift ;;
  esac
  
  export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
  
  case $PERL_CONFIG_SH in
  '')
  	if test -f config.sh; then TOP=.;
  	elif test -f ../config.sh; then TOP=..;
  	elif test -f ../../config.sh; then TOP=../..;
  	elif test -f ../../../config.sh; then TOP=../../..;
  	elif test -f ../../../../config.sh; then TOP=../../../..;
  	else
  		echo "Can't find config.sh."; exit 1
  	fi
  	. $TOP/config.sh
  	;;
  esac
  
  # Avoid localized gcc messages
  case "$ccname" in
      gcc) LC_ALL=C ; export LC_ALL ;;
  esac
  
  # We need .. when we are in the x2p directory if we are using the
  # cppstdin wrapper script.
  # Put .. and . first so that we pick up the present cppstdin, not
  # an older one lying about in /usr/local/bin.
  PATH=".$path_sep..$path_sep$PATH"
  export PATH
  
  case "$osname" in
  amigaos) cat=/bin/cat ;; # must be absolute
  esac
  
  $cat /dev/null >.deptmp
  $rm -f *.c.c c/*.c.c
  if test -f Makefile; then
      rm -f $firstmakefile
      cp Makefile $firstmakefile
      # On QNX, 'cp' preserves timestamp, so $firstmakefile appears
      # to be out of date.  I don't know if OS/2 has touch, so do this:
      case "$osname" in
      os2) ;;
      *) $touch $firstmakefile ;;
      esac
  fi
  mf=$firstmakefile
  if test -f $mf; then
      defrule=`<$mf sed -n		\
  	-e '/^\.c\$(OBJ_EXT):.*;/{'	\
  	-e    's/\$\*\.c//'		\
  	-e    's/^[^;]*;[	 ]*//p'	\
  	-e    q				\
  	-e '}'				\
  	-e '/^\.c\$(OBJ_EXT): *$/{'	\
  	-e    N				\
  	-e    's/\$\*\.c//'		\
  	-e    's/^.*\n[	 ]*//p'		\
  	-e    q				\
  	-e '}'`
  fi
  case "$defrule" in
  '') defrule='$(CC) -c $(CFLAGS)' ;;
  esac
  
  : Create files in UU directory to avoid problems with long filenames
  : on systems with 14 character filename limits so file.c.c and file.c
  : might be identical
  $test -d UU || mkdir UU
  
  $MAKE clist || ($echo "Searching for .c files..."; \
  	$echo *.c | $tr ' ' $trnl | $egrep -v '\*' >.clist)
  for file in `$cat .clist`; do
  # for file in `cat /dev/null`; do
      case "$osname" in
      uwin)     uwinfix="-e s,\\\\\\\\,/,g -e s,\\([a-zA-Z]\\):/,/\\1/,g" ;;
      os2)      uwinfix="-e s,\\\\\\\\,/,g" ;;
      cygwin)   uwinfix="-e s,\\\\\\\\,/,g" ;;
      posix-bc) uwinfix="-e s/\\*POSIX(\\(.*\\))/\\1/" ;;
      vos)      uwinfix="-e s/\#/\\\#/" ;;
      *)        uwinfix="" ;;
      esac
      case "$file" in
      *.c) filebase=`basename $file .c` ;;
      *.y) filebase=`basename $file .y` ;;
      esac
      case "$file" in
      */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
      *)   finc= ;;
      esac
      $echo "Finding dependencies for $filebase$_o."
      # Below, we strip out all but preprocessor directives.
      # We have to take care of situations like
      #       #if defined(FOO) BAR   /* comment line 1
      #                                 more comment lines */
      # If we just delete text starting from the '/*' to the end of line, we will
      # screw up cases like
      #      #if defined(FOO)    /* comment */ \
      #          && defined(BAR) /* comment */ \
      #          && defined(BAZ) /* comment */ \
      #               etc.
      # Also, in lines like
      #      #defined FOO(a,b)    a/**/b
      # the comment may be important and so needs to be retained.
      # This code processes the single-line comments first; it assumes there is
      # at most one straightforward comment per continued preprocessor line,
      # replacing each non-empty comment (and its surrounding white space) by a
      # single space.  (sed only has a greedy '*' quantifier, so this doesn't
      # work right if there are multiple comments per line, and strings can look
      # like comments to it; both are unlikely in a preprocessor statement.) Any
      # continuation line is joined, and the process repeated on the enlarged
      # line as long as there are continuations.  At the end, if there are any
      # comments remaining, they are either completely empty or are like the
      # first situation.  The latter are just deleted by first deleting to the
      # end of line (including preceding white space) things that start with '/*'
      # and the next char isn't a '*'; then things that start with '/**', but the
      # next char isn't a '/'.  (Subsequent lines of the comment are irrelevant
      # and get dropped.)  At the end, we unjoin very long lines to avoid
      # preprocessor limitations
      ( $echo "#line 2 \"$file\"";                               \
        $sed -n <$file                                           \
  	-e "/^${filebase}_init(/q"                             \
          -e ': testcont'                                        \
  	-e '/^[ 	]*#/s|[ 	]*/\*..*\*/[ 	]*| |' \
          -e '/\\$/{'                                            \
              -e 'N'                                             \
              -e 'b testcont'                                    \
          -e '}'                                                 \
  	-e 's/\\\n//g'                                         \
  	-e '/^#line/d'                                         \
  	-e '/^[ 	]*#/{'                                 \
  	    -e 's|[ 	]*/\*[^*].*$||'                        \
  	    -e 's|[ 	]*/\*\*[^/].*$||'                      \
              -e 's/.\{255\}/&\\\n/g'                           \
  	    -e p                                               \
  	-e '}' ) >UU/$file.c
  
      # We're not sure why this was there; the #endif is extraneous on modern z/OS
      #if [ "$osname" = os390 -a "$file" = perly.c ]; then
      #   $echo '#endif' >>UU/$file.c
      #fi
  
      if [ "$osname" = os390 ]; then
          $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
          $sed \
      	    -e '/^#.*<stdin>/d' \
  	    -e '/^#.*"-"/d' \
  	    -e '/^#.*git_version\.h/d' \
  	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  	    -e 's/^[	 ]*#[	 ]*line/#/' \
  	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's|: \./|: |' \
  	    -e 's|\.c\.c|.c|' $uwinfix | \
          $uniq | $sort | $uniq >> .deptmp
      else
          $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c >.cout 2>.cerr
          $sed \
  	    -e '1d' \
  	    -e '/^#.*<stdin>/d' \
              -e '/^#.*<builtin>/d' \
              -e '/^#.*<built-in>/d' \
              -e '/^#.*<command line>/d' \
              -e '/^#.*<command-line>/d' \
  	    -e '/^#.*"-"/d' \
  	    -e '/^#.*"\/.*\/"/d' \
  	    -e '/: file path prefix .* never used$/d' \
  	    -e '/^#.*git_version\.h/d' \
  	    -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
  	    -e 's/^[	 ]*#[	 ]*line/#/' \
  	    -e '/^# *[0-9][0-9]* *[".\/]/!d' \
  	    -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
  	    -e 's|: \./|: |' \
             -e 's|\.c\.c|.c|' $uwinfix .cout .cerr| \
          $uniq | $sort | $uniq >> .deptmp
      fi
      echo "$filebase\$(OBJ_EXT): $@" >> .deptmp
  done
  
  $sed <$mf >$mf.new -e '1,/^# AUTOMATICALLY/!d'
  
  if $test -s .deptmp; then
      $echo "Updating $mf..."
      $echo "# If this runs make out of memory, delete /usr/include lines." \
  	>> $mf.new
      if [ "$osname" = vos ]; then
          $sed 's|\.incl\.c|.h|' .deptmp >.deptmp.vos
          mv -f .deptmp.vos .deptmp
      fi
      $sed 's|^\(.*\$(OBJ_EXT):\) *\(.*/.*\.c\) *$|\1 \2; '"$defrule \2|" .deptmp \
         >>$mf.new
  else
      $MAKE hlist || ($echo "Searching for .h files..."; \
  	$echo *.h | $tr ' ' $trnl | $egrep -v '\*' >.hlist)
      $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
      $egrep '^#include ' `cat .clist` `cat .hlist`  >.deptmp
      $echo "Updating $mf..."
      <.clist $sed -n							\
  	-e '/\//{'							\
  	-e   's|^\(.*\)/\(.*\)\.c|\2\$(OBJ_EXT): \1/\2.c; '"$defrule \1/\2.c|p"	\
  	-e   d								\
  	-e '}'								\
  	-e 's|^\(.*\)\.c|\1\$(OBJ_EXT): \1.c|p' >> $mf.new
      <.hlist $sed -n 's|\(.*/\)\(.*\)|s= \2= \1\2=|p' >.hsed
      <.deptmp $sed -n 's|c:#include "\(.*\)".*$|o: \1|p' | \
         $sed 's|^[^;]*/||' | \
         $sed -f .hsed >> $mf.new
      <.deptmp $sed -n 's|h:#include "\(.*\)".*$|h: \1|p' | \
         $sed -f .hsed >> $mf.new
  fi
  $rm -f $mf.old
  $cp $mf $mf.old
  $rm -f $mf
  $cp $mf.new $mf
  $rm $mf.new
  $echo "# WARNING: Put nothing here or make depend will gobble it up!" >> $mf
  $rm -rf .deptmp UU .clist .hlist .hsed .cout .cerr
  rmdir .depending
  
  !NO!SUBS!
  $eunicefix makedepend
  chmod +x makedepend
  END
  }  
  
  sub _patch_5_005_02 {
    _patch(<<'END');
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3442,7 +3445,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3693,7 +3700,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3980,10 +3988,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -3991,10 +4010,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4031,7 +4046,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4149,9 +4164,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4253,7 +4267,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4308,32 +4322,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5147,7 +5135,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6703,6 +6691,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6771,6 +6763,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7305,7 +7314,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7635,7 +7644,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID messages"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the msg*(2) configured." >&4
  +	echo "But your $osname does not have the msg*(2) configured." >&4
           h_msg=false
   	val="$undef"
   	set msgctl d_msgctl
  @@ -7678,7 +7687,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8136,7 +8145,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID messages"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the sem*(2) configured." >&4
  +	echo "But your $osname does not have the sem*(2) configured." >&4
           h_sem=false
   	val="$undef"
   	set semctl d_semctl
  @@ -8185,6 +8194,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8259,6 +8293,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8305,6 +8340,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8499,7 +8535,7 @@ case "$osname" in
   freebsd)
       case "`ipcs 2>&1`" in
       "SVID shared memory"*"not configured"*)
  -	echo "But your FreeBSD kernel does not have the shm*(2) configured." >&4
  +	echo "But your $osname does not have the shm*(2) configured." >&4
           h_shm=false
   	val="$undef"
   	set shmctl d_shmctl
  @@ -8652,21 +8688,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9610,6 +9633,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10217,8 +10266,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10250,6 +10301,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10458,7 +10603,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10466,7 +10617,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10830,7 +10983,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11055,10 +11214,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11195,6 +11350,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11774,6 +11930,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11882,6 +12039,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11894,6 +12052,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  @@ -12023,51 +12182,6 @@ esac
   : if this fails, just run all the .SH files by hand
   . ./config.sh
   
  -case "$ebcdic" in
  -$define)
  -    xxx=''
  -    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  -    rm -f y.tab.c y.tab.h
  -    yacc -d perly.y >/dev/null 2>&1
  -    if cmp -s y.tab.c perly.c; then
  -        rm -f y.tab.c
  -    else
  -        echo "perly.y -> perly.c" >&4
  -        mv -f y.tab.c perly.c
  -        chmod u+w perly.c
  -        sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  -            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  -        xxx="$xxx perly.c"
  -    fi
  -    if cmp -s y.tab.h perly.h; then
  -        rm -f y.tab.h
  -    else
  -        echo "perly.y -> perly.h" >&4
  -        mv -f y.tab.h perly.h
  -        xxx="$xxx perly.h"
  -    fi
  -    echo "x2p/a2p.y" >&4
  -    cd x2p
  -    rm -f y.tab.c
  -    yacc a2p.y >/dev/null 2>&1
  -    if cmp -s y.tab.c a2p.c
  -    then
  -        rm -f y.tab.c
  -    else
  -        echo "a2p.y -> a2p.c" >&4
  -        mv -f y.tab.c a2p.c
  -        chmod u+w a2p.c
  -        sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  -            -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  -        xxx="$xxx a2p.c"
  -    fi
  -    cd ..
  -    case "$xxx" in
  -    '') echo "No parser files were regenerated.  That's okay." >&4 ;;
  -    esac
  -    ;;
  -esac
  -
   echo " "
   exec 1>&4
   . ./UU/extract
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__) || defined(sun)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  }  
  
  sub _patch_5_005_01 {
    _patch(<<'END');
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3454,7 +3457,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3705,7 +3712,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3992,10 +4000,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -4003,10 +4022,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4043,7 +4058,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4161,9 +4176,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4265,7 +4279,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4320,32 +4334,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5159,7 +5147,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6715,6 +6703,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6783,6 +6775,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7317,7 +7326,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7643,6 +7652,27 @@ echo " "
   case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
   *"$undef"*) h_msg=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the msg*(2) configured." >&4
  +        h_msg=false
  +	val="$undef"
  +	set msgctl d_msgctl
  +	eval $setvar
  +	set msgget d_msgget
  +	eval $setvar
  +	set msgsnd d_msgsnd
  +	eval $setvar
  +	set msgrcv d_msgrcv
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_msg && $test `./findhdr sys/msg.h`; then
   	echo "You have the full msg*(2) library." >&4
  @@ -7671,7 +7701,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8125,6 +8155,25 @@ echo " "
   case "$d_semctl$d_semget$d_semop" in
   *"$undef"*) h_sem=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the sem*(2) configured." >&4
  +        h_sem=false
  +	val="$undef"
  +	set semctl d_semctl
  +	eval $setvar
  +	set semget d_semget
  +	eval $setvar
  +	set semop d_semop
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_sem && $test `./findhdr sys/sem.h`; then
   	echo "You have the full sem*(2) library." >&4
  @@ -8161,6 +8210,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8235,6 +8309,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8281,6 +8356,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8471,6 +8547,27 @@ echo " "
   case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
   *"$undef"*) h_shm=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID shared memory"*"not configured"*)
  +	echo "But your $osname does not have the shm*(2) configured." >&4
  +        h_shm=false
  +	val="$undef"
  +	set shmctl d_shmctl
  +	evat $setvar
  +	set shmget d_shmget
  +	evat $setvar
  +	set shmat d_shmat
  +	evat $setvar
  +	set shmdt d_shmdt
  +	evat $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_shm && $test `./findhdr sys/shm.h`; then
   	echo "You have the full shm*(2) library." >&4
  @@ -8609,21 +8706,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9567,6 +9651,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10174,8 +10284,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10207,6 +10319,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10415,7 +10621,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10423,7 +10635,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10787,7 +11001,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11012,10 +11232,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11152,6 +11368,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11731,6 +11948,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11839,6 +12057,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11851,6 +12070,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__) || defined(sun)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  }
  
  sub _patch_5_005 {
    _patch(<<'END');
  --- Configure
  +++ Configure
  @@ -21,7 +21,7 @@
   # $Id: Head.U,v 3.0.1.9 1997/02/28 15:02:09 ram Exp $
   #
   # Generated on Tue Jul  7 10:10:21 EDT 1998 [metaconfig 3.0 PL70]
  -# (with additional metaconfig patches by doughera@lafayette.edu)
  +# (with additional metaconfig patches by jhi@iki.fi)
   
   cat >/tmp/c1$$ <<EOF
   ARGGGHHHH!!!!!
  @@ -56,33 +56,6 @@ case "$0" in
   	;;
   esac
   
  -: the newline for tr
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\n' x 2>/dev/null`" in
  -	foox)
  -		trnl='\n'
  -		;;
  -	esac
  -fi
  -if test X"$trnl" = X; then
  -	case "`echo foo|tr '\012' x 2>/dev/null`" in
  -	foox)
  -		trnl='\012'
  -		;;
  -	esac
  -fi
  -if test -n "$DJGPP"; then
  -	trnl='\012'
  -fi
  -if test X"$trnl" = X; then
  -	cat <<EOM >&2
  -
  -$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  -
  -EOM
  -	exit 1
  -fi
  -
   : Proper separator for the PATH environment variable
   p_=:
   : On OS/2 this directory should exist if this is not floppy only system :-]
  @@ -391,7 +364,6 @@ d_getservprotos=''
   d_getsbyname=''
   d_getsbyport=''
   d_gnulibc=''
  -i_arpainet=''
   d_htonl=''
   d_inetaton=''
   d_isascii=''
  @@ -540,6 +512,7 @@ dlsrc=''
   ld=''
   lddlflags=''
   usedl=''
  +ebcdic=''
   doublesize=''
   fpostype=''
   gidtype=''
  @@ -548,6 +521,7 @@ h_fcntl=''
   h_sysfile=''
   db_hashtype=''
   db_prefixtype=''
  +i_arpainet=''
   i_db=''
   i_dbm=''
   i_rpcsvcdbm=''
  @@ -633,6 +607,7 @@ libpth=''
   loclibpth=''
   plibpth=''
   xlibpth=''
  +ignore_versioned_solibs=''
   libs=''
   lns=''
   lseektype=''
  @@ -697,11 +672,13 @@ randbits=''
   installscript=''
   scriptdir=''
   scriptdirexp=''
  +selectminbits=''
   selecttype=''
   sh=''
   sig_name=''
   sig_name_init=''
   sig_num=''
  +sig_num_init=''
   installsitearch=''
   sitearch=''
   sitearchexp=''
  @@ -719,6 +696,7 @@ startperl=''
   startsh=''
   stdchar=''
   sysman=''
  +trnl=''
   uidtype=''
   nm_opt=''
   nm_so_opt=''
  @@ -733,7 +711,6 @@ mips_type=''
   usrinc=''
   defvoidused=''
   voidflags=''
  -ebcdic=''
   CONFIG=''
   
   define='define'
  @@ -836,6 +813,8 @@ plibpth=''
   
   : default library list
   libswanted=''
  +: some systems want only to use the non-versioned libso:s
  +ignore_versioned_solibs=''
   : Possible local include directories to search.
   : Set locincpth to "" in a hint file to defeat local include searches.
   locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
  @@ -904,7 +883,7 @@ case "$sh" in
   $me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
   
   Usually it's in /bin/sh.  How did you even get this far?
  -Please contact me (Andy Dougherty) at doughera@lafayette.edu and 
  +Please contact me (Jarkko Hietaniemi) at jhi@iki.fi and 
   we'll try to straighten this all out.
   EOM
   	exit 1
  @@ -1240,7 +1219,7 @@ cat >extract <<'EOS'
   CONFIG=true
   echo "Doing variable substitutions on .SH files..."
   if test -f $src/MANIFEST; then
  -	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH'`
  +	set x `awk '{print $1}' <$src/MANIFEST | grep '\.SH$'`
   else
   	echo "(Looking for .SH files under the source directory.)"
   	set x `(cd $src; find . -name "*.SH" -print)`
  @@ -1373,7 +1352,7 @@ THIS PACKAGE SEEMS TO BE INCOMPLETE.
   You have the option of continuing the configuration process, despite the
   distinct possibility that your kit is damaged, by typing 'y'es.  If you
   do, don't blame me if something goes wrong.  I advise you to type 'n'o
  -and contact the author (doughera@lafayette.edu).
  +and contact the author (jhi@iki.fi).
   
   EOM
   		echo $n "Continue? [n] $c" >&4
  @@ -1396,6 +1375,30 @@ else
   fi
   rm -f missing x??
   
  +echo " "
  +: Find the appropriate value for a newline for tr
  +if test -n "$DJGPP"; then
  +       trnl='\012'
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\n' x 2>/dev/null`" in
  +	foox) trnl='\n' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	case "`echo foo|tr '\012' x 2>/dev/null`" in
  +	foox) trnl='\012' ;;
  +	esac
  +fi
  +if test X"$trnl" = X; then
  +	cat <<EOM >&2
  +
  +$me: Fatal Error: cannot figure out how to translate newlines with 'tr'.
  +
  +EOM
  +	exit 1
  +fi
  +
   : compute the number of columns on the terminal for proper question formatting
   case "$COLUMNS" in
   '') COLUMNS='80';;
  @@ -1574,7 +1577,7 @@ Much effort has been expended to ensure that this shell script will run on any
   Unix system.  If despite that it blows up on yours, your best bet is to edit
   Configure and run it again.  If you can't run Configure for some reason,
   you'll have to generate a config.sh file by hand.  Whatever problems you
  -have, let me (doughera@lafayette.edu) know how I blew it.
  +have, let me (jhi@iki.fi) know how I blew it.
   
   This installation script affects things in two ways:
   
  @@ -1841,14 +1844,14 @@ ABYZ)
   	    *C9D1*|*c9d1*)
   		echo "Hey, this might be EBCDIC." >&4
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
  +		    case "`echo IJ | $tr '[A-IJ-RS-Z]' '[a-ij-rs-z]' 2>/dev/null`" in
   		    ij) up='[A-IJ-RS-Z]'
   		        low='[a-ij-rs-z]'
   			;;
   		    esac
   		fi
   		if test "X$up" = X -o "X$low" = X; then
  -		    case "`echo IJ | tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
  +		    case "`echo IJ | $tr A-IJ-RS-Z a-ij-rs-z 2>/dev/null`" in
   		    ij) up='A-IJ-RS-Z'
   		        low='a-ij-rs-z'
   			;;
  @@ -1941,7 +1944,7 @@ EOM
   	(cd $src/hints; ls -C *.sh) | $sed 's/\.sh/   /g' >&4
   	dflt=''
   	: Half the following guesses are probably wrong... If you have better
  -	: tests or hints, please send them to doughera@lafayette.edu
  +	: tests or hints, please send them to jhi@iki.fi
   	: The metaconfig authors would also appreciate a copy...
   	$test -f /irix && osname=irix
   	$test -f /xenix && osname=sco_xenix
  @@ -2025,7 +2028,7 @@ EOM
   			osvers="$3"
   			;;
   		dynixptx*) osname=dynixptx
  -			osvers="$3"
  +			osvers=`echo "$4" | $sed 's/^v//'`
   			;;
   		freebsd) osname=freebsd 
   			osvers="$3" ;;
  @@ -3454,7 +3457,11 @@ cat <<'EOT' >testcpp.c
   ABC.XYZ
   EOT
   cd ..
  +if test ! -f cppstdin; then
   echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
  +else
  +	echo "Keeping your $hint cppstdin wrapper."
  +fi
   chmod 755 cppstdin
   wrapper=`pwd`/cppstdin
   ok='false'
  @@ -3705,7 +3712,8 @@ case "$libswanted" in
   esac
   for thislib in $libswanted; do
   	
  -	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
  +	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
  +		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
   		echo "Found -l$thislib (shared)."
   		case " $dflt " in
   		*"-l$thislib "*);;
  @@ -3992,10 +4000,21 @@ rmlist="$rmlist pdp11"
   : coherency check
   echo " "
   echo "Checking your choice of C compiler and flags for coherency..." >&4
  +$cat > try.c <<'EOF'
  +#include <stdio.h>
  +main() { printf("Ok\n"); exit(0); }
  +EOF
   set X $cc $optimize $ccflags -o try $ldflags try.c $libs
   shift
  -$cat >try.msg <<EOM
  -I've tried to compile and run a simple program with:
  +$cat >try.msg <<'EOM'
  +I've tried to compile and run the following simple program:
  +
  +EOM
  +$cat try.c
  +
  +$cat >> try.msg <<EOM
  +
  +I used the command:
   
   	$*
   	./try
  @@ -4003,10 +4022,6 @@ I've tried to compile and run a simple program with:
   and I got the following output:
   
   EOM
  -$cat > try.c <<'EOF'
  -#include <stdio.h>
  -main() { printf("Ok\n"); exit(0); }
  -EOF
   dflt=y
   if sh -c "$cc $optimize $ccflags -o try $ldflags try.c $libs" >>try.msg 2>&1; then
   	if sh -c './try' >>try.msg 2>&1; then
  @@ -4043,7 +4058,7 @@ y)
   	$cat try.msg >&4
   	case "$knowitall" in
   	'')
  -		echo "(The supplied flags might be incorrect with this C compiler.)"
  +		echo "(The supplied flags or libraries might be incorrect.)"
   		;;
   	*) dflt=n;;
   	esac
  @@ -4161,9 +4176,8 @@ eval $inhdr
   : determine which malloc to compile in
   echo " "
   case "$usemymalloc" in
  -''|y*|true)	dflt='y' ;;
  -n*|false)	dflt='n' ;;
  -*)	dflt="$usemymalloc" ;;
  +''|[yY]*|true|$define)	dflt='y' ;;
  +*)	dflt='n' ;;
   esac
   rp="Do you wish to attempt to use the malloc that comes with $package?"
   . ./myread
  @@ -4265,7 +4279,7 @@ understands function prototypes.  Unfortunately, your C compiler
   	$cc $ccflags
   doesn't seem to understand them.  Sorry about that.
   
  -If GNU cc is avaiable for your system, perhaps you could try that instead.  
  +If GNU cc is available for your system, perhaps you could try that instead.  
   
   Eventually, we hope to support building Perl with pre-ANSI compilers.
   If you would like to help in that effort, please contact <perlbug@perl.org>.
  @@ -4320,32 +4334,6 @@ shift;
   $cc $optimize $ccflags $ldflags -o ${mc_file} $* ${mc_file}.c $libs;'
   
   echo " "
  -echo "Determining whether or not we are on an EBCDIC system..." >&4
  -cat >tebcdic.c <<EOM
  -int main()
  -{
  -  if ('M'==0xd4) return 0;
  -  return 1;
  -}
  -EOM
  -val=$undef
  -set tebcdic
  -if eval $compile_ok; then
  -	if ./tebcdic; then
  -		echo "You have EBCDIC." >&4
  -		val="$define"
  -	else
  -		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  -	fi
  -else
  -	echo "I'm unable to compile the test program." >&4
  -	echo "I'll asuume ASCII or some ISO Latin." >&4
  -fi
  -$rm -f tebcdic.c tebcdic
  -set ebcdic
  -eval $setvar
  -
  -echo " "
   echo "Checking for GNU C Library..." >&4
   cat >gnulibc.c <<EOM
   #include <stdio.h>
  @@ -5159,7 +5147,7 @@ case "$shrpdir" in
   *)	$cat >&4 <<EOM
   WARNING:  Use of the shrpdir variable for the installation location of
   the shared $libperl is not supported.  It was never documented and
  -will not work in this version.  Let me (doughera@lafayette.edu)
  +will not work in this version.  Let me (jhi@iki.fi)
   know of any problems this may cause.
   
   EOM
  @@ -6715,6 +6703,10 @@ eval $setvar
   set difftime d_difftime
   eval $inlibc
   
  +: see if sys/stat.h is available
  +set sys/stat.h i_sysstat
  +eval $inhdr
  +
   : see if this is a dirent system
   echo " "
   if xinc=`./findhdr dirent.h`; $test "$xinc"; then
  @@ -6783,6 +6775,23 @@ set d_dirnamlen
   eval $setvar
   $rm -f try.c
   
  +hasfield='varname=$1; struct=$2; field=$3; shift; shift; shift;
  +while $test $# -ge 2; do
  +	case "$1" in
  +	$define) echo "#include <$2>";;
  +	esac ;
  +    shift 2;
  +done > try.c;
  +echo "int main () { struct $struct foo; foo.$field = 0; }" >> try.c;
  +if eval $cc $optimize $ccflags -c try.c >/dev/null 2>&1; then
  +	val="$define";
  +else
  +	val="$undef";
  +fi;
  +set $varname;
  +eval $setvar;
  +$rm -f try.c try.o'
  +
   : see if dlerror exists
   xxx_runnm="$runnm"
   runnm=false
  @@ -7317,7 +7326,7 @@ esac
   set netinet/in.h i_niin sys/in.h i_sysin
   eval $inhdr
   
  -: see if this is an arpa/inet.h
  +: see if arpa/inet.h has to be included
   set arpa/inet.h i_arpainet
   eval $inhdr
   
  @@ -7643,6 +7652,27 @@ echo " "
   case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
   *"$undef"*) h_msg=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the msg*(2) configured." >&4
  +        h_msg=false
  +	val="$undef"
  +	set msgctl d_msgctl
  +	eval $setvar
  +	set msgget d_msgget
  +	eval $setvar
  +	set msgsnd d_msgsnd
  +	eval $setvar
  +	set msgrcv d_msgrcv
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_msg && $test `./findhdr sys/msg.h`; then
   	echo "You have the full msg*(2) library." >&4
  @@ -7671,7 +7701,7 @@ set poll d_poll
   eval $inlibc
   
   
  -: see whether the various POSIXish _yields exist within given cccmd
  +: see whether the various POSIXish _yields exist
   $cat >try.c <<EOP
   #include <pthread.h>
   main() {
  @@ -8125,6 +8155,25 @@ echo " "
   case "$d_semctl$d_semget$d_semop" in
   *"$undef"*) h_sem=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID messages"*"not configured"*)
  +	echo "But your $osname does not have the sem*(2) configured." >&4
  +        h_sem=false
  +	val="$undef"
  +	set semctl d_semctl
  +	eval $setvar
  +	set semget d_semget
  +	eval $setvar
  +	set semop d_semop
  +	eval $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_sem && $test `./findhdr sys/sem.h`; then
   	echo "You have the full sem*(2) library." >&4
  @@ -8161,6 +8210,31 @@ case "$d_sem" in
   $define)
       : see whether semctl IPC_STAT can use union semun
       echo " "
  +    $cat > try.h <<END
  +#ifndef S_IRUSR
  +#   ifdef S_IREAD
  +#	define S_IRUSR S_IREAD
  +#	define S_IWUSR S_IWRITE
  +#	define S_IXUSR S_IEXEC
  +#   else
  +#	define S_IRUSR 0400
  +#	define S_IWUSR 0200
  +#	define S_IXUSR 0100
  +#   endif
  +#   define S_IRGRP (S_IRUSR>>3)
  +#   define S_IWGRP (S_IWUSR>>3)
  +#   define S_IXGRP (S_IXUSR>>3)
  +#   define S_IROTH (S_IRUSR>>6)
  +#   define S_IWOTH (S_IWUSR>>6)
  +#   define S_IXOTH (S_IXUSR>>6)
  +#endif
  +#ifndef S_IRWXU
  +#   define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
  +#   define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
  +#   define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)
  +#endif
  +END
  +
       $cat > try.c <<END
   #include <sys/types.h>
   #include <sys/ipc.h>
  @@ -8235,6 +8309,7 @@ END
   #include <sys/stat.h>
   #include <stdio.h>
   #include <errno.h>
  +#include "try.h"
   #ifndef errno
   extern int errno;
   #endif
  @@ -8281,6 +8356,7 @@ END
       *)  echo "You cannot use struct semid_ds * for semctl IPC_STAT." >&4
           ;;
       esac
  +    $rm -f try.h
       ;;
   *)  val="$undef"
   
  @@ -8471,6 +8547,27 @@ echo " "
   case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
   *"$undef"*) h_shm=false;;
   esac
  +
  +case "$osname" in
  +freebsd)
  +    case "`ipcs 2>&1`" in
  +    "SVID shared memory"*"not configured"*)
  +	echo "But your $osname does not have the shm*(2) configured." >&4
  +        h_shm=false
  +	val="$undef"
  +	set shmctl d_shmctl
  +	evat $setvar
  +	set shmget d_shmget
  +	evat $setvar
  +	set shmat d_shmat
  +	evat $setvar
  +	set shmdt d_shmdt
  +	evat $setvar
  +	;;
  +    esac
  +    ;;
  +esac
  +
   : we could also check for sys/ipc.h ...
   if $h_shm && $test `./findhdr sys/shm.h`; then
   	echo "You have the full shm*(2) library." >&4
  @@ -8609,21 +8706,8 @@ eval $inlibc
   
   : see if stat knows about block sizes
   echo " "
  -xxx=`./findhdr sys/stat.h`
  -if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
  -	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
  -		echo "Your stat() knows about block sizes." >&4
  -		val="$define"
  -	else
  -		echo "Your stat() doesn't know about block sizes." >&4
  -		val="$undef"
  -	fi
  -else
  -	echo "Your stat() doesn't know about block sizes." >&4
  -	val="$undef"
  -fi
  -set d_statblks
  -eval $setvar
  +set d_statblks stat st_blocks $i_sysstat sys/stat.h
  +eval $hasfield
   
   : see if _ptr and _cnt from stdio act std
   echo " "
  @@ -9567,6 +9651,32 @@ EOCP
   esac
   $rm -f try.c try
   
  +echo " "
  +echo "Determining whether or not we are on an EBCDIC system..." >&4
  +$cat >tebcdic.c <<EOM
  +int main()
  +{
  +  if ('M'==0xd4) return 0;
  +  return 1;
  +}
  +EOM
  +val=$undef
  +set tebcdic
  +if eval $compile_ok; then
  +	if ./tebcdic; then
  +		echo "You have EBCDIC." >&4
  +		val="$define"
  +	else
  +		echo "Nope, no EBCDIC.  Assuming ASCII or some ISO Latin." >&4
  +	fi
  +else
  +	echo "I'm unable to compile the test program." >&4
  +	echo "I'll assume ASCII or some ISO Latin." >&4
  +fi
  +$rm -f tebcdic.c tebcdic
  +set ebcdic
  +eval $setvar
  +
   : see what type file positions are declared as in the library
   rp="What is the type for file position used by fsetpos()?"
   set fpos_t fpostype long stdio.h sys/types.h
  @@ -10174,8 +10284,10 @@ EOM
   		: The first arg can be int, unsigned, or size_t
   		: The last arg may or may not be 'const'
   		val=''
  +		: void pointer has been seen but using that
  +		: breaks the selectminbits test
   		for xxx in 'fd_set *' 'int *'; do
  -			for nfd in 'int' 'size_t' 'unsigned' ; do
  +			for nfd in 'int' 'size_t' 'unsigned' 'unsigned long'; do
   				for tmo in 'struct timeval *' 'const struct timeval *'; do
   					case "$val" in
   					'')	try="extern select _(($nfd, $xxx, $xxx, $xxx, $tmo));"
  @@ -10207,6 +10319,100 @@ EOM
   	;;
   esac
   
  +: check for the select 'width'
  +case "$selectminbits" in
  +'') case "$d_select" in
  +	$define)
  +		$cat <<EOM
  +
  +Checking to see on how many bits at a time your select() operates...
  +EOM
  +		$cat >try.c <<EOCP
  +#include <sys/types.h>
  +#$i_time I_TIME
  +#$i_systime I_SYS_TIME
  +#$i_systimek I_SYS_TIME_KERNEL
  +#ifdef I_TIME
  +#   include <time.h>
  +#endif
  +#ifdef I_SYS_TIME
  +#   ifdef I_SYS_TIME_KERNEL
  +#	define KERNEL
  +#   endif
  +#   include <sys/time.h>
  +#   ifdef I_SYS_TIME_KERNEL
  +#	undef KERNEL
  +#   endif
  +#endif
  +#$i_sysselct I_SYS_SELECT
  +#ifdef I_SYS_SELECT
  +#include <sys/select.h>
  +#endif
  +#include <stdio.h>
  +$selecttype b;
  +#define S sizeof(*(b))
  +#define MINBITS	64
  +#define NBYTES (S * 8 > MINBITS ? S : MINBITS/8)
  +#define NBITS  (NBYTES * 8)
  +int main() {
  +    char s[NBYTES];
  +    struct timeval t;
  +    int i;
  +    FILE* fp;
  +    int fd;
  +
  +    fclose(stdin);
  +    fp = fopen("try.c", "r");
  +    if (fp == 0)
  +      exit(1);
  +    fd = fileno(fp);
  +    if (fd < 0)
  +      exit(2);
  +    b = ($selecttype)s;
  +    for (i = 0; i < NBITS; i++)
  +	FD_SET(i, b);
  +    t.tv_sec  = 0;
  +    t.tv_usec = 0;
  +    select(fd + 1, b, 0, 0, &t);
  +    for (i = NBITS - 1; i > fd && FD_ISSET(i, b); i--);
  +    printf("%d\n", i + 1);
  +    return 0;
  +}
  +EOCP
  +		set try
  +		if eval $compile_ok; then
  +			selectminbits=`./try`
  +			case "$selectminbits" in
  +			'')	cat >&4 <<EOM
  +Cannot figure out on how many bits at a time your select() operates.
  +I'll play safe and guess it is 32 bits.
  +EOM
  +				selectminbits=32
  +				bits="32 bits"
  +				;;
  +			1)	bits="1 bit" ;;
  +			*)	bits="$selectminbits bits" ;;
  +			esac
  +			echo "Your select() operates on $bits at a time." >&4
  +		else
  +			rp='What is the minimum number of bits your select() operates on?'
  +			case "$byteorder" in
  +			1234|12345678)	dflt=32 ;;
  +			*)		dflt=1	;;
  +			esac
  +			. ./myread
  +			val=$ans
  +			selectminbits="$val"
  +		fi
  +		$rm -f try.* try
  +		;;
  +	*)	: no select, so pick a harmless default
  +		selectminbits='32'
  +		;;
  +	esac
  +	;;
  +esac
  +
   : Trace out the files included by signal.h, then look for SIGxxx names.
   : Remove SIGARRAYSIZE used by HPUX.
   : Remove SIGTYP void lines used by OS2.
  @@ -10415,7 +10621,13 @@ $eunicefix signal_cmd
   : generate list of signal names
   echo " "
   case "$sig_name_init" in
  -'')
  +'') doinit=yes ;;
  +*)  case "$sig_num_init" in
  +    ''|*,*) doinit=yes ;;
  +    esac ;;
  +esac
  +case "$doinit" in
  +yes)
   	echo "Generating a list of signal names and numbers..." >&4
   	. ./signal_cmd
   	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
  @@ -10423,7 +10635,9 @@ case "$sig_name_init" in
   	sig_name_init=`$awk 'BEGIN { printf "\"ZERO\", " }
   						{ printf "\"%s\", ", $1 }
   						END { printf "0\n" }' signal.lst`
  -	sig_num=`$awk 'BEGIN { printf "0, " }
  +	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
  +	sig_num="0 $sig_num"
  +	sig_num_init=`$awk 'BEGIN { printf "0, " }
   					{ printf "%d, ", $2}
   					END { printf "0\n"}' signal.lst`
   	;;
  @@ -10787,7 +11001,13 @@ $rm -f try.c
   EOS
   chmod +x ccsym
   $eunicefix ccsym
  -./ccsym | $sort | $uniq >ccsym.raw
  +./ccsym > ccsym1.raw
  +if $test -s ccsym1.raw; then
  +       $sort ccsym1.raw | $uniq >ccsym.raw
  +else
  +       mv ccsym1.raw ccsym.raw
  +fi
  +
   $awk '/\=/ { print $0; next }
   	{ print $0"=1" }' ccsym.raw >ccsym.list
   $awk '{ print $0"=1" }' Cppsym.true >ccsym.true
  @@ -11012,10 +11232,6 @@ eval $inhdr
   set sys/resource.h i_sysresrc
   eval $inhdr
   
  -: see if sys/stat.h is available
  -set sys/stat.h i_sysstat
  -eval $inhdr
  -
   : see if this is a sys/un.h system
   set sys/un.h i_sysun
   eval $inhdr
  @@ -11152,6 +11368,7 @@ for xxx in $known_extensions ; do
   		esac
   		;;
   	IPC/SysV|ipc/sysv)
  +		: XXX Do we need a useipcsysv variable here
   		case "${d_msg}${d_sem}${d_shm}" in 
   		*"${define}"*) avail_ext="$avail_ext $xxx" ;;
   		esac
  @@ -11731,6 +11948,7 @@ i_values='$i_values'
   i_varargs='$i_varargs'
   i_varhdr='$i_varhdr'
   i_vfork='$i_vfork'
  +ignore_versioned_solibs='$ignore_versioned_solibs'
   incpath='$incpath'
   inews='$inews'
   installarchlib='$installarchlib'
  @@ -11839,6 +12057,7 @@ runnm='$runnm'
   scriptdir='$scriptdir'
   scriptdirexp='$scriptdirexp'
   sed='$sed'
  +selectminbits='$selectminbits'
   selecttype='$selecttype'
   sendmail='$sendmail'
   sh='$sh'
  @@ -11851,6 +12070,7 @@ shsharp='$shsharp'
   sig_name='$sig_name'
   sig_name_init='$sig_name_init'
   sig_num='$sig_num'
  +sig_num_init='$sig_num_init'
   signal_t='$signal_t'
   sitearch='$sitearch'
   sitearchexp='$sitearchexp'
  --- Makefile.SH
  +++ Makefile.SH
  @@ -644,3 +644,83 @@ case `pwd` in
       ;;
   esac
   $rm -f $firstmakefile
  +
  +# Now do any special processing required before building.
  +
  +case "$ebcdic" in
  +$define)
  +    xxx=''
  +    echo "This is an EBCDIC system, checking if any parser files need regenerating." >&4
  +case "$osname" in
  +os390)
  +    rm -f y.tab.c y.tab.h
  +    yacc -d perly.y >/dev/null 2>&1
  +    if cmp -s y.tab.c perly.c; then
  +        rm -f y.tab.c
  +    else
  +        echo "perly.y -> perly.c" >&2
  +        mv -f y.tab.c perly.c
  +        chmod u+w perly.c
  +        sed -e '/^#include "perl\.h"/a\
  +\
  +#define yydebug    PL_yydebug\
  +#define yynerrs    PL_yynerrs\
  +#define yyerrflag  PL_yyerrflag\
  +#define yychar     PL_yychar\
  +#define yyval      PL_yyval\
  +#define yylval     PL_yylval'				\
  +            -e '/YYSTYPE *yyval;/D'			\
  +            -e '/YYSTYPE *yylval;/D'			\
  +            -e '/int  yychar,/,/yynerrs;/D'		\
  +            -e 's/int yydebug = 0;/yydebug = 0;/'	\
  +            -e 's/[^_]realloc(/PerlMem_realloc(/g'	\
  +            -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +            -e 's/y\.tab/perly/g' perly.c >perly.tmp && mv perly.tmp perly.c
  +        xxx="$xxx perly.c"
  +    fi
  +    if cmp -s y.tab.h perly.h; then
  +        rm -f y.tab.h
  +    else
  +        echo "perly.y -> perly.h" >&2
  +        mv -f y.tab.h perly.h
  +        xxx="$xxx perly.h"
  +    fi
  +    if cd x2p
  +    then
  +        rm -f y.tab.c y.tab.h
  +        yacc a2p.y >/dev/null 2>&1
  +        if cmp -s y.tab.c a2p.c
  +        then
  +            rm -f y.tab.c
  +        else
  +            echo "a2p.y -> a2p.c" >&2
  +            mv -f y.tab.c a2p.c
  +            chmod u+w a2p.c
  +            sed -e 's/fprintf *( *stderr *,/PerlIO_printf(Perl_debug_log,/g' \
  +                -e 's/y\.tab/a2p/g' a2p.c >a2p.tmp && mv a2p.tmp a2p.c
  +            xxx="$xxx a2p.c"
  +        fi
  +        # In case somebody yacc -d:ed the a2p.y.
  +        if test -f y.tab.h
  +        then
  +            if cmp -s y.tab.h a2p.h
  +            then
  +                rm -f y.tab.h
  +            else
  +                echo "a2p.h -> a2p.h" >&2
  +                mv -f y.tab.h a2p.h
  +                xxx="$xxx a2p.h"
  +            fi
  +        fi
  +        cd ..
  +    fi
  +    ;;
  +*)
  +    echo "'$osname' is an EBCDIC system I don't know that well." >&4
  +    ;;
  +esac
  +    case "$xxx" in
  +    '') echo "No parser files were regenerated.  That's okay." >&2 ;;
  +    esac
  +    ;;
  +esac
  --- config_h.SH
  +++ config_h.SH
  @@ -1813,7 +1813,7 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
    *	the sig_name list.
    */
   #define SIG_NAME $sig_name_init		/**/
  -#define SIG_NUM  $sig_num			/**/
  +#define SIG_NUM  $sig_num_init		/**/
   
   /* VOIDFLAGS:
    *	This symbol indicates how much support of the void type is given by this
  @@ -1902,6 +1902,15 @@ sed <<!GROK!THIS! >config.h -e 's!^#undef\(.*/\)\*!/\*#define\1 \*!' -e 's!^#un-
   #define PRIVLIB "$privlib"		/**/
   #define PRIVLIB_EXP "$privlibexp"		/**/
   
  +/* SELECT_MIN_BITS:
  + *	This symbol holds the minimum number of bits operated by select.
  + *	That is, if you do select(n, ...), how many bits at least will be
  + *	cleared in the masks if some activity is detected.  Usually this
  + *	is either n or 32*ceil(n/32), especially many little-endians do
  + *	the latter.  This is only useful if you have select(), naturally.
  + */
  +#define SELECT_MIN_BITS 	$selectminbits	/**/
  +
   /* SITEARCH:
    *	This symbol contains the name of the private library for this package.
    *	The library is private in the sense that it needn't be in anyone's
  --- pp_sys.c
  +++ pp_sys.c
  @@ -56,7 +56,10 @@ extern "C" int syscall(unsigned long,...);
   
   /* XXX Configure test needed.
      h_errno might not be a simple 'int', especially for multi-threaded
  -   applications.  HOST_NOT_FOUND is typically defined in <netdb.h>.
  +   applications, see "extern int errno in perl.h".  Creating such
  +   a test requires taking into account the differences between
  +   compiling multithreaded and singlethreaded ($ccflags et al).
  +   HOST_NOT_FOUND is typically defined in <netdb.h>.
   */
   #if defined(HOST_NOT_FOUND) && !defined(h_errno)
   extern int h_errno;
  @@ -753,12 +756,17 @@ PP(pp_sselect)
   	    maxlen = j;
       }
   
  +/* little endians can use vecs directly */
   #if BYTEORDER == 0x1234 || BYTEORDER == 0x12345678
  -/* XXX Configure test needed. */
  -#if defined(__linux__) || defined(OS2) || defined(NeXT) || defined(__osf__)
  -    growsize = sizeof(fd_set);
  +#  if SELECT_MIN_BITS > 1
  +    /* If SELECT_MIN_BITS is greater than one we most probably will want
  +     * to align the sizes with SELECT_MIN_BITS/8 because for example
  +     * in many little-endian (Intel, Alpha) systems (Linux, OS/2, Digital
  +     * UNIX, Solaris, NeXT) the smallest quantum select() operates on
  +     * (sets bit) is 32 bits.  */
  +    growsize = maxlen + (SELECT_MIN_BITS/8 - (maxlen % (SELECT_MIN_BITS/8)));
   #else
  -    growsize = maxlen;		/* little endians can use vecs directly */
  +    growsize = sizeof(fd_set);
   #endif
   #else
   #ifdef NFDBITS
  END
  }
  
  sub _patch_errno_gcc5 {
    my $perlver = shift;
    my $num = _norm_ver( $perlver );
    return unless $num < 5.021009;
    return if $num > 5.020002 && $num < 5.021;
    if ( $num < 5.006 ) {
      warn "The Errno GCC 5 patch only goes back as far as v5.6.0\n";
      warn "You will have to generate your own patch to go farther back\n";
      return;
    }
    elsif ( $num < 5.006001 ) {
      _patch(<<'END');
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index df68dc3..8385048 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -143,16 +143,26 @@ sub write_errno_pm {
   
       # invoke CPP and read the output
   
  +    my $inhibit_linemarkers = '';
  +    if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +        # GCC 5.0 interleaves expanded macros with line numbers breaking
  +        # each line into multiple lines. RT#123784
  +        $inhibit_linemarkers = ' -P';
  +    }
  +
       if ($^O eq 'VMS') {
  -	my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +  my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +    $inhibit_linemarkers . " $Config{cppminus}";
   	$cpp =~ s/sys\$input//i;
   	open(CPPO,"$cpp  errno.c |") or
             die "Cannot exec $Config{cppstdin}";
       } elsif ($^O eq 'MSWin32') {
  -	open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -	    die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +       my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +         $inhibit_linemarkers;
  +       open(CPPO,"$cpp errno.c |") or
  +         die "Cannot run '$cpp errno.c'";
       } else {
  -	my $cpp = default_cpp();
  +	my $cpp = default_cpp() . $inhibit_linemarkers;
   	open(CPPO,"$cpp < errno.c |")
   	    or die "Cannot exec $cpp";
       }
  END
    }
    elsif ( $num == 5.00700 ) {
      _patch_b64(<<'END');
  ZGlmZiAtLWdpdCBhL2V4dC9FcnJuby9FcnJub19wbS5QTCBiL2V4dC9FcnJuby9FcnJub19wbS5Q
  TAppbmRleCBkZjY4ZGMzYmRhLi4yNTFmMmJhNjYzIDEwMDY0NAotLS0gZXh0L0Vycm5vL0Vycm5v
  X3BtLlBMCisrKyBleHQvRXJybm8vRXJybm9fcG0uUEwKQEAgLTIsOSArMiw3IEBAIHVzZSBFeHRV
  dGlsczo6TWFrZU1ha2VyOwogdXNlIENvbmZpZzsKIHVzZSBzdHJpY3Q7CiAKLXVzZSB2YXJzIHF3
  KCRWRVJTSU9OKTsKLQotJFZFUlNJT04gPSAiMS4xMTEiOworb3VyICRWRVJTSU9OID0gIjEuMTEx
  IjsKIAogbXkgJWVyciA9ICgpOwogCkBAIC0yOSw2ICsyNywxMiBAQCBzdWIgcHJvY2Vzc19maWxl
  IHsKICAgICAgICAgICAgIHdhcm4gIkNhbm5vdCBvcGVuICckZmlsZSciOwogICAgICAgICAgICAg
  cmV0dXJuOwogCX0gICAgIAorICAgIH0gZWxzaWYgKCRDb25maWd7Z2NjdmVyc2lvbn0gbmUgJycp
  IHsgCisJIyBXaXRoIHRoZSAtZE0gb3B0aW9uLCBnY2Mgb3V0cHV0cyBldmVyeSAjZGVmaW5lIGl0
  IGZpbmRzCisJdW5sZXNzKG9wZW4oRkgsIiRDb25maWd7Y2N9IC1FIC1kTSAkQ29uZmlne2NwcGZs
  YWdzfSAkZmlsZSB8IikpIHsKKyAgICAgICAgICAgIHdhcm4gIkNhbm5vdCBvcGVuICckZmlsZSci
  OworICAgICAgICAgICAgcmV0dXJuOworCX0gICAgIAogICAgIH0gZWxzZSB7CiAJdW5sZXNzKG9w
  ZW4oRkgsIjwgJGZpbGUiKSkgewogCSAgICAjIFRoaXMgZmlsZSBjb3VsZCBiZSBhIHRlbXBvcmFy
  eSBmaWxlIGNyZWF0ZWQgYnkgY3Bwc3RkaW4KQEAgLTM3LDExICs0MSwxOSBAQCBzdWIgcHJvY2Vz
  c19maWxlIHsKICAgICAgICAgICAgIHJldHVybjsKIAl9CiAgICAgfQotICAgIHdoaWxlKDxGSD4p
  IHsKLQkkZXJyeyQxfSA9IDEKLQkgICAgaWYgL15ccyojXHMqZGVmaW5lXHMrKEVcdyspXHMrLzsK
  LSAgIH0KLSAgIGNsb3NlKEZIKTsKKworICAgIGlmICgkXk8gZXEgJ01hY09TJykgeworCXdoaWxl
  KDxGSD4pIHsKKwkgICAgJGVycnskMX0gPSAkMgorCQlpZiAvXlxzKiNccypkZWZpbmVccysoRVx3
  KylccysoXGQrKS87CisJfQorICAgIH0gZWxzZSB7CisJd2hpbGUoPEZIPikgeworCSAgICAkZXJy
  eyQxfSA9IDEKKwkJaWYgL15ccyojXHMqZGVmaW5lXHMrKEVcdyspXHMrLzsKKwl9CisgICAgfQor
  ICAgIGNsb3NlKEZIKTsKIH0KIAogbXkgJGNwcHN0ZGluOwpAQCAtNzksNiArOTEsMTggQEAgc3Vi
  IGdldF9maWxlcyB7CiAgICAgfSBlbHNpZiAoJF5PIGVxICd2bWVzYScpIHsKIAkjIE9TLzM5MCBD
  IGNvbXBpbGVyIGRvZXNuJ3QgZ2VuZXJhdGUgI2ZpbGUgb3IgI2xpbmUgZGlyZWN0aXZlcwogCSRm
  aWxleycuLi8uLi92bWVzYS9lcnJuby5oJ30gPSAxOworICAgIH0gZWxzaWYgKCRDb25maWd7YXJj
  aG5hbWV9IGVxICdlcG9jJykgeworCSMgV2F0Y2ggb3V0IGZvciBjcm9zcyBjb21waWxpbmcgZm9y
  IEVQT0MgKHVzdWFsbHkgZG9uZSBvbiBsaW51eCkKKwkkZmlsZXsnL3Vzci9sb2NhbC9lcG9jL2lu
  Y2x1ZGUvbGliYy9zeXMvZXJybm8uaCd9ID0gMTsKKyAgICB9IGVsc2lmICgkXk8gZXEgJ2xpbnV4
  JykgeworCSMgU29tZSBMaW51eGVzIGhhdmUgd2VpcmQgZXJybm8uaHMgd2hpY2ggZ2VuZXJhdGUK
  KwkjIG5vICNmaWxlIG9yICNsaW5lIGRpcmVjdGl2ZXMKKwkkZmlsZXsnL3Vzci9pbmNsdWRlL2Vy
  cm5vLmgnfSA9IDE7CisgICAgfSBlbHNpZiAoJF5PIGVxICdNYWNPUycpIHsKKwkjIG5vdGUgdGhh
  dCB3ZSBhcmUgb25seSBnZXR0aW5nIHRoZSBHVVNJIGVycm5vJ3MgaGVyZSAuLi4KKwkjIHdlIG1p
  Z2h0IG1pc3Mgb3V0IG9uIGNvbXBpbGVyLXNwZWNpZmljIG9uZXMKKwkkZmlsZXsiJEVOVntHVVNJ
  fWluY2x1ZGU6c3lzOmVycm5vLmgifSA9IDE7CisKICAgICB9IGVsc2UgewogCW9wZW4oQ1BQSSwi
  PiBlcnJuby5jIikgb3IKIAkgICAgZGllICJDYW5ub3Qgb3BlbiBlcnJuby5jIjsKQEAgLTEwMiw3
  ICsxMjYsNyBAQCBzdWIgZ2V0X2ZpbGVzIHsKIAkgICAgJHBhdCA9ICdeL1wqXHMrKC4rKVxzK1xk
  K1xzKjpccytcKi8nOwogCX0KIAllbHNlIHsKLQkgICAgJHBhdCA9ICdeIyg/OmxpbmUpP1xzKlxk
  K1xzKyIoW14iXSspIic7CisJICAgICRwYXQgPSAnXiNccyooPzpsaW5lKT9ccypcZCtccysiKFte
  Il0rKSInOwogCX0KIAl3aGlsZSg8Q1BQTz4pIHsKIAkgICAgaWYgKCReTyBlcSAnb3MyJyBvciAk
  Xk8gZXEgJ01TV2luMzInKSB7CkBAIC0xNDEsMzEgKzE2NSw0MyBAQCBzdWIgd3JpdGVfZXJybm9f
  cG0gewogCiAgICAgY2xvc2UoQ1BQSSk7CiAKKyAgICB1bmxlc3MgKCReTyBlcSAnTWFjT1MnKSB7
  CSMgdHJ1c3Qgd2hhdCB3ZSBoYXZlCiAgICAgIyBpbnZva2UgQ1BQIGFuZCByZWFkIHRoZSBvdXRw
  dXQKIAotICAgIGlmICgkXk8gZXEgJ1ZNUycpIHsKLQlteSAkY3BwID0gIiRDb25maWd7Y3Bwc3Rk
  aW59ICRDb25maWd7Y3BwZmxhZ3N9ICRDb25maWd7Y3BwbWludXN9IjsKLQkkY3BwID1+IHMvc3lz
  XCRpbnB1dC8vaTsKLQlvcGVuKENQUE8sIiRjcHAgIGVycm5vLmMgfCIpIG9yCi0gICAgICAgICAg
  ZGllICJDYW5ub3QgZXhlYyAkQ29uZmlne2NwcHN0ZGlufSI7Ci0gICAgfSBlbHNpZiAoJF5PIGVx
  ICdNU1dpbjMyJykgewotCW9wZW4oQ1BQTywiJENvbmZpZ3tjcHBydW59ICRDb25maWd7Y3BwZmxh
  Z3N9IGVycm5vLmMgfCIpIG9yCi0JICAgIGRpZSAiQ2Fubm90IHJ1biAnJENvbmZpZ3tjcHBydW59
  ICRDb25maWd7Y3BwZmxhZ3N9IGVycm5vLmMnIjsKLSAgICB9IGVsc2UgewotCW15ICRjcHAgPSBk
  ZWZhdWx0X2NwcCgpOwotCW9wZW4oQ1BQTywiJGNwcCA8IGVycm5vLmMgfCIpCi0JICAgIG9yIGRp
  ZSAiQ2Fubm90IGV4ZWMgJGNwcCI7Ci0gICAgfQorICAgICAgIG15ICRpbmhpYml0X2xpbmVtYXJr
  ZXJzID0gJyc7CisgICAgICAgaWYgKCRDb25maWd7Z2NjdmVyc2lvbn0gPX4gL1xBKFxkKylcLi8g
  YW5kICQxID49IDUpIHsKKyAgICAgICAgICAgIyBHQ0MgNS4wIGludGVybGVhdmVzIGV4cGFuZGVk
  IG1hY3JvcyB3aXRoIGxpbmUgbnVtYmVycyBicmVha2luZworICAgICAgICAgICAjIGVhY2ggbGlu
  ZSBpbnRvIG11bHRpcGxlIGxpbmVzLiBSVCMxMjM3ODQKKyAgICAgICAgICAgJGluaGliaXRfbGlu
  ZW1hcmtlcnMgPSAnIC1QJzsKKyAgICAgICB9CisKKwlpZiAoJF5PIGVxICdWTVMnKSB7CisJICAg
  IG15ICRjcHAgPSAiJENvbmZpZ3tjcHBzdGRpbn0gJENvbmZpZ3tjcHBmbGFnc30iIC4KKyAgICAg
  ICAgJGluaGliaXRfbGluZW1hcmtlcnMgLiAiICRDb25maWd7Y3BwbWludXN9IjsKKwkgICAgJGNw
  cCA9fiBzL3N5c1wkaW5wdXQvL2k7CisJICAgIG9wZW4oQ1BQTywiJGNwcCAgZXJybm8uYyB8Iikg
  b3IKKwkJZGllICJDYW5ub3QgZXhlYyAkQ29uZmlne2NwcHN0ZGlufSI7CisJfSBlbHNpZiAoJF5P
  IGVxICdNU1dpbjMyJykgeworICAgICAgICAgICBteSAkY3BwID0gIiRDb25maWd7Y3BwcnVufSAk
  Q29uZmlne2NwcGZsYWdzfSIgLgorICAgICAgICAgICAgICAgJGluaGliaXRfbGluZW1hcmtlcnM7
  CisgICAgICAgICAgIG9wZW4oQ1BQTywiJGNwcCBlcnJuby5jIHwiKSBvcgorICAgICAgICAgICAg
  ICAgZGllICJDYW5ub3QgcnVuICckY3BwIGVycm5vLmMnIjsKKwl9IGVsc2UgeworCSAgICBteSAk
  Y3BwID0gZGVmYXVsdF9jcHAoKSAuICRpbmhpYml0X2xpbmVtYXJrZXJzOworCSAgICBvcGVuKENQ
  UE8sIiRjcHAgPCBlcnJuby5jIHwiKQorCQlvciBkaWUgIkNhbm5vdCBleGVjICRjcHAiOworCX0K
  IAotICAgICVlcnIgPSAoKTsKKwklZXJyID0gKCk7CiAKLSAgICB3aGlsZSg8Q1BQTz4pIHsKLQlt
  eSgkbmFtZSwkZXhwcik7Ci0JbmV4dCB1bmxlc3MgKCRuYW1lLCAkZXhwcikgPSAvIiguKj8pIlxz
  KlxbXHMqXFtccyooLio/KVxzKlxdXHMqXF0vOwotCW5leHQgaWYgJG5hbWUgZXEgJGV4cHI7Ci0J
  JGVycnskbmFtZX0gPSBldmFsICRleHByOworCXdoaWxlKDxDUFBPPikgeworCSAgICBteSgkbmFt
  ZSwkZXhwcik7CisJICAgIG5leHQgdW5sZXNzICgkbmFtZSwgJGV4cHIpID0gLyIoLio/KSJccypc
  W1xzKlxbXHMqKC4qPylccypcXVxzKlxdLzsKKwkgICAgbmV4dCBpZiAkbmFtZSBlcSAkZXhwcjsK
  KwkgICAgJGVycnskbmFtZX0gPSBldmFsICRleHByOworCX0KKwljbG9zZShDUFBPKTsKICAgICB9
  Ci0gICAgY2xvc2UoQ1BQTyk7CiAKICAgICAjIFdyaXRlIEVycm5vLnBtCiAKQEAgLTE3NSw3ICsy
  MTEsNyBAQCBzdWIgd3JpdGVfZXJybm9fcG0gewogIwogCiBwYWNrYWdlIEVycm5vOwotdXNlIHZh
  cnMgcXcoXEBFWFBPUlRfT0sgXCVFWFBPUlRfVEFHUyBcQElTQSBcJFZFUlNJT04gXCVlcnJubyBc
  JEFVVE9MT0FEKTsKK291ciAoXEBFWFBPUlRfT0ssXCVFWFBPUlRfVEFHUyxcQElTQSxcJFZFUlNJ
  T04sXCVlcnJubyxcJEFVVE9MT0FEKTsKIHVzZSBFeHBvcnRlciAoKTsKIHVzZSBDb25maWc7CiB1
  c2Ugc3RyaWN0Owo=
  END
    }
    elsif ( $num < 5.007002 ) { # v5.6.0 et al
      _patch(<<'END');
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3f2f3e0..d8fe44e 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -172,16 +172,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS') {	# trust what we have
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +        $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
    }
    elsif ( $num < 5.007003 ) { # v5.7.2
      _patch(<<'END');
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3f2f3e0..d8fe44e 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -172,16 +172,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS') {	# trust what we have
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +        $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32' || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
    }
    elsif ( $num < 5.008009 ) {
      _patch(<<'END');
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index d8a0ab3..796e2f1 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -235,16 +235,26 @@ sub write_errno_pm {
       unless ($^O eq 'MacOS' || $^O eq 'beos') {	# trust what we have / get later
       # invoke CPP and read the output
   
  +       my $inhibit_linemarkers = '';
  +       if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +           # GCC 5.0 interleaves expanded macros with line numbers breaking
  +           # each line into multiple lines. RT#123784
  +           $inhibit_linemarkers = ' -P';
  +       }
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +      my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +      $inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($^O eq 'MSWin32' || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +           my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +               $inhibit_linemarkers;
  +           open(CPPO,"$cpp errno.c |") or
  +               die "Cannot run '$cpp errno.c'";
   	} else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
    }
    elsif ( $num > 5.008009 and $num < 5.009003 ) {
      _patch_b64(<<'END');
  LS0tIGV4dC9FcnJuby9FcnJub19wbS5QTAorKysgZXh0L0Vycm5vL0Vycm5vX3BtLlBMCkBAIC03
  LDEyICs3LDM1IEBAIG91ciAkVkVSU0lPTiA9ICIxLjA5XzAxIjsKIG15ICVlcnIgPSAoKTsKIG15
  ICV3c2EgPSAoKTsKIAorIyBTeW1iaWFuIGNyb3NzLWNvbXBpbGluZyBlbnZpcm9ubWVudC4KK215
  ICRJc1N5bWJpYW4gPSBleGlzdHMgJEVOVntTREt9ICYmIC1kICIkRU5We1NES31cXGVwb2MzMiI7
  CisKK215ICRJc01TV2luMzIgPSAkXk8gZXEgJ01TV2luMzInICYmICEkSXNTeW1iaWFuOworCiB1
  bmxpbmsgIkVycm5vLnBtIiBpZiAtZiAiRXJybm8ucG0iOwogb3BlbiBPVVQsICI+RXJybm8ucG0i
  IG9yIGRpZSAiQ2Fubm90IG9wZW4gRXJybm8ucG06ICQhIjsKIHNlbGVjdCBPVVQ7CiBteSAkZmls
  ZTsKLWZvcmVhY2ggJGZpbGUgKGdldF9maWxlcygpKSB7Ci0gICAgcHJvY2Vzc19maWxlKCRmaWxl
  KTsKK215IEBmaWxlcyA9IGdldF9maWxlcygpOworaWYgKCRDb25maWd7Z2NjdmVyc2lvbn0gbmUg
  JycgJiYgJF5PIGVxICdNU1dpbjMyJykgeworICAgICMgTWluR1cgY29tcGxhaW5zICJ3YXJuaW5n
  OiAjcHJhZ21hIHN5c3RlbV9oZWFkZXIgaWdub3JlZCBvdXRzaWRlIGluY2x1ZGUKKyAgICAjIGZp
  bGUiIGlmIHRoZSBoZWFkZXIgZmlsZXMgYXJlIHByb2Nlc3NlZCBpbmRpdmlkdWFsbHksIHNvIGlu
  Y2x1ZGUgdGhlbQorICAgICMgYWxsIGluIC5jIGZpbGUgYW5kIHByb2Nlc3MgdGhhdCBpbnN0ZWFk
  LgorICAgIG9wZW4gSU5DUywgJz5pbmNsdWRlcy5jJyBvcgorCWRpZSAiQ2Fubm90IG9wZW4gaW5j
  bHVkZXMuYyI7CisgICAgZm9yZWFjaCAkZmlsZSAoQGZpbGVzKSB7CisJbmV4dCBpZiAkZmlsZSBl
  cSAnZXJybm8uYyc7CisJbmV4dCB1bmxlc3MgLWYgJGZpbGU7CisJcHJpbnQgSU5DUyBxcVsjaW5j
  bHVkZSAiJGZpbGUiXG5dOworICAgIH0KKyAgICBjbG9zZSBJTkNTOworICAgIHByb2Nlc3NfZmls
  ZSgnaW5jbHVkZXMuYycpOworICAgIHVubGluayAnaW5jbHVkZXMuYyc7Cit9CitlbHNlIHsKKyAg
  ICBmb3JlYWNoICRmaWxlIChAZmlsZXMpIHsKKwlwcm9jZXNzX2ZpbGUoJGZpbGUpOworICAgIH0K
  IH0KIHdyaXRlX2Vycm5vX3BtKCk7CiB1bmxpbmsgImVycm5vLmMiIGlmIC1mICJlcnJuby5jIjsK
  QEAgLTI3LDcgKzUwLDcgQEAgc3ViIHByb2Nlc3NfZmlsZSB7CiAgICAgfQogCiAgICAgcmV0dXJu
  IHVubGVzcyBkZWZpbmVkICRmaWxlIGFuZCAtZiAkZmlsZTsKLSMgICB3YXJuICJQcm9jZXNzaW5n
  ICRmaWxlXG4iOworIyAgICB3YXJuICJQcm9jZXNzaW5nICRmaWxlXG4iOwogCiAgICAgbG9jYWwg
  KkZIOwogICAgIGlmICgoJF5PIGVxICdWTVMnKSAmJiAoJENvbmZpZ3t2bXNfY2NfdHlwZX0gbmUg
  J2dudWMnKSkgewpAQCAtNTMsNyArNzYsNyBAQCBzdWIgcHJvY2Vzc19maWxlIHsKICAgICAgICAg
  ICAgIHJldHVybjsKIAl9CiAgICAgfQotCisgICAgCiAgICAgaWYgKCReTyBlcSAnTWFjT1MnKSB7
  CiAJd2hpbGUoPEZIPikgewogCSAgICAkZXJyeyQxfSA9ICQyCkBAIC02MywxMiArODYsMTMgQEAg
  c3ViIHByb2Nlc3NfZmlsZSB7CiAJd2hpbGUoPEZIPikgewogCSAgICAkZXJyeyQxfSA9IDEKIAkJ
  aWYgL15ccyojXHMqZGVmaW5lXHMrKEVcdyspXHMrLzsKLSAgICAgICAgICAgIGlmICgkXk8gZXEg
  J01TV2luMzInKSB7CisgICAgICAgICAgICBpZiAoJElzTVNXaW4zMikgewogCSAgICAgICAgJHdz
  YXskMX0gPSAxCiAJICAgIAkgICAgaWYgL15ccyojXHMqZGVmaW5lXHMrV1NBKEVcdyspXHMrLzsK
  ICAgICAgICAgICAgIH0KIAl9CiAgICAgfQorCiAgICAgY2xvc2UoRkgpOwogfQogCkBAIC0xMzAs
  NiArMTU0LDEwIEBAIHN1YiBnZXRfZmlsZXMgewogICAgIH0gZWxzaWYgKCReTyBlcSAndm9zJykg
  ewogCSMgYXZvaWQgcHJvYmxlbSB3aGVyZSBjcHAgcmV0dXJucyBub24tUE9TSVggcGF0aG5hbWVz
  CiAJJGZpbGV7Jy9zeXN0ZW0vaW5jbHVkZV9saWJyYXJ5L2Vycm5vLmgnfSA9IDE7CisgICAgfSBl
  bHNpZiAoJElzU3ltYmlhbikgeworICAgICAgICBteSAkU0RLID0gJEVOVntTREt9OworICAgICAg
  ICAkU0RLID1+IHMhXFwhLyFnOworCSRmaWxleyIkU0RLL2Vwb2MzMi9pbmNsdWRlL2xpYmMvc3lz
  L2Vycm5vLmgifSA9IDE7CiAgICAgfSBlbHNlIHsKIAlvcGVuKENQUEksIj4gZXJybm8uYyIpIG9y
  CiAJICAgIGRpZSAiQ2Fubm90IG9wZW4gZXJybm8uYyI7CkBAIC0xMzgsNyArMTY2LDcgQEAgc3Vi
  IGdldF9maWxlcyB7CiAJICAgIHByaW50IENQUEkgIiNpbmNsdWRlIDxud2Vycm5vLmg+XG4iOwog
  CX0gZWxzZSB7CiAJICAgIHByaW50IENQUEkgIiNpbmNsdWRlIDxlcnJuby5oPlxuIjsKLQkgICAg
  aWYgKCReTyBlcSAnTVNXaW4zMicpIHsKKwkgICAgaWYgKCRJc01TV2luMzIpIHsKIAkJcHJpbnQg
  Q1BQSSAiI2RlZmluZSBfV0lOU09DS0FQSV9cbiI7ICMgZG9uJ3QgZHJhZyBpbiBldmVyeXRoaW5n
  CiAJCXByaW50IENQUEkgIiNpbmNsdWRlIDx3aW5zb2NrLmg+XG4iOwogCSAgICB9CkBAIC0xNDcs
  NyArMTc1LDcgQEAgc3ViIGdldF9maWxlcyB7CiAJY2xvc2UoQ1BQSSk7CiAKIAkjIGludm9rZSBD
  UFAgYW5kIHJlYWQgdGhlIG91dHB1dAotCWlmICgkXk8gZXEgJ01TV2luMzInIHx8ICReTyBlcSAn
  TmV0V2FyZScpIHsKKwlpZiAoJElzTVNXaW4zMiB8fCAkXk8gZXEgJ05ldFdhcmUnKSB7CiAJICAg
  IG9wZW4oQ1BQTywiJENvbmZpZ3tjcHBydW59ICRDb25maWd7Y3BwZmxhZ3N9IGVycm5vLmMgfCIp
  IG9yCiAJCWRpZSAiQ2Fubm90IHJ1biAnJENvbmZpZ3tjcHBydW59ICRDb25maWd7Y3BwZmxhZ3N9
  IGVycm5vLmMnIjsKIAl9IGVsc2UgewpAQCAtMTU3LDE0ICsxODUsMTQgQEAgc3ViIGdldF9maWxl
  cyB7CiAJfQogCiAJbXkgJHBhdDsKLQlpZiAoKCReTyBlcSAnTVNXaW4zMicgfHwgJF5PIGVxICdO
  ZXRXYXJlJykgYW5kICRDb25maWd7Y2N9ID1+IC9eYmNjL2kpIHsKKwlpZiAoKCRJc01TV2luMzIg
  fHwgJF5PIGVxICdOZXRXYXJlJykgYW5kICRDb25maWd7Y2N9ID1+IC9eYmNjL2kpIHsKIAkgICAg
  JHBhdCA9ICdeL1wqXHMrKC4rKVxzK1xkK1xzKjpccytcKi8nOwogCX0KIAllbHNlIHsKIAkgICAg
  JHBhdCA9ICdeI1xzKig/OmxpbmUpP1xzKlxkK1xzKyIoW14iXSspIic7CiAJfQogCXdoaWxlKDxD
  UFBPPikgewotCSAgICBpZiAoJF5PIGVxICdvczInIG9yICReTyBlcSAnTVNXaW4zMicgb3IgJF5P
  IGVxICdOZXRXYXJlJykgeworCSAgICBpZiAoJF5PIGVxICdvczInIG9yICRJc01TV2luMzIgb3Ig
  JF5PIGVxICdOZXRXYXJlJykgewogCQlpZiAoLyRwYXQvbykgewogCQkgICBteSAkZiA9ICQxOwog
  CQkgICAkZiA9fiBzLFxcXFwsLyxnOwpAQCAtMTk4LDcgKzIyNiw3IEBAIHN1YiB3cml0ZV9lcnJu
  b19wbSB7CiAgICAgZWxzZSB7CiAJcHJpbnQgQ1BQSSAiI2luY2x1ZGUgPGVycm5vLmg+XG4iOwog
  ICAgIH0KLSAgICBpZiAoJF5PIGVxICdNU1dpbjMyJykgeworICAgIGlmICgkSXNNU1dpbjMyKSB7
  CiAJcHJpbnQgQ1BQSSAiI2luY2x1ZGUgPHdpbnNvY2suaD5cbiI7CiAJZm9yZWFjaCAkZXJyIChr
  ZXlzICV3c2EpIHsKIAkgICAgcHJpbnQgQ1BQSSAiI2lmbmRlZiAkZXJyXG4iOwpAQCAtMjE3LDE2
  ICsyNDUsMzEgQEAgc3ViIHdyaXRlX2Vycm5vX3BtIHsKICAgICB1bmxlc3MgKCReTyBlcSAnTWFj
  T1MnIHx8ICReTyBlcSAnYmVvcycpIHsJIyB0cnVzdCB3aGF0IHdlIGhhdmUgLyBnZXQgbGF0ZXIK
  ICAgICAjIGludm9rZSBDUFAgYW5kIHJlYWQgdGhlIG91dHB1dAogCisJbXkgJGluaGliaXRfbGlu
  ZW1hcmtlcnMgPSAnJzsKKwlpZiAoJENvbmZpZ3tnY2N2ZXJzaW9ufSA9fiAvXEEoXGQrKVwuLyBh
  bmQgJDEgPj0gNSkgeworCSAgICAjIEdDQyA1LjAgaW50ZXJsZWF2ZXMgZXhwYW5kZWQgbWFjcm9z
  IHdpdGggbGluZSBudW1iZXJzIGJyZWFraW5nCisJICAgICMgZWFjaCBsaW5lIGludG8gbXVsdGlw
  bGUgbGluZXMuIFJUIzEyMzc4NAorCSAgICAkaW5oaWJpdF9saW5lbWFya2VycyA9ICcgLVAnOwor
  CX0KKwogCWlmICgkXk8gZXEgJ1ZNUycpIHsKLQkgICAgbXkgJGNwcCA9ICIkQ29uZmlne2NwcHN0
  ZGlufSAkQ29uZmlne2NwcGZsYWdzfSAkQ29uZmlne2NwcG1pbnVzfSI7CisJICAgIG15ICRjcHAg
  PSAiJENvbmZpZ3tjcHBzdGRpbn0gJENvbmZpZ3tjcHBmbGFnc30iIC4KKwkJJGluaGliaXRfbGlu
  ZW1hcmtlcnMgLiAiICRDb25maWd7Y3BwbWludXN9IjsKIAkgICAgJGNwcCA9fiBzL3N5c1wkaW5w
  dXQvL2k7CiAJICAgIG9wZW4oQ1BQTywiJGNwcCAgZXJybm8uYyB8Iikgb3IKIAkJZGllICJDYW5u
  b3QgZXhlYyAkQ29uZmlne2NwcHN0ZGlufSI7Ci0JfSBlbHNpZiAoJF5PIGVxICdNU1dpbjMyJyB8
  fCAkXk8gZXEgJ05ldFdhcmUnKSB7Ci0JICAgIG9wZW4oQ1BQTywiJENvbmZpZ3tjcHBydW59ICRD
  b25maWd7Y3BwZmxhZ3N9IGVycm5vLmMgfCIpIG9yCi0JCWRpZSAiQ2Fubm90IHJ1biAnJENvbmZp
  Z3tjcHBydW59ICRDb25maWd7Y3BwZmxhZ3N9IGVycm5vLmMnIjsKLQl9IGVsc2UgewotCSAgICBt
  eSAkY3BwID0gZGVmYXVsdF9jcHAoKTsKKwl9IGVsc2lmICgkSXNNU1dpbjMyIHx8ICReTyBlcSAn
  TmV0V2FyZScpIHsKKwkgICAgbXkgJGNwcCA9ICIkQ29uZmlne2NwcHJ1bn0gJENvbmZpZ3tjcHBm
  bGFnc30iIC4KKwkJJGluaGliaXRfbGluZW1hcmtlcnM7CisJICAgIG9wZW4oQ1BQTywiJGNwcCBl
  cnJuby5jIHwiKSBvcgorCQlkaWUgIkNhbm5vdCBydW4gJyRjcHAgZXJybm8uYyciOworCX0gZWxz
  aWYgKCRJc1N5bWJpYW4pIHsKKyAgICAgICAgICAgIG15ICRjcHAgPSAiZ2NjIC1FIC1JJEVOVntT
  REt9XFxlcG9jMzJcXGluY2x1ZGVcXGxpYmMiIC4KKwkJJGluaGliaXRfbGluZW1hcmtlcnMgLiIg
  LSI7CisJICAgIG9wZW4oQ1BQTywiJGNwcCA8IGVycm5vLmMgfCIpCisJCW9yIGRpZSAiQ2Fubm90
  IGV4ZWMgJGNwcCI7CisgICAgICAgIH0gZWxzZSB7CisJICAgIG15ICRjcHAgPSBkZWZhdWx0X2Nw
  cCgpIC4gJGluaGliaXRfbGluZW1hcmtlcnM7CiAJICAgIG9wZW4oQ1BQTywiJGNwcCA8IGVycm5v
  LmMgfCIpCiAJCW9yIGRpZSAiQ2Fubm90IGV4ZWMgJGNwcCI7CiAJfQo=
  END
    }
    else {
      _patch(<<'END');
  diff --git a/ext/Errno/Errno_pm.PL b/ext/Errno/Errno_pm.PL
  index 3dadfce..c6bfa06 100644
  --- ext/Errno/Errno_pm.PL
  +++ ext/Errno/Errno_pm.PL
  @@ -215,20 +215,31 @@ sub write_errno_pm {
       {	# BeOS (support now removed) did not enter this block
       # invoke CPP and read the output
   
  +	my $inhibit_linemarkers = '';
  +	if ($Config{gccversion} =~ /\A(\d+)\./ and $1 >= 5) {
  +	    # GCC 5.0 interleaves expanded macros with line numbers breaking
  +	    # each line into multiple lines. RT#123784
  +	    $inhibit_linemarkers = ' -P';
  +	}
  +
   	if ($^O eq 'VMS') {
  -	    my $cpp = "$Config{cppstdin} $Config{cppflags} $Config{cppminus}";
  +	    my $cpp = "$Config{cppstdin} $Config{cppflags}" .
  +		$inhibit_linemarkers . " $Config{cppminus}";
   	    $cpp =~ s/sys\$input//i;
   	    open(CPPO,"$cpp  errno.c |") or
   		die "Cannot exec $Config{cppstdin}";
   	} elsif ($IsMSWin32 || $^O eq 'NetWare') {
  -	    open(CPPO,"$Config{cpprun} $Config{cppflags} errno.c |") or
  -		die "Cannot run '$Config{cpprun} $Config{cppflags} errno.c'";
  +	    my $cpp = "$Config{cpprun} $Config{cppflags}" .
  +		$inhibit_linemarkers;
  +	    open(CPPO,"$cpp errno.c |") or
  +		die "Cannot run '$cpp errno.c'";
   	} elsif ($IsSymbian) {
  -            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc -";
  +            my $cpp = "gcc -E -I$ENV{SDK}\\epoc32\\include\\libc" .
  +		$inhibit_linemarkers ." -";
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
           } else {
  -	    my $cpp = default_cpp();
  +	    my $cpp = default_cpp() . $inhibit_linemarkers;
   	    open(CPPO,"$cpp < errno.c |")
   		or die "Cannot exec $cpp";
   	}
  END
    }
  }
  
  sub _patch_time_hires {
    _patch(<<'END');
  diff --git a/dist/Time-HiRes/HiRes.pm b/dist/Time-HiRes/HiRes.pm
  index ad9a65c99d..a3ddd595b7 100644
  --- dist/Time-HiRes/HiRes.pm
  +++ dist/Time-HiRes/HiRes.pm
  @@ -23,12 +23,12 @@ our @EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
   		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
   		 TIMER_ABSTIME
   		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
  -		 d_nanosleep d_clock_gettime d_clock_getres
  +		 d_nanosleep d_clock_gettime d_clock_getres d_hires_utime
   		 d_clock d_clock_nanosleep
  -		 stat lstat
  +		 stat lstat utime
   		);
   
  -our $VERSION = '1.9733';
  +our $VERSION = '1.9741';
   our $XS_VERSION = $VERSION;
   $VERSION = eval $VERSION;
   
  @@ -60,6 +60,7 @@ sub import {
   	    ($i eq 'clock'           && !&d_clock)           ||
   	    ($i eq 'nanosleep'       && !&d_nanosleep)       ||
   	    ($i eq 'usleep'          && !&d_usleep)          ||
  +	    ($i eq 'utime'           && !&d_hires_utime)     ||
   	    ($i eq 'ualarm'          && !&d_ualarm)) {
   	    require Carp;
   	    Carp::croak("Time::HiRes::$i(): unimplemented in this platform");
  @@ -92,7 +93,7 @@ Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
   
     use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
   		      clock_gettime clock_getres clock_nanosleep clock
  -                      stat lstat );
  +                      stat lstat utime);
   
     usleep ($microseconds);
     nanosleep ($nanoseconds);
  @@ -137,6 +138,9 @@ Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
     my @stat = stat(FH);
     my @stat = lstat("file");
   
  +  use Time::HiRes qw( utime );
  +  utime $floating_seconds, $floating_seconds, file...;
  +
   =head1 DESCRIPTION
   
   The C<Time::HiRes> module implements a Perl interface to the
  @@ -446,6 +450,26 @@ if the operations are
   the access time stamp from t2 need not be greater-than the modify
   time stamp from t1: it may be equal or I<less>.
   
  +=item utime LIST
  +
  +As L<perlfunc/utime>
  +but with the ability to set the access/modify file timestamps
  +in subsecond resolution, if the operating system and the filesystem
  +both support such timestamps.  To override the standard utime():
  +
  +    use Time::HiRes qw(utime);
  +
  +Test for the value of &Time::HiRes::d_hires_utime to find out whether
  +the operating system supports setting subsecond file timestamps.
  +
  +As with CORE::utime(), passing undef as both the atime and mtime will
  +call the syscall with a NULL argument.
  +
  +The actual achievable subsecond resolution depends on the combination
  +of the operating system and the filesystem.
  +
  +Returns the number of files successfully changed.
  +
   =back
   
   =head1 EXAMPLES
  @@ -535,7 +559,7 @@ VMS have emulations for it.)
   Here is an example of using C<NVtime> from C:
   
     NV (*myNVtime)(); /* Returns -1 on failure. */
  -  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
  +  SV **svp = hv_fetchs(PL_modglobal, "Time::NVtime", 0);
     if (!svp)         croak("Time::HiRes is required");
     if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
     myNVtime = INT2PTR(NV(*)(), SvIV(*svp));
  @@ -586,9 +610,13 @@ might help in this (in case your system supports CLOCK_MONOTONIC).
   Some systems have APIs but not implementations: for example QNX and Haiku
   have the interval timer APIs but not the functionality.
   
  -In OS X clock_getres(), clock_gettime() and clock_nanosleep() are
  -emulated using the Mach timers; as a side effect of being emulated
  -the CLOCK_REALTIME and CLOCK_MONOTONIC are the same timer.
  +In pre-Sierra macOS (pre-10.12, OS X) clock_getres(), clock_gettime()
  +and clock_nanosleep() are emulated using the Mach timers; as a side
  +effect of being emulated the CLOCK_REALTIME and CLOCK_MONOTONIC are
  +the same timer.
  +
  +gnukfreebsd seems to have non-functional futimens() and utimensat()
  +(at least as of 10.1): therefore the hires utime() does not work.
   
   =head1 SEE ALSO
   
  diff --git a/dist/Time-HiRes/HiRes.xs b/dist/Time-HiRes/HiRes.xs
  index 38ca0dc320..6b0dba8e68 100644
  --- dist/Time-HiRes/HiRes.xs
  +++ dist/Time-HiRes/HiRes.xs
  @@ -87,6 +87,10 @@ extern "C" {
   #   undef ITIMER_REALPROF
   #endif
   
  +#ifndef TIME_HIRES_CLOCKID_T
  +typedef int clockid_t;
  +#endif
  +
   #if defined(TIME_HIRES_CLOCK_GETTIME) && defined(_STRUCT_ITIMERSPEC)
   
   /* HP-UX has CLOCK_XXX values but as enums, not as defines.
  @@ -747,21 +751,33 @@ hrstatns(UV *atime_nsec, UV *mtime_nsec, UV *ctime_nsec)
   #endif /* !TIME_HIRES_STAT */
   }
   
  -/* Until Apple implements clock_gettime() (ditto clock_getres())
  - * we will emulate it using Mach interfaces. */
  -#if defined(PERL_DARWIN) && !defined(CLOCK_REALTIME)
  -
  -#  include <mach/mach_time.h>
  +/* Until Apple implements clock_gettime()
  + * (ditto clock_getres() and clock_nanosleep())
  + * we will emulate them using the Mach kernel interfaces. */
  +#if defined(PERL_DARWIN) && \
  +  (defined(TIME_HIRES_CLOCK_GETTIME_EMULATION)   || \
  +   defined(TIME_HIRES_CLOCK_GETRES_EMULATION)    || \
  +   defined(TIME_HIRES_CLOCK_NANOSLEEP_EMULATION))
   
  +#ifndef CLOCK_REALTIME
   #  define CLOCK_REALTIME  0x01
   #  define CLOCK_MONOTONIC 0x02
  +#endif
   
  +#ifndef TIMER_ABSTIME
   #  define TIMER_ABSTIME   0x01
  +#endif
   
   #ifdef USE_ITHREADS
  +#  define PERL_DARWIN_MUTEX
  +#endif
  +
  +#ifdef PERL_DARWIN_MUTEX
   STATIC perl_mutex darwin_time_mutex;
   #endif
   
  +#include <mach/mach_time.h>
  +
   static uint64_t absolute_time_init;
   static mach_timebase_info_data_t timebase_info;
   static struct timespec timespec_init;
  @@ -769,7 +785,7 @@ static struct timespec timespec_init;
   static int darwin_time_init() {
     struct timeval tv;
     int success = 1;
  -#ifdef USE_ITHREADS
  +#ifdef PERL_DARWIN_MUTEX
     MUTEX_LOCK(&darwin_time_mutex);
   #endif
     if (absolute_time_init == 0) {
  @@ -784,13 +800,14 @@ static int darwin_time_init() {
         }
       }
     }
  -#ifdef USE_ITHREADS
  +#ifdef PERL_DARWIN_MUTEX
     MUTEX_UNLOCK(&darwin_time_mutex);
   #endif
     return success;
   }
   
  -static int clock_gettime(int clock_id, struct timespec *ts) {
  +#ifdef TIME_HIRES_CLOCK_GETTIME_EMULATION
  +static int th_clock_gettime(clockid_t clock_id, struct timespec *ts) {
     if (darwin_time_init() && timebase_info.denom) {
       switch (clock_id) {
         case CLOCK_REALTIME:
  @@ -822,7 +839,12 @@ static int clock_gettime(int clock_id, struct timespec *ts) {
     return -1;
   }
   
  -static int clock_getres(int clock_id, struct timespec *ts) {
  +#define clock_gettime(clock_id, ts) th_clock_gettime((clock_id), (ts))
  +
  +#endif /* TIME_HIRES_CLOCK_GETTIME_EMULATION */
  +
  +#ifdef TIME_HIRES_CLOCK_GETRES_EMULATION
  +static int th_clock_getres(clockid_t clock_id, struct timespec *ts) {
     if (darwin_time_init() && timebase_info.denom) {
       switch (clock_id) {
         case CLOCK_REALTIME:
  @@ -842,7 +864,11 @@ static int clock_getres(int clock_id, struct timespec *ts) {
     return -1;
   }
   
  -static int clock_nanosleep(int clock_id, int flags,
  +#define clock_getres(clock_id, ts) th_clock_getres((clock_id), (ts))
  +#endif /* TIME_HIRES_CLOCK_GETRES_EMULATION */
  +
  +#ifdef TIME_HIRES_CLOCK_NANOSLEEP_EMULATION
  +static int th_clock_nanosleep(clockid_t clock_id, int flags,
   			   const struct timespec *rqtp,
   			   struct timespec *rmtp) {
     if (darwin_time_init()) {
  @@ -880,6 +906,11 @@ static int clock_nanosleep(int clock_id, int flags,
     return -1;
   }
   
  +#define clock_nanosleep(clock_id, flags, rqtp, rmtp) \
  +  th_clock_nanosleep((clock_id), (flags), (rqtp), (rmtp))
  +
  +#endif /* TIME_HIRES_CLOCK_NANOSLEEP_EMULATION */
  +
   #endif /* PERL_DARWIN */
   
   #include "const-c.inc"
  @@ -921,6 +952,22 @@ nsec_without_unslept(struct timespec *sleepfor,
   
   #endif
   
  +/* In case Perl and/or Devel::PPPort are too old, minimally emulate
  + * IS_SAFE_PATHNAME() (which looks for zero bytes in the pathname). */
  +#ifndef IS_SAFE_PATHNAME
  +#if PERL_VERSION >= 12 /* Perl_ck_warner is 5.10.0 -> */
  +#ifdef WARN_SYSCALLS
  +#define WARNEMUCAT WARN_SYSCALLS /* 5.22.0 -> */
  +#else
  +#define WARNEMUCAT WARN_MISC
  +#endif
  +#define WARNEMU(opname) Perl_ck_warner(aTHX_ packWARN(WARNEMUCAT), "Invalid \\0 character in pathname for %s",opname)
  +#else
  +#define WARNEMU(opname) Perl_warn(aTHX_ "Invalid \\0 character in pathname for %s",opname)
  +#endif
  +#define IS_SAFE_PATHNAME(pv, len, opname) (((len)>1)&&memchr((pv), 0, (len)-1)?(SETERRNO(ENOENT, LIB_INVARG),WARNEMU(opname),FALSE):(TRUE))
  +#endif
  +
   MODULE = Time::HiRes            PACKAGE = Time::HiRes
   
   PROTOTYPES: ENABLE
  @@ -941,7 +988,7 @@ BOOT:
   #   endif
   #endif
   #if defined(PERL_DARWIN)
  -#  ifdef USE_ITHREADS
  +#  if defined(USE_ITHREADS) && defined(PERL_DARWIN_MUTEX)
     MUTEX_INIT(&darwin_time_mutex);
   #  endif
   #endif
  @@ -978,7 +1025,8 @@ usleep(useconds)
   		    useconds -= NV_1E6 * seconds;
   		}
   	    } else if (useconds < 0.0)
  -	        croak("Time::HiRes::usleep(%"NVgf"): negative time not invented yet", useconds);
  +	        croak("Time::HiRes::usleep(%" NVgf
  +                      "): negative time not invented yet", useconds);
   	    usleep((U32)useconds);
   	} else
   	    PerlProc_pause();
  @@ -1000,7 +1048,8 @@ nanosleep(nsec)
   	struct timespec sleepfor, unslept;
   	CODE:
   	if (nsec < 0.0)
  -	    croak("Time::HiRes::nanosleep(%"NVgf"): negative time not invented yet", nsec);
  +	    croak("Time::HiRes::nanosleep(%" NVgf
  +                  "): negative time not invented yet", nsec);
           nanosleep_init(nsec, &sleepfor, &unslept);
   	if (nanosleep(&sleepfor, &unslept) == 0) {
   	    RETVAL = nsec;
  @@ -1045,11 +1094,15 @@ sleep(...)
   		   useconds = -(IV)useconds;
   #endif /* #if defined(__sparc64__) && defined(__GNUC__) */
   		   if ((IV)useconds < 0)
  -		     croak("Time::HiRes::sleep(%"NVgf"): internal error: useconds < 0 (unsigned %"UVuf" signed %"IVdf")", seconds, useconds, (IV)useconds);
  +		     croak("Time::HiRes::sleep(%" NVgf
  +                           "): internal error: useconds < 0 (unsigned %" UVuf
  +                           " signed %" IVdf ")",
  +                           seconds, useconds, (IV)useconds);
   		 }
   		 usleep(useconds);
   	    } else
  -	        croak("Time::HiRes::sleep(%"NVgf"): negative time not invented yet", seconds);
  +	        croak("Time::HiRes::sleep(%" NVgf
  +                      "): negative time not invented yet", seconds);
   	} else
   	    PerlProc_pause();
   	gettimeofday(&Tb, NULL);
  @@ -1097,7 +1150,9 @@ ualarm(useconds,uinterval=0)
   	  }
   #else
   	if (useconds >= IV_1E6 || uinterval >= IV_1E6) 
  -		croak("Time::HiRes::ualarm(%d, %d): useconds or uinterval equal to or more than %"IVdf, useconds, uinterval, IV_1E6);
  +		croak("Time::HiRes::ualarm(%d, %d): useconds or uinterval"
  +                      " equal to or more than %" IVdf,
  +                      useconds, uinterval, IV_1E6);
   	RETVAL = ualarm(useconds, uinterval);
   #endif
   
  @@ -1110,7 +1165,8 @@ alarm(seconds,interval=0)
   	NV interval
   	CODE:
   	if (seconds < 0.0 || interval < 0.0)
  -	    croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): negative time not invented yet", seconds, interval);
  +	    croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                  "): negative time not invented yet", seconds, interval);
   	{
   	  IV iseconds = (IV)seconds;
   	  IV iinterval = (IV)interval;
  @@ -1118,7 +1174,9 @@ alarm(seconds,interval=0)
   	  NV finterval = interval - iinterval;
   	  IV useconds, uinterval;
   	  if (fseconds >= 1.0 || finterval >= 1.0)
  -		croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): seconds or interval too large to split correctly", seconds, interval);
  +		croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                      "): seconds or interval too large to split correctly",
  +                      seconds, interval);
   	  useconds = IV_1E6 * fseconds;
   	  uinterval = IV_1E6 * finterval;
   #if defined(HAS_SETITIMER) && defined(ITIMER_REAL)
  @@ -1138,7 +1196,9 @@ alarm(seconds,interval=0)
   	  }
   #else
   	  if (iseconds || iinterval)
  -		croak("Time::HiRes::alarm(%"NVgf", %"NVgf"): seconds or interval equal to or more than 1.0 ", seconds, interval);
  +		croak("Time::HiRes::alarm(%" NVgf ", %" NVgf
  +                      "): seconds or interval equal to or more than 1.0 ",
  +                      seconds, interval);
   	    RETVAL = (NV)ualarm( useconds, uinterval ) / NV_1E6;
   #endif
   	}
  @@ -1266,7 +1326,9 @@ setitimer(which, seconds, interval = 0)
   	struct itimerval oldit;
       PPCODE:
   	if (seconds < 0.0 || interval < 0.0)
  -	    croak("Time::HiRes::setitimer(%"IVdf", %"NVgf", %"NVgf"): negative time not invented yet", (IV)which, seconds, interval);
  +	    croak("Time::HiRes::setitimer(%" IVdf ", %" NVgf ", %" NVgf
  +                  "): negative time not invented yet",
  +                  (IV)which, seconds, interval);
   	newit.it_value.tv_sec  = (IV)seconds;
   	newit.it_value.tv_usec =
   	  (IV)((seconds  - (NV)newit.it_value.tv_sec)    * NV_1E6);
  @@ -1317,11 +1379,89 @@ getitimer(which)
   
   #endif /* #if defined(HAS_GETITIMER) && defined(HAS_SETITIMER) */
   
  +#if defined(TIME_HIRES_UTIME)
  +
  +I32
  +utime(accessed, modified, ...)
  +PROTOTYPE: $$@
  +    PREINIT:
  +	SV* accessed;
  +	SV* modified;
  +	SV* file;
  +
  +	struct timespec utbuf[2];
  +	struct timespec *utbufp = utbuf;
  +	int tot;
  +
  +    CODE:
  +	accessed = ST(0);
  +	modified = ST(1);
  +	items -= 2;
  +	tot = 0;
  +
  +	if ( accessed == &PL_sv_undef && modified == &PL_sv_undef )
  +		utbufp = NULL;
  +	else {
  +		if (SvNV(accessed) < 0.0 || SvNV(modified) < 0.0)
  +                    croak("Time::HiRes::utime(%" NVgf ", %" NVgf
  +                          "): negative time not invented yet",
  +                              SvNV(accessed), SvNV(modified));
  +		Zero(&utbuf, sizeof utbuf, char);
  +		utbuf[0].tv_sec = (Time_t)SvNV(accessed);  /* time accessed */
  +		utbuf[0].tv_nsec = (long)( ( SvNV(accessed) - utbuf[0].tv_sec ) * 1e9 );
  +		utbuf[1].tv_sec = (Time_t)SvNV(modified);  /* time modified */
  +		utbuf[1].tv_nsec = (long)( ( SvNV(modified) - utbuf[1].tv_sec ) * 1e9 );
  +	}
  +
  +	while (items > 0) {
  +		file = POPs; items--;
  +
  +		if (SvROK(file) && GvIO(SvRV(file)) && IoIFP(sv_2io(SvRV(file)))) {
  +			int fd =  PerlIO_fileno(IoIFP(sv_2io(file)));
  +			if (fd < 0)
  +				SETERRNO(EBADF,RMS_IFI);
  +			else 
  +#ifdef HAS_FUTIMENS
  +			if (futimens(fd, utbufp) == 0)
  +				tot++;
  +#else  /* HAS_FUTIMES */
  +				croak("futimens unimplemented in this platform");
  +#endif /* HAS_FUTIMES */
  +		}
  +		else {
  +#ifdef HAS_UTIMENSAT
  +			STRLEN len;
  +			char * name = SvPV(file, len);
  +			if (IS_SAFE_PATHNAME(name, len, "utime") &&
  +			    utimensat(AT_FDCWD, name, utbufp, 0) == 0)
  +				tot++;
  +#else  /* HAS_UTIMENSAT */
  +			croak("utimensat unimplemented in this platform");
  +#endif /* HAS_UTIMENSAT */
  +		}
  +	} /* while items */
  +	RETVAL = tot;
  +
  +    OUTPUT:
  +	RETVAL
  +
  +#else  /* #if defined(TIME_HIRES_UTIME) */
  +
  +I32
  +utime(accessed, modified, ...)
  +    CODE:
  +        croak("Time::HiRes::utime(): unimplemented in this platform");
  +        RETVAL = 0;
  +    OUTPUT:
  +	RETVAL
  +
  +#endif /* #if defined(TIME_HIRES_UTIME) */
  +
   #if defined(TIME_HIRES_CLOCK_GETTIME)
   
   NV
   clock_gettime(clock_id = CLOCK_REALTIME)
  -	int clock_id
  +	clockid_t clock_id
       PREINIT:
   	struct timespec ts;
   	int status = -1;
  @@ -1340,7 +1480,7 @@ clock_gettime(clock_id = CLOCK_REALTIME)
   
   NV
   clock_gettime(clock_id = 0)
  -	int clock_id
  +	clockid_t clock_id
       CODE:
   	PERL_UNUSED_ARG(clock_id);
           croak("Time::HiRes::clock_gettime(): unimplemented in this platform");
  @@ -1354,7 +1494,7 @@ clock_gettime(clock_id = 0)
   
   NV
   clock_getres(clock_id = CLOCK_REALTIME)
  -	int clock_id
  +	clockid_t clock_id
       PREINIT:
   	int status = -1;
   	struct timespec ts;
  @@ -1373,7 +1513,7 @@ clock_getres(clock_id = CLOCK_REALTIME)
   
   NV
   clock_getres(clock_id = 0)
  -	int clock_id
  +	clockid_t clock_id
       CODE:
   	PERL_UNUSED_ARG(clock_id);
           croak("Time::HiRes::clock_getres(): unimplemented in this platform");
  @@ -1387,14 +1527,15 @@ clock_getres(clock_id = 0)
   
   NV
   clock_nanosleep(clock_id, nsec, flags = 0)
  -	int clock_id
  +	clockid_t clock_id
   	NV  nsec
   	int flags
       PREINIT:
   	struct timespec sleepfor, unslept;
       CODE:
   	if (nsec < 0.0)
  -	    croak("Time::HiRes::clock_nanosleep(..., %"NVgf"): negative time not invented yet", nsec);
  +	    croak("Time::HiRes::clock_nanosleep(..., %" NVgf
  +                  "): negative time not invented yet", nsec);
           nanosleep_init(nsec, &sleepfor, &unslept);
   	if (clock_nanosleep(clock_id, flags, &sleepfor, &unslept) == 0) {
   	    RETVAL = nsec;
  @@ -1408,7 +1549,7 @@ clock_nanosleep(clock_id, nsec, flags = 0)
   
   NV
   clock_nanosleep(clock_id, nsec, flags = 0)
  -	int clock_id
  +	clockid_t clock_id
   	NV  nsec
   	int flags
       CODE:
  diff --git a/dist/Time-HiRes/Makefile.PL b/dist/Time-HiRes/Makefile.PL
  index 087ab79871..ccad6a3e6f 100644
  --- dist/Time-HiRes/Makefile.PL
  +++ dist/Time-HiRes/Makefile.PL
  @@ -88,7 +88,7 @@ sub try_compile_and_link {
       my $obj_ext = $Config{obj_ext} || ".o";
       unlink("$tmp.c", "$tmp$obj_ext");
   
  -    if (open(TMPC, ">$tmp.c")) {
  +    if (open(TMPC, '>', "$tmp.c")) {
   	print TMPC $c;
   	close(TMPC);
   
  @@ -132,7 +132,7 @@ __EOD__
   	    unless defined $cccmd;
   
          if ($^O eq 'VMS') {
  -	    open( CMDFILE, ">$tmp.com" );
  +	    open( CMDFILE, '>', "$tmp.com" );
   	    print CMDFILE "\$ SET MESSAGE/NOFACILITY/NOSEVERITY/NOIDENT/NOTEXT\n";
   	    print CMDFILE "\$ $cccmd\n";
   	    print CMDFILE "\$ IF \$SEVERITY .NE. 1 THEN EXIT 44\n"; # escalate
  @@ -290,6 +290,7 @@ sub has_clock_xxx_syscall {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   #include <$SYSCALL_H>
   int main(int argc, char** argv)
   {
  @@ -309,6 +310,7 @@ sub has_clock_xxx {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   int main(int argc, char** argv)
   {
       struct timespec ts;
  @@ -325,6 +327,7 @@ sub has_clock {
   #include "EXTERN.h"
   #include "perl.h"
   #include "XSUB.h"
  +#include <time.h>
   int main(int argc, char** argv)
   {
       clock_t tictoc;
  @@ -348,12 +351,63 @@ int main(int argc, char** argv)
       struct timespec ts2;
       ts1.tv_sec  = 0;
       ts1.tv_nsec = 750000000;;
  -    ret = clock_nanosleep(CLOCK_MONOTONIC, 0, &ts1, &ts2);
  +    /* All implementations are supposed to support CLOCK_REALTIME. */
  +    ret = clock_nanosleep(CLOCK_REALTIME, 0, &ts1, &ts2);
       ret == 0 ? exit(0) : exit(errno ? errno : -1);
   }
   EOM
   }
   
  +sub has_futimens {
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <sys/stat.h>
  +int main(int argc, char** argv)
  +{
  +    int ret;
  +    struct timespec ts[2];
  +    ret = futimens(0, ts);
  +    ret == 0 ? exit(0) : exit(errno ? errno : -1);
  +}
  +EOM
  +}
  +
  +sub has_utimensat{
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <sys/stat.h>
  +#include <fcntl.h>
  +int main(int argc, char** argv)
  +{
  +    int ret;
  +    struct timespec ts[2];
  +    ret = utimensat(AT_FDCWD, 0, ts, 0);
  +    ret == 0 ? exit(0) : exit(errno ? errno : -1);
  +}
  +EOM
  +}
  +
  +sub has_clockid_t{
  +    return 1 if
  +    try_compile_and_link(<<EOM);
  +#include "EXTERN.h"
  +#include "perl.h"
  +#include "XSUB.h"
  +#include <time.h>
  +int main(int argc, char** argv)
  +{
  +    clockid_t id = CLOCK_REALTIME;
  +    exit(id == CLOCK_REALTIME ? 1 : 0);
  +}
  +EOM
  +}
  +
   sub DEFINE {
       my ($def, $val) = @_;
       my $define = defined $val ? "$def=$val" : $def ;
  @@ -534,6 +588,16 @@ EOD
           print "(It would not be portable anyway.)\n";
       }
   
  +    print "Looking for clockid_t... ";
  +    my $has_clockid_t;
  +    if (has_clockid_t()) {
  +	print "found.\n";
  +        $has_clockid_t++;
  +	$DEFINE .= ' -DTIME_HIRES_CLOCKID_T';
  +    } else {
  +	print "NOT found, will use int.\n";
  +    }
  +
       print "Looking for clock_gettime()... ";
       my $has_clock_gettime;
       my $has_clock_gettime_emulation;
  @@ -548,7 +612,7 @@ EOD
       } elsif ($^O eq 'darwin') {
          $has_clock_gettime_emulation++;
          $has_clock_gettime++;
  -       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETTIME';
  +       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETTIME -DTIME_HIRES_CLOCK_GETTIME_EMULATION';
       }
   
       if ($has_clock_gettime) {
  @@ -577,7 +641,7 @@ EOD
       } elsif ($^O eq 'darwin') {
          $has_clock_getres_emulation++;
          $has_clock_getres++;
  -       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETRES';
  +       $DEFINE .= ' -DTIME_HIRES_CLOCK_GETRES -DTIME_HIRES_CLOCK_GETRES_EMULATION';
       }
   
       if ($has_clock_getres) {
  @@ -603,7 +667,7 @@ EOD
       } elsif ($^O eq 'darwin') {
           $has_clock_nanosleep++;
           $has_clock_nanosleep_emulation++;
  -	$DEFINE .= ' -DTIME_HIRES_CLOCK_NANOSLEEP';
  +	$DEFINE .= ' -DTIME_HIRES_CLOCK_NANOSLEEP -DTIME_HIRES_CLOCK_NANOSLEEP_EMULATION';
       }
   
       if ($has_clock_nanosleep) {
  @@ -631,6 +695,36 @@ EOD
   	print "NOT found.\n";
       }
   
  +    print "Looking for futimens()... ";
  +    my $has_futimens;
  +    if (has_futimens()) {
  +        $has_futimens++;
  +	$DEFINE .= ' -DHAS_FUTIMENS';
  +    }
  +
  +    if ($has_futimens) {
  +        print "found.\n";
  +    } else {
  +	print "NOT found.\n";
  +    }
  +
  +    print "Looking for utimensat()... ";
  +    my $has_utimensat;
  +    if (has_utimensat()) {
  +        $has_utimensat++;
  +	$DEFINE .= ' -DHAS_UTIMENSAT';
  +    }
  +
  +    if ($has_utimensat) {
  +        print "found.\n";
  +    } else {
  +	print "NOT found.\n";
  +    }
  +
  +    if ($has_futimens or $has_utimensat) {
  +	$DEFINE .= ' -DTIME_HIRES_UTIME';
  +    }
  +
       print "Looking for stat() subsecond timestamps...\n";
   
       print "Trying struct stat st_atimespec.tv_nsec...";
  @@ -644,7 +738,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtimespec++;
  -      DEFINE('TIME_HIRES_STAT', 1);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIMESPEC');  # 1
       }
   
       if ($has_stat_st_xtimespec) {
  @@ -664,7 +758,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtimensec++;
  -      DEFINE('TIME_HIRES_STAT', 2);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIMENSEC');  # 2
       }
   
       if ($has_stat_st_xtimensec) {
  @@ -684,7 +778,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtime_n++;
  -      DEFINE('TIME_HIRES_STAT', 3);
  +      DEFINE('TIME_HIRES_STAT_ST_XTIME_N');  # 3
       }
   
       if ($has_stat_st_xtime_n) {
  @@ -704,7 +798,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_xtim++;
  -      DEFINE('TIME_HIRES_STAT', 4);
  +      DEFINE('TIME_HIRES_STAT_XTIM');  # 4
       }
   
       if ($has_stat_st_xtim) {
  @@ -724,7 +818,7 @@ int main(int argc, char** argv) {
   }
   EOM
         $has_stat_st_uxtime++;
  -      DEFINE('TIME_HIRES_STAT', 5);
  +      DEFINE('TIME_HIRES_STAT_ST_UXTIME');  # 5
       }
   
       if ($has_stat_st_uxtime) {
  @@ -733,6 +827,19 @@ EOM
   	print "NOT found.\n";
       }
   
  +    # See HiRes.xs hrstatns()
  +    if ($has_stat_st_xtimespec) {
  +        DEFINE('TIME_HIRES_STAT', 1);
  +    } elsif ($has_stat_st_xtimensec) {
  +        DEFINE('TIME_HIRES_STAT', 2);
  +    } elsif ($has_stat_st_xtime_n) {
  +        DEFINE('TIME_HIRES_STAT', 3);
  +    } elsif ($has_stat_st_xtim) {
  +        DEFINE('TIME_HIRES_STAT', 4);
  +    } elsif ($has_stat_st_uxtime) {
  +        DEFINE('TIME_HIRES_STAT', 5);
  +    }    
  +
      if ($DEFINE =~ /-DTIME_HIRES_STAT=\d+/) {
       print "You seem to have stat() subsecond timestamps.\n";
       print "(Your struct stat has them, but the filesystems must help.)\n";
  @@ -757,7 +864,7 @@ EOM
   
       if ($DEFINE) {
           $DEFINE =~ s/^\s+//;
  -        if (open(XDEFINE, ">xdefine")) {
  +        if (open(XDEFINE, '>', 'xdefine')) {
   	    print XDEFINE $DEFINE, "\n";
   	    close(XDEFINE);
           }
  @@ -791,7 +898,7 @@ sub doMakefile {
   	    'DynaLoader' => 0,
   	    'Exporter' => 0,
   	    'ExtUtils::MakeMaker' => 0,
  -	    'Test::More' => "0.82",
  +	    'Test::More' => 0,
   	    'strict' => 0,
   	},
   	'dist'      => {
  @@ -869,7 +976,8 @@ sub doConstants {
                         );
   	foreach (qw (d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
   		     d_nanosleep d_clock_gettime d_clock_getres
  -		     d_clock d_clock_nanosleep d_hires_stat)) {
  +		     d_clock d_clock_nanosleep d_hires_stat
  +                     d_futimens d_utimensat d_hires_utime)) {
   	    my $macro = $_;
   	    if ($macro =~ /^(d_nanosleep|d_clock)$/) {
   		$macro =~ s/^d_(.+)/TIME_HIRES_\U$1/;
  @@ -879,6 +987,13 @@ sub doConstants {
   		push @names, {name => $_, macro => "TIME_HIRES_STAT", value => $d_hires_stat,
   			      default => ["IV", "0"]};
   		next;
  +	    } elsif ($macro =~ /^(d_hires_utime)$/) {
  +		my $d_hires_utime =
  +                    ($DEFINE =~ /-DHAS_FUTIMENS/ ||
  +                     $DEFINE =~ /-DHAS_UTIMENSAT/) ? 1 : 0;
  +		push @names, {name => $_, macro => "TIME_HIRES_UTIME", value => $d_hires_utime,
  +			      default => ["IV", "0"]};
  +		next;
   	    } elsif ($macro =~ /^(d_clock_gettime|d_clock_getres|d_clock_nanosleep)$/) {
   		$macro =~ s/^d_(.+)/TIME_HIRES_\U$1/;
   		my $val = ($DEFINE =~ /-D$macro\b/) ? 1 : 0;
  @@ -900,8 +1015,8 @@ sub doConstants {
   	foreach $file ('const-c.inc', 'const-xs.inc') {
   	    my $fallback = File::Spec->catfile('fallback', $file);
   	    local $/;
  -	    open IN, "<$fallback" or die "Can't open $fallback: $!";
  -	    open OUT, ">$file" or die "Can't open $file: $!";
  +	    open IN, '<', $fallback or die "Can't open $fallback: $!";
  +	    open OUT, '>', $file or die "Can't open $file: $!";
   	    print OUT <IN> or die $!;
   	    close OUT or die "Can't close $file: $!";
   	    close IN or die "Can't close $fallback: $!";
  @@ -920,7 +1035,7 @@ sub main {
   	    DEFINE('SELECT_IS_BROKEN');
   	    $LIBS = [];
   	    print "System is $^O, skipping full configure...\n";
  -	    open(XDEFINE, ">xdefine") or die "$0: Cannot create xdefine: $!\n";
  +	    open(XDEFINE, '>', 'xdefine') or die "$0: Cannot create xdefine: $!\n";
   	    close(XDEFINE);
   	} else {
   	    init();
  diff --git a/dist/Time-HiRes/fallback/const-c.inc b/dist/Time-HiRes/fallback/const-c.inc
  index a8626172af..524db169a9 100644
  --- dist/Time-HiRes/fallback/const-c.inc
  +++ dist/Time-HiRes/fallback/const-c.inc
  @@ -19,6 +19,7 @@ typedef double NV; /* 5.6 and later define NVTYPE, and typedef NV to it.  */
   #ifndef pTHX_
   #define pTHX_ /* 5.6 or later define this for threading support.  */
   #endif
  +
   static int
   constant_11 (pTHX_ const char *name, IV *iv_return) {
     /* When generated this function returned values for the list of names given
  @@ -86,6 +87,51 @@ constant_11 (pTHX_ const char *name, IV *iv_return) {
     return PERL_constant_NOTFOUND;
   }
   
  +static int
  +constant_13 (pTHX_ const char *name, IV *iv_return) {
  +  /* When generated this function returned values for the list of names given
  +     here.  However, subsequent manual editing may have added or removed some.
  +     CLOCK_HIGHRES TIMER_ABSTIME d_hires_utime */
  +  /* Offset 1 gives the best switch position.  */
  +  switch (name[1]) {
  +  case 'I':
  +    if (memEQ(name, "TIMER_ABSTIME", 13)) {
  +    /*                ^                  */
  +#ifdef TIMER_ABSTIME
  +      *iv_return = TIMER_ABSTIME;
  +      return PERL_constant_ISIV;
  +#else
  +      return PERL_constant_NOTDEF;
  +#endif
  +    }
  +    break;
  +  case 'L':
  +    if (memEQ(name, "CLOCK_HIGHRES", 13)) {
  +    /*                ^                  */
  +#ifdef CLOCK_HIGHRES
  +      *iv_return = CLOCK_HIGHRES;
  +      return PERL_constant_ISIV;
  +#else
  +      return PERL_constant_NOTDEF;
  +#endif
  +    }
  +    break;
  +  case '_':
  +    if (memEQ(name, "d_hires_utime", 13)) {
  +    /*                ^                  */
  +#ifdef TIME_HIRES_UTIME
  +      *iv_return = 1;
  +      return PERL_constant_ISIV;
  +#else
  +      *iv_return = 0;
  +      return PERL_constant_ISIV;
  +#endif
  +    }
  +    break;
  +  }
  +  return PERL_constant_NOTFOUND;
  +}
  +
   static int
   constant_14 (pTHX_ const char *name, IV *iv_return) {
     /* When generated this function returned values for the list of names given
  @@ -250,16 +296,17 @@ my @names = (qw(CLOCKS_PER_SEC CLOCK_HIGHRES CLOCK_MONOTONIC
               {name=>"d_getitimer", type=>"IV", macro=>"HAS_GETITIMER", value=>"1", default=>["IV", "0"]},
               {name=>"d_gettimeofday", type=>"IV", macro=>"HAS_GETTIMEOFDAY", value=>"1", default=>["IV", "0"]},
               {name=>"d_hires_stat", type=>"IV", macro=>"TIME_HIRES_STAT", value=>"1", default=>["IV", "0"]},
  +            {name=>"d_hires_utime", type=>"IV", macro=>"TIME_HIRES_UTIME", value=>"1", default=>["IV", "0"]},
               {name=>"d_nanosleep", type=>"IV", macro=>"TIME_HIRES_NANOSLEEP", value=>"1", default=>["IV", "0"]},
               {name=>"d_setitimer", type=>"IV", macro=>"HAS_SETITIMER", value=>"1", default=>["IV", "0"]},
               {name=>"d_ualarm", type=>"IV", macro=>"HAS_UALARM", value=>"1", default=>["IV", "0"]},
               {name=>"d_usleep", type=>"IV", macro=>"HAS_USLEEP", value=>"1", default=>["IV", "0"]});
   
  -print constant_types(); # macro defs
  +print constant_types(), "\n"; # macro defs
   foreach (C_constant ("Time::HiRes", 'constant', 'IV', $types, undef, 3, @names) ) {
       print $_, "\n"; # C constant subs
   }
  -print "#### XS Section:\n";
  +print "\n#### XS Section:\n";
   print XS_constant ("Time::HiRes", $types);
   __END__
      */
  @@ -322,33 +369,7 @@ __END__
       }
       break;
     case 13:
  -    /* Names all of length 13.  */
  -    /* CLOCK_HIGHRES TIMER_ABSTIME */
  -    /* Offset 2 gives the best switch position.  */
  -    switch (name[2]) {
  -    case 'M':
  -      if (memEQ(name, "TIMER_ABSTIME", 13)) {
  -      /*                 ^                 */
  -#ifdef TIMER_ABSTIME
  -        *iv_return = TIMER_ABSTIME;
  -        return PERL_constant_ISIV;
  -#else
  -        return PERL_constant_NOTDEF;
  -#endif
  -      }
  -      break;
  -    case 'O':
  -      if (memEQ(name, "CLOCK_HIGHRES", 13)) {
  -      /*                 ^                 */
  -#ifdef CLOCK_HIGHRES
  -        *iv_return = CLOCK_HIGHRES;
  -        return PERL_constant_ISIV;
  -#else
  -        return PERL_constant_NOTDEF;
  -#endif
  -      }
  -      break;
  -    }
  +    return constant_13 (aTHX_ name, iv_return);
       break;
     case 14:
       return constant_14 (aTHX_ name, iv_return);
  diff --git a/dist/Time-HiRes/t/Watchdog.pm b/dist/Time-HiRes/t/Watchdog.pm
  index 83e854396f..44ec8081de 100644
  --- dist/Time-HiRes/t/Watchdog.pm
  +++ dist/Time-HiRes/t/Watchdog.pm
  @@ -10,44 +10,44 @@ my $watchdog_pid;
   my $TheEnd;
   
   if ($Config{d_fork}) {
  -    note "I am the main process $$, starting the watchdog process...";
  +    print("# I am the main process $$, starting the watchdog process...\n");
       $watchdog_pid = fork();
       if (defined $watchdog_pid) {
   	if ($watchdog_pid == 0) { # We are the kid, set up the watchdog.
   	    my $ppid = getppid();
  -	    note "I am the watchdog process $$, sleeping for $waitfor seconds...";
  +	    print("# I am the watchdog process $$, sleeping for $waitfor seconds...\n");
   	    sleep($waitfor - 2);    # Workaround for perlbug #49073
   	    sleep(2);               # Wait for parent to exit
   	    if (kill(0, $ppid)) {   # Check if parent still exists
   		warn "\n$0: overall time allowed for tests (${waitfor}s) exceeded!\n";
  -		note "Terminating main process $ppid...";
  +		print("Terminating main process $ppid...\n");
   		kill('KILL', $ppid);
  -		note "This is the watchdog process $$, over and out.";
  +		print("# This is the watchdog process $$, over and out.\n");
   	    }
   	    exit(0);
   	} else {
  -	    note "The watchdog process $watchdog_pid launched, continuing testing...";
  +	    print("# The watchdog process $watchdog_pid launched, continuing testing...\n");
   	    $TheEnd = time() + $waitfor;
   	}
       } else {
   	warn "$0: fork failed: $!\n";
       }
   } else {
  -    note "No watchdog process (need fork)";
  +    print("# No watchdog process (need fork)\n");
   }
   
   END {
       if ($watchdog_pid) { # Only in the main process.
   	my $left = $TheEnd - time();
  -	note sprintf "I am the main process $$, terminating the watchdog process $watchdog_pid before it terminates me in %d seconds (testing took %d seconds).", $left, $waitfor - $left;
  +	printf("# I am the main process $$, terminating the watchdog process $watchdog_pid before it terminates me in %d seconds (testing took %d seconds).\n", $left, $waitfor - $left);
   	if (kill(0, $watchdog_pid)) {
   	    local $? = 0;
   	    my $kill = kill('KILL', $watchdog_pid); # We are done, the watchdog can go.
   	    wait();
  -	    note sprintf "kill KILL $watchdog_pid = %d", $kill;
  +	    printf("# kill KILL $watchdog_pid = %d\n", $kill);
   	}
   	unlink("ktrace.out"); # Used in BSD system call tracing.
  -	note "All done.";
  +	print("# All done.\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/t/alarm.t b/dist/Time-HiRes/t/alarm.t
  index 841694f67c..4935410d36 100644
  --- dist/Time-HiRes/t/alarm.t
  +++ dist/Time-HiRes/t/alarm.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 10;
  +use Test::More tests => 10;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -10,7 +10,7 @@ use Config;
   my $limit = 0.25; # 25% is acceptable slosh for testing timers
   
   my $xdefine = ''; 
  -if (open(XDEFINE, "xdefine")) {
  +if (open(XDEFINE, "<", "xdefine")) {
       chomp($xdefine = <XDEFINE> || "");
       close(XDEFINE);
   }
  @@ -29,12 +29,14 @@ SKIP: {
   
       my ($r, $i, $not, $ok);
   
  +    $not = "";
  +
       $r = [Time::HiRes::gettimeofday()];
       $i = 5;
       my $oldaction;
       if ($use_sigaction) {
   	$oldaction = new POSIX::SigAction;
  -	note sprintf "sigaction tick, ALRM = %d", &POSIX::SIGALRM;
  +	printf("# sigaction tick, ALRM = %d\n", &POSIX::SIGALRM);
   
   	# Perl's deferred signals may be too wimpy to break through
   	# a restartable select(), so use POSIX::sigaction if available.
  @@ -44,7 +46,7 @@ SKIP: {
   			 $oldaction)
   	    or die "Error setting SIGALRM handler with sigaction: $!\n";
       } else {
  -	note "SIG tick";
  +	print("# SIG tick\n");
   	$SIG{ALRM} = "tick";
       }
   
  @@ -56,8 +58,8 @@ SKIP: {
   	    Time::HiRes::alarm(0.3);
   	    select (undef, undef, undef, 3);
   	    my $ival = Time::HiRes::tv_interval ($r);
  -	    note "Select returned! $i $ival";
  -	    note abs($ival/3 - 1);
  +	    print("# Select returned! $i $ival\n");
  +	    printf("# %s\n", abs($ival/3 - 1));
   	    # Whether select() gets restarted after signals is
   	    # implementation dependent.  If it is restarted, we
   	    # will get about 3.3 seconds: 3 from the select, 0.3
  @@ -86,7 +88,7 @@ SKIP: {
       sub tick {
   	$i--;
   	my $ival = Time::HiRes::tv_interval ($r);
  -	note "Tick! $i $ival";
  +	print("# Tick! $i $ival\n");
   	my $exp = 0.3 * (5 - $i);
   	if ($exp == 0) {
   	    $not = "tick: divisor became zero";
  @@ -106,8 +108,8 @@ SKIP: {
   	Time::HiRes::alarm(0); # can't cancel usig %SIG
       }
   
  +    print("# $not\n");
       ok !$not;
  -    note $not || $ok;
   }
   
   SKIP: {
  @@ -126,7 +128,7 @@ SKIP: {
       # http://groups.google.com/group/perl.perl5.porters/browse_thread/thread/adaffaaf939b042e/20dafc298df737f0%2320dafc298df737f0?sa=X&oi=groupsr&start=0&num=3
       # Perl changes [18765] and [18770], perl bug [perl #20920]
   
  -    note "Finding delay loop...";
  +    print("# Finding delay loop...\n");
   
       my $T = 0.01;
       my $DelayN = 1024;
  @@ -137,7 +139,7 @@ SKIP: {
   	 for ($i = 0; $i < $DelayN; $i++) { }
   	 my $t1 = Time::HiRes::time();
   	 my $dt = $t1 - $t0;
  -	 note "N = $DelayN, t1 = $t1, t0 = $t0, dt = $dt";
  +	 print("# N = $DelayN, t1 = $t1, t0 = $t0, dt = $dt\n");
   	 last N if $dt > $T;
   	 $DelayN *= 2;
        } while (1);
  @@ -169,7 +171,7 @@ SKIP: {
   
       $SIG{ALRM} = sub {
   	$a++;
  -	note "Alarm $a - ", Time::HiRes::time();
  +	printf("# Alarm $a - %s\n", Time::HiRes::time());
   	Time::HiRes::alarm(0) if $a >= $A; # Disarm the alarm.
   	$Delay->(2); # Try burning CPU at least for 2T seconds.
       }; 
  @@ -204,18 +206,18 @@ SKIP: {
   	my $alrm = 0;
   	$SIG{ALRM} = sub { $alrm++ };
   	my $got = Time::HiRes::alarm(2.7);
  -	ok $got == 0 or note $got;
  +	ok $got == 0 or print("# $got\n");
   
   	my $t0 = Time::HiRes::time();
   	1 while Time::HiRes::time() - $t0 <= 1;
   
   	$got = Time::HiRes::alarm(0);
  -	ok $got > 0 && $got < 1.8 or note $got;
  +	ok $got > 0 && $got < 1.8 or print("# $got\n");
   
  -	ok $alrm == 0 or note $alrm;
  +	ok $alrm == 0 or print("# $alrm\n");
   
   	$got = Time::HiRes::alarm(0);
  -	ok $got == 0 or note $got;
  +	ok $got == 0 or print("# $got\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/t/clock.t b/dist/Time-HiRes/t/clock.t
  index 6d11dd2ca0..346ca57fbf 100644
  --- dist/Time-HiRes/t/clock.t
  +++ dist/Time-HiRes/t/clock.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 5;
  +use Test::More tests => 5;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -13,10 +13,10 @@ sub has_symbol {
       return $@ eq '';
   }
   
  -note sprintf "have_clock_gettime   = %d", &Time::HiRes::d_clock_gettime;
  -note sprintf "have_clock_getres    = %d", &Time::HiRes::d_clock_getres;
  -note sprintf "have_clock_nanosleep = %d", &Time::HiRes::d_clock_nanosleep;
  -note sprintf "have_clock           = %d", &Time::HiRes::d_clock;
  +printf("# have_clock_gettime   = %d\n", &Time::HiRes::d_clock_gettime);
  +printf("# have_clock_getres    = %d\n", &Time::HiRes::d_clock_getres);
  +printf("# have_clock_nanosleep = %d\n", &Time::HiRes::d_clock_nanosleep);
  +printf("# have_clock           = %d\n", &Time::HiRes::d_clock);
   
   # Ideally, we'd like to test that the timers are rather precise.
   # However, if the system is busy, there are no guarantees on how
  @@ -36,25 +36,25 @@ SKIP: {
       my $ok = 0;
    TRY: {
   	for my $try (1..3) {
  -	    note "CLOCK_REALTIME: try = $try";
  +	    print("# CLOCK_REALTIME: try = $try\n");
   	    my $t0 = Time::HiRes::clock_gettime(&CLOCK_REALTIME);
   	    my $T = 1.5;
   	    Time::HiRes::sleep($T);
   	    my $t1 = Time::HiRes::clock_gettime(&CLOCK_REALTIME);
   	    if ($t0 > 0 && $t1 > $t0) {
  -		note "t1 = $t1, t0 = $t0";
  +		print("# t1 = $t1, t0 = $t0\n");
   		my $dt = $t1 - $t0;
   		my $rt = abs(1 - $dt / $T);
  -		note "dt = $dt, rt = $rt";
  +		print("# dt = $dt, rt = $rt\n");
   		if ($rt <= 2 * $limit) {
   		    $ok = 1;
   		    last TRY;
   		}
   	    } else {
  -		note "Error: t0 = $t0, t1 = $t1";
  +		print("# Error: t0 = $t0, t1 = $t1\n");
   	    }
   	    my $r = rand() + rand();
  -	    note sprintf "Sleeping for %.6f seconds...\n", $r;
  +	    printf("# Sleeping for %.6f seconds...\n", $r);
   	    Time::HiRes::sleep($r);
   	}
       }
  @@ -64,7 +64,7 @@ SKIP: {
   SKIP: {
       skip "no clock_getres", 1 unless &Time::HiRes::d_clock_getres;
       my $tr = Time::HiRes::clock_getres();
  -    ok $tr > 0 or note "tr = $tr";
  +    ok $tr > 0 or print("# tr = $tr\n");
   }
   
   SKIP: {
  @@ -73,17 +73,17 @@ SKIP: {
       my $s = 1.5e9;
       my $t = Time::HiRes::clock_nanosleep(&CLOCK_REALTIME, $s);
       my $r = abs(1 - $t / $s);
  -    ok $r < 2 * $limit or note "t = $t, r = $r";
  +    ok $r < 2 * $limit or print("# t = $t, r = $r\n");
   }
   
   SKIP: {
       skip "no clock", 1 unless &Time::HiRes::d_clock;
       my @clock = Time::HiRes::clock();
  -    note "clock = @clock";
  +    print("# clock = @clock\n");
       for my $i (1..3) {
   	for (my $j = 0; $j < 1e6; $j++) { }
   	push @clock, Time::HiRes::clock();
  -	note "clock = @clock";
  +	print("# clock = @clock\n");
       }
       ok $clock[0] >= 0 &&
   	$clock[1] > $clock[0] &&
  diff --git a/dist/Time-HiRes/t/gettimeofday.t b/dist/Time-HiRes/t/gettimeofday.t
  index 8f7c5f3039..69defe8672 100644
  --- dist/Time-HiRes/t/gettimeofday.t
  +++ dist/Time-HiRes/t/gettimeofday.t
  @@ -8,26 +8,26 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 6;
  +use Test::More tests => 6;
   use t::Watchdog;
   
   my @one = Time::HiRes::gettimeofday();
  -note 'gettimeofday returned ', 0+@one, ' args';
  +printf("# gettimeofday returned %d args\n", 0+@one);
   ok @one == 2;
  -ok $one[0] > 850_000_000 or note "@one too small";
  +ok $one[0] > 850_000_000 or print("# @one too small\n");
   
   sleep 1;
   
   my @two = Time::HiRes::gettimeofday();
   ok $two[0] > $one[0] || ($two[0] == $one[0] && $two[1] > $one[1])
  -	or note "@two is not greater than @one";
  +	or print("# @two is not greater than @one\n");
   
   my $f = Time::HiRes::time();
  -ok $f > 850_000_000 or note "$f too small";
  -ok $f - $two[0] < 2 or note "$f - $two[0] >= 2";
  +ok $f > 850_000_000 or print("# $f too small\n");
  +ok $f - $two[0] < 2 or print("# $f - $two[0] >= 2\n");
   
   my $r = [Time::HiRes::gettimeofday()];
   my $g = Time::HiRes::tv_interval $r;
  -ok $g < 2 or note $g;
  +ok $g < 2 or print("# $g\n");
   
   1;
  diff --git a/dist/Time-HiRes/t/itimer.t b/dist/Time-HiRes/t/itimer.t
  index 9eb2b93f6f..31cdd674ae 100644
  --- dist/Time-HiRes/t/itimer.t
  +++ dist/Time-HiRes/t/itimer.t
  @@ -25,7 +25,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   use t::Watchdog;
   
   my $limit = 0.25; # 25% is acceptable slosh for testing timers
  @@ -35,11 +35,11 @@ my $r = [Time::HiRes::gettimeofday()];
   
   $SIG{VTALRM} = sub {
       $i ? $i-- : Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0);
  -    note "Tick! $i ", Time::HiRes::tv_interval($r);
  +    printf("# Tick! $i %s\n", Time::HiRes::tv_interval($r));
   };	
   
  -note "setitimer: ", join(" ",
  -    Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0.5, 0.4));
  +printf("# setitimer: %s\n", join(" ",
  +       Time::HiRes::setitimer(&Time::HiRes::ITIMER_VIRTUAL, 0.5, 0.4)));
   
   # Assume interval timer granularity of $limit * 0.5 seconds.  Too bold?
   my $virt = Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL);
  @@ -47,19 +47,19 @@ ok(defined $virt && abs($virt / 0.5) - 1 < $limit,
      "ITIMER_VIRTUAL defined with sufficient granularity")
      or diag "virt=" . (defined $virt ? $virt : 'undef');
   
  -note "getitimer: ", join(" ",
  -    Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL));
  +printf("# getitimer: %s\n", join(" ",
  +       Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)));
   
   while (Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)) {
       my $j;
       for (1..1000) { $j++ } # Can't be unbreakable, must test getitimer().
   }
   
  -note "getitimer: ", join(" ",
  -    Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL));
  +printf("# getitimer: %s\n", join(" ",
  +       Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL)));
   
   $virt = Time::HiRes::getitimer(&Time::HiRes::ITIMER_VIRTUAL);
  -note "at end, i=$i";
  +print("# at end, i=$i\n");
   is($virt, 0, "time left should be zero");
   
   $SIG{VTALRM} = 'DEFAULT';
  diff --git a/dist/Time-HiRes/t/nanosleep.t b/dist/Time-HiRes/t/nanosleep.t
  index aef9db6163..c17a7e4790 100644
  --- dist/Time-HiRes/t/nanosleep.t
  +++ dist/Time-HiRes/t/nanosleep.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 3;
  +use Test::More tests => 3;
   use t::Watchdog;
   
   eval { Time::HiRes::nanosleep(-5) };
  @@ -21,7 +21,7 @@ my $two = CORE::time;
   Time::HiRes::nanosleep(10_000_000);
   my $three = CORE::time;
   ok $one == $two || $two == $three
  -    or note "slept too long, $one $two $three";
  +    or print("# slept too long, $one $two $three\n");
   
   SKIP: {
       skip "no gettimeofday", 1 unless &Time::HiRes::d_gettimeofday;
  @@ -29,7 +29,7 @@ SKIP: {
       Time::HiRes::nanosleep(500_000_000);
       my $f2 = Time::HiRes::time();
       my $d = $f2 - $f;
  -    ok $d > 0.4 && $d < 0.9 or note "slept $d secs $f to $f2";
  +    ok $d > 0.4 && $d < 0.9 or print("# slept $d secs $f to $f2\n");
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/sleep.t b/dist/Time-HiRes/t/sleep.t
  index e7cc6271a8..b84b4c6725 100644
  --- dist/Time-HiRes/t/sleep.t
  +++ dist/Time-HiRes/t/sleep.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 4;
  +use Test::More tests => 4;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -8,7 +8,7 @@ BEGIN { require_ok "Time::HiRes"; }
   use Config;
   
   my $xdefine = ''; 
  -if (open(XDEFINE, "xdefine")) {
  +if (open(XDEFINE, "<", "xdefine")) {
       chomp($xdefine = <XDEFINE> || "");
       close(XDEFINE);
   }
  @@ -26,12 +26,12 @@ like $@, qr/::sleep\(-1\): negative time not invented yet/,
   SKIP: {
       skip "no subsecond alarm", 2 unless $can_subsecond_alarm;
       my $f = Time::HiRes::time; 
  -    note "time...$f";
  +    print("# time...$f\n");
       ok 1;
   
       my $r = [Time::HiRes::gettimeofday()];
       Time::HiRes::sleep (0.5);
  -    note "sleep...", Time::HiRes::tv_interval($r);
  +    printf("# sleep...%s\n", Time::HiRes::tv_interval($r));
       ok 1;
   }
   
  diff --git a/dist/Time-HiRes/t/stat.t b/dist/Time-HiRes/t/stat.t
  index 68a6fb6bbd..a59a342e20 100644
  --- dist/Time-HiRes/t/stat.t
  +++ dist/Time-HiRes/t/stat.t
  @@ -13,14 +13,14 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 43;
  +use Test::More tests => 43;
   use t::Watchdog;
   
   my @atime;
   my @mtime;
   for (1..5) {
       Time::HiRes::sleep(rand(0.1) + 0.1);
  -    open(X, ">$$");
  +    open(X, '>', $$);
       print X $$;
       close(X);
       my($a, $stat, $b) = ("a", [Time::HiRes::stat($$)], "b");
  @@ -33,7 +33,7 @@ for (1..5) {
       is $b, "b";
       is_deeply $lstat, $stat;
       Time::HiRes::sleep(rand(0.1) + 0.1);
  -    open(X, "<$$");
  +    open(X, '<', $$);
       <X>;
       close(X);
       $stat = [Time::HiRes::stat($$)];
  @@ -42,8 +42,8 @@ for (1..5) {
       is_deeply $lstat, $stat;
   }
   1 while unlink $$;
  -note "mtime = @mtime";
  -note "atime = @atime";
  +print("# mtime = @mtime\n");
  +print("# atime = @atime\n");
   my $ai = 0;
   my $mi = 0;
   my $ss = 0;
  @@ -63,7 +63,7 @@ for (my $i = 1; $i < @mtime; $i++) {
   	$ss++;
       }
   }
  -note "ai = $ai, mi = $mi, ss = $ss";
  +print("# ai = $ai, mi = $mi, ss = $ss\n");
   # Need at least 75% of monotonical increase and
   # 20% of subsecond results. Yes, this is guessing.
   SKIP: {
  @@ -75,7 +75,7 @@ SKIP: {
   my $targetname = "tgt$$";
   my $linkname = "link$$";
   SKIP: {
  -    open(X, ">$targetname");
  +    open(X, '>', $targetname);
       print X $$;
       close(X);
       eval { symlink $targetname, $linkname or die "can't symlink: $!"; };
  diff --git a/dist/Time-HiRes/t/time.t b/dist/Time-HiRes/t/time.t
  index feec4799d9..6f219f9e0c 100644
  --- dist/Time-HiRes/t/time.t
  +++ dist/Time-HiRes/t/time.t
  @@ -1,6 +1,6 @@
   use strict;
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   use t::Watchdog;
   
   BEGIN { require_ok "Time::HiRes"; }
  @@ -16,8 +16,8 @@ SKIP: {
       # (CORE::time() may be rounding down, up, or closest),
       # but allow 10% of slop.
       ok abs($s) / $n <= 1.10
  -	or note "Time::HiRes::time() not close to CORE::time()";
  -    note "s = $s, n = $n, s/n = ", abs($s)/$n;
  +	or print("# Time::HiRes::time() not close to CORE::time()\n");
  +    printf("# s = $s, n = $n, s/n = %s\n", abs($s)/$n);
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/tv_interval.t b/dist/Time-HiRes/t/tv_interval.t
  index bffcf39ec1..8ac876daf3 100644
  --- dist/Time-HiRes/t/tv_interval.t
  +++ dist/Time-HiRes/t/tv_interval.t
  @@ -1,10 +1,10 @@
   use strict;
   
  -use Test::More 0.82 tests => 2;
  +use Test::More tests => 2;
   
   BEGIN { require_ok "Time::HiRes"; }
   
   my $f = Time::HiRes::tv_interval [5, 100_000], [10, 500_000];
  -ok abs($f - 5.4) < 0.001 or note $f;
  +ok abs($f - 5.4) < 0.001 or print("# $f\n");
   
   1;
  diff --git a/dist/Time-HiRes/t/ualarm.t b/dist/Time-HiRes/t/ualarm.t
  index 12ef4b52cc..b50a175f44 100644
  --- dist/Time-HiRes/t/ualarm.t
  +++ dist/Time-HiRes/t/ualarm.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 12;
  +use Test::More tests => 12;
   use t::Watchdog;
   
   use Config;
  @@ -24,13 +24,13 @@ SKIP: {
       $tick = 0; Time::HiRes::ualarm(10_000); while ($tick == 0) { }
       my $three = CORE::time;
       ok $one == $two || $two == $three
  -	or note "slept too long, $one $two $three";
  -    note "tick = $tick, one = $one, two = $two, three = $three";
  +	or print("# slept too long, $one $two $three\n");
  +    print("# tick = $tick, one = $one, two = $two, three = $three\n");
   
       $tick = 0; Time::HiRes::ualarm(10_000, 10_000); while ($tick < 3) { }
       ok 1;
       Time::HiRes::ualarm(0);
  -    note "tick = $tick, one = $one, two = $two, three = $three";
  +    print("# tick = $tick, one = $one, two = $two, three = $three\n");
   }
   
   eval { Time::HiRes::ualarm(-4) };
  @@ -59,24 +59,24 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
   	my $alarmed = 0;
   	local $SIG{ ALRM } = sub { $alarmed++ };
   	my $t0 = Time::HiRes::time();
  -	note "t0 = $t0";
  -	note "ualarm($n)";
  +	print("# t0 = $t0\n");
  +	print("# ualarm($n)\n");
   	Time::HiRes::ualarm($n); 1 while $alarmed == 0;
   	my $t1 = Time::HiRes::time();
  -	note "t1 = $t1";
  +	print("# t1 = $t1\n");
   	my $dt = $t1 - $t0;
  -	note "dt = $dt";
  +	print("# dt = $dt\n");
   	my $r = $dt / ($n/1e6);
  -	note "r = $r";
  +	print("# r = $r\n");
   	$ok =
   	    ($n < 1_000_000 || # Too much noise.
   	     ($r >= 0.8 && $r <= 1.6));
   	last if $ok;
   	my $nap = bellish(3, 15);
  -	note sprintf "Retrying in %.1f seconds...\n", $nap;
  +	printf("# Retrying in %.1f seconds...\n", $nap);
   	Time::HiRes::sleep($nap);
       }
  -    ok $ok or note "ualarm($n) close enough";
  +    ok $ok or print("# ualarm($n) close enough\n");
   }
   
   {
  @@ -93,12 +93,12 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
       } while $t1 - $t0 <= 0.3;
       my $got1 = Time::HiRes::ualarm(0);
   
  -    note "t0 = $t0";
  -    note "got0 = $got0";
  -    note "t1 = $t1";
  -    note "t1 - t0 = ", ($t1 - $t0);
  -    note "got1 = $got1";
  -    ok $got0 == 0 or note $got0;
  +    print("# t0 = $t0\n");
  +    print("# got0 = $got0\n");
  +    print("# t1 = $t1\n");
  +    printf("# t1 - t0 = %s\n", ($t1 - $t0));
  +    print("# got1 = $got1\n");
  +    ok $got0 == 0 or print("# $got0\n");
       SKIP: {
   	skip "alarm interval exceeded", 2 if $t1 - $t0 >= 0.5;
   	ok $got1 > 0;
  @@ -106,7 +106,7 @@ for my $n (100_000, 1_100_000, 2_200_000, 4_300_000) {
       }
       ok $got1 < 300_000;
       my $got2 = Time::HiRes::ualarm(0);
  -    ok $got2 == 0 or note $got2;
  +    ok $got2 == 0 or print("# $got2\n");
   }
   
   1;
  diff --git a/dist/Time-HiRes/t/usleep.t b/dist/Time-HiRes/t/usleep.t
  index 0d6bacfac3..bdf372bd16 100644
  --- dist/Time-HiRes/t/usleep.t
  +++ dist/Time-HiRes/t/usleep.t
  @@ -8,7 +8,7 @@ BEGIN {
       }
   }
   
  -use Test::More 0.82 tests => 6;
  +use Test::More tests => 6;
   use t::Watchdog;
   
   eval { Time::HiRes::usleep(-2) };
  @@ -23,7 +23,7 @@ my $two = CORE::time;
   Time::HiRes::usleep(10_000);
   my $three = CORE::time;
   ok $one == $two || $two == $three
  -or note "slept too long, $one $two $three";
  +or print("# slept too long, $one $two $three\n");
   
   SKIP: {
       skip "no gettimeofday", 1 unless &Time::HiRes::d_gettimeofday;
  @@ -31,7 +31,7 @@ SKIP: {
       Time::HiRes::usleep(500_000);
       my $f2 = Time::HiRes::time();
       my $d = $f2 - $f;
  -    ok $d > 0.4 && $d < 0.9 or note "slept $d secs $f to $f2";
  +    ok $d > 0.4 && $d < 0.9 or print("# slept $d secs $f to $f2\n");
   }
   
   SKIP: {
  @@ -39,7 +39,7 @@ SKIP: {
       my $r = [ Time::HiRes::gettimeofday() ];
       Time::HiRes::sleep( 0.5 );
       my $f = Time::HiRes::tv_interval $r;
  -    ok $f > 0.4 && $f < 0.9 or note "slept $f instead of 0.5 secs.";
  +    ok $f > 0.4 && $f < 0.9 or print("# slept $f instead of 0.5 secs.\n");
   }
   
   SKIP: {
  @@ -59,7 +59,7 @@ SKIP: {
   
       SKIP: {
   	skip $msg, 1 unless $td < $sleep * (1 + $limit);
  -	ok $a < $limit or note $msg;
  +	ok $a < $limit or print("# $msg\n");
       }
   
       $t0 = Time::HiRes::gettimeofday();
  @@ -71,7 +71,7 @@ SKIP: {
   
       SKIP: {
   	skip $msg, 1 unless $td < $sleep * (1 + $limit);
  -	ok $a < $limit or note $msg;
  +	ok $a < $limit or print("# $msg\n");
       }
   }
   
  diff --git a/dist/Time-HiRes/typemap b/dist/Time-HiRes/typemap
  index 1124eb6483..3fa91f3a0b 100644
  --- dist/Time-HiRes/typemap
  +++ dist/Time-HiRes/typemap
  @@ -28,6 +28,8 @@ AV *			T_AVREF
   HV *			T_HVREF
   CV *			T_CVREF
   
  +clockid_t               T_IV
  +
   IV			T_IV
   UV			T_UV
   NV                      T_NV
  END
  }
  
  sub _patch_fp_class_denorm {
    my $perlver = shift;
    my $num = _norm_ver( $perlver );
  
    if ($num < 5.025004) {
      _patch(<<'END');
  --- perl.h.orig
  +++ perl.h
  @@ -1585,6 +1585,26 @@ EXTERN_C char *crypt(const char *, const char *);
   #endif
   #endif
   
  +/* We have somehow managed not to define the denormal/subnormal
  + * detection.
  + *
  + * This may happen if the compiler doesn't expose the C99 math like
  + * the fpclassify() without some special switches.  Perl tries to
  + * stay C89, so for example -std=c99 is not an option.
  + *
  + * The Perl_isinf() and Perl_isnan() should have been defined even if
  + * the C99 isinf() and isnan() are unavailable, and the NV_MIN becomes
  + * from the C89 DBL_MIN or moral equivalent. */
  +#if !defined(Perl_fp_class_denorm) && defined(Perl_isinf) && defined(Perl_isnan) && defined(NV_MIN)
  +#  define Perl_fp_class_denorm(x) ((x) != 0.0 && !Perl_isinf(x) && !Perl_isnan(x) && PERL_ABS(x) < NV_MIN)
  +#endif
  +
  +/* This is not a great fallback: subnormals tests will fail,
  + * but at least Perl will link and 99.999% of tests will work. */
  +#if !defined(Perl_fp_class_denorm)
  +#  define Perl_fp_class_denorm(x) FALSE
  +#endif
  +
   /* There is no quadmath_vsnprintf, and therefore my_vsnprintf()
    * dies if called under USE_QUADMATH. */
   #if defined(HAS_VSNPRINTF) && defined(HAS_C99_VARIADIC_MACROS) && !(defined(DEBUGGING) && !defined(PERL_USE_GCC_BRACE_GROUPS)) && !defined(PERL_GCC_PEDANTIC)
  END
  
    }
    else {
      _patch(<<'END');
  --- perl.h.orig
  +++ perl.h
  @@ -6867,6 +6867,26 @@ extern void moncontrol(int);
   #  endif
   #endif
   
  +/* We have somehow managed not to define the denormal/subnormal
  + * detection.
  + *
  + * This may happen if the compiler doesn't expose the C99 math like
  + * the fpclassify() without some special switches.  Perl tries to
  + * stay C89, so for example -std=c99 is not an option.
  + *
  + * The Perl_isinf() and Perl_isnan() should have been defined even if
  + * the C99 isinf() and isnan() are unavailable, and the NV_MIN becomes
  + * from the C89 DBL_MIN or moral equivalent. */
  +#if !defined(Perl_fp_class_denorm) && defined(Perl_isinf) && defined(Perl_isnan) && defined(NV_MIN)
  +#  define Perl_fp_class_denorm(x) ((x) != 0.0 && !Perl_isinf(x) && !Perl_isnan(x) && PERL_ABS(x) < NV_MIN)
  +#endif
  +
  +/* This is not a great fallback: subnormals tests will fail,
  + * but at least Perl will link and 99.999% of tests will work. */
  +#if !defined(Perl_fp_class_denorm)
  +#  define Perl_fp_class_denorm(x) FALSE
  +#endif
  +
   #ifdef DOUBLE_IS_IEEE_FORMAT
   #  define DOUBLE_HAS_INF
   #  define DOUBLE_HAS_NAN
  END
    }
  }
  
  sub _norm_ver {
    my $ver = shift;
    my @v = split(qr/[._]0*/, $ver);
    $v[2] ||= 0;
    return sprintf '%d.%03d%03d', @v;
  }
  
  sub _patch_develpatchperlversion {
    return if -d '.git';
    my $dpv = $Devel::PatchPerl::VERSION || "(unreleased)";
    _patch(<<"END");
  diff --git a/Configure b/Configure
  index e12c8bb..1a8088f 100755
  --- Configure
  +++ Configure
  @@ -25151,6 +25151,8 @@ zcat='\$zcat'
   zip='\$zip'
   EOT
   
  +echo "BuiltWithPatchPerl='$dpv'" >>config.sh
  +
   : add special variables
   \$test -f \$src/patchlevel.h && \
   awk '/^#define[ 	]+PERL_/ {printf "\%s=\%s\\n",\$2,\$3}' \$src/patchlevel.h >>config.sh
  END
  }
  
  sub _patch_conf_fwrapv {
    my $perlver = shift;
    my $num = _norm_ver( $perlver );
    return unless $num < 5.019011;
    _patch(<<'FWRAPV');
  diff --git a/Configure b/Configure
  index 15b3da1769..791889a2ab 100755
  --- Configure
  +++ Configure
  @@ -4643,6 +4643,22 @@ case "$gccversion" in
       $rm -f try try.*
   esac
   
  +# gcc 4.9 by default does some optimizations that break perl.
  +# see ticket 121505.
  +#
  +# The -fwrapv disables those optimizations (and probably others,) so
  +# for gcc 4.9 (and later, since the optimizations probably won't go
  +# away), add -fwrapv unless the user requests -fno-wrapv, which
  +# disables -fwrapv, or if the user requests -fsanitize=undefined,
  +# which turns the overflows -fwrapv ignores into runtime errors.
  +case "$gccversion" in
  +4.[3-9].*|4.[1-9][0-9]*|[5-9].*|[1-9][0-9]*)
  +    case "$ccflags" in
  +    *-fno-wrapv*|*-fsanitize=undefined*|*-fwrapv*) ;;
  +    *) ccflags="$ccflags -fwrapv" ;;
  +    esac
  +esac
  +
   : What should the include directory be ?
   : Use sysroot if set, so findhdr looks in the right place.
   echo " "
  FWRAPV
  }
  
  sub _patch_utils_h2ph {
    my $perlver = shift;
    my $num = _norm_ver( $perlver );
    return unless $num < 5.021010;
    return if    $num == 5.020003;
    if ( $num < 5.006001 ) {
      return _patch_b64(<<'UH2PH560');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTM2LDEzICszNiwyMSBAQCAk
  Q29uZmlne3N0YXJ0cGVybH0KIAogcHJpbnQgT1VUIDw8JyFOTyFTVUJTISc7CiAKK3VzZSBzdHJp
  Y3Q7CisKIHVzZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9w
  dDo6U3RkOwogCi1nZXRvcHRzKCdEZDpybGhhUScpOworIyBNYWtlIHN1cmUgcmVhZCBwZXJtaXNz
  aW9ucyBmb3IgYWxsIGFyZSBzZXQ6CitpZiAoZGVmaW5lZCB1bWFzayAmJiAodW1hc2soKSAmIDA0
  NDQpKSB7CisgICAgdW1hc2sgKHVtYXNrKCkgJiB+MDQ0NCk7Cit9CisKK2dldG9wdHMoJ0RkOnJs
  aGFRZScpOwordXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3IgJG9wdF9sICRvcHRfaCAk
  b3B0X2EgJG9wdF9RICRvcHRfZSk7CiBkaWUgIi1yIGFuZCAtYSBvcHRpb25zIGFyZSBtdXR1YWxs
  eSBleGNsdXNpdmVcbiIgaWYgKCRvcHRfciBhbmQgJG9wdF9hKTsKLUBpbmNfZGlycyA9IGluY19k
  aXJzKCkgaWYgJG9wdF9hOworbXkgQGluY19kaXJzID0gaW5jX2RpcnMoKSBpZiAkb3B0X2E7CiAK
  IG15ICRFeGl0ID0gMDsKIApAQCAtNTAsNyArNTgsNyBAQCBteSAkRGVzdF9kaXIgPSAkb3B0X2Qg
  fHwgJENvbmZpZ3tpbnN0YWxsc2l0ZWFyY2h9OwogZGllICJEZXN0aW5hdGlvbiBkaXJlY3Rvcnkg
  JERlc3RfZGlyIGRvZXNuJ3QgZXhpc3Qgb3IgaXNuJ3QgYSBkaXJlY3RvcnlcbiIKICAgICB1bmxl
  c3MgLWQgJERlc3RfZGlyOwogCi1AaXNhdHlwZSA9IHNwbGl0KCcgJyw8PEVORCk7CitteSBAaXNh
  dHlwZSA9IHNwbGl0KCcgJyw8PEVORCk7CiAJY2hhcgl1Y2hhcgl1X2NoYXIKIAlzaG9ydAl1c2hv
  cnQJdV9zaG9ydAogCWludAl1aW50CXVfaW50CkBAIC01OCwxNCArNjYsMjYgQEAgZGllICJEZXN0
  aW5hdGlvbiBkaXJlY3RvcnkgJERlc3RfZGlyIGRvZXNuJ3QgZXhpc3Qgb3IgaXNuJ3QgYSBkaXJl
  Y3RvcnlcbiIKIAlGSUxFCWtleV90CWNhZGRyX3QKIEVORAogCitteSAlaXNhdHlwZTsKIEBpc2F0
  eXBle0Bpc2F0eXBlfSA9ICgxKSB4IEBpc2F0eXBlOwotJGluaWYgPSAwOworbXkgJGluaWYgPSAw
  OworbXkgJUlzX2NvbnZlcnRlZDsKK215ICViYWRfZmlsZSA9ICgpOwogCiBAQVJHViA9ICgnLScp
  IHVubGVzcyBAQVJHVjsKIAogYnVpbGRfcHJlYW1ibGVfaWZfbmVjZXNzYXJ5KCk7CiAKLXdoaWxl
  IChkZWZpbmVkICgkZmlsZSA9IG5leHRfZmlsZSgpKSkgeworc3ViIHJlaW5kZW50KCQpIHsKKyAg
  ICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOworICAgICR0
  ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKworbXkgKCR0LCAkdGFiLCAl
  Y3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91dGZpbGUp
  OworbXkgKCRpbmNsLCAkaW5jbF90eXBlLCAkaW5jbF9xdW90ZSwgJG5leHQpOword2hpbGUgKGRl
  ZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAgICAgaWYgKC1sICRmaWxlIGFuZCAt
  ZCAkZmlsZSkgewogICAgICAgICBsaW5rX2lmX3Bvc3NpYmxlKCRmaWxlKSBpZiAoJG9wdF9sKTsK
  ICAgICAgICAgbmV4dDsKQEAgLTEwMCwzNiArMTIwLDIzIEBAIHdoaWxlIChkZWZpbmVkICgkZmls
  ZSA9IG5leHRfZmlsZSgpKSkgewogCW9wZW4oT1VULCI+JERlc3RfZGlyLyRvdXRmaWxlIikgfHwg
  ZGllICJDYW4ndCBjcmVhdGUgJG91dGZpbGU6ICQhXG4iOwogICAgIH0KIAotICAgIHByaW50IE9V
  VCAicmVxdWlyZSAnX2gycGhfcHJlLnBoJztcblxuIjsKLSAgICB3aGlsZSAoPElOPikgewotCWNo
  b3A7Ci0Jd2hpbGUgKC9cXCQvKSB7Ci0JICAgIGNob3A7Ci0JICAgICRfIC49IDxJTj47Ci0JICAg
  IGNob3A7Ci0JfQotCXByaW50IE9VVCAiIyAkX1xuIiBpZiAkb3B0X0Q7Ci0KLQlpZiAoczovXCo6
  XDIwMDpnKSB7Ci0JICAgIHM6XCovOlwyMDE6ZzsKLQkgICAgcy9cMjAwW15cMjAxXSpcMjAxLy9n
  OwkjIGRlbGV0ZSBzaW5nbGUgbGluZSBjb21tZW50cwotCSAgICBpZiAocy9cMjAwLiovLykgewkJ
  IyBiZWdpbiBtdWx0aS1saW5lIGNvbW1lbnQ/Ci0JCSRfIC49ICcvKic7Ci0JCSRfIC49IDxJTj47
  Ci0JCXJlZG87Ci0JICAgIH0KLQl9CisgICAgcHJpbnQgT1VUCisgICAgICAgICJyZXF1aXJlICdf
  aDJwaF9wcmUucGgnO1xuXG4iLAorICAgICAgICAibm8gd2FybmluZ3MgJ3JlZGVmaW5lJztcblxu
  IjsKKworICAgIHdoaWxlIChkZWZpbmVkIChsb2NhbCAkXyA9IG5leHRfbGluZSgkZmlsZSkpKSB7
  CiAJaWYgKHMvXlxzKlwjXHMqLy8pIHsKIAkgICAgaWYgKHMvXmRlZmluZVxzKyhcdyspLy8pIHsK
  IAkJJG5hbWUgPSAkMTsKIAkJJG5ldyA9ICcnOwogCQlzL1xzKyQvLzsKKwkJcy9cKFx3K1xzKlwo
  XCpcKVxzKlwoXHcqXClcKVxzKigtP1xkKykvJDEvOyAjIChpbnQgKCopKGZvb190KSkwCiAJCWlm
  IChzL15cKChbXHcsXHNdKilcKS8vKSB7CiAJCSAgICAkYXJncyA9ICQxOwogICAgIAkgICAgCSAg
  ICBteSAkcHJvdG8gPSAnKCkgJzsKIAkJICAgIGlmICgkYXJncyBuZSAnJykgewogICAgIAkgICAg
  CSAgICAJJHByb3RvID0gJyc7Ci0JCQlmb3JlYWNoICRhcmcgKHNwbGl0KC8sXHMqLywkYXJncykp
  IHsKKwkJCWZvcmVhY2ggbXkgJGFyZyAoc3BsaXQoLyxccyovLCRhcmdzKSkgewogCQkJICAgICRh
  cmcgPX4gcy9eXHMqKFteXHNdLipbXlxzXSlccyokLyQxLzsKIAkJCSAgICAkY3VyYXJnc3skYXJn
  fSA9IDE7CiAJCQl9CkBAIC0xNzcsMjIgKzE4NCwzMiBAQCB3aGlsZSAoZGVmaW5lZCAoJGZpbGUg
  PSBuZXh0X2ZpbGUoKSkpIHsKICAgICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgJHQsInVu
  bGVzcyhkZWZpbmVkKFwmJG5hbWUpKSB7XG4gICAgc3ViICRuYW1lICgpIHtcdCIsJG5ldywiO31c
  bn1cbiI7CiAJCSAgICB9CiAJCX0KLQkgICAgfSBlbHNpZiAoL14oaW5jbHVkZXxpbXBvcnQpXHMq
  WzwiXSguKilbPiJdLykgewotCQkoJGluY2wgPSAkMikgPX4gcy9cLmgkLy5waC87Ci0JCXByaW50
  IE9VVCAkdCwicmVxdWlyZSAnJGluY2wnO1xuIjsKLQkgICAgfSBlbHNpZigvXmluY2x1ZGVfbmV4
  dFxzKls8Il0oLiopWz4iXS8pIHsKLQkJKCRpbmNsID0gJDEpID1+IHMvXC5oJC8ucGgvOworCSAg
  ICB9IGVsc2lmICgvXihpbmNsdWRlfGltcG9ydHxpbmNsdWRlX25leHQpXHMqKFs8XCJdKSguKilb
  PlwiXS8pIHsKKyAgICAgICAgICAgICAgICAkaW5jbF90eXBlID0gJDE7CisgICAgICAgICAgICAg
  ICAgJGluY2xfcXVvdGUgPSAkMjsKKyAgICAgICAgICAgICAgICAkaW5jbCA9ICQzOworICAgICAg
  ICAgICAgICAgIGlmICgoJGluY2xfdHlwZSBlcSAnaW5jbHVkZV9uZXh0JykgfHwKKyAgICAgICAg
  ICAgICAgICAgICAgKCRvcHRfZSAmJiBleGlzdHMoJGJhZF9maWxleyRpbmNsfSkpKSB7CisgICAg
  ICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgvOwogCQlwcmludCBPVVQgKCR0LAog
  CQkJICAgImV2YWwge1xuIik7CiAgICAgICAgICAgICAgICAgJHRhYiArPSA0OwogICAgICAgICAg
  ICAgICAgICR0ID0gIlx0IiB4ICgkdGFiIC8gOCkgLiAnICcgeCAoJHRhYiAlIDgpOworICAgICAg
  ICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LCAibXkoXEBSRU0pO1xuIik7CisgICAgICAgICAg
  ICAgICAgICAgIGlmICgkaW5jbF90eXBlIGVxICdpbmNsdWRlX25leHQnKSB7CiAJCXByaW50IE9V
  VCAoJHQsCiAJCQkgICAibXkoXCVJTkNEKSA9IG1hcCB7IFwkSU5De1wkX30gPT4gMSB9ICIsCi0J
  CQkgICAiKGdyZXAgeyBcJF8gZXEgXCIkaW5jbFwiIH0ga2V5cyhcJUlOQykpO1xuIik7CisJCQkg
  ICAgICAgICAgICIoZ3JlcCB7IFwkXyBlcSBcIiRpbmNsXCIgfSAiLAorICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAia2V5cyhcJUlOQykpO1xuIik7CiAJCXByaW50IE9VVCAoJHQs
  Ci0JCQkgICAibXkoXEBSRU0pID0gbWFwIHsgXCJcJF8vJGluY2xcIiB9ICIsCisJCQkgICAgICAg
  ICAgICJcQFJFTSA9IG1hcCB7IFwiXCRfLyRpbmNsXCIgfSAiLAogCQkJICAgIihncmVwIHsgbm90
  IGV4aXN0cyhcJElOQ0R7XCJcJF8vJGluY2xcIn0pIiwKLQkJCSAgICJhbmQgLWYgXCJcJF8vJGlu
  Y2xcIiB9IFxASU5DKTtcbiIpOworCQkJICAgICAgICAgICAiIGFuZCAtZiBcIlwkXy8kaW5jbFwi
  IH0gXEBJTkMpO1xuIik7CisgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAg
  ICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LAorICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAiXEBSRU0gPSBtYXAgeyBcIlwkXy8kaW5jbFwiIH0gIiwKKyAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgIihncmVwIHstciBcIlwkXy8kaW5jbFwiIH0gXEBJTkMpO1xu
  Iik7CisgICAgICAgICAgICAgICAgICAgIH0KIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJyZXF1
  aXJlIFwiXCRSRU1bMF1cIiBpZiBcQFJFTTtcbiIpOwogICAgICAgICAgICAgICAgICR0YWIgLT0g
  NDsKQEAgLTIwMSw2ICsyMTgsMTQgQEAgd2hpbGUgKGRlZmluZWQgKCRmaWxlID0gbmV4dF9maWxl
  KCkpKSB7CiAJCQkgICAifTtcbiIpOwogCQlwcmludCBPVVQgKCR0LAogCQkJICAgIndhcm4oXCRc
  QCkgaWYgXCRcQDtcbiIpOworICAgICAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAg
  ICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgvOworICAgICAgICAgICAgICAgICAgICAjIGNvcHkg
  dGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3ludGF4ICgjaW5jbHVkZSAieC5oIikgY2FzZQorICAg
  ICAgICAgICAgICAgICAgICBpZiAoJGluY2wgIX4gbXwvfCAmJiAkaW5jbF9xdW90ZSBlcSBxeyJ9
  ICYmICRmaWxlID1+IG18XiguKikvfCkgeworICAgICAgICAgICAgICAgICAgICAgICAgJGluY2wg
  PSAiJDEvJGluY2wiOworICAgICAgICAgICAgICAgICAgICB9CisJCSAgICBwcmludCBPVVQgJHQs
  InJlcXVpcmUgJyRpbmNsJztcbiI7CisgICAgICAgICAgICAgICAgfQogCSAgICB9IGVsc2lmICgv
  XmlmZGVmXHMrKFx3KykvKSB7CiAJCXByaW50IE9VVCAkdCwiaWYoZGVmaW5lZCgmJDEpKSB7XG4i
  OwogCQkkdGFiICs9IDQ7CkBAIC0yNDgsMjAgKzI3MywyNCBAQCB3aGlsZSAoZGVmaW5lZCAoJGZp
  bGUgPSBuZXh0X2ZpbGUoKSkpIHsKIAkgICAgfSBlbHNpZigvXmlkZW50XHMrKC4qKS8pIHsKIAkJ
  cHJpbnQgT1VUICR0LCAiIyAkMVxuIjsKIAkgICAgfQotIAl9IGVsc2lmKC9eXHMqKHR5cGVkZWZc
  cyopP2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMqKT9cey8pIHsKLQkgICAgdW50aWwoL1x9Lio/
  Oy8pIHsKLQkJY2hvbXAoJG5leHQgPSA8SU4+KTsKKwl9IGVsc2lmKC9eXHMqKHR5cGVkZWZccyop
  P2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMqKT8vKSB7CisJICAgIHVudGlsKC9ce1tefV0qXH0u
  KjsvIHx8IC87LykgeworCQlsYXN0IHVubGVzcyBkZWZpbmVkICgkbmV4dCA9IG5leHRfbGluZSgk
  ZmlsZSkpOworCQljaG9tcCAkbmV4dDsKKwkJIyBkcm9wICIjZGVmaW5lIEZPTyBGT08iIGluIGVu
  dW1zCisJCSRuZXh0ID1+IHMvXlxzKiNccypkZWZpbmVccysoXHcrKVxzK1wxXHMqJC8vOwogCQkk
  XyAuPSAkbmV4dDsKIAkJcHJpbnQgT1VUICIjICRuZXh0XG4iIGlmICRvcHRfRDsKIAkgICAgfQor
  CSAgICBzLyNccyppZi4qPyNccyplbmRpZi8vZzsgIyBkcm9wICNpZmRlZnMKIAkgICAgc0AvXCou
  Kj9cKi9AQGc7CiAJICAgIHMvXHMrLyAvZzsKLQkgICAgL15ccz8odHlwZWRlZlxzPyk/ZW51bVxz
  PyhbYS16QS1aX11cdyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/XHM/Oy87Ci0JICAg
  ICgkZW51bV9zdWJzID0gJDMpID1+IHMvXHMvL2c7Ci0JICAgIEBlbnVtX3N1YnMgPSBzcGxpdCgv
  LC8sICRlbnVtX3N1YnMpOwotCSAgICAkZW51bV92YWwgPSAtMTsKLQkgICAgZm9yICRlbnVtIChA
  ZW51bV9zdWJzKSB7Ci0JCSgkZW51bV9uYW1lLCAkZW51bV92YWx1ZSkgPSAkZW51bSA9fiAvXihb
  YS16QS1aX11cdyopKD0uKyk/JC87CisJICAgIG5leHQgdW5sZXNzIC9eXHM/KHR5cGVkZWZccz8p
  P2VudW1ccz8oW2EtekEtWl9dXHcqKT9ccz9ceyguKilcfVxzPyhbYS16QS1aX11cdyopP1xzPzsv
  OworCSAgICAobXkgJGVudW1fc3VicyA9ICQzKSA9fiBzL1xzLy9nOworCSAgICBteSBAZW51bV9z
  dWJzID0gc3BsaXQoLywvLCAkZW51bV9zdWJzKTsKKwkgICAgbXkgJGVudW1fdmFsID0gLTE7CisJ
  ICAgIGZvcmVhY2ggbXkgJGVudW0gKEBlbnVtX3N1YnMpIHsKKwkJbXkgKCRlbnVtX25hbWUsICRl
  bnVtX3ZhbHVlKSA9ICRlbnVtID1+IC9eKFthLXpBLVpfXVx3KikoPS4rKT8kLzsKIAkJJGVudW1f
  dmFsdWUgPX4gcy9ePS8vOwogCQkkZW51bV92YWwgPSAobGVuZ3RoKCRlbnVtX3ZhbHVlKSA/ICRl
  bnVtX3ZhbHVlIDogJGVudW1fdmFsICsgMSk7CiAJCWlmICgkb3B0X2gpIHsKQEAgLTI3OCwzMSAr
  MzA3LDQ3IEBAIHdoaWxlIChkZWZpbmVkICgkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCSAgICB9
  CiAJfQogICAgIH0KLSAgICBwcmludCBPVVQgIjE7XG4iOwotCi0gICAgJGlzX2NvbnZlcnRlZHsk
  ZmlsZX0gPSAxOworICAgICRJc19jb252ZXJ0ZWR7JGZpbGV9ID0gMTsKKyAgICBpZiAoJG9wdF9l
  ICYmIGV4aXN0cygkYmFkX2ZpbGV7JGZpbGV9KSkgeworICAgICAgICB1bmxpbmsoJERlc3RfZGly
  IC4gJy8nIC4gJG91dGZpbGUpOworICAgICAgICAkbmV4dCA9ICcnOworICAgIH0gZWxzZSB7Cisg
  ICAgICAgIHByaW50IE9VVCAiMTtcbiI7CiAgICAgcXVldWVfaW5jbHVkZXNfZnJvbSgkZmlsZSkg
  aWYgKCRvcHRfYSk7CisgICAgfQogfQogCi1leGl0ICRFeGl0OwotCi1zdWIgcmVpbmRlbnQoJCkg
  ewotICAgIG15KCR0ZXh0KSA9IHNoaWZ0OwotICAgICR0ZXh0ID1+IHMvXG4vXG4gICAgL2c7Ci0g
  ICAgJHRleHQgPX4gcy8gICAgICAgIC9cdC9nOwotICAgICR0ZXh0OworaWYgKCRvcHRfZSAmJiAo
  c2NhbGFyKGtleXMgJWJhZF9maWxlKSA+IDApKSB7CisgICAgd2FybiAiV2FzIHVuYWJsZSB0byBj
  b252ZXJ0IHRoZSBmb2xsb3dpbmcgZmlsZXM6XG4iOworICAgIHdhcm4gIlx0IiAuIGpvaW4oIlxu
  XHQiLHNvcnQoa2V5cyAlYmFkX2ZpbGUpKSAuICJcbiI7CiB9CiAKK2V4aXQgJEV4aXQ7CisKIHN1
  YiBleHByIHsKKyAgICBteSAkam9pbmVkX2FyZ3M7CiAgICAgaWYoa2V5cyglY3VyYXJncykpIHsK
  LQlteSgkam9pbmVkX2FyZ3MpID0gam9pbignfCcsIGtleXMoJWN1cmFyZ3MpKTsKKwkkam9pbmVk
  X2FyZ3MgPSBqb2luKCd8Jywga2V5cyglY3VyYXJncykpOwogICAgIH0KICAgICB3aGlsZSAoJF8g
  bmUgJycpIHsKIAlzL15cJlwmLy8gJiYgZG8geyAkbmV3IC49ICIgJiYiOyBuZXh0O307ICMgaGFu
  ZGxlICYmIG9wZXJhdG9yCiAJcy9eXCYoW1woYS16XCldKykvJDEvaTsJIyBoYWNrIGZvciB0aGlu
  Z3MgdGhhdCB0YWtlIHRoZSBhZGRyZXNzIG9mCiAJcy9eKFxzKykvLwkJJiYgZG8geyRuZXcgLj0g
  JyAnOyBuZXh0O307Ci0Jcy9eKDBYWzAtOUEtRl0rKVtVTF0qLy9pCSYmIGRvIHskbmV3IC49IGxj
  KCQxKTsgbmV4dDt9OwotCXMvXigtP1xkK1wuXGQrRVstK11cZCspRj8vL2kJJiYgZG8geyRuZXcg
  Lj0gJDE7IG5leHQ7fTsKKwlzL14wWChbMC05QS1GXSspW1VMXSovL2kgCisJICAgICYmIGRvIHtt
  eSAkaGV4ID0gJDE7CisJCSAgICRoZXggPX4gcy9eMCsvLzsKKwkJICAgaWYgKGxlbmd0aCAkaGV4
  ID4gOCAmJiAhJENvbmZpZ3t1c2U2NGJpdGludH0pIHsKKwkJICAgICAgICMgQ3JvYWsgaWYgbnZf
  cHJlc2VydmVzX3V2X2JpdHMgPCA2NCA/CisJCSAgICAgICAkbmV3IC49ICAgICAgICAgaGV4KHN1
  YnN0cigkaGV4LCAtOCkpICsKKwkJCSAgICAgICAyKiozMiAqIGhleChzdWJzdHIoJGhleCwgIDAs
  IC04KSk7CisJCSAgICAgICAjIFRoZSBhYm92ZSB3aWxsIHByb2R1Y2UgImVycm9ybmV1cyIgY29k
  ZQorCQkgICAgICAgIyBpZiB0aGUgaGV4IGNvbnN0YW50IHdhcyBlLmcuIGluc2lkZSBVSU5UNjRf
  QworCQkgICAgICAgIyBtYWNybywgYnV0IHRoZW4gYWdhaW4sIGgycGggaXMgYW4gYXBwcm94aW1h
  dGlvbi4KKwkJICAgfSBlbHNlIHsKKwkJICAgICAgICRuZXcgLj0gbGMoIjB4JGhleCIpOworCQkg
  ICB9CisJCSAgIG5leHQ7fTsKKwlzL14oLT9cZCtcLlxkK0VbLStdP1xkKylbRkxdPy8vaQkmJiBk
  byB7JG5ldyAuPSAkMTsgbmV4dDt9OwogCXMvXihcZCspXHMqW0xVXSovL2kJJiYgZG8geyRuZXcg
  Lj0gJDE7IG5leHQ7fTsKIAlzL14oIihcXCJ8W14iXSkqIikvLwkmJiBkbyB7JG5ldyAuPSAkMTsg
  bmV4dDt9OwogCXMvXicoKFxcInxbXiJdKSopJy8vCSYmIGRvIHsKQEAgLTM0MSwxMyArMzg2LDEz
  IEBAIHN1YiBleHByIHsKIAkjIEVsaW1pbmF0ZSB0eXBlZGVmcwogCS9cKChbXHdcc10rKVtcKlxz
  XSpcKVxzKltcd1woXS8gJiYgZG8gewogCSAgICBmb3JlYWNoIChzcGxpdCAvXHMrLywgJDEpIHsg
  ICMgTWFrZSBzdXJlIGFsbCB0aGUgd29yZHMgYXJlIHR5cGVzLAotCQlsYXN0IHVubGVzcyAoJGlz
  YXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnKTsKKwkJbGFzdCB1bmxlc3MgKCRpc2F0eXBleyRf
  fSBvciAkXyBlcSAnc3RydWN0JyBvciAkXyBlcSAndW5pb24nKTsKIAkgICAgfQogCSAgICBzL1wo
  W1x3XHNdK1tcKlxzXSpcKS8vICYmIG5leHQ7ICAgICAgIyB0aGVuIGVsaW1pbmF0ZSB0aGVtLgog
  CX07CiAJIyBzdHJ1Y3QvdW5pb24gbWVtYmVyLCBpbmNsdWRpbmcgYXJyYXlzOgogCXMvXihbX0Et
  Wl1cdyooXFtbXlxdXStcXSk/KChcLnwtPilbX0EtWl1cdyooXFtbXlxdXStcXSk/KSspLy9pICYm
  IGRvIHsKLQkgICAgJGlkID0gJDE7CisJICAgIG15ICRpZCA9ICQxOwogCSAgICAkaWQgPX4gcy8o
  XC58KC0+KSkoW15cLlwtXSopLy0+XHskM1x9L2c7CiAJICAgICRpZCA9fiBzL1xiKFteXCRdKSgk
  am9pbmVkX2FyZ3MpLyQxXCQkMi9nIGlmIGxlbmd0aCgkam9pbmVkX2FyZ3MpOwogCSAgICB3aGls
  ZSgkaWQgPX4gL1xbXHMqKFteXCRcJlxkXF1dKylcXS8pIHsKQEAgLTM2Myw4ICs0MDgsOCBAQCBz
  dWIgZXhwciB7CiAJICAgICRuZXcgLj0gIiAoXCQkaWQpIjsKIAl9OwogCXMvXihbX2EtekEtWl1c
  dyopLy8JJiYgZG8gewotCSAgICAkaWQgPSAkMTsKLQkgICAgaWYgKCRpZCBlcSAnc3RydWN0Jykg
  eworCSAgICBteSAkaWQgPSAkMTsKKwkgICAgaWYgKCRpZCBlcSAnc3RydWN0JyB8fCAkaWQgZXEg
  J3VuaW9uJykgewogCQlzL15ccysoXHcrKS8vOwogCQkkaWQgLj0gJyAnIC4gJDE7CiAJCSRpc2F0
  eXBleyRpZH0gPSAxOwpAQCAtMzc3LDggKzQyMiw4IEBAIHN1YiBleHByIHsKIAkJJG5ldyAuPSAn
  LT4nIGlmIC9eW1xbXHtdLzsKIAkgICAgfSBlbHNpZiAoJGlkIGVxICdkZWZpbmVkJykgewogCQkk
  bmV3IC49ICdkZWZpbmVkJzsKLQkgICAgfSBlbHNpZiAoL15cKC8pIHsKLQkJcy9eXCgoXHcpLC8o
  IiQxIiwvIGlmICRpZCA9fiAvXl9JT1tXUl0qJC9pOwkjIGNoZWF0CisJICAgIH0gZWxzaWYgKC9e
  XHMqXCgvKSB7CisJCXMvXlxzKlwoKFx3KSwvKCIkMSIsLyBpZiAkaWQgPX4gL15fSU9bV1JdKiQv
  aTsJIyBjaGVhdAogCQkkbmV3IC49ICIgJiRpZCI7CiAJICAgIH0gZWxzaWYgKCRpc2F0eXBleyRp
  ZH0pIHsKIAkJaWYgKCRuZXcgPX4gL3tccyokLykgewpAQCAtMzkxLDcgKzQzNiw3IEBAIHN1YiBl
  eHByIHsKIAkJfQogCSAgICB9IGVsc2UgewogCQlpZiAoJGluaWYgJiYgJG5ldyAhfiAvZGVmaW5l
  ZFxzKlwoJC8pIHsKLQkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAu
  ICRpZCAuICcgOiAwKSc7CisJCSAgICAkbmV3IC49ICcoZGVmaW5lZCgmJyAuICRpZCAuICcpID8g
  JicgLiAkaWQgLiAnIDogdW5kZWYpJzsKIAkJfSBlbHNpZiAoL15cWy8pIHsKIAkJICAgICRuZXcg
  Lj0gIiBcJCRpZCI7CiAJCX0gZWxzZSB7CkBAIC00MDUsNiArNDUwLDEwMSBAQCBzdWIgZXhwciB7
  CiB9CiAKIAorc3ViIG5leHRfbGluZQoreworICAgIG15ICRmaWxlID0gc2hpZnQ7CisgICAgbXkg
  KCRpbiwgJG91dCk7CisgICAgbXkgJHByZV9zdWJfdHJpX2dyYXBocyA9IDE7CisKKyAgICBSRUFE
  OiB3aGlsZSAobm90IGVvZiBJTikgeworICAgICAgICAkaW4gIC49IDxJTj47CisgICAgICAgIGNo
  b21wICRpbjsKKyAgICAgICAgbmV4dCB1bmxlc3MgbGVuZ3RoICRpbjsKKworICAgICAgICB3aGls
  ZSAobGVuZ3RoICRpbikgeworICAgICAgICAgICAgaWYgKCRwcmVfc3ViX3RyaV9ncmFwaHMpIHsK
  KyAgICAgICAgICAgICAgICAjIFByZXByb2Nlc3MgYWxsIHRyaS1ncmFwaHMgCisgICAgICAgICAg
  ICAgICAgIyBpbmNsdWRpbmcgdGhpbmdzIHN0dWNrIGluIHF1b3RlZCBzdHJpbmcgY29uc3RhbnRz
  LgorICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD89LyMvZzsgICAgICAgICAgICAgICAgICAg
  ICAgICAgIyB8ID8/PXwgICN8CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1whL3wvZzsg
  ICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz8hfCAgfHwKKyAgICAgICAgICAgICAgICAkaW4g
  PX4gcy9cP1w/Jy9eL2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pyd8ICBefAorICAg
  ICAgICAgICAgICAgICRpbiA9fiBzL1w/XD9cKC9bL2c7ICAgICAgICAgICAgICAgICAgICAgICAg
  IyB8ID8/KHwgIFt8CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1wpL10vZzsgICAgICAg
  ICAgICAgICAgICAgICAgICAjIHwgPz8pfCAgXXwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9c
  P1w/XC0vfi9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Py18ICB+fAorICAgICAgICAg
  ICAgICAgICRpbiA9fiBzL1w/XD9cLy9cXC9nOyAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/
  L3wgIFx8CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cPzwvey9nOyAgICAgICAgICAgICAg
  ICAgICAgICAgICAjIHwgPz88fCAge3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/Pi99
  L2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pz58ICB9fAorICAgICAgICAgICAgfQor
  CSAgICBpZiAoJGluID1+IC9eXCNpZmRlZiBfX0xBTkdVQUdFX1BBU0NBTF9fLykgeworICAgICAg
  ICAgICAgICAgICMgVHJ1NjQgZGlzYXNzZW1ibGVyLmggZXZpbG5lc3M6IG1peGVkIEMgYW5kIFBh
  c2NhbC4KKwkJd2hpbGUgKDxJTj4pIHsKKwkJICAgIGxhc3QgaWYgL15cI2VuZGlmLzsgCisJCX0K
  KwkJbmV4dCBSRUFEOworCSAgICB9CisJICAgIGlmICgkaW4gPX4gL15leHRlcm4gaW5saW5lIC8g
  JiYgIyBJbmxpbmVkIGFzc2VtYmxlci4KKwkJJF5PIGVxICdsaW51eCcgJiYgJGZpbGUgPX4gbSEo
  PzpefC8pYXNtL1teL10rXC5oJCEpIHsKKyAJCXdoaWxlICg8SU4+KSB7CisJCSAgICBsYXN0IGlm
  IC9efS87IAorCQl9CisJCW5leHQgUkVBRDsKKwkgICAgfQorICAgICAgICAgICAgaWYgKCRpbiA9
  fiBzL1xcJC8vKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBcLW5ld2xpbmUKKyAgICAg
  ICAgICAgICAgICAkb3V0ICAgIC49ICcgJzsKKyAgICAgICAgICAgICAgICBuZXh0IFJFQUQ7Cisg
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteIidcXFwvXSspLy8pIHsgICAgICAgICAg
  ICAjIFBhc3N0aHJvdWdoCisgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oXFwuKS8vKSB7ICAgICAgICAgICAgICAgICAgICMgXC4u
  LgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  aW4gPX4gL14nLykgeyAgICAgICAgICAgICAgICAgICAgICAgICAjICcuLi4KKyAgICAgICAgICAg
  ICAgICBpZiAoJGluID1+IHMvXignKFxcLnxbXidcXF0pKicpLy8pIHsKKyAgICAgICAgICAgICAg
  ICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAg
  ICAgICAgICAgICBuZXh0IFJFQUQ7CisgICAgICAgICAgICAgICAgfQorICAgICAgICAgICAgfSBl
  bHNpZiAoJGluID1+IC9eIi8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgIyAiLi4uCisgICAg
  ICAgICAgICAgICAgaWYgKCRpbiA9fiBzL14oIihcXC58W14iXFxdKSoiKS8vKSB7CisgICAgICAg
  ICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsKKyAg
  ICAgICAgICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL15cL1wvLiovLykgeyAgICAgICAgICAgICAgICAgICMgLy8u
  Li4KKyAgICAgICAgICAgICAgICAjIGZhbGwgdGhyb3VnaAorICAgICAgICAgICAgfSBlbHNpZiAo
  JGluID1+IG0vXlwvXCovKSB7ICAgICAgICAgICAgICAgICAgICAgIyAvKi4uLgorICAgICAgICAg
  ICAgICAgICMgQyBjb21tZW50IHJlbW92YWwgYWRhcHRlZCBmcm9tIHBlcmxmYXE2OgorICAgICAg
  ICAgICAgICAgIGlmICgkaW4gPX4gcy9eXC9cKlteKl0qXCorKFteXC8qXVteKl0qXCorKSpcLy8v
  KSB7CisgICAgICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOworICAgICAgICAgICAgICAg
  IH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBJbmNvbXBsZXRl
  IC8qICovCisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgICAgICB9
  CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFwvKS8vKSB7ICAgICAgICAgICAgICAg
  ICAgICAjIC8uLi4KKyAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAg
  fSBlbHNpZiAoJGluID1+IHMvXihbXlwnXCJcXFwvXSspLy8pIHsKKyAgICAgICAgICAgICAgICAk
  b3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJF5PIGVxICdsaW51eCcgJiYKKyAg
  ICAgICAgICAgICAgICAgICAgICRmaWxlID1+IG0hKD86XnwvKWxpbnV4L2J5dGVvcmRlci9wZHBf
  ZW5kaWFuXC5oJCEgJiYKKyAgICAgICAgICAgICAgICAgICAgICRpbiAgID1+IHMhXCdUIEtOT1ch
  ISkgeworICAgICAgICAgICAgICAgICRvdXQgICAgPX4gcyFJIERPTiQhSV9ET19OT1RfS05PVyE7
  CisgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgIGlmICgkb3B0X2UpIHsKKyAg
  ICAgICAgICAgICAgICAgICAgd2FybiAiQ2Fubm90IHBhcnNlICRmaWxlOlxuJGluXG4iOworICAg
  ICAgICAgICAgICAgICAgICAkYmFkX2ZpbGV7JGZpbGV9ID0gMTsKKyAgICAgICAgICAgICAgICAg
  ICAgJGluID0gJyc7CisgICAgICAgICAgICAgICAgICAgICRvdXQgPSB1bmRlZjsKKyAgICAgICAg
  ICAgICAgICAgICAgbGFzdCBSRUFEOworICAgICAgICAgICAgICAgIH0gZWxzZSB7CisJCWRpZSAi
  Q2Fubm90IHBhcnNlOlxuJGluXG4iOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgIH0K
  KyAgICAgICAgfQorCisgICAgICAgIGxhc3QgUkVBRCBpZiAkb3V0ID1+IC9cUy87CisgICAgfQor
  CisgICAgcmV0dXJuICRvdXQ7Cit9CisKKwogIyBIYW5kbGUgcmVjdXJzaXZlIHN1YmRpcmVjdG9y
  aWVzIHdpdGhvdXQgZ2V0dGluZyBhIGdyb3Rlc3F1ZWx5IGJpZyBzdGFjay4KICMgQ291bGQgdGhp
  cyBiZSBpbXBsZW1lbnRlZCB1c2luZyBGaWxlOjpGaW5kPwogc3ViIG5leHRfZmlsZQpAQCAtNTA0
  LDggKzY0NCwxMyBAQCBzdWIgcXVldWVfaW5jbHVkZXNfZnJvbQogICAgICAgICAgICAgICAgICRs
  aW5lIC49IDxIRUFERVI+OwogICAgICAgICAgICAgfQogCi0gICAgICAgICAgICBpZiAoJGxpbmUg
  PX4gL14jXHMqaW5jbHVkZVxzKzwoLio/KT4vKSB7Ci0gICAgICAgICAgICAgICAgcHVzaChAQVJH
  ViwgJDEpIHVubGVzcyAkaXNfY29udmVydGVkeyQxfTsKKyAgICAgICAgICAgIGlmICgkbGluZSA9
  fiAvXiNccyppbmNsdWRlXHMrKFs8Il0pKC4qPylbPiJdLykgeworICAgICAgICAgICAgICAgIG15
  ICgkZGVsaW1pdGVyLCAkbmV3X2ZpbGUpID0gKCQxLCAkMik7CisgICAgICAgICAgICAgICAgIyBj
  b3B5IHRoZSBwcmVmaXggaW4gdGhlIHF1b3RlIHN5bnRheCAoI2luY2x1ZGUgInguaCIpIGNhc2UK
  KyAgICAgICAgICAgICAgICBpZiAoJGRlbGltaXRlciBlcSBxeyJ9ICYmICRmaWxlID1+IG18Xigu
  KikvfCkgeworICAgICAgICAgICAgICAgICAgICAkbmV3X2ZpbGUgPSAiJDEvJG5ld19maWxlIjsK
  KyAgICAgICAgICAgICAgICB9CisgICAgICAgICAgICAgICAgcHVzaChAQVJHViwgJG5ld19maWxl
  KSB1bmxlc3MgJElzX2NvbnZlcnRlZHskbmV3X2ZpbGV9OwogICAgICAgICAgICAgfQogICAgICAg
  ICB9CiAgICAgY2xvc2UgSEVBREVSOwpAQCAtNTQ2LDI1ICs2OTEsNTAgQEAgc3ViIGJ1aWxkX3By
  ZWFtYmxlX2lmX25lY2Vzc2FyeQogICAgIG15ICglZGVmaW5lKSA9IF9leHRyYWN0X2NjX2RlZmlu
  ZXMoKTsKIAogICAgIG9wZW4gIFBSRUFNQkxFLCAiPiRwcmVhbWJsZSIgb3IgZGllICJDYW5ub3Qg
  b3BlbiAkcHJlYW1ibGU6ICAkISI7Ci0gICAgICAgIHByaW50IFBSRUFNQkxFICIjIFRoaXMgZmls
  ZSB3YXMgY3JlYXRlZCBieSBoMnBoIHZlcnNpb24gJFZFUlNJT05cbiI7Ci0KLSAgICAgICAgZm9y
  ZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKLSAgICAgICAgICAgIGlmICgkb3B0X0QpIHsKLSAg
  ICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKLSAgICAg
  ICAgICAgIH0KLQotICAgICAgICAgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eXGQrJC8pIHsKLSAg
  ICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNz
  IChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICRkZWZpbmV7JF99IH0gfVxuXG4iOwotICAgICAg
  ICAgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAg
  IHByaW50IFBSRUFNQkxFCi0gICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNl
  IHsKKwlwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJz
  aW9uICRWRVJTSU9OXG4iOworICAgICAgICAjIFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25z
  dGFudHMgZnJvbSB3YXJuaW5nLgorICAgICAgICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVj
  ZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlmIHdlIGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEg
  aGV4IGNvbnN0YW50IGFzIGFuIGludGVnZXIuCisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3
  YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4iOworCisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUp
  IHsKKwkgICAgaWYgKCRvcHRfRCkgeworCQlwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRf
  fVxuIjsKKwkgICAgfQorCSAgICBpZiAoJGRlZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJ
  CSMgcGFyZW50aGVzaXplZCB2YWx1ZTogIGQ9KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAg
  IH0KKwkgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/
  XGQrKT8pW0ZMXT8kLykgeworCQkjIGZsb2F0OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVu
  bGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNp
  ZiAoJGRlZmluZXskX30gPX4gL14oWystXT9cZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2Vy
  OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRf
  KCkgeyAkMSB9IH1cblxuIjsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9e
  KFsrLV0/MHhbXGRhLWZdKylVP0x7MCwyfSQvaSkgeworICAgICAgICAgICAgICAgICMgaGV4IGlu
  dGVnZXIKKyAgICAgICAgICAgICAgICAjIFNwZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMg
  b24gaGV4IGludGVnZXJzCisgICAgICAgICAgICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2Vu
  dGVkIGluIGEgVVYuCisgICAgICAgICAgICAgICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3
  YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0IHRpbWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAg
  ICAgICAgICAgICMgb25seSBnZXRzIHRoZSB3YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0
  aGlzCisgICAgICAgICAgICAgICAgIyBwbGF0Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAg
  ICAgICAgICAgICAgIG15ICRjb2RlID0gJDE7CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4
  KCckY29kZScpIiBpZiBsZW5ndGggJGNvZGUgPiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQ
  UkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIg
  JF8oKSB7IFwiIiwKLSAgICAgICAgICAgICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwg
  IlwiIH0gfVxuXG4iOwotICAgICAgICAgICAgfQotICAgICAgICB9CisgICAgICAgICAgICAgICAg
  ICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJ
  ICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUK
  KwkJICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0g
  fVxuXG4iOworCSAgICB9IGVsc2UgeworCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAo
  ZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyBcIiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXsk
  X30pLCAiXCIgfSB9XG5cbiI7CisJICAgIH0KKwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAg
  ICAgICAgICBvciBkaWUgIkNhbm5vdCBjbG9zZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTU3
  NSwxNSArNzQ1LDE1IEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKIHN1YiBfZXh0
  cmFjdF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKLSAgICBteSAkYWxsc3ltYm9scyA9
  IGpvaW4gIiAiLCBAQ29uZmlne2Njc3ltYm9scywgY3Bwc3ltYm9scywgY3BwY2NzeW1ib2xzfTsK
  KyAgICBteSAkYWxsc3ltYm9scyAgPSBqb2luICIgIiwKKwlAQ29uZmlneydjY3N5bWJvbHMnLCAn
  Y3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMnfTsKIAogICAgICMgU3BsaXQgY29tcGlsZXIgcHJl
  LWRlZmluaXRpb25zIGludG8gYGtleT12YWx1ZScgcGFpcnM6Ci0gICAgZm9yZWFjaCAoc3BsaXQg
  L1xzKy8sICRhbGxzeW1ib2xzKSB7Ci0gICAgICAgIC8oLis/KT0oLispLyBhbmQgJGRlZmluZXsk
  MX0gPSAkMjsKLQotICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICBwcmludCBTVERF
  UlIgIiRfOiAgJDEgLT4gJDJcbiI7Ci0gICAgICAgIH0KKyAgICB3aGlsZSAoJGFsbHN5bWJvbHMg
  PX4gLyhbXlxzXSspPSgoXFxcc3xbXlxzXSkrKS9nKSB7CisJJGRlZmluZXskMX0gPSAkMjsKKwlp
  ZiAoJG9wdF9EKSB7CisJICAgIHByaW50IFNUREVSUiAiJF86ICAkMSAtPiAkMlxuIjsKKwl9CiAg
  ICAgfQogCiAgICAgcmV0dXJuICVkZWZpbmU7CkBAIC02MTIsNiArNzgyLDEwIEBAIEl0IGlzIG1v
  c3QgZWFzaWx5IHJ1biB3aGlsZSBpbiAvdXNyL2luY2x1ZGU6CiAKIAljZCAvdXNyL2luY2x1ZGU7
  IGgycGggKiBzeXMvKgogCitvcgorCisJY2QgL3Vzci9pbmNsdWRlOyBoMnBoICogc3lzLyogYXJw
  YS8qIG5ldGluZXQvKgorCiBvcgogCiAJY2QgL3Vzci9pbmNsdWRlOyBoMnBoIC1yIC1sIC4KQEAg
  LTYyOSw3ICs4MDMsNyBAQCBJZiBydW4gd2l0aCBubyBhcmd1bWVudHMsIGZpbHRlcnMgc3RhbmRh
  cmQgaW5wdXQgdG8gc3RhbmRhcmQgb3V0cHV0LgogPWl0ZW0gLWQgZGVzdGluYXRpb25fZGlyCiAK
  IFB1dCB0aGUgcmVzdWx0aW5nIEI8LnBoPiBmaWxlcyBiZW5lYXRoIEI8ZGVzdGluYXRpb25fZGly
  PiwgaW5zdGVhZCBvZgotYmVuZWF0aCB0aGUgZGVmYXVsdCBQZXJsIGxpYnJhcnkgbG9jYXRpb24g
  KEM8JENvbmZpZ3snaW5zdGFsbHNpdHNlYXJjaCd9PikuCitiZW5lYXRoIHRoZSBkZWZhdWx0IFBl
  cmwgbGlicmFyeSBsb2NhdGlvbiAoQzwkQ29uZmlneydpbnN0YWxsc2l0ZWFyY2gnfT4pLgogCiA9
  aXRlbSAtcgogCkBAIC03MDgsMTggKzg4MiwxNiBAQCB0aGF0IGl0IGNhbiB0cmFuc2xhdGUuCiBJ
  dCdzIG9ubHkgaW50ZW5kZWQgYXMgYSByb3VnaCB0b29sLgogWW91IG1heSBuZWVkIHRvIGRpY2tl
  ciB3aXRoIHRoZSBmaWxlcyBwcm9kdWNlZC4KIAotRG9lc24ndCBydW4gd2l0aCBDPHVzZSBzdHJp
  Y3Q+Ci0KIFlvdSBoYXZlIHRvIHJ1biB0aGlzIHByb2dyYW0gYnkgaGFuZDsgaXQncyBub3QgcnVu
  IGFzIHBhcnQgb2YgdGhlIFBlcmwKIGluc3RhbGxhdGlvbi4KIAogRG9lc24ndCBoYW5kbGUgY29t
  cGxpY2F0ZWQgZXhwcmVzc2lvbnMgYnVpbHQgcGllY2VtZWFsLCBhIGxhOgogCiAgICAgZW51bSB7
  Ci0gICAgICAgIEZJUlNUX1ZBTFVFLAotICAgICAgICBTRUNPTkRfVkFMVUUsCisJRklSU1RfVkFM
  VUUsCisJU0VDT05EX1ZBTFVFLAogICAgICNpZmRlZiBBQkMKLSAgICAgICAgVEhJUkRfVkFMVUUK
  KwlUSElSRF9WQUxVRQogICAgICNlbmRpZgogICAgIH07CiAK
  UH2PH560
    }
    if ( $num < 5.007000 ) {
      return _patch_b64(<<'UH2PH562');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTQyLDggKzQyLDEzIEBAIHVz
  ZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9wdDo6U3RkOwog
  Ci1nZXRvcHRzKCdEZDpybGhhUScpOwotdXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3Ig
  JG9wdF9sICRvcHRfaCAkb3B0X2EgJG9wdF9RKTsKKyMgTWFrZSBzdXJlIHJlYWQgcGVybWlzc2lv
  bnMgZm9yIGFsbCBhcmUgc2V0OgoraWYgKGRlZmluZWQgdW1hc2sgJiYgKHVtYXNrKCkgJiAwNDQ0
  KSkgeworICAgIHVtYXNrICh1bWFzaygpICYgfjA0NDQpOworfQorCitnZXRvcHRzKCdEZDpybGhh
  UWUnKTsKK3VzZSB2YXJzIHF3KCRvcHRfRCAkb3B0X2QgJG9wdF9yICRvcHRfbCAkb3B0X2ggJG9w
  dF9hICRvcHRfUSAkb3B0X2UpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7CiBteSBAaW5jX2RpcnMgPSBpbmNf
  ZGlycygpIGlmICRvcHRfYTsKIApAQCAtNjUsMTMgKzcwLDIxIEBAIG15ICVpc2F0eXBlOwogQGlz
  YXR5cGV7QGlzYXR5cGV9ID0gKDEpIHggQGlzYXR5cGU7CiBteSAkaW5pZiA9IDA7CiBteSAlSXNf
  Y29udmVydGVkOworbXkgJWJhZF9maWxlID0gKCk7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBB
  UkdWOwogCiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkoKTsKIAorc3ViIHJlaW5kZW50KCQp
  IHsKKyAgICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwor
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKwogbXkgKCR0LCAk
  dGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91
  dGZpbGUpOwotbXkgKCRpbmNsLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNs
  X3F1b3RlLCAkbmV4dCk7CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkp
  IHsKICAgICBpZiAoLWwgJGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9z
  c2libGUoJGZpbGUpIGlmICgkb3B0X2wpOwpAQCAtMTA3LDMwICsxMjAsMTcgQEAgd2hpbGUgKGRl
  ZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJb3BlbihPVVQsIj4kRGVzdF9kaXIv
  JG91dGZpbGUiKSB8fCBkaWUgIkNhbid0IGNyZWF0ZSAkb3V0ZmlsZTogJCFcbiI7CiAgICAgfQog
  Ci0gICAgcHJpbnQgT1VUICJyZXF1aXJlICdfaDJwaF9wcmUucGgnO1xuXG4iOwotICAgIHdoaWxl
  ICg8SU4+KSB7Ci0JY2hvcDsKLQl3aGlsZSAoL1xcJC8pIHsKLQkgICAgY2hvcDsKLQkgICAgJF8g
  Lj0gPElOPjsKLQkgICAgY2hvcDsKLQl9Ci0JcHJpbnQgT1VUICIjICRfXG4iIGlmICRvcHRfRDsK
  LQotCWlmIChzOi9cKjpcMjAwOmcpIHsKLQkgICAgczpcKi86XDIwMTpnOwotCSAgICBzL1wyMDBb
  XlwyMDFdKlwyMDEvL2c7CSMgZGVsZXRlIHNpbmdsZSBsaW5lIGNvbW1lbnRzCi0JICAgIGlmIChz
  L1wyMDAuKi8vKSB7CQkjIGJlZ2luIG11bHRpLWxpbmUgY29tbWVudD8KLQkJJF8gLj0gJy8qJzsK
  LQkJJF8gLj0gPElOPjsKLQkJcmVkbzsKLQkgICAgfQotCX0KKyAgICBwcmludCBPVVQKKyAgICAg
  ICAgInJlcXVpcmUgJ19oMnBoX3ByZS5waCc7XG5cbiIsCisgICAgICAgICJubyB3YXJuaW5ncyAn
  cmVkZWZpbmUnO1xuXG4iOworCisgICAgd2hpbGUgKGRlZmluZWQgKGxvY2FsICRfID0gbmV4dF9s
  aW5lKCRmaWxlKSkpIHsKIAlpZiAocy9eXHMqXCNccyovLykgewogCSAgICBpZiAocy9eZGVmaW5l
  XHMrKFx3KykvLykgewogCQkkbmFtZSA9ICQxOwogCQkkbmV3ID0gJyc7CiAJCXMvXHMrJC8vOwor
  CQlzL1woXHcrXHMqXChcKlwpXHMqXChcdypcKVwpXHMqKC0/XGQrKS8kMS87ICMgKGludCAoKiko
  Zm9vX3QpKTAKIAkJaWYgKHMvXlwoKFtcdyxcc10qKVwpLy8pIHsKIAkJICAgICRhcmdzID0gJDE7
  CiAgICAgCSAgICAJICAgIG15ICRwcm90byA9ICcoKSAnOwpAQCAtMTg0LDIyICsxODQsMzIgQEAg
  d2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAgICAgICAgICAgICAg
  ICAgICAgICAgcHJpbnQgT1VUICR0LCJ1bmxlc3MoZGVmaW5lZChcJiRuYW1lKSkge1xuICAgIHN1
  YiAkbmFtZSAoKSB7XHQiLCRuZXcsIjt9XG59XG4iOwogCQkgICAgfQogCQl9Ci0JICAgIH0gZWxz
  aWYgKC9eKGluY2x1ZGV8aW1wb3J0KVxzKls8Il0oLiopWz4iXS8pIHsKLQkJKCRpbmNsID0gJDIp
  ID1+IHMvXC5oJC8ucGgvOwotCQlwcmludCBPVVQgJHQsInJlcXVpcmUgJyRpbmNsJztcbiI7Ci0J
  ICAgIH0gZWxzaWYoL15pbmNsdWRlX25leHRccypbPCJdKC4qKVs+Il0vKSB7Ci0JCSgkaW5jbCA9
  ICQxKSA9fiBzL1wuaCQvLnBoLzsKKwkgICAgfSBlbHNpZiAoL14oaW5jbHVkZXxpbXBvcnR8aW5j
  bHVkZV9uZXh0KVxzKihbPFwiXSkoLiopWz5cIl0vKSB7CisgICAgICAgICAgICAgICAgJGluY2xf
  dHlwZSA9ICQxOworICAgICAgICAgICAgICAgICRpbmNsX3F1b3RlID0gJDI7CisgICAgICAgICAg
  ICAgICAgJGluY2wgPSAkMzsKKyAgICAgICAgICAgICAgICBpZiAoKCRpbmNsX3R5cGUgZXEgJ2lu
  Y2x1ZGVfbmV4dCcpIHx8CisgICAgICAgICAgICAgICAgICAgICgkb3B0X2UgJiYgZXhpc3RzKCRi
  YWRfZmlsZXskaW5jbH0pKSkgeworICAgICAgICAgICAgICAgICAgICAkaW5jbCA9fiBzL1wuaCQv
  LnBoLzsKIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJldmFsIHtcbiIpOwogICAgICAgICAgICAg
  ICAgICR0YWIgKz0gNDsKICAgICAgICAgICAgICAgICAkdCA9ICJcdCIgeCAoJHRhYiAvIDgpIC4g
  JyAnIHggKCR0YWIgJSA4KTsKKyAgICAgICAgICAgICAgICAgICAgcHJpbnQgT1VUICgkdCwgIm15
  KFxAUkVNKTtcbiIpOworICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2xfdHlwZSBlcSAnaW5j
  bHVkZV9uZXh0JykgewogCQlwcmludCBPVVQgKCR0LAogCQkJICAgIm15KFwlSU5DRCkgPSBtYXAg
  eyBcJElOQ3tcJF99ID0+IDEgfSAiLAotCQkJICAgIihncmVwIHsgXCRfIGVxIFwiJGluY2xcIiB9
  IGtleXMoXCVJTkMpKTtcbiIpOworCQkJICAgICAgICAgICAiKGdyZXAgeyBcJF8gZXEgXCIkaW5j
  bFwiIH0gIiwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgImtleXMoXCVJTkMp
  KTtcbiIpOwogCQlwcmludCBPVVQgKCR0LAotCQkJICAgIm15KFxAUkVNKSA9IG1hcCB7IFwiXCRf
  LyRpbmNsXCIgfSAiLAorCQkJICAgICAgICAgICAiXEBSRU0gPSBtYXAgeyBcIlwkXy8kaW5jbFwi
  IH0gIiwKIAkJCSAgICIoZ3JlcCB7IG5vdCBleGlzdHMoXCRJTkNEe1wiXCRfLyRpbmNsXCJ9KSIs
  Ci0JCQkgICAiYW5kIC1mIFwiXCRfLyRpbmNsXCIgfSBcQElOQyk7XG4iKTsKKwkJCSAgICAgICAg
  ICAgIiBhbmQgLWYgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAgICAgICAgICAgICAg
  ICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgT1VUICgkdCwKKyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlxAUkVNID0gbWFwIHsgXCJcJF8vJGlu
  Y2xcIiB9ICIsCisgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICIoZ3JlcCB7LXIg
  XCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAgICAgICAgICAgICAgICAgICB9CiAJCXBy
  aW50IE9VVCAoJHQsCiAJCQkgICAicmVxdWlyZSBcIlwkUkVNWzBdXCIgaWYgXEBSRU07XG4iKTsK
  ICAgICAgICAgICAgICAgICAkdGFiIC09IDQ7CkBAIC0yMDgsNiArMjE4LDE0IEBAIHdoaWxlIChk
  ZWZpbmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCQkJICAgIn07XG4iKTsKIAkJcHJp
  bnQgT1VUICgkdCwKIAkJCSAgICJ3YXJuKFwkXEApIGlmIFwkXEA7XG4iKTsKKyAgICAgICAgICAg
  ICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAkaW5jbCA9fiBzL1wuaCQvLnBoLzsK
  KyAgICAgICAgICAgICAgICAgICAgIyBjb3B5IHRoZSBwcmVmaXggaW4gdGhlIHF1b3RlIHN5bnRh
  eCAoI2luY2x1ZGUgInguaCIpIGNhc2UKKyAgICAgICAgICAgICAgICAgICAgaWYgKCRpbmNsICF+
  IG18L3wgJiYgJGluY2xfcXVvdGUgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAg
  ICAgICAgICAgICAgICAgICAgICAgICRpbmNsID0gIiQxLyRpbmNsIjsKKyAgICAgICAgICAgICAg
  ICAgICAgfQorCQkgICAgcHJpbnQgT1VUICR0LCJyZXF1aXJlICckaW5jbCc7XG4iOworICAgICAg
  ICAgICAgICAgIH0KIAkgICAgfSBlbHNpZiAoL15pZmRlZlxzKyhcdyspLykgewogCQlwcmludCBP
  VVQgJHQsImlmKGRlZmluZWQoJiQxKSkge1xuIjsKIAkJJHRhYiArPSA0OwpAQCAtMjU1LDE1ICsy
  NzMsMTkgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJICAg
  IH0gZWxzaWYoL15pZGVudFxzKyguKikvKSB7CiAJCXByaW50IE9VVCAkdCwgIiMgJDFcbiI7CiAJ
  ICAgIH0KLSAJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3
  KlxzKik/XHsvKSB7Ci0JICAgIHVudGlsKC9cfS4qPzsvKSB7Ci0JCWNob21wKCRuZXh0ID0gPElO
  Pik7CisJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3Klxz
  Kik/LykgeworCSAgICB1bnRpbCgvXHtbXn1dKlx9Lio7LyB8fCAvOy8pIHsKKwkJbGFzdCB1bmxl
  c3MgZGVmaW5lZCAoJG5leHQgPSBuZXh0X2xpbmUoJGZpbGUpKTsKKwkJY2hvbXAgJG5leHQ7CisJ
  CSMgZHJvcCAiI2RlZmluZSBGT08gRk9PIiBpbiBlbnVtcworCQkkbmV4dCA9fiBzL15ccyojXHMq
  ZGVmaW5lXHMrKFx3KylccytcMVxzKiQvLzsKIAkJJF8gLj0gJG5leHQ7CiAJCXByaW50IE9VVCAi
  IyAkbmV4dFxuIiBpZiAkb3B0X0Q7CiAJICAgIH0KKwkgICAgcy8jXHMqaWYuKj8jXHMqZW5kaWYv
  L2c7ICMgZHJvcCAjaWZkZWZzCiAJICAgIHNAL1wqLio/XCovQEBnOwogCSAgICBzL1xzKy8gL2c7
  Ci0JICAgIC9eXHM/KHR5cGVkZWZccz8pP2VudW1ccz8oW2EtekEtWl9dXHcqKT9ccz9ceyguKilc
  fVxzPyhbYS16QS1aX11cdyopP1xzPzsvOworCSAgICBuZXh0IHVubGVzcyAvXlxzPyh0eXBlZGVm
  XHM/KT9lbnVtXHM/KFthLXpBLVpfXVx3Kik/XHM/XHsoLiopXH1ccz8oW2EtekEtWl9dXHcqKT9c
  cz87LzsKIAkgICAgKG15ICRlbnVtX3N1YnMgPSAkMykgPX4gcy9ccy8vZzsKIAkgICAgbXkgQGVu
  dW1fc3VicyA9IHNwbGl0KC8sLywgJGVudW1fc3Vicyk7CiAJICAgIG15ICRlbnVtX3ZhbCA9IC0x
  OwpAQCAtMjg1LDIyICszMDcsMjIgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9m
  aWxlKCkpKSB7CiAJICAgIH0KIAl9CiAgICAgfQotICAgIHByaW50IE9VVCAiMTtcbiI7Ci0KICAg
  ICAkSXNfY29udmVydGVkeyRmaWxlfSA9IDE7CisgICAgaWYgKCRvcHRfZSAmJiBleGlzdHMoJGJh
  ZF9maWxleyRmaWxlfSkpIHsKKyAgICAgICAgdW5saW5rKCREZXN0X2RpciAuICcvJyAuICRvdXRm
  aWxlKTsKKyAgICAgICAgJG5leHQgPSAnJzsKKyAgICB9IGVsc2UgeworICAgICAgICBwcmludCBP
  VVQgIjE7XG4iOwogICAgIHF1ZXVlX2luY2x1ZGVzX2Zyb20oJGZpbGUpIGlmICgkb3B0X2EpOwor
  ICAgIH0KIH0KIAotZXhpdCAkRXhpdDsKLQotCi1zdWIgcmVpbmRlbnQoJCkgewotICAgIG15KCR0
  ZXh0KSA9IHNoaWZ0OwotICAgICR0ZXh0ID1+IHMvXG4vXG4gICAgL2c7Ci0gICAgJHRleHQgPX4g
  cy8gICAgICAgIC9cdC9nOwotICAgICR0ZXh0OworaWYgKCRvcHRfZSAmJiAoc2NhbGFyKGtleXMg
  JWJhZF9maWxlKSA+IDApKSB7CisgICAgd2FybiAiV2FzIHVuYWJsZSB0byBjb252ZXJ0IHRoZSBm
  b2xsb3dpbmcgZmlsZXM6XG4iOworICAgIHdhcm4gIlx0IiAuIGpvaW4oIlxuXHQiLHNvcnQoa2V5
  cyAlYmFkX2ZpbGUpKSAuICJcbiI7CiB9CiAKK2V4aXQgJEV4aXQ7CiAKIHN1YiBleHByIHsKICAg
  ICBteSAkam9pbmVkX2FyZ3M7CkBAIC0zMTEsOCArMzMzLDIxIEBAIHN1YiBleHByIHsKIAlzL15c
  JlwmLy8gJiYgZG8geyAkbmV3IC49ICIgJiYiOyBuZXh0O307ICMgaGFuZGxlICYmIG9wZXJhdG9y
  CiAJcy9eXCYoW1woYS16XCldKykvJDEvaTsJIyBoYWNrIGZvciB0aGluZ3MgdGhhdCB0YWtlIHRo
  ZSBhZGRyZXNzIG9mCiAJcy9eKFxzKykvLwkJJiYgZG8geyRuZXcgLj0gJyAnOyBuZXh0O307Ci0J
  cy9eKDBYWzAtOUEtRl0rKVtVTF0qLy9pCSYmIGRvIHskbmV3IC49IGxjKCQxKTsgbmV4dDt9Owot
  CXMvXigtP1xkK1wuXGQrRVstK11cZCspRj8vL2kJJiYgZG8geyRuZXcgLj0gJDE7IG5leHQ7fTsK
  KwlzL14wWChbMC05QS1GXSspW1VMXSovL2kgCisJICAgICYmIGRvIHtteSAkaGV4ID0gJDE7CisJ
  CSAgICRoZXggPX4gcy9eMCsvLzsKKwkJICAgaWYgKGxlbmd0aCAkaGV4ID4gOCAmJiAhJENvbmZp
  Z3t1c2U2NGJpdGludH0pIHsKKwkJICAgICAgICMgQ3JvYWsgaWYgbnZfcHJlc2VydmVzX3V2X2Jp
  dHMgPCA2NCA/CisJCSAgICAgICAkbmV3IC49ICAgICAgICAgaGV4KHN1YnN0cigkaGV4LCAtOCkp
  ICsKKwkJCSAgICAgICAyKiozMiAqIGhleChzdWJzdHIoJGhleCwgIDAsIC04KSk7CisJCSAgICAg
  ICAjIFRoZSBhYm92ZSB3aWxsIHByb2R1Y2UgImVycm9ybmV1cyIgY29kZQorCQkgICAgICAgIyBp
  ZiB0aGUgaGV4IGNvbnN0YW50IHdhcyBlLmcuIGluc2lkZSBVSU5UNjRfQworCQkgICAgICAgIyBt
  YWNybywgYnV0IHRoZW4gYWdhaW4sIGgycGggaXMgYW4gYXBwcm94aW1hdGlvbi4KKwkJICAgfSBl
  bHNlIHsKKwkJICAgICAgICRuZXcgLj0gbGMoIjB4JGhleCIpOworCQkgICB9CisJCSAgIG5leHQ7
  fTsKKwlzL14oLT9cZCtcLlxkK0VbLStdP1xkKylbRkxdPy8vaQkmJiBkbyB7JG5ldyAuPSAkMTsg
  bmV4dDt9OwogCXMvXihcZCspXHMqW0xVXSovL2kJJiYgZG8geyRuZXcgLj0gJDE7IG5leHQ7fTsK
  IAlzL14oIihcXCJ8W14iXSkqIikvLwkmJiBkbyB7JG5ldyAuPSAkMTsgbmV4dDt9OwogCXMvXico
  KFxcInxbXiJdKSopJy8vCSYmIGRvIHsKQEAgLTM1MSw3ICszODYsNyBAQCBzdWIgZXhwciB7CiAJ
  IyBFbGltaW5hdGUgdHlwZWRlZnMKIAkvXCgoW1x3XHNdKylbXCpcc10qXClccypbXHdcKF0vICYm
  IGRvIHsKIAkgICAgZm9yZWFjaCAoc3BsaXQgL1xzKy8sICQxKSB7ICAjIE1ha2Ugc3VyZSBhbGwg
  dGhlIHdvcmRzIGFyZSB0eXBlcywKLQkJbGFzdCB1bmxlc3MgKCRpc2F0eXBleyRffSBvciAkXyBl
  cSAnc3RydWN0Jyk7CisJCWxhc3QgdW5sZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVj
  dCcgb3IgJF8gZXEgJ3VuaW9uJyk7CiAJICAgIH0KIAkgICAgcy9cKFtcd1xzXStbXCpcc10qXCkv
  LyAmJiBuZXh0OyAgICAgICMgdGhlbiBlbGltaW5hdGUgdGhlbS4KIAl9OwpAQCAtMzc0LDcgKzQw
  OSw3IEBAIHN1YiBleHByIHsKIAl9OwogCXMvXihbX2EtekEtWl1cdyopLy8JJiYgZG8gewogCSAg
  ICBteSAkaWQgPSAkMTsKLQkgICAgaWYgKCRpZCBlcSAnc3RydWN0JykgeworCSAgICBpZiAoJGlk
  IGVxICdzdHJ1Y3QnIHx8ICRpZCBlcSAndW5pb24nKSB7CiAJCXMvXlxzKyhcdyspLy87CiAJCSRp
  ZCAuPSAnICcgLiAkMTsKIAkJJGlzYXR5cGV7JGlkfSA9IDE7CkBAIC0zODcsOCArNDIyLDggQEAg
  c3ViIGV4cHIgewogCQkkbmV3IC49ICctPicgaWYgL15bXFtce10vOwogCSAgICB9IGVsc2lmICgk
  aWQgZXEgJ2RlZmluZWQnKSB7CiAJCSRuZXcgLj0gJ2RlZmluZWQnOwotCSAgICB9IGVsc2lmICgv
  XlwoLykgewotCQlzL15cKChcdyksLygiJDEiLC8gaWYgJGlkID1+IC9eX0lPW1dSXSokL2k7CSMg
  Y2hlYXQKKwkgICAgfSBlbHNpZiAoL15ccypcKC8pIHsKKwkJcy9eXHMqXCgoXHcpLC8oIiQxIiwv
  IGlmICRpZCA9fiAvXl9JT1tXUl0qJC9pOwkjIGNoZWF0CiAJCSRuZXcgLj0gIiAmJGlkIjsKIAkg
  ICAgfSBlbHNpZiAoJGlzYXR5cGV7JGlkfSkgewogCQlpZiAoJG5ldyA9fiAve1xzKiQvKSB7CkBA
  IC00MDEsNyArNDM2LDcgQEAgc3ViIGV4cHIgewogCQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgk
  aW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVkXHMqXCgkLykgewotCQkgICAgJG5ldyAuPSAnKGRlZmlu
  ZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4gJGlkIC4gJyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhk
  ZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAuICRpZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lm
  ICgvXlxbLykgewogCQkgICAgJG5ldyAuPSAiIFwkJGlkIjsKIAkJfSBlbHNlIHsKQEAgLTQxNSw2
  ICs0NTAsMTAxIEBAIHN1YiBleHByIHsKIH0KIAogCitzdWIgbmV4dF9saW5lCit7CisgICAgbXkg
  JGZpbGUgPSBzaGlmdDsKKyAgICBteSAoJGluLCAkb3V0KTsKKyAgICBteSAkcHJlX3N1Yl90cmlf
  Z3JhcGhzID0gMTsKKworICAgIFJFQUQ6IHdoaWxlIChub3QgZW9mIElOKSB7CisgICAgICAgICRp
  biAgLj0gPElOPjsKKyAgICAgICAgY2hvbXAgJGluOworICAgICAgICBuZXh0IHVubGVzcyBsZW5n
  dGggJGluOworCisgICAgICAgIHdoaWxlIChsZW5ndGggJGluKSB7CisgICAgICAgICAgICBpZiAo
  JHByZV9zdWJfdHJpX2dyYXBocykgeworICAgICAgICAgICAgICAgICMgUHJlcHJvY2VzcyBhbGwg
  dHJpLWdyYXBocyAKKyAgICAgICAgICAgICAgICAjIGluY2x1ZGluZyB0aGluZ3Mgc3R1Y2sgaW4g
  cXVvdGVkIHN0cmluZyBjb25zdGFudHMuCisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cPz0v
  Iy9nOyAgICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz89fCAgI3wKKyAgICAgICAgICAgICAg
  ICAkaW4gPX4gcy9cP1w/XCEvfC9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/PyF8ICB8
  fAorICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD8nL14vZzsgICAgICAgICAgICAgICAgICAg
  ICAgICAgIyB8ID8/J3wgIF58CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1woL1svZzsg
  ICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz8ofCAgW3wKKyAgICAgICAgICAgICAgICAkaW4g
  PX4gcy9cP1w/XCkvXS9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pyl8ICBdfAorICAg
  ICAgICAgICAgICAgICRpbiA9fiBzL1w/XD9cLS9+L2c7ICAgICAgICAgICAgICAgICAgICAgICAg
  IyB8ID8/LXwgIH58CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1wvL1xcL2c7ICAgICAg
  ICAgICAgICAgICAgICAgICAjIHwgPz8vfCAgXHwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9c
  P1w/PC97L2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pzx8ICB7fAorICAgICAgICAg
  ICAgICAgICRpbiA9fiBzL1w/XD8+L30vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/
  PnwgIH18CisgICAgICAgICAgICB9CisJICAgIGlmICgkaW4gPX4gL15cI2lmZGVmIF9fTEFOR1VB
  R0VfUEFTQ0FMX18vKSB7CisgICAgICAgICAgICAgICAgIyBUcnU2NCBkaXNhc3NlbWJsZXIuaCBl
  dmlsbmVzczogbWl4ZWQgQyBhbmQgUGFzY2FsLgorCQl3aGlsZSAoPElOPikgeworCQkgICAgbGFz
  dCBpZiAvXlwjZW5kaWYvOyAKKwkJfQorCQluZXh0IFJFQUQ7CisJICAgIH0KKwkgICAgaWYgKCRp
  biA9fiAvXmV4dGVybiBpbmxpbmUgLyAmJiAjIElubGluZWQgYXNzZW1ibGVyLgorCQkkXk8gZXEg
  J2xpbnV4JyAmJiAkZmlsZSA9fiBtISg/Ol58Lylhc20vW14vXStcLmgkISkgeworIAkJd2hpbGUg
  KDxJTj4pIHsKKwkJICAgIGxhc3QgaWYgL159LzsgCisJCX0KKwkJbmV4dCBSRUFEOworCSAgICB9
  CisgICAgICAgICAgICBpZiAoJGluID1+IHMvXFwkLy8pIHsgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAjIFwtbmV3bGluZQorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOworICAgICAg
  ICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oW14i
  J1xcXC9dKykvLykgeyAgICAgICAgICAgICMgUGFzc3Rocm91Z2gKKyAgICAgICAgICAgICAgICAk
  b3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihcXC4pLy8pIHsg
  ICAgICAgICAgICAgICAgICAgIyBcLi4uCisgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsK
  KyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiAvXicvKSB7ICAgICAgICAgICAgICAgICAgICAg
  ICAgICMgJy4uLgorICAgICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eKCcoXFwufFteJ1xcXSkq
  JykvLykgeworICAgICAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAg
  ICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAg
  ICAgICB9CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gL14iLykgeyAgICAgICAgICAgICAg
  ICAgICAgICAgICAjICIuLi4KKyAgICAgICAgICAgICAgICBpZiAoJGluID1+IHMvXigiKFxcLnxb
  XiJcXF0pKiIpLy8pIHsKKyAgICAgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAg
  ICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICBuZXh0IFJFQUQ7CisgICAg
  ICAgICAgICAgICAgfQorICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXlwvXC8uKi8vKSB7
  ICAgICAgICAgICAgICAgICAgIyAvLy4uLgorICAgICAgICAgICAgICAgICMgZmFsbCB0aHJvdWdo
  CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gbS9eXC9cKi8pIHsgICAgICAgICAgICAgICAg
  ICAgICAjIC8qLi4uCisgICAgICAgICAgICAgICAgIyBDIGNvbW1lbnQgcmVtb3ZhbCBhZGFwdGVk
  IGZyb20gcGVybGZhcTY6CisgICAgICAgICAgICAgICAgaWYgKCRpbiA9fiBzL15cL1wqW14qXSpc
  KisoW15cLypdW14qXSpcKispKlwvLy8pIHsKKyAgICAgICAgICAgICAgICAgICAgJG91dCAgICAu
  PSAnICc7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAjIEluY29tcGxldGUgLyogKi8KKyAgICAgICAgICAgICAgICAgICAgbmV4dCBS
  RUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14o
  XC8pLy8pIHsgICAgICAgICAgICAgICAgICAgICMgLy4uLgorICAgICAgICAgICAgICAgICRvdXQg
  ICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteXCdcIlxcXC9dKykv
  LykgeworICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lm
  ICgkXk8gZXEgJ2xpbnV4JyAmJgorICAgICAgICAgICAgICAgICAgICAgJGZpbGUgPX4gbSEoPzpe
  fC8pbGludXgvYnl0ZW9yZGVyL3BkcF9lbmRpYW5cLmgkISAmJgorICAgICAgICAgICAgICAgICAg
  ICAgJGluICAgPX4gcyFcJ1QgS05PVyEhKSB7CisgICAgICAgICAgICAgICAgJG91dCAgICA9fiBz
  IUkgRE9OJCFJX0RPX05PVF9LTk9XITsKKyAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAg
  ICAgICAgaWYgKCRvcHRfZSkgeworICAgICAgICAgICAgICAgICAgICB3YXJuICJDYW5ub3QgcGFy
  c2UgJGZpbGU6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgICAgICRiYWRfZmlsZXskZmlsZX0g
  PSAxOworICAgICAgICAgICAgICAgICAgICAkaW4gPSAnJzsKKyAgICAgICAgICAgICAgICAgICAg
  JG91dCA9IHVuZGVmOworICAgICAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAg
  ICAgICAgfSBlbHNlIHsKKwkJZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAg
  ICAgICAgfQorICAgICAgICAgICAgfQorICAgICAgICB9CisKKyAgICAgICAgbGFzdCBSRUFEIGlm
  ICRvdXQgPX4gL1xTLzsKKyAgICB9CisKKyAgICByZXR1cm4gJG91dDsKK30KKworCiAjIEhhbmRs
  ZSByZWN1cnNpdmUgc3ViZGlyZWN0b3JpZXMgd2l0aG91dCBnZXR0aW5nIGEgZ3JvdGVzcXVlbHkg
  YmlnIHN0YWNrLgogIyBDb3VsZCB0aGlzIGJlIGltcGxlbWVudGVkIHVzaW5nIEZpbGU6OkZpbmQ/
  CiBzdWIgbmV4dF9maWxlCkBAIC01MTQsOCArNjQ0LDEzIEBAIHN1YiBxdWV1ZV9pbmNsdWRlc19m
  cm9tCiAgICAgICAgICAgICAgICAgJGxpbmUgLj0gPEhFQURFUj47CiAgICAgICAgICAgICB9CiAK
  LSAgICAgICAgICAgIGlmICgkbGluZSA9fiAvXiNccyppbmNsdWRlXHMrPCguKj8pPi8pIHsKLSAg
  ICAgICAgICAgICAgICBwdXNoKEBBUkdWLCAkMSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JDF9Owor
  ICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccysoWzwiXSkoLio/KVs+Il0v
  KSB7CisgICAgICAgICAgICAgICAgbXkgKCRkZWxpbWl0ZXIsICRuZXdfZmlsZSkgPSAoJDEsICQy
  KTsKKyAgICAgICAgICAgICAgICAjIGNvcHkgdGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3ludGF4
  ICgjaW5jbHVkZSAieC5oIikgY2FzZQorICAgICAgICAgICAgICAgIGlmICgkZGVsaW1pdGVyIGVx
  IHF7In0gJiYgJGZpbGUgPX4gbXxeKC4qKS98KSB7CisgICAgICAgICAgICAgICAgICAgICRuZXdf
  ZmlsZSA9ICIkMS8kbmV3X2ZpbGUiOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgICAg
  ICBwdXNoKEBBUkdWLCAkbmV3X2ZpbGUpIHVubGVzcyAkSXNfY29udmVydGVkeyRuZXdfZmlsZX07
  CiAgICAgICAgICAgICB9CiAgICAgICAgIH0KICAgICBjbG9zZSBIRUFERVI7CkBAIC01NTYsMjUg
  KzY5MSw1MCBAQCBzdWIgYnVpbGRfcHJlYW1ibGVfaWZfbmVjZXNzYXJ5CiAgICAgbXkgKCVkZWZp
  bmUpID0gX2V4dHJhY3RfY2NfZGVmaW5lcygpOwogCiAgICAgb3BlbiAgUFJFQU1CTEUsICI+JHBy
  ZWFtYmxlIiBvciBkaWUgIkNhbm5vdCBvcGVuICRwcmVhbWJsZTogICQhIjsKLSAgICAgICAgcHJp
  bnQgUFJFQU1CTEUgIiMgVGhpcyBmaWxlIHdhcyBjcmVhdGVkIGJ5IGgycGggdmVyc2lvbiAkVkVS
  U0lPTlxuIjsKLQotICAgICAgICBmb3JlYWNoIChzb3J0IGtleXMgJWRlZmluZSkgewotICAgICAg
  ICAgICAgaWYgKCRvcHRfRCkgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFICIjICRf
  PSRkZWZpbmV7JF99XG4iOwotICAgICAgICAgICAgfQotCi0gICAgICAgICAgICBpZiAoJGRlZmlu
  ZXskX30gPX4gL15cZCskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAg
  ICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJGRlZmlu
  ZXskX30gfSB9XG5cbiI7Ci0gICAgICAgICAgICB9IGVsc2lmICgkZGVmaW5leyRffSA9fiAvXlx3
  KyQvKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1CTEUKLSAgICAgICAgICAgICAgICAg
  ICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAmJGRlZmluZXskX30gfSB9XG5c
  biI7Ci0gICAgICAgICAgICB9IGVsc2UgeworCXByaW50IFBSRUFNQkxFICIjIFRoaXMgZmlsZSB3
  YXMgY3JlYXRlZCBieSBoMnBoIHZlcnNpb24gJFZFUlNJT05cbiI7CisgICAgICAgICMgUHJldmVu
  dCBub24tcG9ydGFibGUgaGV4IGNvbnN0YW50cyBmcm9tIHdhcm5pbmcuCisgICAgICAgICMKKyAg
  ICAgICAgIyBXZSBzdGlsbCBwcm9kdWNlIGFuIG92ZXJmbG93IHdhcm5pbmcgaWYgd2UgY2FuJ3Qg
  cmVwcmVzZW50CisgICAgICAgICMgYSBoZXggY29uc3RhbnQgYXMgYW4gaW50ZWdlci4KKyAgICAg
  ICAgcHJpbnQgUFJFQU1CTEUgIm5vIHdhcm5pbmdzIHF3KHBvcnRhYmxlKTtcbiI7CisKKwlmb3Jl
  YWNoIChzb3J0IGtleXMgJWRlZmluZSkgeworCSAgICBpZiAoJG9wdF9EKSB7CisJCXByaW50IFBS
  RUFNQkxFICIjICRfPSRkZWZpbmV7JF99XG4iOworCSAgICB9CisJICAgIGlmICgkZGVmaW5leyRf
  fSA9fiAvXlwoKC4qKVwpJC8pIHsKKwkJIyBwYXJlbnRoZXNpemVkIHZhbHVlOiAgZD0odikKKwkJ
  JGRlZmluZXskX30gPSAkMTsKKwkgICAgfQorCSAgICBpZiAoJGRlZmluZXskX30gPX4gL14oWyst
  XT8oXGQrKT9cLlxkKyhbZUVdWystXT9cZCspPylbRkxdPyQvKSB7CisJCSMgZmxvYXQ6CisJCXBy
  aW50IFBSRUFNQkxFCisJCSAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQx
  IH0gfVxuXG4iOworCSAgICB9IGVsc2lmICgkZGVmaW5leyRffSA9fiAvXihbKy1dP1xkKylVP0x7
  MCwyfSQvaSkgeworCQkjIGludGVnZXI6CisJCXByaW50IFBSRUFNQkxFCisJCSAgICAidW5sZXNz
  IChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOworICAgICAgICAgICAgfSBl
  bHNpZiAoJGRlZmluZXskX30gPX4gL14oWystXT8weFtcZGEtZl0rKVU/THswLDJ9JC9pKSB7Cisg
  ICAgICAgICAgICAgICAgIyBoZXggaW50ZWdlcgorICAgICAgICAgICAgICAgICMgU3BlY2lhbCBj
  YXNlZCwgc2luY2UgcGVybCB3YXJucyBvbiBoZXggaW50ZWdlcnMKKyAgICAgICAgICAgICAgICAj
  IHRoYXQgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgaW4gYSBVVi4KKyAgICAgICAgICAgICAgICAjCisg
  ICAgICAgICAgICAgICAgIyBUaGlzIHdheSB3ZSBnZXQgdGhlIHdhcm5pbmcgYXQgdGltZSBvZiB1
  c2UsIHNvIHRoZSB1c2VyCisgICAgICAgICAgICAgICAgIyBvbmx5IGdldHMgdGhlIHdhcm5pbmcg
  aWYgdGhleSBoYXBwZW4gdG8gdXNlIHRoaXMKKyAgICAgICAgICAgICAgICAjIHBsYXRmb3JtLXNw
  ZWNpZmljIGRlZmluaXRpb24uCisgICAgICAgICAgICAgICAgbXkgJGNvZGUgPSAkMTsKKyAgICAg
  ICAgICAgICAgICAkY29kZSA9ICJoZXgoJyRjb2RlJykiIGlmIGxlbmd0aCAkY29kZSA+IDEwOwog
  ICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAgICAgICAgICAgICAgICJ1bmxl
  c3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgXCIiLAotICAgICAgICAgICAgICAgICAgICBx
  dW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7Ci0gICAgICAgICAgICB9Ci0gICAg
  ICAgIH0KKyAgICAgICAgICAgICAgICAgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRf
  KCkgeyAkY29kZSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL15cdysk
  LykgeworCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3Vi
  ICRfKCkgeyAmJGRlZmluZXskX30gfSB9XG5cbiI7CisJICAgIH0gZWxzZSB7CisJCXByaW50IFBS
  RUFNQkxFCisJCSAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKKwkJ
  ICAgIHF1b3RlbWV0YSgkZGVmaW5leyRffSksICJcIiB9IH1cblxuIjsKKwkgICAgfQorCX0KICAg
  ICBjbG9zZSBQUkVBTUJMRSAgICAgICAgICAgICAgIG9yIGRpZSAiQ2Fubm90IGNsb3NlICRwcmVh
  bWJsZTogICQhIjsKIH0KIApAQCAtNTg2LDE1ICs3NDYsMTQgQEAgc3ViIF9leHRyYWN0X2NjX2Rl
  ZmluZXMKIHsKICAgICBteSAlZGVmaW5lOwogICAgIG15ICRhbGxzeW1ib2xzICA9IGpvaW4gIiAi
  LAotICAgICAgICBAQ29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJv
  bHMnfTsKKwlAQ29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMn
  fTsKIAogICAgICMgU3BsaXQgY29tcGlsZXIgcHJlLWRlZmluaXRpb25zIGludG8gYGtleT12YWx1
  ZScgcGFpcnM6Ci0gICAgZm9yZWFjaCAoc3BsaXQgL1xzKy8sICRhbGxzeW1ib2xzKSB7Ci0gICAg
  ICAgIC8oLis/KT0oLispLyBhbmQgJGRlZmluZXskMX0gPSAkMjsKLQotICAgICAgICBpZiAoJG9w
  dF9EKSB7Ci0gICAgICAgICAgICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7Ci0gICAg
  ICAgIH0KKyAgICB3aGlsZSAoJGFsbHN5bWJvbHMgPX4gLyhbXlxzXSspPSgoXFxcc3xbXlxzXSkr
  KS9nKSB7CisJJGRlZmluZXskMX0gPSAkMjsKKwlpZiAoJG9wdF9EKSB7CisJICAgIHByaW50IFNU
  REVSUiAiJF86ICAkMSAtPiAkMlxuIjsKKwl9CiAgICAgfQogCiAgICAgcmV0dXJuICVkZWZpbmU7
  CkBAIC02MjMsNiArNzgyLDEwIEBAIEl0IGlzIG1vc3QgZWFzaWx5IHJ1biB3aGlsZSBpbiAvdXNy
  L2luY2x1ZGU6CiAKIAljZCAvdXNyL2luY2x1ZGU7IGgycGggKiBzeXMvKgogCitvcgorCisJY2Qg
  L3Vzci9pbmNsdWRlOyBoMnBoICogc3lzLyogYXJwYS8qIG5ldGluZXQvKgorCiBvcgogCiAJY2Qg
  L3Vzci9pbmNsdWRlOyBoMnBoIC1yIC1sIC4KQEAgLTY0MCw3ICs4MDMsNyBAQCBJZiBydW4gd2l0
  aCBubyBhcmd1bWVudHMsIGZpbHRlcnMgc3RhbmRhcmQgaW5wdXQgdG8gc3RhbmRhcmQgb3V0cHV0
  LgogPWl0ZW0gLWQgZGVzdGluYXRpb25fZGlyCiAKIFB1dCB0aGUgcmVzdWx0aW5nIEI8LnBoPiBm
  aWxlcyBiZW5lYXRoIEI8ZGVzdGluYXRpb25fZGlyPiwgaW5zdGVhZCBvZgotYmVuZWF0aCB0aGUg
  ZGVmYXVsdCBQZXJsIGxpYnJhcnkgbG9jYXRpb24gKEM8JENvbmZpZ3snaW5zdGFsbHNpdHNlYXJj
  aCd9PikuCitiZW5lYXRoIHRoZSBkZWZhdWx0IFBlcmwgbGlicmFyeSBsb2NhdGlvbiAoQzwkQ29u
  ZmlneydpbnN0YWxsc2l0ZWFyY2gnfT4pLgogCiA9aXRlbSAtcgogCkBAIC03MjUsMTAgKzg4OCwx
  MCBAQCBpbnN0YWxsYXRpb24uCiBEb2Vzbid0IGhhbmRsZSBjb21wbGljYXRlZCBleHByZXNzaW9u
  cyBidWlsdCBwaWVjZW1lYWwsIGEgbGE6CiAKICAgICBlbnVtIHsKLSAgICAgICAgRklSU1RfVkFM
  VUUsCi0gICAgICAgIFNFQ09ORF9WQUxVRSwKKwlGSVJTVF9WQUxVRSwKKwlTRUNPTkRfVkFMVUUs
  CiAgICAgI2lmZGVmIEFCQwotICAgICAgICBUSElSRF9WQUxVRQorCVRISVJEX1ZBTFVFCiAgICAg
  I2VuZGlmCiAgICAgfTsKIAo=
  UH2PH562
    }
    if ( $num < 5.007001 ) {
      _patch_b64(<<'UH2PH570');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTM2LDEzICszNiwxNiBAQAog
  CiBwcmludCBPVVQgPDwnIU5PIVNVQlMhJzsKIAordXNlIHN0cmljdDsKKwogdXNlIENvbmZpZzsK
  IHVzZSBGaWxlOjpQYXRoIHF3KG1rcGF0aCk7CiB1c2UgR2V0b3B0OjpTdGQ7CiAKIGdldG9wdHMo
  J0RkOnJsaGFRJyk7Cit1c2UgdmFycyBxdygkb3B0X0QgJG9wdF9kICRvcHRfciAkb3B0X2wgJG9w
  dF9oICRvcHRfYSAkb3B0X1EpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7Ci1AaW5jX2RpcnMgPSBpbmNfZGly
  cygpIGlmICRvcHRfYTsKK215IEBpbmNfZGlycyA9IGluY19kaXJzKCkgaWYgJG9wdF9hOwogCiBt
  eSAkRXhpdCA9IDA7CiAKQEAgLTUwLDcgKzUzLDcgQEAKIGRpZSAiRGVzdGluYXRpb24gZGlyZWN0
  b3J5ICREZXN0X2RpciBkb2Vzbid0IGV4aXN0IG9yIGlzbid0IGEgZGlyZWN0b3J5XG4iCiAgICAg
  dW5sZXNzIC1kICREZXN0X2RpcjsKIAotQGlzYXR5cGUgPSBzcGxpdCgnICcsPDxFTkQpOworbXkg
  QGlzYXR5cGUgPSBzcGxpdCgnICcsPDxFTkQpOwogCWNoYXIJdWNoYXIJdV9jaGFyCiAJc2hvcnQJ
  dXNob3J0CXVfc2hvcnQKIAlpbnQJdWludAl1X2ludApAQCAtNTgsMTQgKzYxLDE4IEBACiAJRklM
  RQlrZXlfdAljYWRkcl90CiBFTkQKIAorbXkgJWlzYXR5cGU7CiBAaXNhdHlwZXtAaXNhdHlwZX0g
  PSAoMSkgeCBAaXNhdHlwZTsKLSRpbmlmID0gMDsKK215ICRpbmlmID0gMDsKK215ICVJc19jb252
  ZXJ0ZWQ7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBBUkdWOwogCiBidWlsZF9wcmVhbWJsZV9p
  Zl9uZWNlc3NhcnkoKTsKIAotd2hpbGUgKGRlZmluZWQgKCRmaWxlID0gbmV4dF9maWxlKCkpKSB7
  CitteSAoJHQsICR0YWIsICVjdXJhcmdzLCAkbmV3LCAkZXZhbF9pbmRleCwgJGRpciwgJG5hbWUs
  ICRhcmdzLCAkb3V0ZmlsZSk7CitteSAoJGluY2wsICRuZXh0KTsKK3doaWxlIChkZWZpbmVkICht
  eSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogICAgIGlmICgtbCAkZmlsZSBhbmQgLWQgJGZpbGUp
  IHsKICAgICAgICAgbGlua19pZl9wb3NzaWJsZSgkZmlsZSkgaWYgKCRvcHRfbCk7CiAgICAgICAg
  IG5leHQ7CkBAIC0xMDEsMjQgKzEwOCw3IEBACiAgICAgfQogCiAgICAgcHJpbnQgT1VUICJyZXF1
  aXJlICdfaDJwaF9wcmUucGgnO1xuXG4iOwotICAgIHdoaWxlICg8SU4+KSB7Ci0JY2hvcDsKLQl3
  aGlsZSAoL1xcJC8pIHsKLQkgICAgY2hvcDsKLQkgICAgJF8gLj0gPElOPjsKLQkgICAgY2hvcDsK
  LQl9Ci0JcHJpbnQgT1VUICIjICRfXG4iIGlmICRvcHRfRDsKLQotCWlmIChzOi9cKjpcMjAwOmcp
  IHsKLQkgICAgczpcKi86XDIwMTpnOwotCSAgICBzL1wyMDBbXlwyMDFdKlwyMDEvL2c7CSMgZGVs
  ZXRlIHNpbmdsZSBsaW5lIGNvbW1lbnRzCi0JICAgIGlmIChzL1wyMDAuKi8vKSB7CQkjIGJlZ2lu
  IG11bHRpLWxpbmUgY29tbWVudD8KLQkJJF8gLj0gJy8qJzsKLQkJJF8gLj0gPElOPjsKLQkJcmVk
  bzsKLQkgICAgfQotCX0KKyAgICB3aGlsZSAoZGVmaW5lZCAobG9jYWwgJF8gPSBuZXh0X2xpbmUo
  KSkpIHsKIAlpZiAocy9eXHMqXCNccyovLykgewogCSAgICBpZiAocy9eZGVmaW5lXHMrKFx3Kykv
  LykgewogCQkkbmFtZSA9ICQxOwpAQCAtMTI5LDcgKzExOSw3IEBACiAgICAgCSAgICAJICAgIG15
  ICRwcm90byA9ICcoKSAnOwogCQkgICAgaWYgKCRhcmdzIG5lICcnKSB7CiAgICAgCSAgICAJICAg
  IAkkcHJvdG8gPSAnJzsKLQkJCWZvcmVhY2ggJGFyZyAoc3BsaXQoLyxccyovLCRhcmdzKSkgewor
  CQkJZm9yZWFjaCBteSAkYXJnIChzcGxpdCgvLFxzKi8sJGFyZ3MpKSB7CiAJCQkgICAgJGFyZyA9
  fiBzL15ccyooW15cc10uKlteXHNdKVxzKiQvJDEvOwogCQkJICAgICRjdXJhcmdzeyRhcmd9ID0g
  MTsKIAkJCX0KQEAgLTI0OCwyMCArMjM4LDI0IEBACiAJICAgIH0gZWxzaWYoL15pZGVudFxzKygu
  KikvKSB7CiAJCXByaW50IE9VVCAkdCwgIiMgJDFcbiI7CiAJICAgIH0KLSAJfSBlbHNpZigvXlxz
  Kih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3KlxzKik/XHsvKSB7Ci0JICAgIHVu
  dGlsKC9cfS4qPzsvKSB7Ci0JCWNob21wKCRuZXh0ID0gPElOPik7CisJfSBlbHNpZigvXlxzKih0
  eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3KlxzKik/LykgeworCSAgICB1bnRpbCgv
  XHtbXn1dKlx9Lio7LyB8fCAvOy8pIHsKKwkJbGFzdCB1bmxlc3MgZGVmaW5lZCAoJG5leHQgPSBu
  ZXh0X2xpbmUoKSk7CisJCWNob21wICRuZXh0OworCQkjIGRyb3AgIiNkZWZpbmUgRk9PIEZPTyIg
  aW4gZW51bXMKKwkJJG5leHQgPX4gcy9eXHMqI1xzKmRlZmluZVxzKyhcdyspXHMrXDFccyokLy87
  CiAJCSRfIC49ICRuZXh0OwogCQlwcmludCBPVVQgIiMgJG5leHRcbiIgaWYgJG9wdF9EOwogCSAg
  ICB9CisJICAgIHMvI1xzKmlmLio/I1xzKmVuZGlmLy9nOyAjIGRyb3AgI2lmZGVmcwogCSAgICBz
  QC9cKi4qP1wqL0BAZzsKIAkgICAgcy9ccysvIC9nOwotCSAgICAvXlxzPyh0eXBlZGVmXHM/KT9l
  bnVtXHM/KFthLXpBLVpfXVx3Kik/XHM/XHsoLiopXH1ccz8oW2EtekEtWl9dXHcqKT9ccz87LzsK
  LQkgICAgKCRlbnVtX3N1YnMgPSAkMykgPX4gcy9ccy8vZzsKLQkgICAgQGVudW1fc3VicyA9IHNw
  bGl0KC8sLywgJGVudW1fc3Vicyk7Ci0JICAgICRlbnVtX3ZhbCA9IC0xOwotCSAgICBmb3IgJGVu
  dW0gKEBlbnVtX3N1YnMpIHsKLQkJKCRlbnVtX25hbWUsICRlbnVtX3ZhbHVlKSA9ICRlbnVtID1+
  IC9eKFthLXpBLVpfXVx3KikoPS4rKT8kLzsKKwkgICAgbmV4dCB1bmxlc3MgL15ccz8odHlwZWRl
  ZlxzPyk/ZW51bVxzPyhbYS16QS1aX11cdyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/
  XHM/Oy87CisJICAgIChteSAkZW51bV9zdWJzID0gJDMpID1+IHMvXHMvL2c7CisJICAgIG15IEBl
  bnVtX3N1YnMgPSBzcGxpdCgvLC8sICRlbnVtX3N1YnMpOworCSAgICBteSAkZW51bV92YWwgPSAt
  MTsKKwkgICAgZm9yZWFjaCBteSAkZW51bSAoQGVudW1fc3VicykgeworCQlteSAoJGVudW1fbmFt
  ZSwgJGVudW1fdmFsdWUpID0gJGVudW0gPX4gL14oW2EtekEtWl9dXHcqKSg9LispPyQvOwogCQkk
  ZW51bV92YWx1ZSA9fiBzL149Ly87CiAJCSRlbnVtX3ZhbCA9IChsZW5ndGgoJGVudW1fdmFsdWUp
  ID8gJGVudW1fdmFsdWUgOiAkZW51bV92YWwgKyAxKTsKIAkJaWYgKCRvcHRfaCkgewpAQCAtMjgw
  LDEyICsyNzQsMTMgQEAKICAgICB9CiAgICAgcHJpbnQgT1VUICIxO1xuIjsKIAotICAgICRpc19j
  b252ZXJ0ZWR7JGZpbGV9ID0gMTsKKyAgICAkSXNfY29udmVydGVkeyRmaWxlfSA9IDE7CiAgICAg
  cXVldWVfaW5jbHVkZXNfZnJvbSgkZmlsZSkgaWYgKCRvcHRfYSk7CiB9CiAKIGV4aXQgJEV4aXQ7
  CiAKKwogc3ViIHJlaW5kZW50KCQpIHsKICAgICBteSgkdGV4dCkgPSBzaGlmdDsKICAgICAkdGV4
  dCA9fiBzL1xuL1xuICAgIC9nOwpAQCAtMjkzLDkgKzI4OCwxMSBAQAogICAgICR0ZXh0OwogfQog
  CisKIHN1YiBleHByIHsKKyAgICBteSAkam9pbmVkX2FyZ3M7CiAgICAgaWYoa2V5cyglY3VyYXJn
  cykpIHsKLQlteSgkam9pbmVkX2FyZ3MpID0gam9pbignfCcsIGtleXMoJWN1cmFyZ3MpKTsKKwkk
  am9pbmVkX2FyZ3MgPSBqb2luKCd8Jywga2V5cyglY3VyYXJncykpOwogICAgIH0KICAgICB3aGls
  ZSAoJF8gbmUgJycpIHsKIAlzL15cJlwmLy8gJiYgZG8geyAkbmV3IC49ICIgJiYiOyBuZXh0O307
  ICMgaGFuZGxlICYmIG9wZXJhdG9yCkBAIC0zNDEsMTMgKzMzOCwxMyBAQAogCSMgRWxpbWluYXRl
  IHR5cGVkZWZzCiAJL1woKFtcd1xzXSspW1wqXHNdKlwpXHMqW1x3XChdLyAmJiBkbyB7CiAJICAg
  IGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkMSkgeyAgIyBNYWtlIHN1cmUgYWxsIHRoZSB3b3JkcyBh
  cmUgdHlwZXMsCi0JCWxhc3QgdW5sZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVjdCcp
  OworCQlsYXN0IHVubGVzcyAoJGlzYXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnIG9yICRfIGVx
  ICd1bmlvbicpOwogCSAgICB9CiAJICAgIHMvXChbXHdcc10rW1wqXHNdKlwpLy8gJiYgbmV4dDsg
  ICAgICAjIHRoZW4gZWxpbWluYXRlIHRoZW0uCiAJfTsKIAkjIHN0cnVjdC91bmlvbiBtZW1iZXIs
  IGluY2x1ZGluZyBhcnJheXM6CiAJcy9eKFtfQS1aXVx3KihcW1teXF1dK1xdKT8oKFwufC0+KVtf
  QS1aXVx3KihcW1teXF1dK1xdKT8pKykvL2kgJiYgZG8gewotCSAgICAkaWQgPSAkMTsKKwkgICAg
  bXkgJGlkID0gJDE7CiAJICAgICRpZCA9fiBzLyhcLnwoLT4pKShbXlwuXC1dKikvLT5ceyQzXH0v
  ZzsKIAkgICAgJGlkID1+IHMvXGIoW15cJF0pKCRqb2luZWRfYXJncykvJDFcJCQyL2cgaWYgbGVu
  Z3RoKCRqb2luZWRfYXJncyk7CiAJICAgIHdoaWxlKCRpZCA9fiAvXFtccyooW15cJFwmXGRcXV0r
  KVxdLykgewpAQCAtMzYzLDggKzM2MCw4IEBACiAJICAgICRuZXcgLj0gIiAoXCQkaWQpIjsKIAl9
  OwogCXMvXihbX2EtekEtWl1cdyopLy8JJiYgZG8gewotCSAgICAkaWQgPSAkMTsKLQkgICAgaWYg
  KCRpZCBlcSAnc3RydWN0JykgeworCSAgICBteSAkaWQgPSAkMTsKKwkgICAgaWYgKCRpZCBlcSAn
  c3RydWN0JyB8fCAkaWQgZXEgJ3VuaW9uJykgewogCQlzL15ccysoXHcrKS8vOwogCQkkaWQgLj0g
  JyAnIC4gJDE7CiAJCSRpc2F0eXBleyRpZH0gPSAxOwpAQCAtMzc3LDggKzM3NCw4IEBACiAJCSRu
  ZXcgLj0gJy0+JyBpZiAvXltcW1x7XS87CiAJICAgIH0gZWxzaWYgKCRpZCBlcSAnZGVmaW5lZCcp
  IHsKIAkJJG5ldyAuPSAnZGVmaW5lZCc7Ci0JICAgIH0gZWxzaWYgKC9eXCgvKSB7Ci0JCXMvXlwo
  KFx3KSwvKCIkMSIsLyBpZiAkaWQgPX4gL15fSU9bV1JdKiQvaTsJIyBjaGVhdAorCSAgICB9IGVs
  c2lmICgvXlxzKlwoLykgeworCQlzL15ccypcKChcdyksLygiJDEiLC8gaWYgJGlkID1+IC9eX0lP
  W1dSXSokL2k7CSMgY2hlYXQKIAkJJG5ldyAuPSAiICYkaWQiOwogCSAgICB9IGVsc2lmICgkaXNh
  dHlwZXskaWR9KSB7CiAJCWlmICgkbmV3ID1+IC97XHMqJC8pIHsKQEAgLTQwNSw2ICs0MDIsNjYg
  QEAKIH0KIAogCitzdWIgbmV4dF9saW5lCit7CisgICAgbXkgKCRpbiwgJG91dCk7CisgICAgbXkg
  JHByZV9zdWJfdHJpX2dyYXBocyA9IDE7CisKKyAgICBSRUFEOiB3aGlsZSAobm90IGVvZiBJTikg
  eworICAgICAgICAkaW4gIC49IDxJTj47CisgICAgICAgIGNob21wICRpbjsKKyAgICAgICAgbmV4
  dCB1bmxlc3MgbGVuZ3RoICRpbjsKKworICAgICAgICB3aGlsZSAobGVuZ3RoICRpbikgeworICAg
  ICAgICAgICAgaWYgKCRwcmVfc3ViX3RyaV9ncmFwaHMpIHsKKyAgICAgICAgICAgICAgICAjIFBy
  ZXByb2Nlc3MgYWxsIHRyaS1ncmFwaHMgCisgICAgICAgICAgICAgICAgIyBpbmNsdWRpbmcgdGhp
  bmdzIHN0dWNrIGluIHF1b3RlZCBzdHJpbmcgY29uc3RhbnRzLgorICAgICAgICAgICAgICAgICRp
  biA9fiBzL1w/XD89LyMvZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PXwgICN8Cisg
  ICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1whL3wvZzsgICAgICAgICAgICAgICAgICAgICAg
  ICAjIHwgPz8hfCAgfHwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/Jy9eL2c7ICAgICAg
  ICAgICAgICAgICAgICAgICAgICMgfCA/Pyd8ICBefAorICAgICAgICAgICAgICAgICRpbiA9fiBz
  L1w/XD9cKC9bL2c7ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/KHwgIFt8CisgICAgICAg
  ICAgICAgICAgJGluID1+IHMvXD9cP1wpL10vZzsgICAgICAgICAgICAgICAgICAgICAgICAjIHwg
  Pz8pfCAgXXwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/XC0vfi9nOyAgICAgICAgICAg
  ICAgICAgICAgICAgICMgfCA/Py18ICB+fAorICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD9c
  Ly9cXC9nOyAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/L3wgIFx8CisgICAgICAgICAgICAg
  ICAgJGluID1+IHMvXD9cPzwvey9nOyAgICAgICAgICAgICAgICAgICAgICAgICAjIHwgPz88fCAg
  e3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/Pi99L2c7ICAgICAgICAgICAgICAgICAg
  ICAgICAgICMgfCA/Pz58ICB9fAorICAgICAgICAgICAgfQorICAgICAgICAgICAgaWYgKCRpbiA9
  fiBzL1xcJC8vKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBcLW5ld2xpbmUKKyAgICAg
  ICAgICAgICAgICAkb3V0ICAgIC49ICcgJzsKKyAgICAgICAgICAgICAgICBuZXh0IFJFQUQ7Cisg
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteIidcXFwvXSspLy8pIHsgICAgICAgICAg
  ICAjIFBhc3N0aHJvdWdoCisgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsKKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oXFwuKS8vKSB7ICAgICAgICAgICAgICAgICAgICMgXC4u
  LgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  aW4gPX4gcy9eKCcoXFwufFteJ1xcXSkqJykvLykgeyAgICAgICAjICcuLi4KKyAgICAgICAgICAg
  ICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXigiKFxc
  LnxbXiJcXF0pKiIpLy8pIHsgICAgICAgIyAiLi4uCisgICAgICAgICAgICAgICAgJG91dCAgICAu
  PSAkMTsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL15cL1wvLiovLykgeyAgICAgICAg
  ICAgICAgICAgICMgLy8uLi4KKyAgICAgICAgICAgICAgICAjIGZhbGwgdGhyb3VnaAorICAgICAg
  ICAgICAgfSBlbHNpZiAoJGluID1+IG0vXlwvXCovKSB7ICAgICAgICAgICAgICAgICAgICAgIyAv
  Ki4uLgorICAgICAgICAgICAgICAgICMgQyBjb21tZW50IHJlbW92YWwgYWRhcHRlZCBmcm9tIHBl
  cmxmYXE2OgorICAgICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eXC9cKlteKl0qXCorKFteXC8q
  XVteKl0qXCorKSpcLy8vKSB7CisgICAgICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOwor
  ICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgIyBJbmNvbXBsZXRlIC8qICovCisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAg
  ICAgICAgICAgICAgICB9CisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFwvKS8vKSB7
  ICAgICAgICAgICAgICAgICAgICAjIC8uLi4KKyAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQx
  OworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihbXlwnXCJcXFwvXSspLy8pIHsKKyAg
  ICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNlIHsKKyAgICAg
  ICAgICAgICAgICBkaWUgIkNhbm5vdCBwYXJzZTpcbiRpblxuIjsKKyAgICAgICAgICAgIH0KKyAg
  ICAgICAgfQorCisgICAgICAgIGxhc3QgUkVBRCBpZiAkb3V0ID1+IC9cUy87CisgICAgfQorCisg
  ICAgcmV0dXJuICRvdXQ7Cit9CisKKwogIyBIYW5kbGUgcmVjdXJzaXZlIHN1YmRpcmVjdG9yaWVz
  IHdpdGhvdXQgZ2V0dGluZyBhIGdyb3Rlc3F1ZWx5IGJpZyBzdGFjay4KICMgQ291bGQgdGhpcyBi
  ZSBpbXBsZW1lbnRlZCB1c2luZyBGaWxlOjpGaW5kPwogc3ViIG5leHRfZmlsZQpAQCAtNTA1LDcg
  KzU2Miw3IEBACiAgICAgICAgICAgICB9CiAKICAgICAgICAgICAgIGlmICgkbGluZSA9fiAvXiNc
  cyppbmNsdWRlXHMrPCguKj8pPi8pIHsKLSAgICAgICAgICAgICAgICBwdXNoKEBBUkdWLCAkMSkg
  dW5sZXNzICRpc19jb252ZXJ0ZWR7JDF9OworICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQx
  KSB1bmxlc3MgJElzX2NvbnZlcnRlZHskMX07CiAgICAgICAgICAgICB9CiAgICAgICAgIH0KICAg
  ICBjbG9zZSBIRUFERVI7CkBAIC01NTMsOSArNjEwLDkgQEAKICAgICAgICAgICAgICAgICBwcmlu
  dCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKICAgICAgICAgICAgIH0KIAotICAgICAg
  ICAgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eXGQrJC8pIHsKKyAgICAgICAgICAgIGlmICgkZGVm
  aW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKICAgICAgICAgICAgICAgICBwcmludCBQ
  UkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIg
  JF8oKSB7ICRkZWZpbmV7JF99IH0gfVxuXG4iOworICAgICAgICAgICAgICAgICAgICAidW5sZXNz
  IChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwogICAgICAgICAgICAgfSBl
  bHNpZiAoJGRlZmluZXskX30gPX4gL15cdyskLykgewogICAgICAgICAgICAgICAgIHByaW50IFBS
  RUFNQkxFCiAgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAk
  XygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOwpAQCAtNTc1LDcgKzYzMiw4IEBACiBzdWIgX2V4
  dHJhY3RfY2NfZGVmaW5lcwogewogICAgIG15ICVkZWZpbmU7Ci0gICAgbXkgJGFsbHN5bWJvbHMg
  PSBqb2luICIgIiwgQENvbmZpZ3tjY3N5bWJvbHMsIGNwcHN5bWJvbHMsIGNwcGNjc3ltYm9sc307
  CisgICAgbXkgJGFsbHN5bWJvbHMgID0gam9pbiAiICIsCisgICAgICAgIEBDb25maWd7J2Njc3lt
  Ym9scycsICdjcHBzeW1ib2xzJywgJ2NwcGNjc3ltYm9scyd9OwogCiAgICAgIyBTcGxpdCBjb21w
  aWxlciBwcmUtZGVmaW5pdGlvbnMgaW50byBga2V5PXZhbHVlJyBwYWlyczoKICAgICBmb3JlYWNo
  IChzcGxpdCAvXHMrLywgJGFsbHN5bWJvbHMpIHsKQEAgLTcwOCw4ICs3NjYsNiBAQAogSXQncyBv
  bmx5IGludGVuZGVkIGFzIGEgcm91Z2ggdG9vbC4KIFlvdSBtYXkgbmVlZCB0byBkaWNrZXIgd2l0
  aCB0aGUgZmlsZXMgcHJvZHVjZWQuCiAKLURvZXNuJ3QgcnVuIHdpdGggQzx1c2Ugc3RyaWN0Pgot
  CiBZb3UgaGF2ZSB0byBydW4gdGhpcyBwcm9ncmFtIGJ5IGhhbmQ7IGl0J3Mgbm90IHJ1biBhcyBw
  YXJ0IG9mIHRoZSBQZXJsCiBpbnN0YWxsYXRpb24uCiAK
  UH2PH570
    }
    elsif ( $num < 5.007002 ) {
      _patch_b64(<<'UH2PH571');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTEwOCwyNCArMTA4LDcgQEAK
  ICAgICB9CiAKICAgICBwcmludCBPVVQgInJlcXVpcmUgJ19oMnBoX3ByZS5waCc7XG5cbiI7Ci0g
  ICAgd2hpbGUgKDxJTj4pIHsKLQljaG9wOwotCXdoaWxlICgvXFwkLykgewotCSAgICBjaG9wOwot
  CSAgICAkXyAuPSA8SU4+OwotCSAgICBjaG9wOwotCX0KLQlwcmludCBPVVQgIiMgJF9cbiIgaWYg
  JG9wdF9EOwotCi0JaWYgKHM6L1wqOlwyMDA6ZykgewotCSAgICBzOlwqLzpcMjAxOmc7Ci0JICAg
  IHMvXDIwMFteXDIwMV0qXDIwMS8vZzsJIyBkZWxldGUgc2luZ2xlIGxpbmUgY29tbWVudHMKLQkg
  ICAgaWYgKHMvXDIwMC4qLy8pIHsJCSMgYmVnaW4gbXVsdGktbGluZSBjb21tZW50PwotCQkkXyAu
  PSAnLyonOwotCQkkXyAuPSA8SU4+OwotCQlyZWRvOwotCSAgICB9Ci0JfQorICAgIHdoaWxlIChk
  ZWZpbmVkIChsb2NhbCAkXyA9IG5leHRfbGluZSgpKSkgewogCWlmIChzL15ccypcI1xzKi8vKSB7
  CiAJICAgIGlmIChzL15kZWZpbmVccysoXHcrKS8vKSB7CiAJCSRuYW1lID0gJDE7CkBAIC0yNTUs
  MTUgKzIzOCwxOSBAQAogCSAgICB9IGVsc2lmKC9eaWRlbnRccysoLiopLykgewogCQlwcmludCBP
  VVQgJHQsICIjICQxXG4iOwogCSAgICB9Ci0gCX0gZWxzaWYoL15ccyoodHlwZWRlZlxzKik/ZW51
  bVxzKihccytbYS16QS1aX11cdypccyopP1x7LykgewotCSAgICB1bnRpbCgvXH0uKj87Lykgewot
  CQljaG9tcCgkbmV4dCA9IDxJTj4pOworCX0gZWxzaWYoL15ccyoodHlwZWRlZlxzKik/ZW51bVxz
  KihccytbYS16QS1aX11cdypccyopPy8pIHsKKwkgICAgdW50aWwoL1x7W159XSpcfS4qOy8gfHwg
  LzsvKSB7CisJCWxhc3QgdW5sZXNzIGRlZmluZWQgKCRuZXh0ID0gbmV4dF9saW5lKCkpOworCQlj
  aG9tcCAkbmV4dDsKKwkJIyBkcm9wICIjZGVmaW5lIEZPTyBGT08iIGluIGVudW1zCisJCSRuZXh0
  ID1+IHMvXlxzKiNccypkZWZpbmVccysoXHcrKVxzK1wxXHMqJC8vOwogCQkkXyAuPSAkbmV4dDsK
  IAkJcHJpbnQgT1VUICIjICRuZXh0XG4iIGlmICRvcHRfRDsKIAkgICAgfQorCSAgICBzLyNccypp
  Zi4qPyNccyplbmRpZi8vZzsgIyBkcm9wICNpZmRlZnMKIAkgICAgc0AvXCouKj9cKi9AQGc7CiAJ
  ICAgIHMvXHMrLyAvZzsKLQkgICAgL15ccz8odHlwZWRlZlxzPyk/ZW51bVxzPyhbYS16QS1aX11c
  dyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/XHM/Oy87CisJICAgIG5leHQgdW5sZXNz
  IC9eXHM/KHR5cGVkZWZccz8pP2VudW1ccz8oW2EtekEtWl9dXHcqKT9ccz9ceyguKilcfVxzPyhb
  YS16QS1aX11cdyopP1xzPzsvOwogCSAgICAobXkgJGVudW1fc3VicyA9ICQzKSA9fiBzL1xzLy9n
  OwogCSAgICBteSBAZW51bV9zdWJzID0gc3BsaXQoLywvLCAkZW51bV9zdWJzKTsKIAkgICAgbXkg
  JGVudW1fdmFsID0gLTE7CkBAIC0zNTEsNyArMzM4LDcgQEAKIAkjIEVsaW1pbmF0ZSB0eXBlZGVm
  cwogCS9cKChbXHdcc10rKVtcKlxzXSpcKVxzKltcd1woXS8gJiYgZG8gewogCSAgICBmb3JlYWNo
  IChzcGxpdCAvXHMrLywgJDEpIHsgICMgTWFrZSBzdXJlIGFsbCB0aGUgd29yZHMgYXJlIHR5cGVz
  LAotCQlsYXN0IHVubGVzcyAoJGlzYXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnKTsKKwkJbGFz
  dCB1bmxlc3MgKCRpc2F0eXBleyRffSBvciAkXyBlcSAnc3RydWN0JyBvciAkXyBlcSAndW5pb24n
  KTsKIAkgICAgfQogCSAgICBzL1woW1x3XHNdK1tcKlxzXSpcKS8vICYmIG5leHQ7ICAgICAgIyB0
  aGVuIGVsaW1pbmF0ZSB0aGVtLgogCX07CkBAIC0zNzQsNyArMzYxLDcgQEAKIAl9OwogCXMvXihb
  X2EtekEtWl1cdyopLy8JJiYgZG8gewogCSAgICBteSAkaWQgPSAkMTsKLQkgICAgaWYgKCRpZCBl
  cSAnc3RydWN0JykgeworCSAgICBpZiAoJGlkIGVxICdzdHJ1Y3QnIHx8ICRpZCBlcSAndW5pb24n
  KSB7CiAJCXMvXlxzKyhcdyspLy87CiAJCSRpZCAuPSAnICcgLiAkMTsKIAkJJGlzYXR5cGV7JGlk
  fSA9IDE7CkBAIC0zODcsOCArMzc0LDggQEAKIAkJJG5ldyAuPSAnLT4nIGlmIC9eW1xbXHtdLzsK
  IAkgICAgfSBlbHNpZiAoJGlkIGVxICdkZWZpbmVkJykgewogCQkkbmV3IC49ICdkZWZpbmVkJzsK
  LQkgICAgfSBlbHNpZiAoL15cKC8pIHsKLQkJcy9eXCgoXHcpLC8oIiQxIiwvIGlmICRpZCA9fiAv
  Xl9JT1tXUl0qJC9pOwkjIGNoZWF0CisJICAgIH0gZWxzaWYgKC9eXHMqXCgvKSB7CisJCXMvXlxz
  KlwoKFx3KSwvKCIkMSIsLyBpZiAkaWQgPX4gL15fSU9bV1JdKiQvaTsJIyBjaGVhdAogCQkkbmV3
  IC49ICIgJiRpZCI7CiAJICAgIH0gZWxzaWYgKCRpc2F0eXBleyRpZH0pIHsKIAkJaWYgKCRuZXcg
  PX4gL3tccyokLykgewpAQCAtNDE1LDYgKzQwMiw2NiBAQAogfQogCiAKK3N1YiBuZXh0X2xpbmUK
  K3sKKyAgICBteSAoJGluLCAkb3V0KTsKKyAgICBteSAkcHJlX3N1Yl90cmlfZ3JhcGhzID0gMTsK
  KworICAgIFJFQUQ6IHdoaWxlIChub3QgZW9mIElOKSB7CisgICAgICAgICRpbiAgLj0gPElOPjsK
  KyAgICAgICAgY2hvbXAgJGluOworICAgICAgICBuZXh0IHVubGVzcyBsZW5ndGggJGluOworCisg
  ICAgICAgIHdoaWxlIChsZW5ndGggJGluKSB7CisgICAgICAgICAgICBpZiAoJHByZV9zdWJfdHJp
  X2dyYXBocykgeworICAgICAgICAgICAgICAgICMgUHJlcHJvY2VzcyBhbGwgdHJpLWdyYXBocyAK
  KyAgICAgICAgICAgICAgICAjIGluY2x1ZGluZyB0aGluZ3Mgc3R1Y2sgaW4gcXVvdGVkIHN0cmlu
  ZyBjb25zdGFudHMuCisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cPz0vIy9nOyAgICAgICAg
  ICAgICAgICAgICAgICAgICAjIHwgPz89fCAgI3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9c
  P1w/XCEvfC9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/PyF8ICB8fAorICAgICAgICAg
  ICAgICAgICRpbiA9fiBzL1w/XD8nL14vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/
  J3wgIF58CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1woL1svZzsgICAgICAgICAgICAg
  ICAgICAgICAgICAjIHwgPz8ofCAgW3wKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/XCkv
  XS9nOyAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pyl8ICBdfAorICAgICAgICAgICAgICAg
  ICRpbiA9fiBzL1w/XD9cLS9+L2c7ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/LXwgIH58
  CisgICAgICAgICAgICAgICAgJGluID1+IHMvXD9cP1wvL1xcL2c7ICAgICAgICAgICAgICAgICAg
  ICAgICAjIHwgPz8vfCAgXHwKKyAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/PC97L2c7ICAg
  ICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pzx8ICB7fAorICAgICAgICAgICAgICAgICRpbiA9
  fiBzL1w/XD8+L30vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PnwgIH18CisgICAg
  ICAgICAgICB9CisgICAgICAgICAgICBpZiAoJGluID1+IHMvXFwkLy8pIHsgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAjIFwtbmV3bGluZQorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAn
  OworICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9
  fiBzL14oW14iJ1xcXC9dKykvLykgeyAgICAgICAgICAgICMgUGFzc3Rocm91Z2gKKyAgICAgICAg
  ICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihc
  XC4pLy8pIHsgICAgICAgICAgICAgICAgICAgIyBcLi4uCisgICAgICAgICAgICAgICAgJG91dCAg
  ICAuPSAkMTsKKyAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSon
  KS8vKSB7ICAgICAgICMgJy4uLgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAg
  ICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeyAgICAgICAj
  ICIuLi4KKyAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNp
  ZiAoJGluID1+IHMvXlwvXC8uKi8vKSB7ICAgICAgICAgICAgICAgICAgIyAvLy4uLgorICAgICAg
  ICAgICAgICAgICMgZmFsbCB0aHJvdWdoCisgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gbS9e
  XC9cKi8pIHsgICAgICAgICAgICAgICAgICAgICAjIC8qLi4uCisgICAgICAgICAgICAgICAgIyBD
  IGNvbW1lbnQgcmVtb3ZhbCBhZGFwdGVkIGZyb20gcGVybGZhcTY6CisgICAgICAgICAgICAgICAg
  aWYgKCRpbiA9fiBzL15cL1wqW14qXSpcKisoW15cLypdW14qXSpcKispKlwvLy8pIHsKKyAgICAg
  ICAgICAgICAgICAgICAgJG91dCAgICAuPSAnICc7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEluY29tcGxldGUgLyogKi8KKyAg
  ICAgICAgICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oXC8pLy8pIHsgICAgICAgICAgICAgICAgICAgICMgLy4u
  LgorICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  aW4gPX4gcy9eKFteXCdcIlxcXC9dKykvLykgeworICAgICAgICAgICAgICAgICRvdXQgICAgLj0g
  JDE7CisgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgIGRpZSAiQ2Fubm90IHBh
  cnNlOlxuJGluXG4iOworICAgICAgICAgICAgfQorICAgICAgICB9CisKKyAgICAgICAgbGFzdCBS
  RUFEIGlmICRvdXQgPX4gL1xTLzsKKyAgICB9CisKKyAgICByZXR1cm4gJG91dDsKK30KKworCiAj
  IEhhbmRsZSByZWN1cnNpdmUgc3ViZGlyZWN0b3JpZXMgd2l0aG91dCBnZXR0aW5nIGEgZ3JvdGVz
  cXVlbHkgYmlnIHN0YWNrLgogIyBDb3VsZCB0aGlzIGJlIGltcGxlbWVudGVkIHVzaW5nIEZpbGU6
  OkZpbmQ/CiBzdWIgbmV4dF9maWxlCkBAIC01NjMsOSArNjEwLDkgQEAKICAgICAgICAgICAgICAg
  ICBwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKICAgICAgICAgICAgIH0KIAot
  ICAgICAgICAgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eXGQrJC8pIHsKKyAgICAgICAgICAgIGlm
  ICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKICAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICRkZWZpbmV7JF99IH0gfVxuXG4iOworICAgICAgICAgICAgICAgICAgICAi
  dW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwogICAgICAgICAg
  ICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL15cdyskLykgewogICAgICAgICAgICAgICAgIHBy
  aW50IFBSRUFNQkxFCiAgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7
  IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOwo=
  UH2PH571
    }
    elsif ( $num < 5.007003 ) {
      _patch_b64(<<'UH2PH572');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTIzOCwxNSArMjM4LDE5IEBA
  CiAJICAgIH0gZWxzaWYoL15pZGVudFxzKyguKikvKSB7CiAJCXByaW50IE9VVCAkdCwgIiMgJDFc
  biI7CiAJICAgIH0KLSAJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpB
  LVpfXVx3KlxzKik/XHsvKSB7Ci0JICAgIHVudGlsKC9cfS4qPzsvKSB7Ci0JCWNob21wKCRuZXh0
  ID0gPElOPik7CisJfSBlbHNpZigvXlxzKih0eXBlZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpf
  XVx3KlxzKik/LykgeworCSAgICB1bnRpbCgvXHtbXn1dKlx9Lio7LyB8fCAvOy8pIHsKKwkJbGFz
  dCB1bmxlc3MgZGVmaW5lZCAoJG5leHQgPSBuZXh0X2xpbmUoKSk7CisJCWNob21wICRuZXh0Owor
  CQkjIGRyb3AgIiNkZWZpbmUgRk9PIEZPTyIgaW4gZW51bXMKKwkJJG5leHQgPX4gcy9eXHMqI1xz
  KmRlZmluZVxzKyhcdyspXHMrXDFccyokLy87CiAJCSRfIC49ICRuZXh0OwogCQlwcmludCBPVVQg
  IiMgJG5leHRcbiIgaWYgJG9wdF9EOwogCSAgICB9CisJICAgIHMvI1xzKmlmLio/I1xzKmVuZGlm
  Ly9nOyAjIGRyb3AgI2lmZGVmcwogCSAgICBzQC9cKi4qP1wqL0BAZzsKIAkgICAgcy9ccysvIC9n
  OwotCSAgICAvXlxzPyh0eXBlZGVmXHM/KT9lbnVtXHM/KFthLXpBLVpfXVx3Kik/XHM/XHsoLiop
  XH1ccz8oW2EtekEtWl9dXHcqKT9ccz87LzsKKwkgICAgbmV4dCB1bmxlc3MgL15ccz8odHlwZWRl
  ZlxzPyk/ZW51bVxzPyhbYS16QS1aX11cdyopP1xzP1x7KC4qKVx9XHM/KFthLXpBLVpfXVx3Kik/
  XHM/Oy87CiAJICAgIChteSAkZW51bV9zdWJzID0gJDMpID1+IHMvXHMvL2c7CiAJICAgIG15IEBl
  bnVtX3N1YnMgPSBzcGxpdCgvLC8sICRlbnVtX3N1YnMpOwogCSAgICBteSAkZW51bV92YWwgPSAt
  MTsKQEAgLTMzNCw3ICszMzgsNyBAQAogCSMgRWxpbWluYXRlIHR5cGVkZWZzCiAJL1woKFtcd1xz
  XSspW1wqXHNdKlwpXHMqW1x3XChdLyAmJiBkbyB7CiAJICAgIGZvcmVhY2ggKHNwbGl0IC9ccysv
  LCAkMSkgeyAgIyBNYWtlIHN1cmUgYWxsIHRoZSB3b3JkcyBhcmUgdHlwZXMsCi0JCWxhc3QgdW5s
  ZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVjdCcpOworCQlsYXN0IHVubGVzcyAoJGlz
  YXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnIG9yICRfIGVxICd1bmlvbicpOwogCSAgICB9CiAJ
  ICAgIHMvXChbXHdcc10rW1wqXHNdKlwpLy8gJiYgbmV4dDsgICAgICAjIHRoZW4gZWxpbWluYXRl
  IHRoZW0uCiAJfTsKQEAgLTM1Nyw3ICszNjEsNyBAQAogCX07CiAJcy9eKFtfYS16QS1aXVx3Kikv
  LwkmJiBkbyB7CiAJICAgIG15ICRpZCA9ICQxOwotCSAgICBpZiAoJGlkIGVxICdzdHJ1Y3QnKSB7
  CisJICAgIGlmICgkaWQgZXEgJ3N0cnVjdCcgfHwgJGlkIGVxICd1bmlvbicpIHsKIAkJcy9eXHMr
  KFx3KykvLzsKIAkJJGlkIC49ICcgJyAuICQxOwogCQkkaXNhdHlwZXskaWR9ID0gMTsKQEAgLTQz
  NCw3ICs0MzgsNyBAQAogICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXigiKFxcLnxbXiJc
  XF0pKiIpLy8pIHsgICAgICAgIyAiLi4uCiAgICAgICAgICAgICAgICAgJG91dCAgICAuPSAkMTsK
  ICAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL15cL1wvLiovLykgeyAgICAgICAgICAgICAg
  ICAgICMgLy8uLi4KLSAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAgICAgICAg
  IyBmYWxsIHRocm91Z2gKICAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBtL15cL1wqLykgeyAg
  ICAgICAgICAgICAgICAgICAgICMgLyouLi4KICAgICAgICAgICAgICAgICAjIEMgY29tbWVudCBy
  ZW1vdmFsIGFkYXB0ZWQgZnJvbSBwZXJsZmFxNjoKICAgICAgICAgICAgICAgICBpZiAoJGluID1+
  IHMvXlwvXCpbXipdKlwqKyhbXlwvKl1bXipdKlwqKykqXC8vLykgewpAQCAtNDUxLDcgKzQ1NSw3
  IEBACiAgICAgICAgICAgICB9CiAgICAgICAgIH0KIAotICAgICAgICBsYXN0IFJFQUQ7CisgICAg
  ICAgIGxhc3QgUkVBRCBpZiAkb3V0ID1+IC9cUy87CiAgICAgfQogCiAgICAgcmV0dXJuICRvdXQ7
  CkBAIC02MDYsOSArNjEwLDkgQEAKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRSAiIyAk
  Xz0kZGVmaW5leyRffVxuIjsKICAgICAgICAgICAgIH0KIAotICAgICAgICAgICAgaWYgKCRkZWZp
  bmV7JF99ID1+IC9eXGQrJC8pIHsKKyAgICAgICAgICAgIGlmICgkZGVmaW5leyRffSA9fiAvXihc
  ZCspVT9MezAsMn0kL2kpIHsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAg
  ICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7ICRkZWZpbmV7
  JF99IH0gfVxuXG4iOworICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwogICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXsk
  X30gPX4gL15cdyskLykgewogICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCiAgICAgICAg
  ICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7
  JF99IH0gfVxuXG4iOwo=
  UH2PH572
    }
    if ( $num < 5.008000 ) {
      return _patch_b64(<<'UH2PH573');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTQyLDggKzQyLDEzIEBAIHVz
  ZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9wdDo6U3RkOwog
  Ci1nZXRvcHRzKCdEZDpybGhhUScpOwotdXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3Ig
  JG9wdF9sICRvcHRfaCAkb3B0X2EgJG9wdF9RKTsKKyMgTWFrZSBzdXJlIHJlYWQgcGVybWlzc2lv
  bnMgZm9yIGFsbCBhcmUgc2V0OgoraWYgKGRlZmluZWQgdW1hc2sgJiYgKHVtYXNrKCkgJiAwNDQ0
  KSkgeworICAgIHVtYXNrICh1bWFzaygpICYgfjA0NDQpOworfQorCitnZXRvcHRzKCdEZDpybGhh
  UWUnKTsKK3VzZSB2YXJzIHF3KCRvcHRfRCAkb3B0X2QgJG9wdF9yICRvcHRfbCAkb3B0X2ggJG9w
  dF9hICRvcHRfUSAkb3B0X2UpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7CiBteSBAaW5jX2RpcnMgPSBpbmNf
  ZGlycygpIGlmICRvcHRfYTsKIApAQCAtNjUsMTMgKzcwLDIxIEBAIG15ICVpc2F0eXBlOwogQGlz
  YXR5cGV7QGlzYXR5cGV9ID0gKDEpIHggQGlzYXR5cGU7CiBteSAkaW5pZiA9IDA7CiBteSAlSXNf
  Y29udmVydGVkOworbXkgJWJhZF9maWxlID0gKCk7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBB
  UkdWOwogCiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkoKTsKIAorc3ViIHJlaW5kZW50KCQp
  IHsKKyAgICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwor
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKwogbXkgKCR0LCAk
  dGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91
  dGZpbGUpOwotbXkgKCRpbmNsLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNs
  X3F1b3RlLCAkbmV4dCk7CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkp
  IHsKICAgICBpZiAoLWwgJGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9z
  c2libGUoJGZpbGUpIGlmICgkb3B0X2wpOwpAQCAtMTA3LDEzICsxMjAsMTcgQEAgd2hpbGUgKGRl
  ZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJb3BlbihPVVQsIj4kRGVzdF9kaXIv
  JG91dGZpbGUiKSB8fCBkaWUgIkNhbid0IGNyZWF0ZSAkb3V0ZmlsZTogJCFcbiI7CiAgICAgfQog
  Ci0gICAgcHJpbnQgT1VUICJyZXF1aXJlICdfaDJwaF9wcmUucGgnO1xuXG4iOwotICAgIHdoaWxl
  IChkZWZpbmVkIChsb2NhbCAkXyA9IG5leHRfbGluZSgpKSkgeworICAgIHByaW50IE9VVAorICAg
  ICAgICAicmVxdWlyZSAnX2gycGhfcHJlLnBoJztcblxuIiwKKyAgICAgICAgIm5vIHdhcm5pbmdz
  ICdyZWRlZmluZSc7XG5cbiI7CisKKyAgICB3aGlsZSAoZGVmaW5lZCAobG9jYWwgJF8gPSBuZXh0
  X2xpbmUoJGZpbGUpKSkgewogCWlmIChzL15ccypcI1xzKi8vKSB7CiAJICAgIGlmIChzL15kZWZp
  bmVccysoXHcrKS8vKSB7CiAJCSRuYW1lID0gJDE7CiAJCSRuZXcgPSAnJzsKIAkJcy9ccyskLy87
  CisJCXMvXChcdytccypcKFwqXClccypcKFx3KlwpXClccyooLT9cZCspLyQxLzsgIyAoaW50ICgq
  KShmb29fdCkpMAogCQlpZiAocy9eXCgoW1x3LFxzXSopXCkvLykgewogCQkgICAgJGFyZ3MgPSAk
  MTsKICAgICAJICAgIAkgICAgbXkgJHByb3RvID0gJygpICc7CkBAIC0xNjcsMjIgKzE4NCwzMiBA
  QCB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkpIHsKICAgICAgICAgICAg
  ICAgICAgICAgICBwcmludCBPVVQgJHQsInVubGVzcyhkZWZpbmVkKFwmJG5hbWUpKSB7XG4gICAg
  c3ViICRuYW1lICgpIHtcdCIsJG5ldywiO31cbn1cbiI7CiAJCSAgICB9CiAJCX0KLQkgICAgfSBl
  bHNpZiAoL14oaW5jbHVkZXxpbXBvcnQpXHMqWzwiXSguKilbPiJdLykgewotCQkoJGluY2wgPSAk
  MikgPX4gcy9cLmgkLy5waC87Ci0JCXByaW50IE9VVCAkdCwicmVxdWlyZSAnJGluY2wnO1xuIjsK
  LQkgICAgfSBlbHNpZigvXmluY2x1ZGVfbmV4dFxzKls8Il0oLiopWz4iXS8pIHsKLQkJKCRpbmNs
  ID0gJDEpID1+IHMvXC5oJC8ucGgvOworCSAgICB9IGVsc2lmICgvXihpbmNsdWRlfGltcG9ydHxp
  bmNsdWRlX25leHQpXHMqKFs8XCJdKSguKilbPlwiXS8pIHsKKyAgICAgICAgICAgICAgICAkaW5j
  bF90eXBlID0gJDE7CisgICAgICAgICAgICAgICAgJGluY2xfcXVvdGUgPSAkMjsKKyAgICAgICAg
  ICAgICAgICAkaW5jbCA9ICQzOworICAgICAgICAgICAgICAgIGlmICgoJGluY2xfdHlwZSBlcSAn
  aW5jbHVkZV9uZXh0JykgfHwKKyAgICAgICAgICAgICAgICAgICAgKCRvcHRfZSAmJiBleGlzdHMo
  JGJhZF9maWxleyRpbmNsfSkpKSB7CisgICAgICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5o
  JC8ucGgvOwogCQlwcmludCBPVVQgKCR0LAogCQkJICAgImV2YWwge1xuIik7CiAgICAgICAgICAg
  ICAgICAgJHRhYiArPSA0OwogICAgICAgICAgICAgICAgICR0ID0gIlx0IiB4ICgkdGFiIC8gOCkg
  LiAnICcgeCAoJHRhYiAlIDgpOworICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LCAi
  bXkoXEBSRU0pO1xuIik7CisgICAgICAgICAgICAgICAgICAgIGlmICgkaW5jbF90eXBlIGVxICdp
  bmNsdWRlX25leHQnKSB7CiAJCXByaW50IE9VVCAoJHQsCiAJCQkgICAibXkoXCVJTkNEKSA9IG1h
  cCB7IFwkSU5De1wkX30gPT4gMSB9ICIsCi0JCQkgICAiKGdyZXAgeyBcJF8gZXEgXCIkaW5jbFwi
  IH0ga2V5cyhcJUlOQykpO1xuIik7CisJCQkgICAgICAgICAgICIoZ3JlcCB7IFwkXyBlcSBcIiRp
  bmNsXCIgfSAiLAorICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAia2V5cyhcJUlO
  QykpO1xuIik7CiAJCXByaW50IE9VVCAoJHQsCi0JCQkgICAibXkoXEBSRU0pID0gbWFwIHsgXCJc
  JF8vJGluY2xcIiB9ICIsCisJCQkgICAgICAgICAgICJcQFJFTSA9IG1hcCB7IFwiXCRfLyRpbmNs
  XCIgfSAiLAogCQkJICAgIihncmVwIHsgbm90IGV4aXN0cyhcJElOQ0R7XCJcJF8vJGluY2xcIn0p
  IiwKLQkJCSAgICJhbmQgLWYgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworCQkJICAgICAg
  ICAgICAiIGFuZCAtZiBcIlwkXy8kaW5jbFwiIH0gXEBJTkMpO1xuIik7CisgICAgICAgICAgICAg
  ICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgKCR0LAor
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiXEBSRU0gPSBtYXAgeyBcIlwkXy8k
  aW5jbFwiIH0gIiwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIihncmVwIHst
  ciBcIlwkXy8kaW5jbFwiIH0gXEBJTkMpO1xuIik7CisgICAgICAgICAgICAgICAgICAgIH0KIAkJ
  cHJpbnQgT1VUICgkdCwKIAkJCSAgICJyZXF1aXJlIFwiXCRSRU1bMF1cIiBpZiBcQFJFTTtcbiIp
  OwogICAgICAgICAgICAgICAgICR0YWIgLT0gNDsKQEAgLTE5MSw2ICsyMTgsMTQgQEAgd2hpbGUg
  KGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJCQkgICAifTtcbiIpOwogCQlw
  cmludCBPVVQgKCR0LAogCQkJICAgIndhcm4oXCRcQCkgaWYgXCRcQDtcbiIpOworICAgICAgICAg
  ICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgv
  OworICAgICAgICAgICAgICAgICAgICAjIGNvcHkgdGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3lu
  dGF4ICgjaW5jbHVkZSAieC5oIikgY2FzZQorICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2wg
  IX4gbXwvfCAmJiAkaW5jbF9xdW90ZSBlcSBxeyJ9ICYmICRmaWxlID1+IG18XiguKikvfCkgewor
  ICAgICAgICAgICAgICAgICAgICAgICAgJGluY2wgPSAiJDEvJGluY2wiOworICAgICAgICAgICAg
  ICAgICAgICB9CisJCSAgICBwcmludCBPVVQgJHQsInJlcXVpcmUgJyRpbmNsJztcbiI7CisgICAg
  ICAgICAgICAgICAgfQogCSAgICB9IGVsc2lmICgvXmlmZGVmXHMrKFx3KykvKSB7CiAJCXByaW50
  IE9VVCAkdCwiaWYoZGVmaW5lZCgmJDEpKSB7XG4iOwogCQkkdGFiICs9IDQ7CkBAIC0yNDAsNyAr
  Mjc1LDcgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAJICAg
  IH0KIAl9IGVsc2lmKC9eXHMqKHR5cGVkZWZccyopP2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMq
  KT8vKSB7CiAJICAgIHVudGlsKC9ce1tefV0qXH0uKjsvIHx8IC87LykgewotCQlsYXN0IHVubGVz
  cyBkZWZpbmVkICgkbmV4dCA9IG5leHRfbGluZSgpKTsKKwkJbGFzdCB1bmxlc3MgZGVmaW5lZCAo
  JG5leHQgPSBuZXh0X2xpbmUoJGZpbGUpKTsKIAkJY2hvbXAgJG5leHQ7CiAJCSMgZHJvcCAiI2Rl
  ZmluZSBGT08gRk9PIiBpbiBlbnVtcwogCQkkbmV4dCA9fiBzL15ccyojXHMqZGVmaW5lXHMrKFx3
  KylccytcMVxzKiQvLzsKQEAgLTI3MiwyMiArMzA3LDIyIEBAIHdoaWxlIChkZWZpbmVkIChteSAk
  ZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCSAgICB9CiAJfQogICAgIH0KLSAgICBwcmludCBPVVQg
  IjE7XG4iOwotCiAgICAgJElzX2NvbnZlcnRlZHskZmlsZX0gPSAxOworICAgIGlmICgkb3B0X2Ug
  JiYgZXhpc3RzKCRiYWRfZmlsZXskZmlsZX0pKSB7CisgICAgICAgIHVubGluaygkRGVzdF9kaXIg
  LiAnLycgLiAkb3V0ZmlsZSk7CisgICAgICAgICRuZXh0ID0gJyc7CisgICAgfSBlbHNlIHsKKyAg
  ICAgICAgcHJpbnQgT1VUICIxO1xuIjsKICAgICBxdWV1ZV9pbmNsdWRlc19mcm9tKCRmaWxlKSBp
  ZiAoJG9wdF9hKTsKKyAgICB9CiB9CiAKLWV4aXQgJEV4aXQ7Ci0KLQotc3ViIHJlaW5kZW50KCQp
  IHsKLSAgICBteSgkdGV4dCkgPSBzaGlmdDsKLSAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwot
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKLSAgICAkdGV4dDsKK2lmICgkb3B0X2UgJiYg
  KHNjYWxhcihrZXlzICViYWRfZmlsZSkgPiAwKSkgeworICAgIHdhcm4gIldhcyB1bmFibGUgdG8g
  Y29udmVydCB0aGUgZm9sbG93aW5nIGZpbGVzOlxuIjsKKyAgICB3YXJuICJcdCIgLiBqb2luKCJc
  blx0Iixzb3J0KGtleXMgJWJhZF9maWxlKSkgLiAiXG4iOwogfQogCitleGl0ICRFeGl0OwogCiBz
  dWIgZXhwciB7CiAgICAgbXkgJGpvaW5lZF9hcmdzOwpAQCAtMjk4LDggKzMzMywyMSBAQCBzdWIg
  ZXhwciB7CiAJcy9eXCZcJi8vICYmIGRvIHsgJG5ldyAuPSAiICYmIjsgbmV4dDt9OyAjIGhhbmRs
  ZSAmJiBvcGVyYXRvcgogCXMvXlwmKFtcKGEtelwpXSspLyQxL2k7CSMgaGFjayBmb3IgdGhpbmdz
  IHRoYXQgdGFrZSB0aGUgYWRkcmVzcyBvZgogCXMvXihccyspLy8JCSYmIGRvIHskbmV3IC49ICcg
  JzsgbmV4dDt9OwotCXMvXigwWFswLTlBLUZdKylbVUxdKi8vaQkmJiBkbyB7JG5ldyAuPSBsYygk
  MSk7IG5leHQ7fTsKLQlzL14oLT9cZCtcLlxkK0VbLStdXGQrKUY/Ly9pCSYmIGRvIHskbmV3IC49
  ICQxOyBuZXh0O307CisJcy9eMFgoWzAtOUEtRl0rKVtVTF0qLy9pIAorCSAgICAmJiBkbyB7bXkg
  JGhleCA9ICQxOworCQkgICAkaGV4ID1+IHMvXjArLy87CisJCSAgIGlmIChsZW5ndGggJGhleCA+
  IDggJiYgISRDb25maWd7dXNlNjRiaXRpbnR9KSB7CisJCSAgICAgICAjIENyb2FrIGlmIG52X3By
  ZXNlcnZlc191dl9iaXRzIDwgNjQgPworCQkgICAgICAgJG5ldyAuPSAgICAgICAgIGhleChzdWJz
  dHIoJGhleCwgLTgpKSArCisJCQkgICAgICAgMioqMzIgKiBoZXgoc3Vic3RyKCRoZXgsICAwLCAt
  OCkpOworCQkgICAgICAgIyBUaGUgYWJvdmUgd2lsbCBwcm9kdWNlICJlcnJvcm5ldXMiIGNvZGUK
  KwkJICAgICAgICMgaWYgdGhlIGhleCBjb25zdGFudCB3YXMgZS5nLiBpbnNpZGUgVUlOVDY0X0MK
  KwkJICAgICAgICMgbWFjcm8sIGJ1dCB0aGVuIGFnYWluLCBoMnBoIGlzIGFuIGFwcHJveGltYXRp
  b24uCisJCSAgIH0gZWxzZSB7CisJCSAgICAgICAkbmV3IC49IGxjKCIweCRoZXgiKTsKKwkJICAg
  fQorCQkgICBuZXh0O307CisJcy9eKC0/XGQrXC5cZCtFWy0rXT9cZCspW0ZMXT8vL2kJJiYgZG8g
  eyRuZXcgLj0gJDE7IG5leHQ7fTsKIAlzL14oXGQrKVxzKltMVV0qLy9pCSYmIGRvIHskbmV3IC49
  ICQxOyBuZXh0O307CiAJcy9eKCIoXFwifFteIl0pKiIpLy8JJiYgZG8geyRuZXcgLj0gJDE7IG5l
  eHQ7fTsKIAlzL14nKChcXCJ8W14iXSkqKScvLwkmJiBkbyB7CkBAIC0zODgsNyArNDM2LDcgQEAg
  c3ViIGV4cHIgewogCQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9k
  ZWZpbmVkXHMqXCgkLykgewotCQkgICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/
  ICYnIC4gJGlkIC4gJyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4g
  JykgPyAmJyAuICRpZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAg
  JG5ldyAuPSAiIFwkJGlkIjsKIAkJfSBlbHNlIHsKQEAgLTQwNCw2ICs0NTIsNyBAQCBzdWIgZXhw
  ciB7CiAKIHN1YiBuZXh0X2xpbmUKIHsKKyAgICBteSAkZmlsZSA9IHNoaWZ0OwogICAgIG15ICgk
  aW4sICRvdXQpOwogICAgIG15ICRwcmVfc3ViX3RyaV9ncmFwaHMgPSAxOwogCkBAIC00MjYsNiAr
  NDc1LDIwIEBAIHN1YiBuZXh0X2xpbmUKICAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/PC97
  L2c7ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pzx8ICB7fAogICAgICAgICAgICAgICAg
  ICRpbiA9fiBzL1w/XD8+L30vZzsgICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PnwgIH18
  CiAgICAgICAgICAgICB9CisJICAgIGlmICgkaW4gPX4gL15cI2lmZGVmIF9fTEFOR1VBR0VfUEFT
  Q0FMX18vKSB7CisgICAgICAgICAgICAgICAgIyBUcnU2NCBkaXNhc3NlbWJsZXIuaCBldmlsbmVz
  czogbWl4ZWQgQyBhbmQgUGFzY2FsLgorCQl3aGlsZSAoPElOPikgeworCQkgICAgbGFzdCBpZiAv
  XlwjZW5kaWYvOyAKKwkJfQorCQluZXh0IFJFQUQ7CisJICAgIH0KKwkgICAgaWYgKCRpbiA9fiAv
  XmV4dGVybiBpbmxpbmUgLyAmJiAjIElubGluZWQgYXNzZW1ibGVyLgorCQkkXk8gZXEgJ2xpbnV4
  JyAmJiAkZmlsZSA9fiBtISg/Ol58Lylhc20vW14vXStcLmgkISkgeworIAkJd2hpbGUgKDxJTj4p
  IHsKKwkJICAgIGxhc3QgaWYgL159LzsgCisJCX0KKwkJbmV4dCBSRUFEOworCSAgICB9CiAgICAg
  ICAgICAgICBpZiAoJGluID1+IHMvXFwkLy8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAj
  IFwtbmV3bGluZQogICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJyAnOwogICAgICAgICAgICAg
  ICAgIG5leHQgUkVBRDsKQEAgLTQzMywxMCArNDk2LDE4IEBAIHN1YiBuZXh0X2xpbmUKICAgICAg
  ICAgICAgICAgICAkb3V0ICAgIC49ICQxOwogICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMv
  XihcXC4pLy8pIHsgICAgICAgICAgICAgICAgICAgIyBcLi4uCiAgICAgICAgICAgICAgICAgJG91
  dCAgICAuPSAkMTsKLSAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxd
  KSonKS8vKSB7ICAgICAgICMgJy4uLgotICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7Ci0g
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeyAgICAg
  ICAjICIuLi4KLSAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBl
  bHNpZiAoJGluID1+IC9eJy8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgIyAnLi4uCisgICAg
  ICAgICAgICAgICAgaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSonKS8vKSB7CisgICAgICAg
  ICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsKKyAg
  ICAgICAgICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRpbiA9fiAvXiIvKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICMgIi4u
  LgorICAgICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgewor
  ICAgICAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgICAgIH0gZWxz
  ZSB7CisgICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgICAgICB9CiAg
  ICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eXC9cLy4qLy8pIHsgICAgICAgICAgICAgICAg
  ICAjIC8vLi4uCiAgICAgICAgICAgICAgICAgIyBmYWxsIHRocm91Z2gKICAgICAgICAgICAgIH0g
  ZWxzaWYgKCRpbiA9fiBtL15cL1wqLykgeyAgICAgICAgICAgICAgICAgICAgICMgLyouLi4KQEAg
  LTQ1MCw4ICs1MjEsMjAgQEAgc3ViIG5leHRfbGluZQogICAgICAgICAgICAgICAgICRvdXQgICAg
  Lj0gJDE7CiAgICAgICAgICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKFteXCdcIlxcXC9dKykvLykg
  ewogICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICB9IGVsc2lmICgk
  Xk8gZXEgJ2xpbnV4JyAmJgorICAgICAgICAgICAgICAgICAgICAgJGZpbGUgPX4gbSEoPzpefC8p
  bGludXgvYnl0ZW9yZGVyL3BkcF9lbmRpYW5cLmgkISAmJgorICAgICAgICAgICAgICAgICAgICAg
  JGluICAgPX4gcyFcJ1QgS05PVyEhKSB7CisgICAgICAgICAgICAgICAgJG91dCAgICA9fiBzIUkg
  RE9OJCFJX0RPX05PVF9LTk9XITsKICAgICAgICAgICAgIH0gZWxzZSB7Ci0gICAgICAgICAgICAg
  ICAgZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgaWYgKCRvcHRf
  ZSkgeworICAgICAgICAgICAgICAgICAgICB3YXJuICJDYW5ub3QgcGFyc2UgJGZpbGU6XG4kaW5c
  biI7CisgICAgICAgICAgICAgICAgICAgICRiYWRfZmlsZXskZmlsZX0gPSAxOworICAgICAgICAg
  ICAgICAgICAgICAkaW4gPSAnJzsKKyAgICAgICAgICAgICAgICAgICAgJG91dCA9IHVuZGVmOwor
  ICAgICAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsK
  KwkJZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgfQogICAgICAg
  ICAgICAgfQogICAgICAgICB9CiAKQEAgLTU2MSw4ICs2NDQsMTMgQEAgc3ViIHF1ZXVlX2luY2x1
  ZGVzX2Zyb20KICAgICAgICAgICAgICAgICAkbGluZSAuPSA8SEVBREVSPjsKICAgICAgICAgICAg
  IH0KIAotICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccys8KC4qPyk+Lykg
  ewotICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQxKSB1bmxlc3MgJElzX2NvbnZlcnRlZHsk
  MX07CisgICAgICAgICAgICBpZiAoJGxpbmUgPX4gL14jXHMqaW5jbHVkZVxzKyhbPCJdKSguKj8p
  Wz4iXS8pIHsKKyAgICAgICAgICAgICAgICBteSAoJGRlbGltaXRlciwgJG5ld19maWxlKSA9ICgk
  MSwgJDIpOworICAgICAgICAgICAgICAgICMgY29weSB0aGUgcHJlZml4IGluIHRoZSBxdW90ZSBz
  eW50YXggKCNpbmNsdWRlICJ4LmgiKSBjYXNlCisgICAgICAgICAgICAgICAgaWYgKCRkZWxpbWl0
  ZXIgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAgICAgICAgICAgICAgICAgICAg
  JG5ld19maWxlID0gIiQxLyRuZXdfZmlsZSI7CisgICAgICAgICAgICAgICAgfQorICAgICAgICAg
  ICAgICAgIHB1c2goQEFSR1YsICRuZXdfZmlsZSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JG5ld19m
  aWxlfTsKICAgICAgICAgICAgIH0KICAgICAgICAgfQogICAgIGNsb3NlIEhFQURFUjsKQEAgLTYw
  MywyNSArNjkxLDUwIEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKICAgICBteSAo
  JWRlZmluZSkgPSBfZXh0cmFjdF9jY19kZWZpbmVzKCk7CiAKICAgICBvcGVuICBQUkVBTUJMRSwg
  Ij4kcHJlYW1ibGUiIG9yIGRpZSAiQ2Fubm90IG9wZW4gJHByZWFtYmxlOiAgJCEiOwotICAgICAg
  ICBwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9u
  ICRWRVJTSU9OXG4iOwotCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5lKSB7Ci0g
  ICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1CTEUg
  IiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAgIGlmICgk
  ZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAgICBwcmlu
  dCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBz
  dWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXskX30g
  PX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAgICAg
  ICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99
  IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKKwlwcmludCBQUkVBTUJMRSAiIyBUaGlz
  IGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9uICRWRVJTSU9OXG4iOworICAgICAgICAj
  IFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25zdGFudHMgZnJvbSB3YXJuaW5nLgorICAgICAg
  ICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVjZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlmIHdl
  IGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEgaGV4IGNvbnN0YW50IGFzIGFuIGludGVnZXIu
  CisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4iOwor
  CisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgeworCQlw
  cmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAoJGRl
  ZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTogIGQ9
  KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99ID1+
  IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZsb2F0
  OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRf
  KCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWystXT9c
  ZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkgICAg
  InVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKyAgICAgICAg
  ICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/MHhbXGRhLWZdKylVP0x7MCwyfSQv
  aSkgeworICAgICAgICAgICAgICAgICMgaGV4IGludGVnZXIKKyAgICAgICAgICAgICAgICAjIFNw
  ZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMgb24gaGV4IGludGVnZXJzCisgICAgICAgICAg
  ICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGluIGEgVVYuCisgICAgICAgICAgICAg
  ICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0IHRp
  bWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAgICAgICAgICAgICMgb25seSBnZXRzIHRoZSB3
  YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0aGlzCisgICAgICAgICAgICAgICAgIyBwbGF0
  Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAgICAgICAgICAgICAgIG15ICRjb2RlID0gJDE7
  CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4KCckY29kZScpIiBpZiBsZW5ndGggJGNvZGUg
  PiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAg
  ICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAgICAg
  ICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAgICAg
  fQotICAgICAgICB9CisgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7
  IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+
  IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUKKwkJICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOworCSAgICB9IGVsc2UgeworCQlw
  cmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyBc
  IiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7CisJICAgIH0K
  Kwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBjbG9z
  ZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTYzMywxNSArNzQ2LDE0IEBAIHN1YiBfZXh0cmFj
  dF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKICAgICBteSAkYWxsc3ltYm9scyAgPSBq
  b2luICIgIiwKLSAgICAgICAgQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3Bw
  Y2NzeW1ib2xzJ307CisJQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3BwY2Nz
  eW1ib2xzJ307CiAKICAgICAjIFNwbGl0IGNvbXBpbGVyIHByZS1kZWZpbml0aW9ucyBpbnRvIGBr
  ZXk9dmFsdWUnIHBhaXJzOgotICAgIGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkYWxsc3ltYm9scykg
  ewotICAgICAgICAvKC4rPyk9KC4rKS8gYW5kICRkZWZpbmV7JDF9ID0gJDI7Ci0KLSAgICAgICAg
  aWYgKCRvcHRfRCkgewotICAgICAgICAgICAgcHJpbnQgU1RERVJSICIkXzogICQxIC0+ICQyXG4i
  OwotICAgICAgICB9CisgICAgd2hpbGUgKCRhbGxzeW1ib2xzID1+IC8oW15cc10rKT0oKFxcXHN8
  W15cc10pKykvZykgeworCSRkZWZpbmV7JDF9ID0gJDI7CisJaWYgKCRvcHRfRCkgeworCSAgICBw
  cmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7CisJfQogICAgIH0KIAogICAgIHJldHVybiAl
  ZGVmaW5lOwpAQCAtNjcwLDYgKzc4MiwxMCBAQCBJdCBpcyBtb3N0IGVhc2lseSBydW4gd2hpbGUg
  aW4gL3Vzci9pbmNsdWRlOgogCiAJY2QgL3Vzci9pbmNsdWRlOyBoMnBoICogc3lzLyoKIAorb3IK
  KworCWNkIC91c3IvaW5jbHVkZTsgaDJwaCAqIHN5cy8qIGFycGEvKiBuZXRpbmV0LyoKKwogb3IK
  IAogCWNkIC91c3IvaW5jbHVkZTsgaDJwaCAtciAtbCAuCkBAIC02ODcsNyArODAzLDcgQEAgSWYg
  cnVuIHdpdGggbm8gYXJndW1lbnRzLCBmaWx0ZXJzIHN0YW5kYXJkIGlucHV0IHRvIHN0YW5kYXJk
  IG91dHB1dC4KID1pdGVtIC1kIGRlc3RpbmF0aW9uX2RpcgogCiBQdXQgdGhlIHJlc3VsdGluZyBC
  PC5waD4gZmlsZXMgYmVuZWF0aCBCPGRlc3RpbmF0aW9uX2Rpcj4sIGluc3RlYWQgb2YKLWJlbmVh
  dGggdGhlIGRlZmF1bHQgUGVybCBsaWJyYXJ5IGxvY2F0aW9uIChDPCRDb25maWd7J2luc3RhbGxz
  aXRzZWFyY2gnfT4pLgorYmVuZWF0aCB0aGUgZGVmYXVsdCBQZXJsIGxpYnJhcnkgbG9jYXRpb24g
  KEM8JENvbmZpZ3snaW5zdGFsbHNpdGVhcmNoJ30+KS4KIAogPWl0ZW0gLXIKIApAQCAtNzcyLDEw
  ICs4ODgsMTAgQEAgaW5zdGFsbGF0aW9uLgogRG9lc24ndCBoYW5kbGUgY29tcGxpY2F0ZWQgZXhw
  cmVzc2lvbnMgYnVpbHQgcGllY2VtZWFsLCBhIGxhOgogCiAgICAgZW51bSB7Ci0gICAgICAgIEZJ
  UlNUX1ZBTFVFLAotICAgICAgICBTRUNPTkRfVkFMVUUsCisJRklSU1RfVkFMVUUsCisJU0VDT05E
  X1ZBTFVFLAogICAgICNpZmRlZiBBQkMKLSAgICAgICAgVEhJUkRfVkFMVUUKKwlUSElSRF9WQUxV
  RQogICAgICNlbmRpZgogICAgIH07CiAK
  UH2PH573
    }
    if ( $num < 5.008001 ) {
      return _patch_b64(<<'UH2PH580');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTQyLDggKzQyLDEzIEBAIHVz
  ZSBDb25maWc7CiB1c2UgRmlsZTo6UGF0aCBxdyhta3BhdGgpOwogdXNlIEdldG9wdDo6U3RkOwog
  Ci1nZXRvcHRzKCdEZDpybGhhUScpOwotdXNlIHZhcnMgcXcoJG9wdF9EICRvcHRfZCAkb3B0X3Ig
  JG9wdF9sICRvcHRfaCAkb3B0X2EgJG9wdF9RKTsKKyMgTWFrZSBzdXJlIHJlYWQgcGVybWlzc2lv
  bnMgZm9yIGFsbCBhcmUgc2V0OgoraWYgKGRlZmluZWQgdW1hc2sgJiYgKHVtYXNrKCkgJiAwNDQ0
  KSkgeworICAgIHVtYXNrICh1bWFzaygpICYgfjA0NDQpOworfQorCitnZXRvcHRzKCdEZDpybGhh
  UWUnKTsKK3VzZSB2YXJzIHF3KCRvcHRfRCAkb3B0X2QgJG9wdF9yICRvcHRfbCAkb3B0X2ggJG9w
  dF9hICRvcHRfUSAkb3B0X2UpOwogZGllICItciBhbmQgLWEgb3B0aW9ucyBhcmUgbXV0dWFsbHkg
  ZXhjbHVzaXZlXG4iIGlmICgkb3B0X3IgYW5kICRvcHRfYSk7CiBteSBAaW5jX2RpcnMgPSBpbmNf
  ZGlycygpIGlmICRvcHRfYTsKIApAQCAtNjUsMTMgKzcwLDIxIEBAIG15ICVpc2F0eXBlOwogQGlz
  YXR5cGV7QGlzYXR5cGV9ID0gKDEpIHggQGlzYXR5cGU7CiBteSAkaW5pZiA9IDA7CiBteSAlSXNf
  Y29udmVydGVkOworbXkgJWJhZF9maWxlID0gKCk7CiAKIEBBUkdWID0gKCctJykgdW5sZXNzIEBB
  UkdWOwogCiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkoKTsKIAorc3ViIHJlaW5kZW50KCQp
  IHsKKyAgICBteSgkdGV4dCkgPSBzaGlmdDsKKyAgICAkdGV4dCA9fiBzL1xuL1xuICAgIC9nOwor
  ICAgICR0ZXh0ID1+IHMvICAgICAgICAvXHQvZzsKKyAgICAkdGV4dDsKK30KKwogbXkgKCR0LCAk
  dGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxfaW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91
  dGZpbGUpOwotbXkgKCRpbmNsLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNs
  X3F1b3RlLCAkbmV4dCk7CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkp
  IHsKICAgICBpZiAoLWwgJGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9z
  c2libGUoJGZpbGUpIGlmICgkb3B0X2wpOwpAQCAtMTA3LDcgKzEyMCw5IEBAIHdoaWxlIChkZWZp
  bmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCW9wZW4oT1VULCI+JERlc3RfZGlyLyRv
  dXRmaWxlIikgfHwgZGllICJDYW4ndCBjcmVhdGUgJG91dGZpbGU6ICQhXG4iOwogICAgIH0KIAot
  ICAgIHByaW50IE9VVCAicmVxdWlyZSAnX2gycGhfcHJlLnBoJztcblxuIjsKKyAgICBwcmludCBP
  VVQKKyAgICAgICAgInJlcXVpcmUgJ19oMnBoX3ByZS5waCc7XG5cbiIsCisgICAgICAgICJubyB3
  YXJuaW5ncyAncmVkZWZpbmUnO1xuXG4iOwogCiAgICAgd2hpbGUgKGRlZmluZWQgKGxvY2FsICRf
  ID0gbmV4dF9saW5lKCRmaWxlKSkpIHsKIAlpZiAocy9eXHMqXCNccyovLykgewpAQCAtMTY5LDIy
  ICsxODQsMzIgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxlKCkpKSB7CiAg
  ICAgICAgICAgICAgICAgICAgICAgcHJpbnQgT1VUICR0LCJ1bmxlc3MoZGVmaW5lZChcJiRuYW1l
  KSkge1xuICAgIHN1YiAkbmFtZSAoKSB7XHQiLCRuZXcsIjt9XG59XG4iOwogCQkgICAgfQogCQl9
  Ci0JICAgIH0gZWxzaWYgKC9eKGluY2x1ZGV8aW1wb3J0KVxzKls8Il0oLiopWz4iXS8pIHsKLQkJ
  KCRpbmNsID0gJDIpID1+IHMvXC5oJC8ucGgvOwotCQlwcmludCBPVVQgJHQsInJlcXVpcmUgJyRp
  bmNsJztcbiI7Ci0JICAgIH0gZWxzaWYoL15pbmNsdWRlX25leHRccypbPCJdKC4qKVs+Il0vKSB7
  Ci0JCSgkaW5jbCA9ICQxKSA9fiBzL1wuaCQvLnBoLzsKKwkgICAgfSBlbHNpZiAoL14oaW5jbHVk
  ZXxpbXBvcnR8aW5jbHVkZV9uZXh0KVxzKihbPFwiXSkoLiopWz5cIl0vKSB7CisgICAgICAgICAg
  ICAgICAgJGluY2xfdHlwZSA9ICQxOworICAgICAgICAgICAgICAgICRpbmNsX3F1b3RlID0gJDI7
  CisgICAgICAgICAgICAgICAgJGluY2wgPSAkMzsKKyAgICAgICAgICAgICAgICBpZiAoKCRpbmNs
  X3R5cGUgZXEgJ2luY2x1ZGVfbmV4dCcpIHx8CisgICAgICAgICAgICAgICAgICAgICgkb3B0X2Ug
  JiYgZXhpc3RzKCRiYWRfZmlsZXskaW5jbH0pKSkgeworICAgICAgICAgICAgICAgICAgICAkaW5j
  bCA9fiBzL1wuaCQvLnBoLzsKIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJldmFsIHtcbiIpOwog
  ICAgICAgICAgICAgICAgICR0YWIgKz0gNDsKICAgICAgICAgICAgICAgICAkdCA9ICJcdCIgeCAo
  JHRhYiAvIDgpIC4gJyAnIHggKCR0YWIgJSA4KTsKKyAgICAgICAgICAgICAgICAgICAgcHJpbnQg
  T1VUICgkdCwgIm15KFxAUkVNKTtcbiIpOworICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2xf
  dHlwZSBlcSAnaW5jbHVkZV9uZXh0JykgewogCQlwcmludCBPVVQgKCR0LAogCQkJICAgIm15KFwl
  SU5DRCkgPSBtYXAgeyBcJElOQ3tcJF99ID0+IDEgfSAiLAotCQkJICAgIihncmVwIHsgXCRfIGVx
  IFwiJGluY2xcIiB9IGtleXMoXCVJTkMpKTtcbiIpOworCQkJICAgICAgICAgICAiKGdyZXAgeyBc
  JF8gZXEgXCIkaW5jbFwiIH0gIiwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ImtleXMoXCVJTkMpKTtcbiIpOwogCQlwcmludCBPVVQgKCR0LAotCQkJICAgIm15KFxAUkVNKSA9
  IG1hcCB7IFwiXCRfLyRpbmNsXCIgfSAiLAorCQkJICAgICAgICAgICAiXEBSRU0gPSBtYXAgeyBc
  IlwkXy8kaW5jbFwiIH0gIiwKIAkJCSAgICIoZ3JlcCB7IG5vdCBleGlzdHMoXCRJTkNEe1wiXCRf
  LyRpbmNsXCJ9KSIsCi0JCQkgICAiYW5kIC1mIFwiXCRfLyRpbmNsXCIgfSBcQElOQyk7XG4iKTsK
  KwkJCSAgICAgICAgICAgIiBhbmQgLWYgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAg
  ICAgICAgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQg
  T1VUICgkdCwKKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlxAUkVNID0gbWFw
  IHsgXCJcJF8vJGluY2xcIiB9ICIsCisgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICIoZ3JlcCB7LXIgXCJcJF8vJGluY2xcIiB9IFxASU5DKTtcbiIpOworICAgICAgICAgICAgICAg
  ICAgICB9CiAJCXByaW50IE9VVCAoJHQsCiAJCQkgICAicmVxdWlyZSBcIlwkUkVNWzBdXCIgaWYg
  XEBSRU07XG4iKTsKICAgICAgICAgICAgICAgICAkdGFiIC09IDQ7CkBAIC0xOTMsNiArMjE4LDE0
  IEBAIHdoaWxlIChkZWZpbmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCQkJICAgIn07
  XG4iKTsKIAkJcHJpbnQgT1VUICgkdCwKIAkJCSAgICJ3YXJuKFwkXEApIGlmIFwkXEA7XG4iKTsK
  KyAgICAgICAgICAgICAgICB9IGVsc2UgeworICAgICAgICAgICAgICAgICAgICAkaW5jbCA9fiBz
  L1wuaCQvLnBoLzsKKyAgICAgICAgICAgICAgICAgICAgIyBjb3B5IHRoZSBwcmVmaXggaW4gdGhl
  IHF1b3RlIHN5bnRheCAoI2luY2x1ZGUgInguaCIpIGNhc2UKKyAgICAgICAgICAgICAgICAgICAg
  aWYgKCRpbmNsICF+IG18L3wgJiYgJGluY2xfcXVvdGUgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4o
  LiopL3wpIHsKKyAgICAgICAgICAgICAgICAgICAgICAgICRpbmNsID0gIiQxLyRpbmNsIjsKKyAg
  ICAgICAgICAgICAgICAgICAgfQorCQkgICAgcHJpbnQgT1VUICR0LCJyZXF1aXJlICckaW5jbCc7
  XG4iOworICAgICAgICAgICAgICAgIH0KIAkgICAgfSBlbHNpZiAoL15pZmRlZlxzKyhcdyspLykg
  ewogCQlwcmludCBPVVQgJHQsImlmKGRlZmluZWQoJiQxKSkge1xuIjsKIAkJJHRhYiArPSA0OwpA
  QCAtMjc0LDIyICszMDcsMjIgQEAgd2hpbGUgKGRlZmluZWQgKG15ICRmaWxlID0gbmV4dF9maWxl
  KCkpKSB7CiAJICAgIH0KIAl9CiAgICAgfQotICAgIHByaW50IE9VVCAiMTtcbiI7Ci0KICAgICAk
  SXNfY29udmVydGVkeyRmaWxlfSA9IDE7CisgICAgaWYgKCRvcHRfZSAmJiBleGlzdHMoJGJhZF9m
  aWxleyRmaWxlfSkpIHsKKyAgICAgICAgdW5saW5rKCREZXN0X2RpciAuICcvJyAuICRvdXRmaWxl
  KTsKKyAgICAgICAgJG5leHQgPSAnJzsKKyAgICB9IGVsc2UgeworICAgICAgICBwcmludCBPVVQg
  IjE7XG4iOwogICAgIHF1ZXVlX2luY2x1ZGVzX2Zyb20oJGZpbGUpIGlmICgkb3B0X2EpOworICAg
  IH0KIH0KIAotZXhpdCAkRXhpdDsKLQotCi1zdWIgcmVpbmRlbnQoJCkgewotICAgIG15KCR0ZXh0
  KSA9IHNoaWZ0OwotICAgICR0ZXh0ID1+IHMvXG4vXG4gICAgL2c7Ci0gICAgJHRleHQgPX4gcy8g
  ICAgICAgIC9cdC9nOwotICAgICR0ZXh0OworaWYgKCRvcHRfZSAmJiAoc2NhbGFyKGtleXMgJWJh
  ZF9maWxlKSA+IDApKSB7CisgICAgd2FybiAiV2FzIHVuYWJsZSB0byBjb252ZXJ0IHRoZSBmb2xs
  b3dpbmcgZmlsZXM6XG4iOworICAgIHdhcm4gIlx0IiAuIGpvaW4oIlxuXHQiLHNvcnQoa2V5cyAl
  YmFkX2ZpbGUpKSAuICJcbiI7CiB9CiAKK2V4aXQgJEV4aXQ7CiAKIHN1YiBleHByIHsKICAgICBt
  eSAkam9pbmVkX2FyZ3M7CkBAIC00MDMsNyArNDM2LDcgQEAgc3ViIGV4cHIgewogCQl9CiAJICAg
  IH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVkXHMqXCgkLykgewotCQkg
  ICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4gJGlkIC4gJyA6IDApJzsK
  KwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAuICRpZCAuICcgOiB1
  bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAgJG5ldyAuPSAiIFwkJGlkIjsKIAkJ
  fSBlbHNlIHsKQEAgLTQ2MywxMCArNDk2LDE4IEBAIHN1YiBuZXh0X2xpbmUKICAgICAgICAgICAg
  ICAgICAkb3V0ICAgIC49ICQxOwogICAgICAgICAgICAgfSBlbHNpZiAoJGluID1+IHMvXihcXC4p
  Ly8pIHsgICAgICAgICAgICAgICAgICAgIyBcLi4uCiAgICAgICAgICAgICAgICAgJG91dCAgICAu
  PSAkMTsKLSAgICAgICAgICAgIH0gZWxzaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSonKS8v
  KSB7ICAgICAgICMgJy4uLgotICAgICAgICAgICAgICAgICRvdXQgICAgLj0gJDE7Ci0gICAgICAg
  ICAgICB9IGVsc2lmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeyAgICAgICAjICIu
  Li4KLSAgICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgfSBlbHNpZiAo
  JGluID1+IC9eJy8pIHsgICAgICAgICAgICAgICAgICAgICAgICAgIyAnLi4uCisgICAgICAgICAg
  ICAgICAgaWYgKCRpbiA9fiBzL14oJyhcXC58W14nXFxdKSonKS8vKSB7CisgICAgICAgICAgICAg
  ICAgICAgICRvdXQgICAgLj0gJDE7CisgICAgICAgICAgICAgICAgfSBlbHNlIHsKKyAgICAgICAg
  ICAgICAgICAgICAgbmV4dCBSRUFEOworICAgICAgICAgICAgICAgIH0KKyAgICAgICAgICAgIH0g
  ZWxzaWYgKCRpbiA9fiAvXiIvKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICMgIi4uLgorICAg
  ICAgICAgICAgICAgIGlmICgkaW4gPX4gcy9eKCIoXFwufFteIlxcXSkqIikvLykgeworICAgICAg
  ICAgICAgICAgICAgICAkb3V0ICAgIC49ICQxOworICAgICAgICAgICAgICAgIH0gZWxzZSB7Cisg
  ICAgICAgICAgICAgICAgICAgIG5leHQgUkVBRDsKKyAgICAgICAgICAgICAgICB9CiAgICAgICAg
  ICAgICB9IGVsc2lmICgkaW4gPX4gcy9eXC9cLy4qLy8pIHsgICAgICAgICAgICAgICAgICAjIC8v
  Li4uCiAgICAgICAgICAgICAgICAgIyBmYWxsIHRocm91Z2gKICAgICAgICAgICAgIH0gZWxzaWYg
  KCRpbiA9fiBtL15cL1wqLykgeyAgICAgICAgICAgICAgICAgICAgICMgLyouLi4KQEAgLTQ4NSw3
  ICs1MjYsMTUgQEAgc3ViIG5leHRfbGluZQogICAgICAgICAgICAgICAgICAgICAgJGluICAgPX4g
  cyFcJ1QgS05PVyEhKSB7CiAgICAgICAgICAgICAgICAgJG91dCAgICA9fiBzIUkgRE9OJCFJX0RP
  X05PVF9LTk9XITsKICAgICAgICAgICAgIH0gZWxzZSB7CisgICAgICAgICAgICAgICAgaWYgKCRv
  cHRfZSkgeworICAgICAgICAgICAgICAgICAgICB3YXJuICJDYW5ub3QgcGFyc2UgJGZpbGU6XG4k
  aW5cbiI7CisgICAgICAgICAgICAgICAgICAgICRiYWRfZmlsZXskZmlsZX0gPSAxOworICAgICAg
  ICAgICAgICAgICAgICAkaW4gPSAnJzsKKyAgICAgICAgICAgICAgICAgICAgJG91dCA9IHVuZGVm
  OworICAgICAgICAgICAgICAgICAgICBsYXN0IFJFQUQ7CisgICAgICAgICAgICAgICAgfSBlbHNl
  IHsKIAkJZGllICJDYW5ub3QgcGFyc2U6XG4kaW5cbiI7CisgICAgICAgICAgICAgICAgfQogICAg
  ICAgICAgICAgfQogICAgICAgICB9CiAKQEAgLTU5NSw4ICs2NDQsMTMgQEAgc3ViIHF1ZXVlX2lu
  Y2x1ZGVzX2Zyb20KICAgICAgICAgICAgICAgICAkbGluZSAuPSA8SEVBREVSPjsKICAgICAgICAg
  ICAgIH0KIAotICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccys8KC4qPyk+
  LykgewotICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQxKSB1bmxlc3MgJElzX2NvbnZlcnRl
  ZHskMX07CisgICAgICAgICAgICBpZiAoJGxpbmUgPX4gL14jXHMqaW5jbHVkZVxzKyhbPCJdKSgu
  Kj8pWz4iXS8pIHsKKyAgICAgICAgICAgICAgICBteSAoJGRlbGltaXRlciwgJG5ld19maWxlKSA9
  ICgkMSwgJDIpOworICAgICAgICAgICAgICAgICMgY29weSB0aGUgcHJlZml4IGluIHRoZSBxdW90
  ZSBzeW50YXggKCNpbmNsdWRlICJ4LmgiKSBjYXNlCisgICAgICAgICAgICAgICAgaWYgKCRkZWxp
  bWl0ZXIgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAgICAgICAgICAgICAgICAg
  ICAgJG5ld19maWxlID0gIiQxLyRuZXdfZmlsZSI7CisgICAgICAgICAgICAgICAgfQorICAgICAg
  ICAgICAgICAgIHB1c2goQEFSR1YsICRuZXdfZmlsZSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JG5l
  d19maWxlfTsKICAgICAgICAgICAgIH0KICAgICAgICAgfQogICAgIGNsb3NlIEhFQURFUjsKQEAg
  LTYzNywyNSArNjkxLDUwIEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKICAgICBt
  eSAoJWRlZmluZSkgPSBfZXh0cmFjdF9jY19kZWZpbmVzKCk7CiAKICAgICBvcGVuICBQUkVBTUJM
  RSwgIj4kcHJlYW1ibGUiIG9yIGRpZSAiQ2Fubm90IG9wZW4gJHByZWFtYmxlOiAgJCEiOwotICAg
  ICAgICBwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJz
  aW9uICRWRVJTSU9OXG4iOwotCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5lKSB7
  Ci0gICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1C
  TEUgIiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAgIGlm
  ICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXsk
  X30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAg
  ICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7
  JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKKwlwcmludCBQUkVBTUJMRSAiIyBU
  aGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9uICRWRVJTSU9OXG4iOworICAgICAg
  ICAjIFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25zdGFudHMgZnJvbSB3YXJuaW5nLgorICAg
  ICAgICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVjZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlm
  IHdlIGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEgaGV4IGNvbnN0YW50IGFzIGFuIGludGVn
  ZXIuCisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4i
  OworCisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgewor
  CQlwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAo
  JGRlZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTog
  IGQ9KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99
  ID1+IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZs
  b2F0OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3Vi
  ICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWyst
  XT9cZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkg
  ICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKyAgICAg
  ICAgICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/MHhbXGRhLWZdKylVP0x7MCwy
  fSQvaSkgeworICAgICAgICAgICAgICAgICMgaGV4IGludGVnZXIKKyAgICAgICAgICAgICAgICAj
  IFNwZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMgb24gaGV4IGludGVnZXJzCisgICAgICAg
  ICAgICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGluIGEgVVYuCisgICAgICAgICAg
  ICAgICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0
  IHRpbWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAgICAgICAgICAgICMgb25seSBnZXRzIHRo
  ZSB3YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0aGlzCisgICAgICAgICAgICAgICAgIyBw
  bGF0Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAgICAgICAgICAgICAgIG15ICRjb2RlID0g
  JDE7CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4KCckY29kZScpIiBpZiBsZW5ndGggJGNv
  ZGUgPiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAg
  ICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAg
  ICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAg
  ICAgfQotICAgICAgICB9CisgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99
  ID1+IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUKKwkJICAgICJ1bmxlc3MgKGRlZmluZWQg
  JiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOworCSAgICB9IGVsc2Ugewor
  CQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkg
  eyBcIiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7CisJICAg
  IH0KKwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBj
  bG9zZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTY2NywxNSArNzQ2LDE0IEBAIHN1YiBfZXh0
  cmFjdF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKICAgICBteSAkYWxsc3ltYm9scyAg
  PSBqb2luICIgIiwKLSAgICAgICAgQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAn
  Y3BwY2NzeW1ib2xzJ307CisJQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3Bw
  Y2NzeW1ib2xzJ307CiAKICAgICAjIFNwbGl0IGNvbXBpbGVyIHByZS1kZWZpbml0aW9ucyBpbnRv
  IGBrZXk9dmFsdWUnIHBhaXJzOgotICAgIGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkYWxsc3ltYm9s
  cykgewotICAgICAgICAvKC4rPyk9KC4rKS8gYW5kICRkZWZpbmV7JDF9ID0gJDI7Ci0KLSAgICAg
  ICAgaWYgKCRvcHRfRCkgewotICAgICAgICAgICAgcHJpbnQgU1RERVJSICIkXzogICQxIC0+ICQy
  XG4iOwotICAgICAgICB9CisgICAgd2hpbGUgKCRhbGxzeW1ib2xzID1+IC8oW15cc10rKT0oKFxc
  XHN8W15cc10pKykvZykgeworCSRkZWZpbmV7JDF9ID0gJDI7CisJaWYgKCRvcHRfRCkgeworCSAg
  ICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7CisJfQogICAgIH0KIAogICAgIHJldHVy
  biAlZGVmaW5lOwpAQCAtNzI1LDcgKzgwMyw3IEBAIElmIHJ1biB3aXRoIG5vIGFyZ3VtZW50cywg
  ZmlsdGVycyBzdGFuZGFyZCBpbnB1dCB0byBzdGFuZGFyZCBvdXRwdXQuCiA9aXRlbSAtZCBkZXN0
  aW5hdGlvbl9kaXIKIAogUHV0IHRoZSByZXN1bHRpbmcgQjwucGg+IGZpbGVzIGJlbmVhdGggQjxk
  ZXN0aW5hdGlvbl9kaXI+LCBpbnN0ZWFkIG9mCi1iZW5lYXRoIHRoZSBkZWZhdWx0IFBlcmwgbGli
  cmFyeSBsb2NhdGlvbiAoQzwkQ29uZmlneydpbnN0YWxsc2l0c2VhcmNoJ30+KS4KK2JlbmVhdGgg
  dGhlIGRlZmF1bHQgUGVybCBsaWJyYXJ5IGxvY2F0aW9uIChDPCRDb25maWd7J2luc3RhbGxzaXRl
  YXJjaCd9PikuCiAKID1pdGVtIC1yCiAKQEAgLTgxMCwxMCArODg4LDEwIEBAIGluc3RhbGxhdGlv
  bi4KIERvZXNuJ3QgaGFuZGxlIGNvbXBsaWNhdGVkIGV4cHJlc3Npb25zIGJ1aWx0IHBpZWNlbWVh
  bCwgYSBsYToKIAogICAgIGVudW0gewotICAgICAgICBGSVJTVF9WQUxVRSwKLSAgICAgICAgU0VD
  T05EX1ZBTFVFLAorCUZJUlNUX1ZBTFVFLAorCVNFQ09ORF9WQUxVRSwKICAgICAjaWZkZWYgQUJD
  Ci0gICAgICAgIFRISVJEX1ZBTFVFCisJVEhJUkRfVkFMVUUKICAgICAjZW5kaWYKICAgICB9Owog
  Cg==
  UH2PH580
    }
    if ( $num < 5.008009 ) {
      return _patch(<<'UH2PH588');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTg0LDcgKzg0LDcgQEAgc3Vi
  IHJlaW5kZW50KCQpIHsKIH0KIAogbXkgKCR0LCAkdGFiLCAlY3VyYXJncywgJG5ldywgJGV2YWxf
  aW5kZXgsICRkaXIsICRuYW1lLCAkYXJncywgJG91dGZpbGUpOwotbXkgKCRpbmNsLCAkaW5jbF90
  eXBlLCAkbmV4dCk7CitteSAoJGluY2wsICRpbmNsX3R5cGUsICRpbmNsX3F1b3RlLCAkbmV4dCk7
  CiB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUgPSBuZXh0X2ZpbGUoKSkpIHsKICAgICBpZiAoLWwg
  JGZpbGUgYW5kIC1kICRmaWxlKSB7CiAgICAgICAgIGxpbmtfaWZfcG9zc2libGUoJGZpbGUpIGlm
  ICgkb3B0X2wpOwpAQCAtMTg0LDkgKzE4NCwxMCBAQCB3aGlsZSAoZGVmaW5lZCAobXkgJGZpbGUg
  PSBuZXh0X2ZpbGUoKSkpIHsKICAgICAgICAgICAgICAgICAgICAgICBwcmludCBPVVQgJHQsInVu
  bGVzcyhkZWZpbmVkKFwmJG5hbWUpKSB7XG4gICAgc3ViICRuYW1lICgpIHtcdCIsJG5ldywiO31c
  bn1cbiI7CiAJCSAgICB9CiAJCX0KLQkgICAgfSBlbHNpZiAoL14oaW5jbHVkZXxpbXBvcnR8aW5j
  bHVkZV9uZXh0KVxzKls8XCJdKC4qKVs+XCJdLykgeworCSAgICB9IGVsc2lmICgvXihpbmNsdWRl
  fGltcG9ydHxpbmNsdWRlX25leHQpXHMqKFs8XCJdKSguKilbPlwiXS8pIHsKICAgICAgICAgICAg
  ICAgICAkaW5jbF90eXBlID0gJDE7Ci0gICAgICAgICAgICAgICAgJGluY2wgPSAkMjsKKyAgICAg
  ICAgICAgICAgICAkaW5jbF9xdW90ZSA9ICQyOworICAgICAgICAgICAgICAgICRpbmNsID0gJDM7
  CiAgICAgICAgICAgICAgICAgaWYgKCgkaW5jbF90eXBlIGVxICdpbmNsdWRlX25leHQnKSB8fAog
  ICAgICAgICAgICAgICAgICAgICAoJG9wdF9lICYmIGV4aXN0cygkYmFkX2ZpbGV7JGluY2x9KSkp
  IHsKICAgICAgICAgICAgICAgICAgICAgJGluY2wgPX4gcy9cLmgkLy5waC87CkBAIC0yMTksNiAr
  MjIwLDEwIEBAIHdoaWxlIChkZWZpbmVkIChteSAkZmlsZSA9IG5leHRfZmlsZSgpKSkgewogCQkJ
  ICAgIndhcm4oXCRcQCkgaWYgXCRcQDtcbiIpOwogICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAg
  ICAgICAgICAgICAgICAgICAgICRpbmNsID1+IHMvXC5oJC8ucGgvOworICAgICAgICAgICAgICAg
  ICAgICAjIGNvcHkgdGhlIHByZWZpeCBpbiB0aGUgcXVvdGUgc3ludGF4ICgjaW5jbHVkZSAieC5o
  IikgY2FzZQorICAgICAgICAgICAgICAgICAgICBpZiAoJGluY2wgIX4gbXwvfCAmJiAkaW5jbF9x
  dW90ZSBlcSBxeyJ9ICYmICRmaWxlID1+IG18XiguKikvfCkgeworICAgICAgICAgICAgICAgICAg
  ICAgICAgJGluY2wgPSAiJDEvJGluY2wiOworICAgICAgICAgICAgICAgICAgICB9CiAJCSAgICBw
  cmludCBPVVQgJHQsInJlcXVpcmUgJyRpbmNsJztcbiI7CiAgICAgICAgICAgICAgICAgfQogCSAg
  ICB9IGVsc2lmICgvXmlmZGVmXHMrKFx3KykvKSB7CkBAIC00MzEsNyArNDM2LDcgQEAgc3ViIGV4
  cHIgewogCQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVk
  XHMqXCgkLykgewotCQkgICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4g
  JGlkIC4gJyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAm
  JyAuICRpZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAgJG5ldyAu
  PSAiIFwkJGlkIjsKIAkJfSBlbHNlIHsKQEAgLTYzOSw4ICs2NDQsMTMgQEAgc3ViIHF1ZXVlX2lu
  Y2x1ZGVzX2Zyb20KICAgICAgICAgICAgICAgICAkbGluZSAuPSA8SEVBREVSPjsKICAgICAgICAg
  ICAgIH0KIAotICAgICAgICAgICAgaWYgKCRsaW5lID1+IC9eI1xzKmluY2x1ZGVccys8KC4qPyk+
  LykgewotICAgICAgICAgICAgICAgIHB1c2goQEFSR1YsICQxKSB1bmxlc3MgJElzX2NvbnZlcnRl
  ZHskMX07CisgICAgICAgICAgICBpZiAoJGxpbmUgPX4gL14jXHMqaW5jbHVkZVxzKyhbPCJdKSgu
  Kj8pWz4iXS8pIHsKKyAgICAgICAgICAgICAgICBteSAoJGRlbGltaXRlciwgJG5ld19maWxlKSA9
  ICgkMSwgJDIpOworICAgICAgICAgICAgICAgICMgY29weSB0aGUgcHJlZml4IGluIHRoZSBxdW90
  ZSBzeW50YXggKCNpbmNsdWRlICJ4LmgiKSBjYXNlCisgICAgICAgICAgICAgICAgaWYgKCRkZWxp
  bWl0ZXIgZXEgcXsifSAmJiAkZmlsZSA9fiBtfF4oLiopL3wpIHsKKyAgICAgICAgICAgICAgICAg
  ICAgJG5ld19maWxlID0gIiQxLyRuZXdfZmlsZSI7CisgICAgICAgICAgICAgICAgfQorICAgICAg
  ICAgICAgICAgIHB1c2goQEFSR1YsICRuZXdfZmlsZSkgdW5sZXNzICRJc19jb252ZXJ0ZWR7JG5l
  d19maWxlfTsKICAgICAgICAgICAgIH0KICAgICAgICAgfQogICAgIGNsb3NlIEhFQURFUjsKQEAg
  LTY4MSwyNSArNjkxLDUwIEBAIHN1YiBidWlsZF9wcmVhbWJsZV9pZl9uZWNlc3NhcnkKICAgICBt
  eSAoJWRlZmluZSkgPSBfZXh0cmFjdF9jY19kZWZpbmVzKCk7CiAKICAgICBvcGVuICBQUkVBTUJM
  RSwgIj4kcHJlYW1ibGUiIG9yIGRpZSAiQ2Fubm90IG9wZW4gJHByZWFtYmxlOiAgJCEiOwotICAg
  ICAgICBwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJz
  aW9uICRWRVJTSU9OXG4iOwotCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5lKSB7
  Ci0gICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJFQU1C
  TEUgIiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAgIGlm
  ICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmluZXsk
  X30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAgICAg
  ICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7
  JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKKwlwcmludCBQUkVBTUJMRSAiIyBU
  aGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2ZXJzaW9uICRWRVJTSU9OXG4iOworICAgICAg
  ICAjIFByZXZlbnQgbm9uLXBvcnRhYmxlIGhleCBjb25zdGFudHMgZnJvbSB3YXJuaW5nLgorICAg
  ICAgICAjCisgICAgICAgICMgV2Ugc3RpbGwgcHJvZHVjZSBhbiBvdmVyZmxvdyB3YXJuaW5nIGlm
  IHdlIGNhbid0IHJlcHJlc2VudAorICAgICAgICAjIGEgaGV4IGNvbnN0YW50IGFzIGFuIGludGVn
  ZXIuCisgICAgICAgIHByaW50IFBSRUFNQkxFICJubyB3YXJuaW5ncyBxdyhwb3J0YWJsZSk7XG4i
  OworCisJZm9yZWFjaCAoc29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgewor
  CQlwcmludCBQUkVBTUJMRSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAo
  JGRlZmluZXskX30gPX4gL15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTog
  IGQ9KHYpCisJCSRkZWZpbmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99
  ID1+IC9eKFsrLV0/KFxkKyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZs
  b2F0OgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3Vi
  ICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWyst
  XT9cZCspVT9MezAsMn0kL2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkg
  ICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKyAgICAg
  ICAgICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/MHhbXGRhLWZdKylVP0x7MCwy
  fSQvaSkgeworICAgICAgICAgICAgICAgICMgaGV4IGludGVnZXIKKyAgICAgICAgICAgICAgICAj
  IFNwZWNpYWwgY2FzZWQsIHNpbmNlIHBlcmwgd2FybnMgb24gaGV4IGludGVnZXJzCisgICAgICAg
  ICAgICAgICAgIyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGluIGEgVVYuCisgICAgICAgICAg
  ICAgICAgIworICAgICAgICAgICAgICAgICMgVGhpcyB3YXkgd2UgZ2V0IHRoZSB3YXJuaW5nIGF0
  IHRpbWUgb2YgdXNlLCBzbyB0aGUgdXNlcgorICAgICAgICAgICAgICAgICMgb25seSBnZXRzIHRo
  ZSB3YXJuaW5nIGlmIHRoZXkgaGFwcGVuIHRvIHVzZSB0aGlzCisgICAgICAgICAgICAgICAgIyBw
  bGF0Zm9ybS1zcGVjaWZpYyBkZWZpbml0aW9uLgorICAgICAgICAgICAgICAgIG15ICRjb2RlID0g
  JDE7CisgICAgICAgICAgICAgICAgJGNvZGUgPSAiaGV4KCckY29kZScpIiBpZiBsZW5ndGggJGNv
  ZGUgPiAxMDsKICAgICAgICAgICAgICAgICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAg
  ICAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAg
  ICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAg
  ICAgfQotICAgICAgICB9CisgICAgICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRf
  KSB7IHN1YiAkXygpIHsgJGNvZGUgfSB9XG5cbiI7CisJICAgIH0gZWxzaWYgKCRkZWZpbmV7JF99
  ID1+IC9eXHcrJC8pIHsKKwkJcHJpbnQgUFJFQU1CTEUKKwkJICAgICJ1bmxlc3MgKGRlZmluZWQg
  JiRfKSB7IHN1YiAkXygpIHsgJiRkZWZpbmV7JF99IH0gfVxuXG4iOworCSAgICB9IGVsc2Ugewor
  CQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkg
  eyBcIiIsCisJCSAgICBxdW90ZW1ldGEoJGRlZmluZXskX30pLCAiXCIgfSB9XG5cbiI7CisJICAg
  IH0KKwl9CiAgICAgY2xvc2UgUFJFQU1CTEUgICAgICAgICAgICAgICBvciBkaWUgIkNhbm5vdCBj
  bG9zZSAkcHJlYW1ibGU6ICAkISI7CiB9CiAKQEAgLTcxMSwxNSArNzQ2LDE0IEBAIHN1YiBfZXh0
  cmFjdF9jY19kZWZpbmVzCiB7CiAgICAgbXkgJWRlZmluZTsKICAgICBteSAkYWxsc3ltYm9scyAg
  PSBqb2luICIgIiwKLSAgICAgICAgQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAn
  Y3BwY2NzeW1ib2xzJ307CisJQENvbmZpZ3snY2NzeW1ib2xzJywgJ2NwcHN5bWJvbHMnLCAnY3Bw
  Y2NzeW1ib2xzJ307CiAKICAgICAjIFNwbGl0IGNvbXBpbGVyIHByZS1kZWZpbml0aW9ucyBpbnRv
  IGBrZXk9dmFsdWUnIHBhaXJzOgotICAgIGZvcmVhY2ggKHNwbGl0IC9ccysvLCAkYWxsc3ltYm9s
  cykgewotICAgICAgICAvKC4rPyk9KC4rKS8gYW5kICRkZWZpbmV7JDF9ID0gJDI7Ci0KLSAgICAg
  ICAgaWYgKCRvcHRfRCkgewotICAgICAgICAgICAgcHJpbnQgU1RERVJSICIkXzogICQxIC0+ICQy
  XG4iOwotICAgICAgICB9CisgICAgd2hpbGUgKCRhbGxzeW1ib2xzID1+IC8oW15cc10rKT0oKFxc
  XHN8W15cc10pKykvZykgeworCSRkZWZpbmV7JDF9ID0gJDI7CisJaWYgKCRvcHRfRCkgeworCSAg
  ICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7CisJfQogICAgIH0KIAogICAgIHJldHVy
  biAlZGVmaW5lOwpAQCAtNzY5LDcgKzgwMyw3IEBAIElmIHJ1biB3aXRoIG5vIGFyZ3VtZW50cywg
  ZmlsdGVycyBzdGFuZGFyZCBpbnB1dCB0byBzdGFuZGFyZCBvdXRwdXQuCiA9aXRlbSAtZCBkZXN0
  aW5hdGlvbl9kaXIKIAogUHV0IHRoZSByZXN1bHRpbmcgQjwucGg+IGZpbGVzIGJlbmVhdGggQjxk
  ZXN0aW5hdGlvbl9kaXI+LCBpbnN0ZWFkIG9mCi1iZW5lYXRoIHRoZSBkZWZhdWx0IFBlcmwgbGli
  cmFyeSBsb2NhdGlvbiAoQzwkQ29uZmlneydpbnN0YWxsc2l0c2VhcmNoJ30+KS4KK2JlbmVhdGgg
  dGhlIGRlZmF1bHQgUGVybCBsaWJyYXJ5IGxvY2F0aW9uIChDPCRDb25maWd7J2luc3RhbGxzaXRl
  YXJjaCd9PikuCiAKID1pdGVtIC1yCiAKQEAgLTg1NCwxMCArODg4LDEwIEBAIGluc3RhbGxhdGlv
  bi4KIERvZXNuJ3QgaGFuZGxlIGNvbXBsaWNhdGVkIGV4cHJlc3Npb25zIGJ1aWx0IHBpZWNlbWVh
  bCwgYSBsYToKIAogICAgIGVudW0gewotICAgICAgICBGSVJTVF9WQUxVRSwKLSAgICAgICAgU0VD
  T05EX1ZBTFVFLAorCUZJUlNUX1ZBTFVFLAorCVNFQ09ORF9WQUxVRSwKICAgICAjaWZkZWYgQUJD
  Ci0gICAgICAgIFRISVJEX1ZBTFVFCisJVEhJUkRfVkFMVUUKICAgICAjZW5kaWYKICAgICB9Owog
  Cg==
  UH2PH588
    }
    if ( $num > 5.008009 and $num < 5.009002 ) {
      _patch_b64(<<'UH2PH592');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTU4LDEzICs1OCwxNCBAQAog
  ZGllICJEZXN0aW5hdGlvbiBkaXJlY3RvcnkgJERlc3RfZGlyIGRvZXNuJ3QgZXhpc3Qgb3IgaXNu
  J3QgYSBkaXJlY3RvcnlcbiIKICAgICB1bmxlc3MgLWQgJERlc3RfZGlyOwogCi1teSBAaXNhdHlw
  ZSA9IHNwbGl0KCcgJyw8PEVORCk7CitteSBAaXNhdHlwZSA9IHF3KAogCWNoYXIJdWNoYXIJdV9j
  aGFyCiAJc2hvcnQJdXNob3J0CXVfc2hvcnQKIAlpbnQJdWludAl1X2ludAogCWxvbmcJdWxvbmcJ
  dV9sb25nCiAJRklMRQlrZXlfdAljYWRkcl90Ci1FTkQKKwlmbG9hdAlkb3VibGUJc2l6ZV90Cisp
  OwogCiBteSAlaXNhdHlwZTsKIEBpc2F0eXBle0Bpc2F0eXBlfSA9ICgxKSB4IEBpc2F0eXBlOwpA
  QCAtMTMzLDE5ICsxMzQsMjAgQEAKIAkJcy9cKFx3K1xzKlwoXCpcKVxzKlwoXHcqXClcKVxzKigt
  P1xkKykvJDEvOyAjIChpbnQgKCopKGZvb190KSkwCiAJCWlmIChzL15cKChbXHcsXHNdKilcKS8v
  KSB7CiAJCSAgICAkYXJncyA9ICQxOwotICAgIAkgICAgCSAgICBteSAkcHJvdG8gPSAnKCkgJzsK
  KwkJICAgIG15ICRwcm90byA9ICcoKSAnOwogCQkgICAgaWYgKCRhcmdzIG5lICcnKSB7Ci0gICAg
  CSAgICAJICAgIAkkcHJvdG8gPSAnJzsKKwkJCSRwcm90byA9ICcnOwogCQkJZm9yZWFjaCBteSAk
  YXJnIChzcGxpdCgvLFxzKi8sJGFyZ3MpKSB7CiAJCQkgICAgJGFyZyA9fiBzL15ccyooW15cc10u
  KlteXHNdKVxzKiQvJDEvOwogCQkJICAgICRjdXJhcmdzeyRhcmd9ID0gMTsKIAkJCX0KIAkJCSRh
  cmdzID1+IHMvXGIoXHcpL1wkJDEvZzsKLQkJCSRhcmdzID0gImxvY2FsKCRhcmdzKSA9IFxAXztc
  biR0ICAgICI7CisJCQkkYXJncyA9ICJteSgkYXJncykgPSBcQF87XG4kdCAgICAiOwogCQkgICAg
  fQogCQkgICAgcy9eXHMrLy87CiAJCSAgICBleHByKCk7CiAJCSAgICAkbmV3ID1+IHMvKFsiXFxd
  KS9cXCQxL2c7ICAgICAgICMiXSk7CisJCSAgRU1JVDoKIAkJICAgICRuZXcgPSByZWluZGVudCgk
  bmV3KTsKIAkJICAgICRhcmdzID0gcmVpbmRlbnQoJGFyZ3MpOwogCQkgICAgaWYgKCR0IG5lICcn
  KSB7CkBAIC0yNjgsMTIgKzI3MCwxNCBAQAogCSAgICB9IGVsc2lmKC9eaWRlbnRccysoLiopLykg
  ewogCQlwcmludCBPVVQgJHQsICIjICQxXG4iOwogCSAgICB9Ci0JfSBlbHNpZigvXlxzKih0eXBl
  ZGVmXHMqKT9lbnVtXHMqKFxzK1thLXpBLVpfXVx3KlxzKik/LykgeworCX0gZWxzaWYgKC9eXHMq
  KHR5cGVkZWZccyopP2VudW1ccyooXHMrW2EtekEtWl9dXHcqXHMqKT8vKSB7ICMgeyBmb3IgdmkK
  IAkgICAgdW50aWwoL1x7W159XSpcfS4qOy8gfHwgLzsvKSB7CiAJCWxhc3QgdW5sZXNzIGRlZmlu
  ZWQgKCRuZXh0ID0gbmV4dF9saW5lKCRmaWxlKSk7CiAJCWNob21wICRuZXh0OwogCQkjIGRyb3Ag
  IiNkZWZpbmUgRk9PIEZPTyIgaW4gZW51bXMKIAkJJG5leHQgPX4gcy9eXHMqI1xzKmRlZmluZVxz
  KyhcdyspXHMrXDFccyokLy87CisJCSMgI2RlZmluZXMgaW4gZW51bXMgKGFsaWFzZXMpCisJCSRu
  ZXh0ID1+IHMvXlxzKiNccypkZWZpbmVccysoXHcrKVxzKyhcdyspXHMqJC8kMSA9ICQyLC87CiAJ
  CSRfIC49ICRuZXh0OwogCQlwcmludCBPVVQgIiMgJG5leHRcbiIgaWYgJG9wdF9EOwogCSAgICB9
  CkBAIC0yODYsNiArMjkwLDcgQEAKIAkgICAgbXkgJGVudW1fdmFsID0gLTE7CiAJICAgIGZvcmVh
  Y2ggbXkgJGVudW0gKEBlbnVtX3N1YnMpIHsKIAkJbXkgKCRlbnVtX25hbWUsICRlbnVtX3ZhbHVl
  KSA9ICRlbnVtID1+IC9eKFthLXpBLVpfXVx3KikoPS4rKT8kLzsKKwkJJGVudW1fbmFtZSBvciBu
  ZXh0OwogCQkkZW51bV92YWx1ZSA9fiBzL149Ly87CiAJCSRlbnVtX3ZhbCA9IChsZW5ndGgoJGVu
  dW1fdmFsdWUpID8gJGVudW1fdmFsdWUgOiAkZW51bV92YWwgKyAxKTsKIAkJaWYgKCRvcHRfaCkg
  ewpAQCAtMzAwLDYgKzMwNSw3NSBAQAogCQkJICAgICAgICJ1bmxlc3MgZGVmaW5lZChcJiRlbnVt
  X25hbWUpO1xuIik7CiAJCX0KIAkgICAgfQorCX0gZWxzaWYgKC9eKD86X19leHRlbnNpb25fX1xz
  Kyk/KD86ZXh0ZXJufHN0YXRpYylccysoPzpfXyk/aW5saW5lKD86X18pP1xzKy8KKwkgICAgYW5k
  ICEvO1xzKiQvIGFuZCAhL3tccyp9XHMqJC8pCisJeyAjIHsgZm9yIHZpCisJICAgICMgVGhpcyBp
  cyBhIGhhY2sgdG8gcGFyc2UgdGhlIGlubGluZSBmdW5jdGlvbnMgaW4gdGhlIGdsaWJjIGhlYWRl
  cnMuCisJICAgICMgV2FybmluZzogbWFzc2l2ZSBrbHVkZ2UgYWhlYWQuIFdlIHN1cHBvc2UgaW5s
  aW5lIGZ1bmN0aW9ucworCSAgICAjIGFyZSBtYWlubHkgY29uc3RydWN0ZWQgbGlrZSBtYWNyb3Mu
  CisJICAgIHdoaWxlICgxKSB7CisJCWxhc3QgdW5sZXNzIGRlZmluZWQgKCRuZXh0ID0gbmV4dF9s
  aW5lKCRmaWxlKSk7CisJCWNob21wICRuZXh0OworCQl1bmRlZiAkXywgbGFzdCBpZiAkbmV4dCA9
  fiAvX19USFJPV1xzKjsvCisJCQkgICAgICAgb3IgJG5leHQgPX4gL14oX19leHRlbnNpb25fX3xl
  eHRlcm58c3RhdGljKVxiLzsKKwkJJF8gLj0gIiAkbmV4dCI7CisJCXByaW50IE9VVCAiIyAkbmV4
  dFxuIiBpZiAkb3B0X0Q7CisJCWxhc3QgaWYgJG5leHQgPX4gL159fF57Lip9XHMqJC87CisJICAg
  IH0KKwkgICAgbmV4dCBpZiBub3QgZGVmaW5lZDsgIyBiZWNhdXNlIGl0J3Mgb25seSBhIHByb3Rv
  dHlwZQorCSAgICBzL1xiKF9fZXh0ZW5zaW9uX198ZXh0ZXJufHN0YXRpY3woPzpfXyk/aW5saW5l
  KD86X18pPylcYi8vZzsKKwkgICAgIyB2aW9sZW50bHkgZHJvcCAjaWZkZWZzCisJICAgIHMvI1xz
  KmlmLio/I1xzKmVuZGlmLy9nCisJCWFuZCBwcmludCBPVVQgIiMgc29tZSAjaWZkZWYgd2VyZSBk
  cm9wcGVkIGhlcmUgLS0gZmlsbCBpbiB0aGUgYmxhbmtzXG4iOworCSAgICBpZiAocy9eKD86XHd8
  XHN8XCopKlxzKFx3KylccyovLykgeworCQkkbmFtZSA9ICQxOworCSAgICB9IGVsc2UgeworCQl3
  YXJuICJuYW1lIG5vdCBmb3VuZCI7IG5leHQ7ICMgc2hvdWxkbid0IG9jY3VyLi4uCisJICAgIH0K
  KwkgICAgbXkgQGFyZ3M7CisJICAgIGlmIChzL15cKChbXigpXSopXClccyooXHcrXHMqKSovLykg
  eworCQlmb3IgbXkgJGFyZyAoc3BsaXQgLywvLCAkMSkgeworCQkgICAgaWYgKCRhcmcgPX4gLyhc
  dyspXHMqJC8pIHsKKwkJCSRjdXJhcmdzeyQxfSA9IDE7CisJCQlwdXNoIEBhcmdzLCAkMTsKKwkJ
  ICAgIH0KKwkJfQorCSAgICB9CisJICAgICRhcmdzID0gKAorCQlAYXJncworCQk/ICJteSgiIC4g
  KGpvaW4gJywnLCBtYXAgIlwkJF8iLCBAYXJncykgLiAiKSA9IFxAXztcbiR0ICAgICIKKwkJOiAi
  IgorCSAgICApOworCSAgICBteSAkcHJvdG8gPSBAYXJncyA/ICcnIDogJygpICc7CisJICAgICRu
  ZXcgPSAnJzsKKwkgICAgcy9cYnJldHVyblxiLy9nOyAjICJyZXR1cm4iIGRvZXNuJ3Qgb2NjdXIg
  aW4gbWFjcm9zIHVzdWFsbHkuLi4KKwkgICAgZXhwcigpOworCSAgICAjIHRyeSB0byBmaW5kIGFu
  ZCBwZXJsaWZ5IGxvY2FsIEMgdmFyaWFibGVzCisJICAgIG91ciBAbG9jYWxfdmFyaWFibGVzID0g
  KCk7ICMgbmVlZHMgdG8gYmUgYSBvdXIoKTogKD97Li4ufSkgYnVnIHdvcmthcm91bmQKKwkgICAg
  eworCQl1c2UgcmUgImV2YWwiOworCQlteSAkdHlwZWxpc3QgPSBqb2luICd8Jywga2V5cyAlaXNh
  dHlwZTsKKwkJJG5ldyA9fiBzWycKKwkJICAoPzooPzp1bik/c2lnbmVkXHMrKT8KKwkJICAoPzps
  b25nXHMrKT8KKwkJICAoPzokdHlwZWxpc3QpXHMrCisJCSAgKFx3KykKKwkJICAoP3sgcHVzaCBA
  bG9jYWxfdmFyaWFibGVzLCAkMSB9KQorCQkgICddCisJCSBbbXkgXCQkMV1neDsKKwkJJG5ldyA9
  fiBzWycKKwkJICAoPzooPzp1bik/c2lnbmVkXHMrKT8KKwkJICAoPzpsb25nXHMrKT8KKwkJICAo
  PzokdHlwZWxpc3QpXHMrCisJCSAgJyBccysgJihcdyspIFxzKiA7CisJCSAgKD97IHB1c2ggQGxv
  Y2FsX3ZhcmlhYmxlcywgJDEgfSkKKwkJICBdCisJCSBbbXkgXCQkMTtdZ3g7CisJICAgICB9CisJ
  ICAgICRuZXcgPX4gcy8mJF9cYi9cJCRfL2cgZm9yIEBsb2NhbF92YXJpYWJsZXM7CisJICAgICRu
  ZXcgPX4gcy8oWyJcXF0pL1xcJDEvZzsgICAgICAgIyJdKTsKKwkgICAgIyBub3cgdGhhdCdzIGFs
  bW9zdCBsaWtlIGEgbWFjcm8gKHdlIGhvcGUpCisJICAgIGdvdG8gRU1JVDsKIAl9CiAgICAgfQog
  ICAgICRJc19jb252ZXJ0ZWR7JGZpbGV9ID0gMTsKQEAgLTMwOCw3ICszODIsNyBAQAogICAgICAg
  ICAkbmV4dCA9ICcnOwogICAgIH0gZWxzZSB7CiAgICAgICAgIHByaW50IE9VVCAiMTtcbiI7Ci0g
  ICAgcXVldWVfaW5jbHVkZXNfZnJvbSgkZmlsZSkgaWYgKCRvcHRfYSk7CisJcXVldWVfaW5jbHVk
  ZXNfZnJvbSgkZmlsZSkgaWYgJG9wdF9hOwogICAgIH0KIH0KIApAQCAtMzIwLDYgKzM5NCw3IEBA
  CiBleGl0ICRFeGl0OwogCiBzdWIgZXhwciB7CisgICAgJG5ldyA9ICciKGFzc2VtYmx5IGNvZGUp
  IicgYW5kIHJldHVybiBpZiAvXGJfX2FzbV9fXGIvOyAjIGZyZWFrIG91dC4KICAgICBteSAkam9p
  bmVkX2FyZ3M7CiAgICAgaWYoa2V5cyglY3VyYXJncykpIHsKIAkkam9pbmVkX2FyZ3MgPSBqb2lu
  KCd8Jywga2V5cyglY3VyYXJncykpOwpAQCAtMzI4LDcgKzQwMyw3IEBACiAJcy9eXCZcJi8vICYm
  IGRvIHsgJG5ldyAuPSAiICYmIjsgbmV4dDt9OyAjIGhhbmRsZSAmJiBvcGVyYXRvcgogCXMvXlwm
  KFtcKGEtelwpXSspLyQxL2k7CSMgaGFjayBmb3IgdGhpbmdzIHRoYXQgdGFrZSB0aGUgYWRkcmVz
  cyBvZgogCXMvXihccyspLy8JCSYmIGRvIHskbmV3IC49ICcgJzsgbmV4dDt9OwotCXMvXjBYKFsw
  LTlBLUZdKylbVUxdKi8vaSAKKwlzL14wWChbMC05QS1GXSspW1VMXSovL2kKIAkgICAgJiYgZG8g
  e215ICRoZXggPSAkMTsKIAkJICAgJGhleCA9fiBzL14wKy8vOwogCQkgICBpZiAobGVuZ3RoICRo
  ZXggPiA4ICYmICEkQ29uZmlne3VzZTY0Yml0aW50fSkgewpAQCAtMzgwLDEwICs0NTUsMTYgQEAK
  ICAgICAgICAgfTsKIAkjIEVsaW1pbmF0ZSB0eXBlZGVmcwogCS9cKChbXHdcc10rKVtcKlxzXSpc
  KVxzKltcd1woXS8gJiYgZG8geworCSAgICBteSAkZG9pdCA9IDE7CiAJICAgIGZvcmVhY2ggKHNw
  bGl0IC9ccysvLCAkMSkgeyAgIyBNYWtlIHN1cmUgYWxsIHRoZSB3b3JkcyBhcmUgdHlwZXMsCi0J
  CWxhc3QgdW5sZXNzICgkaXNhdHlwZXskX30gb3IgJF8gZXEgJ3N0cnVjdCcgb3IgJF8gZXEgJ3Vu
  aW9uJyk7CisJICAgICAgICB1bmxlc3MoJGlzYXR5cGV7JF99IG9yICRfIGVxICdzdHJ1Y3QnIG9y
  ICRfIGVxICd1bmlvbicpeworCQkgICAgJGRvaXQgPSAwOworCQkgICAgbGFzdDsKKwkJfQorCSAg
  ICB9CisJICAgIGlmKCAkZG9pdCApeworCQlzL1woW1x3XHNdK1tcKlxzXSpcKS8vICYmIG5leHQ7
  ICAgICAgIyB0aGVuIGVsaW1pbmF0ZSB0aGVtLgogCSAgICB9Ci0JICAgIHMvXChbXHdcc10rW1wq
  XHNdKlwpLy8gJiYgbmV4dDsgICAgICAjIHRoZW4gZWxpbWluYXRlIHRoZW0uCiAJfTsKIAkjIHN0
  cnVjdC91bmlvbiBtZW1iZXIsIGluY2x1ZGluZyBhcnJheXM6CiAJcy9eKFtfQS1aXVx3KihcW1te
  XF1dK1xdKT8oKFwufC0+KVtfQS1aXVx3KihcW1teXF1dK1xdKT8pKykvL2kgJiYgZG8gewpAQCAt
  NDU4LDcgKzUzOSw3IEBACiAKICAgICAgICAgd2hpbGUgKGxlbmd0aCAkaW4pIHsKICAgICAgICAg
  ICAgIGlmICgkcHJlX3N1Yl90cmlfZ3JhcGhzKSB7Ci0gICAgICAgICAgICAgICAgIyBQcmVwcm9j
  ZXNzIGFsbCB0cmktZ3JhcGhzIAorICAgICAgICAgICAgICAgICMgUHJlcHJvY2VzcyBhbGwgdHJp
  LWdyYXBocwogICAgICAgICAgICAgICAgICMgaW5jbHVkaW5nIHRoaW5ncyBzdHVjayBpbiBxdW90
  ZWQgc3RyaW5nIGNvbnN0YW50cy4KICAgICAgICAgICAgICAgICAkaW4gPX4gcy9cP1w/PS8jL2c7
  ICAgICAgICAgICAgICAgICAgICAgICAgICMgfCA/Pz18ICAjfAogICAgICAgICAgICAgICAgICRp
  biA9fiBzL1w/XD9cIS98L2c7ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/IXwgIHx8CkBA
  IC00NzEsMTcgKzU1MiwxOSBAQAogICAgICAgICAgICAgICAgICRpbiA9fiBzL1w/XD8+L30vZzsg
  ICAgICAgICAgICAgICAgICAgICAgICAgIyB8ID8/PnwgIH18CiAgICAgICAgICAgICB9CiAJICAg
  IGlmICgkaW4gPX4gL15cI2lmZGVmIF9fTEFOR1VBR0VfUEFTQ0FMX18vKSB7Ci0gICAgICAgICAg
  ICAgICAgIyBUcnU2NCBkaXNhc3NlbWJsZXIuaCBldmlsbmVzczogbWl4ZWQgQyBhbmQgUGFzY2Fs
  LgorCQkjIFRydTY0IGRpc2Fzc2VtYmxlci5oIGV2aWxuZXNzOiBtaXhlZCBDIGFuZCBQYXNjYWwu
  CiAJCXdoaWxlICg8SU4+KSB7Ci0JCSAgICBsYXN0IGlmIC9eXCNlbmRpZi87IAorCQkgICAgbGFz
  dCBpZiAvXlwjZW5kaWYvOwogCQl9CisJCSRpbiA9ICIiOwogCQluZXh0IFJFQUQ7CiAJICAgIH0K
  IAkgICAgaWYgKCRpbiA9fiAvXmV4dGVybiBpbmxpbmUgLyAmJiAjIElubGluZWQgYXNzZW1ibGVy
  LgogCQkkXk8gZXEgJ2xpbnV4JyAmJiAkZmlsZSA9fiBtISg/Ol58Lylhc20vW14vXStcLmgkISkg
  ewotIAkJd2hpbGUgKDxJTj4pIHsKLQkJICAgIGxhc3QgaWYgL159LzsgCisJCXdoaWxlICg8SU4+
  KSB7CisJCSAgICBsYXN0IGlmIC9efS87CiAJCX0KKwkJJGluID0gIiI7CiAJCW5leHQgUkVBRDsK
  IAkgICAgfQogICAgICAgICAgICAgaWYgKCRpbiA9fiBzL1xcJC8vKSB7ICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgIyBcLW5ld2xpbmUK
  UH2PH592
    }
    if ( $num > 5.008009 and $num < 5.009003 ) {
      _patch_b64(<<'UH2PH593');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTM1NCw2ICszNTQsNyBAQAog
  CQl1c2UgcmUgImV2YWwiOwogCQlteSAkdHlwZWxpc3QgPSBqb2luICd8Jywga2V5cyAlaXNhdHlw
  ZTsKIAkJJG5ldyA9fiBzWycKKwkJICAoPzooPzpfXyk/Y29uc3QoPzpfXyk/XHMrKT8KIAkJICAo
  PzooPzp1bik/c2lnbmVkXHMrKT8KIAkJICAoPzpsb25nXHMrKT8KIAkJICAoPzokdHlwZWxpc3Qp
  XHMrCkBAIC0zNjIsNiArMzYzLDcgQEAKIAkJICAnXQogCQkgW215IFwkJDFdZ3g7CiAJCSRuZXcg
  PX4gc1snCisJCSAgKD86KD86X18pP2NvbnN0KD86X18pP1xzKyk/CiAJCSAgKD86KD86dW4pP3Np
  Z25lZFxzKyk/CiAJCSAgKD86bG9uZ1xzKyk/CiAJCSAgKD86JHR5cGVsaXN0KVxzKwpAQCAtNzM0
  LDkgKzczNiwxNSBAQAogIyBub24tR0NDPykgQyBjb21waWxlcnMsIGJ1dCBnY2MgdXNlcyBhbiBh
  ZGRpdGlvbmFsIGluY2x1ZGUgZGlyZWN0b3J5Lgogc3ViIGluY19kaXJzCiB7Ci0gICAgbXkgJGZy
  b21fZ2NjICAgID0gYCRDb25maWd7Y2N9IC12IDI+JjFgOwotICAgICRmcm9tX2djYyAgICAgICA9
  fiBzOl5SZWFkaW5nIHNwZWNzIGZyb20gKC4qPykvc3BlY3NcYi4qOiQxL2luY2x1ZGU6czsKLQor
  ICAgIG15ICRmcm9tX2djYyAgICA9IGBMQ19BTEw9QyAkQ29uZmlne2NjfSAtdiAyPiYxYDsKKyAg
  ICBpZiggISggJGZyb21fZ2NjID1+IHM6XlJlYWRpbmcgc3BlY3MgZnJvbSAoLio/KS9zcGVjc1xi
  Lio6JDEvaW5jbHVkZTpzICkgKQorICAgIHsgIyBnY2MtNCsgOgorICAgICAgICRmcm9tX2djYyAg
  ID0gYExDX0FMTD1DICRDb25maWd7Y2N9IC1wcmludC1zZWFyY2gtZGlycyAyPiYxYDsKKyAgICAg
  ICBpZiAoICEoJGZyb21fZ2NjID1+IHMvXmluc3RhbGw6XHMqKFteXHNdK1teXHNcL10pKFtcc1wv
  XSopLiokLyQxXC9pbmNsdWRlL3MpICkKKyAgICAgICB7CisgICAgICAgICAgICRmcm9tX2djYyA9
  ICcnOworICAgICAgIH07CisgICAgfTsKICAgICBsZW5ndGgoJGZyb21fZ2NjKSA/ICgkZnJvbV9n
  Y2MsICRDb25maWd7dXNyaW5jfSkgOiAoJENvbmZpZ3t1c3JpbmN9KTsKIH0KIAo=
  UH2PH593
    }
    if ( $num > 5.008009 and $num < 5.009004 ) {
      _patch_b64(<<'UH2PH594');
  LS0tIHV0aWxzL2gycGguUEwKKysrIHV0aWxzL2gycGguUEwKQEAgLTUxNCw3ICs1MTQsNyBAQAog
  CQl9CiAJICAgIH0gZWxzZSB7CiAJCWlmICgkaW5pZiAmJiAkbmV3ICF+IC9kZWZpbmVkXHMqXCgk
  LykgewotCQkgICAgJG5ldyAuPSAnKGRlZmluZWQoJicgLiAkaWQgLiAnKSA/ICYnIC4gJGlkIC4g
  JyA6IDApJzsKKwkJICAgICRuZXcgLj0gJyhkZWZpbmVkKCYnIC4gJGlkIC4gJykgPyAmJyAuICRp
  ZCAuICcgOiB1bmRlZiknOwogCQl9IGVsc2lmICgvXlxbLykgewogCQkgICAgJG5ldyAuPSAiIFwk
  JGlkIjsKIAkJfSBlbHNlIHsKQEAgLTc3MiwyNSArNzcyLDMzIEBACiAgICAgbXkgKCVkZWZpbmUp
  ID0gX2V4dHJhY3RfY2NfZGVmaW5lcygpOwogCiAgICAgb3BlbiAgUFJFQU1CTEUsICI+JHByZWFt
  YmxlIiBvciBkaWUgIkNhbm5vdCBvcGVuICRwcmVhbWJsZTogICQhIjsKLSAgICAgICAgcHJpbnQg
  UFJFQU1CTEUgIiMgVGhpcyBmaWxlIHdhcyBjcmVhdGVkIGJ5IGgycGggdmVyc2lvbiAkVkVSU0lP
  TlxuIjsKKwlwcmludCBQUkVBTUJMRSAiIyBUaGlzIGZpbGUgd2FzIGNyZWF0ZWQgYnkgaDJwaCB2
  ZXJzaW9uICRWRVJTSU9OXG4iOwogCi0gICAgICAgIGZvcmVhY2ggKHNvcnQga2V5cyAlZGVmaW5l
  KSB7Ci0gICAgICAgICAgICBpZiAoJG9wdF9EKSB7Ci0gICAgICAgICAgICAgICAgcHJpbnQgUFJF
  QU1CTEUgIiMgJF89JGRlZmluZXskX31cbiI7Ci0gICAgICAgICAgICB9Ci0KLSAgICAgICAgICAg
  IGlmICgkZGVmaW5leyRffSA9fiAvXihcZCspVT9MezAsMn0kL2kpIHsKLSAgICAgICAgICAgICAg
  ICBwcmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYk
  XykgeyBzdWIgJF8oKSB7ICQxIH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNpZiAoJGRlZmlu
  ZXskX30gPX4gL15cdyskLykgewotICAgICAgICAgICAgICAgIHByaW50IFBSRUFNQkxFCi0gICAg
  ICAgICAgICAgICAgICAgICJ1bmxlc3MgKGRlZmluZWQgJiRfKSB7IHN1YiAkXygpIHsgJiRkZWZp
  bmV7JF99IH0gfVxuXG4iOwotICAgICAgICAgICAgfSBlbHNlIHsKLSAgICAgICAgICAgICAgICBw
  cmludCBQUkVBTUJMRQotICAgICAgICAgICAgICAgICAgICAidW5sZXNzIChkZWZpbmVkICYkXykg
  eyBzdWIgJF8oKSB7IFwiIiwKLSAgICAgICAgICAgICAgICAgICAgcXVvdGVtZXRhKCRkZWZpbmV7
  JF99KSwgIlwiIH0gfVxuXG4iOwotICAgICAgICAgICAgfQotICAgICAgICB9CisJZm9yZWFjaCAo
  c29ydCBrZXlzICVkZWZpbmUpIHsKKwkgICAgaWYgKCRvcHRfRCkgeworCQlwcmludCBQUkVBTUJM
  RSAiIyAkXz0kZGVmaW5leyRffVxuIjsKKwkgICAgfQorCSAgICBpZiAoJGRlZmluZXskX30gPX4g
  L15cKCguKilcKSQvKSB7CisJCSMgcGFyZW50aGVzaXplZCB2YWx1ZTogIGQ9KHYpCisJCSRkZWZp
  bmV7JF99ID0gJDE7CisJICAgIH0KKwkgICAgaWYgKCRkZWZpbmV7JF99ID1+IC9eKFsrLV0/KFxk
  Kyk/XC5cZCsoW2VFXVsrLV0/XGQrKT8pW0ZMXT8kLykgeworCQkjIGZsb2F0OgorCQlwcmludCBQ
  UkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVmaW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1c
  blxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmluZXskX30gPX4gL14oWystXT9cZCspVT9MezAsMn0k
  L2kpIHsKKwkJIyBpbnRlZ2VyOgorCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVm
  aW5lZCAmJF8pIHsgc3ViICRfKCkgeyAkMSB9IH1cblxuIjsKKwkgICAgfSBlbHNpZiAoJGRlZmlu
  ZXskX30gPX4gL15cdyskLykgeworCQlwcmludCBQUkVBTUJMRQorCQkgICAgInVubGVzcyAoZGVm
  aW5lZCAmJF8pIHsgc3ViICRfKCkgeyAmJGRlZmluZXskX30gfSB9XG5cbiI7CisJICAgIH0gZWxz
  ZSB7CisJCXByaW50IFBSRUFNQkxFCisJCSAgICAidW5sZXNzIChkZWZpbmVkICYkXykgeyBzdWIg
  JF8oKSB7IFwiIiwKKwkJICAgIHF1b3RlbWV0YSgkZGVmaW5leyRffSksICJcIiB9IH1cblxuIjsK
  KwkgICAgfQorCX0KICAgICBjbG9zZSBQUkVBTUJMRSAgICAgICAgICAgICAgIG9yIGRpZSAiQ2Fu
  bm90IGNsb3NlICRwcmVhbWJsZTogICQhIjsKIH0KIApAQCAtODAyLDE1ICs4MTAsMTQgQEAKIHsK
  ICAgICBteSAlZGVmaW5lOwogICAgIG15ICRhbGxzeW1ib2xzICA9IGpvaW4gIiAiLAotICAgICAg
  ICBAQ29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMnfTsKKwlA
  Q29uZmlneydjY3N5bWJvbHMnLCAnY3Bwc3ltYm9scycsICdjcHBjY3N5bWJvbHMnfTsKIAogICAg
  ICMgU3BsaXQgY29tcGlsZXIgcHJlLWRlZmluaXRpb25zIGludG8gYGtleT12YWx1ZScgcGFpcnM6
  Ci0gICAgZm9yZWFjaCAoc3BsaXQgL1xzKy8sICRhbGxzeW1ib2xzKSB7Ci0gICAgICAgIC8oLis/
  KT0oLispLyBhbmQgJGRlZmluZXskMX0gPSAkMjsKLQotICAgICAgICBpZiAoJG9wdF9EKSB7Ci0g
  ICAgICAgICAgICBwcmludCBTVERFUlIgIiRfOiAgJDEgLT4gJDJcbiI7Ci0gICAgICAgIH0KKyAg
  ICB3aGlsZSAoJGFsbHN5bWJvbHMgPX4gLyhbXlxzXSspPSgoXFxcc3xbXlxzXSkrKS9nKSB7CisJ
  JGRlZmluZXskMX0gPSAkMjsKKwlpZiAoJG9wdF9EKSB7CisJICAgIHByaW50IFNUREVSUiAiJF86
  ICAkMSAtPiAkMlxuIjsKKwl9CiAgICAgfQogCiAgICAgcmV0dXJuICVkZWZpbmU7CkBAIC05NDUs
  MTAgKzk1MiwxMCBAQAogRG9lc24ndCBoYW5kbGUgY29tcGxpY2F0ZWQgZXhwcmVzc2lvbnMgYnVp
  bHQgcGllY2VtZWFsLCBhIGxhOgogCiAgICAgZW51bSB7Ci0gICAgICAgIEZJUlNUX1ZBTFVFLAot
  ICAgICAgICBTRUNPTkRfVkFMVUUsCisJRklSU1RfVkFMVUUsCisJU0VDT05EX1ZBTFVFLAogICAg
  ICNpZmRlZiBBQkMKLSAgICAgICAgVEhJUkRfVkFMVUUKKwlUSElSRF9WQUxVRQogICAgICNlbmRp
  ZgogICAgIH07CiAK
  UH2PH594
    }
    # All the rest
    _patch(<<'UH2PH');
  --- utils/h2ph.PL
  +++ utils/h2ph.PL
  @@ -788,6 +788,11 @@ sub build_preamble_if_necessary
   
       open  PREAMBLE, ">$preamble" or die "Cannot open $preamble:  $!";
   	print PREAMBLE "# This file was created by h2ph version $VERSION\n";
  +        # Prevent non-portable hex constants from warning.
  +        #
  +        # We still produce an overflow warning if we can't represent
  +        # a hex constant as an integer.
  +        print PREAMBLE "no warnings qw(portable);\n";
   
   	foreach (sort keys %define) {
   	    if ($opt_D) {
  @@ -814,6 +819,18 @@ DEFINE
   		# integer:
   		print PREAMBLE
   		    "unless (defined &$_) { sub $_() { $1 } }\n\n";
  +            } elsif ($define{$_} =~ /^([+-]?0x[\da-f]+)U?L{0,2}$/i) {
  +                # hex integer
  +                # Special cased, since perl warns on hex integers
  +                # that can't be represented in a UV.
  +                #
  +                # This way we get the warning at time of use, so the user
  +                # only gets the warning if they happen to use this
  +                # platform-specific definition.
  +                my $code = $1;
  +                $code = "hex('$code')" if length $code > 10;
  +                print PREAMBLE
  +                    "unless (defined &$_) { sub $_() { $code } }\n\n";
   	    } elsif ($define{$_} =~ /^\w+$/) {
   		my $def = $define{$_};
   		if ($isatype{$def}) {
  UH2PH
  }
  
  sub _patch_lib_h2ph {
    my $perlver = shift;
    my $num = _norm_ver( $perlver );
    return unless $num < 5.021010;
    return if    $num == 5.020003;
    if ( $num >= 5.013005 ) {
      _patch(<<'LH2PH1');
  --- lib/h2ph.t
  +++ lib/h2ph.t
  @@ -48,7 +48,7 @@ $result = runperl( progfile => '_h2ph_pre.ph',
                      stderr => 1 );
   like( $result, qr/syntax OK$/, "preamble compiles");
   
  -$result = runperl( switches => ["-w"],
  +$result = runperl( switches => ['-I.', "-w"],
                      stderr => 1,
                      prog => <<'PROG' );
   $SIG{__WARN__} = sub { die $_[0] }; require q(lib/h2ph.pht);
  LH2PH1
    }
    elsif ( $num >= 5.013001 ) {
      _patch(<<'LH2PH2');
  --- lib/h2ph.t
  +++ lib/h2ph.t
  @@ -48,7 +48,7 @@ $result = runperl( progfile => '_h2ph_pre.ph',
                      stderr => 1 );
   like( $result, qr/syntax OK$/, "preamble compiles");
   
  -$result = runperl( switches => ["-w"], 
  +$result = runperl( switches => ['-I.', "-w"], 
                      stderr => 1,
                      prog => <<'PROG' );
   $SIG{__WARN__} = sub { die $_[0] }; require q(lib/h2ph.pht);
  LH2PH2
    }
    elsif ( $num >= 5.010001 ) {
      _patch(<<'LH2PH3');
  --- lib/h2ph.t
  +++ lib/h2ph.t
  @@ -41,7 +41,7 @@ $result = runperl( progfile => 'lib/h2ph.pht',
                      stderr => 1 );
   like( $result, qr/syntax OK$/, "output compiles");
   
  -$result = runperl( switches => ["-w"], 
  +$result = runperl( switches => ['-I.',"-w"], 
                      prog => '$SIG{__WARN__} = sub { die $_[0] }; require q(lib/h2ph.pht);');
   is( $result, '', "output free of warnings" );
   
  LH2PH3
    }
  }
  
  qq[patchin'];
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::PatchPerl - Patch perl source a la Devel::PPPort's buildperl.pl
  
  =head1 VERSION
  
  version 1.78
  
  =head1 SYNOPSIS
  
    use strict;
    use warnings;
  
    use Devel::PatchPerl;
  
    Devel::PatchPerl->patch_source( '5.6.1', '/path/to/untarred/perl/source/perl-5.6.1' );
  
  =head1 DESCRIPTION
  
  Devel::PatchPerl is a modularisation of the patching code contained in L<Devel::PPPort>'s
  C<buildperl.pl>.
  
  It does not build perls, it merely provides an interface to the source patching
  functionality.
  
  =head1 FUNCTION
  
  =over
  
  =item C<patch_source>
  
  Takes two parameters, a C<perl> version and the path to unwrapped perl source for that version.
  It dies on any errors.
  
  If you don't supply a C<perl> version, it will attempt to auto-determine the
  C<perl> version from the specified path.
  
  If you don't supply the path to unwrapped perl source, it will assume the
  current working directory.
  
  =item C<determine_version>
  
  Takes one optional parameter, the path to unwrapped perl source. It returns the perl version
  of the source code at the given location. It returns undef on error.
  
  If you don't supply the path to unwrapped perl source, it will assume the
  current working directory.
  
  =back
  
  =head1 PLUGIN SYSTEM
  
  See L<Devel::PatchPerl::Plugin> for details of Devel::PatchPerl's plugin system.
  
  =head1 CAVEAT
  
  Devel::PatchPerl is intended only to facilitate the C<building> of perls, not to
  facilitate the C<testing> of perls. This means that it will not patch failing tests
  in the perl testsuite.
  
  =head1 SEE ALSO
  
  L<Devel::PPPort>
  
  L<Devel::PatchPerl::Plugin>
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2019 by Chris Williams and Marcus Holland-Moritz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DEVEL_PATCHPERL

$fatpacked{"Devel/PatchPerl/Hints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL_HINTS';
  package Devel::PatchPerl::Hints;
  $Devel::PatchPerl::Hints::VERSION = '1.78';
  #ABSTRACT: replacement 'hints' files
  
  use strict;
  use warnings;
  use MIME::Base64 qw[decode_base64];
  use File::Spec;
  
  our @ISA            = qw[Exporter];
  our @EXPORT_OK      = qw[hint_file hints];
  
  my %hints = (
  'bitrig' =>
  'IyBoaW50cy9vcGVuYnNkLnNoCiMKIyBoaW50cyBmaWxlIGZvciBPcGVuQlNEOyBUb2RkIE1pbGxl
  ciA8bWlsbGVydEBvcGVuYnNkLm9yZz4KIyBFZGl0ZWQgdG8gYWxsb3cgQ29uZmlndXJlIGNvbW1h
  bmQtbGluZSBvdmVycmlkZXMgYnkKIyAgQW5keSBEb3VnaGVydHkgPGRvdWdoZXJhQGxhZmF5ZXR0
  ZS5lZHU+CiMKIyBUbyBidWlsZCB3aXRoIGRpc3RyaWJ1dGlvbiBwYXRocywgdXNlOgojCS4vQ29u
  ZmlndXJlIC1kZXMgLURvcGVuYnNkX2Rpc3RyaWJ1dGlvbj1kZWZpbmVkCiMKCiMgT3BlbkJTRCBo
  YXMgYSBiZXR0ZXIgbWFsbG9jIHRoYW4gcGVybC4uLgp0ZXN0ICIkdXNlbXltYWxsb2MiIHx8IHVz
  ZW15bWFsbG9jPSduJwoKIyBDdXJyZW50bHksIHZmb3JrKDIpIGlzIG5vdCBhIHJlYWwgd2luIG92
  ZXIgZm9yaygyKS4KdXNldmZvcms9IiR1bmRlZiIKCiMKIyBOb3QgYWxsIHBsYXRmb3JtcyBzdXBw
  b3J0IGR5bmFtaWMgbG9hZGluZy4uLgojIEZvciB0aGUgY2FzZSBvZiAiJG9wZW5ic2RfZGlzdHJp
  YnV0aW9uIiwgdGhlIGhpbnRzIGZpbGUKIyBuZWVkcyB0byBrbm93IHdoZXRoZXIgd2UgYXJlIHVz
  aW5nIGR5bmFtaWMgbG9hZGluZyBzbyB0aGF0CiMgaXQgY2FuIHNldCB0aGUgbGlicGVybCBuYW1l
  IGFwcHJvcHJpYXRlbHkuCiMgQWxsb3cgY29tbWFuZCBsaW5lIG92ZXJyaWRlcy4KIwojQVJDSD1g
  YXJjaCB8IHNlZCAncy9eT3BlbkJTRC4vLydgCkFSQ0g9YGFyY2ggfCBzZWQgJ3MvXkJpdHJpZy4v
  LydgCmNhc2UgIiR7QVJDSH0tJHtvc3ZlcnN9IiBpbgoqKQoJdGVzdCAteiAiJHVzZWRsIiAmJiB1
  c2VkbD0kZGVmaW5lCgkjIFdlIHVzZSAtZlBJQyBoZXJlIGJlY2F1c2UgLWZwaWMgaXMgKk5PVCog
  ZW5vdWdoIGZvciBzb21lIG9mIHRoZQoJIyBleHRlbnNpb25zIGxpa2UgVGsgb24gc29tZSBPcGVu
  QlNEIHBsYXRmb3JtcyAoaWU6IHNwYXJjKQoJY2NjZGxmbGFncz0iLURQSUMgLWZQSUMgJGNjY2Rs
  ZmxhZ3MiCgljYXNlICIkb3N2ZXJzIiBpbgoJKikgIyBmcm9tIDMuMSBvbndhcmRzCgkJbGQ9JHtj
  YzotY2N9CgkJbGRkbGZsYWdzPSItc2hhcmVkIC1mUElDICRsZGRsZmxhZ3MiCgkJbGlic3dhbnRl
  ZD1gZWNobyAkbGlic3dhbnRlZCB8IHNlZCAncy8gZGwgLyAvJ2AKCQk7OwoJZXNhYwoKCSMgV2Ug
  bmVlZCB0byBmb3JjZSBsZCB0byBleHBvcnQgc3ltYm9scyBvbiBFTEYgcGxhdGZvcm1zLgoJIyBX
  aXRob3V0IHRoaXMsIGRsb3BlbigpIGlzIGNyaXBwbGVkLgoJRUxGPWAke2NjOi1jY30gLWRNIC1F
  IC0gPC9kZXYvbnVsbCB8IGdyZXAgX19FTEZfX2AKCXRlc3QgLW4gIiRFTEYiICYmIGxkZmxhZ3M9
  Ii1XbCwtRSAkbGRmbGFncyIKCTs7CmVzYWMKCiMgbWFsbG9jIHdyYXAgY2F1c2VzIHByb2JsZW1z
  IG9uIG02OGsKaWYgWyBYIiR1c2VtYWxsb2N3cmFwIiA9IFgiIiBdOyB0aGVuCgljYXNlICIke0FS
  Q0h9IiBpbgoJKikgICAgdXNlbWFsbG9jd3JhcD0iZGVmaW5lIiA7OwoJZXNhYwpmaQoKIyBPcGVu
  QlNEIGRvZXNuJ3QgbmVlZCBsaWJjcnlwdCBidXQgbWFueSBmb2xrcyBrZWVwIGEgc3R1YiBsaWIK
  IyBhcm91bmQgZm9yIG9sZCBOZXRCU0QgYmluYXJpZXMuCmxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3
  YW50ZWQgfCBzZWQgJ3MvIGNyeXB0IC8gLydgCgojIENvbmZpZ3VyZSBjYW4ndCBmaWd1cmUgdGhp
  cyBvdXQgbm9uLWludGVyYWN0aXZlbHkKZF9zdWlkc2FmZT0kZGVmaW5lCgojIGNjIGlzIGdjYyBz
  byB3ZSBjYW4gZG8gYmV0dGVyIHRoYW4gLU8KIyBBbGxvdyBhIGNvbW1hbmQtbGluZSBvdmVycmlk
  ZSwgc3VjaCBhcyAtRG9wdGltaXplPS1nCmNhc2UgIiR7QVJDSH0tJHtvc3ZlcnN9IiBpbgoqKQog
  ICB0ZXN0ICIkb3B0aW1pemUiIHx8IG9wdGltaXplPSctTzInCiAgIDs7CmVzYWMKCiMgVGhpcyBz
  Y3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1
  cmUgCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2VyIGZvciB3aGV0aGVyIHRvIHVzZSB0
  aHJlYWRzLgpjYXQgPiBVVS91c2V0aHJlYWRzLmNidSA8PCdFT0NCVScKY2FzZSAiJHVzZXRocmVh
  ZHMiIGluCiRkZWZpbmV8dHJ1ZXxbeVldKikKCSMgYW55IG9wZW5ic2QgdmVyc2lvbiBkZXBlbmRl
  bmNpZXMgd2l0aCBwdGhyZWFkcz8KCWNjZmxhZ3M9Ii1wdGhyZWFkICRjY2ZsYWdzIgoJbGRmbGFn
  cz0iLXB0aHJlYWQgJGxkZmxhZ3MiCmVzYWMKRU9DQlUKCiMgV2hlbiBidWlsZGluZyBpbiB0aGUg
  T3BlbkJTRCB0cmVlIHdlIHVzZSBkaWZmZXJlbnQgcGF0aHMKIyBUaGlzIGlzIG9ubHkgcGFydCBv
  ZiB0aGUgc3RvcnksIHRoZSByZXN0IGNvbWVzIGZyb20gY29uZmlnLm92ZXIKY2FzZSAiJG9wZW5i
  c2RfZGlzdHJpYnV0aW9uIiBpbgonJ3wkdW5kZWZ8ZmFsc2UpIDs7CiopCgkjIFdlIHB1dCB0aGlu
  Z3MgaW4gL3Vzciwgbm90IC91c3IvbG9jYWwKCXByZWZpeD0nL3VzcicKCXByZWZpeGV4cD0nL3Vz
  cicKCXN5c21hbj0nL3Vzci9zaGFyZS9tYW4vbWFuMScKCWxpYnB0aD0nL3Vzci9saWInCglnbGli
  cHRoPScvdXNyL2xpYicKCSMgTG9jYWwgdGhpbmdzLCBob3dldmVyLCBkbyBnbyBpbiAvdXNyL2xv
  Y2FsCglzaXRlcHJlZml4PScvdXNyL2xvY2FsJwoJc2l0ZXByZWZpeGV4cD0nL3Vzci9sb2NhbCcK
  CSMgUG9ydHMgaW5zdGFsbHMgbm9uLXN0ZCBsaWJzIGluIC91c3IvbG9jYWwvbGliIHNvIGxvb2sg
  dGhlcmUgdG9vCglsb2NpbmNwdGg9Jy91c3IvbG9jYWwvaW5jbHVkZScKCWxvY2xpYnB0aD0nL3Vz
  ci9sb2NhbC9saWInCgkjIExpbmsgcGVybCB3aXRoIHNoYXJlZCBsaWJwZXJsCglpZiBbICIkdXNl
  ZGwiID0gIiRkZWZpbmUiIC1hIC1yICRzcmMvc2hsaWJfdmVyc2lvbiBdOyB0aGVuCgkJdXNlc2hy
  cGxpYj10cnVlCgkJbGlicGVybD1gLiAkc3JjL3NobGliX3ZlcnNpb247IGVjaG8gbGlicGVybC5z
  by4ke21ham9yfS4ke21pbm9yfWAKCWZpCgk7Owplc2FjCgojIGVuZAo=',
  'cygwin' =>
  'IyEgL2Jpbi9zaAojIGN5Z3dpbi5zaCAtIGhpbnRzIGZvciBidWlsZGluZyBwZXJsIHVzaW5nIHRo
  ZSBDeWd3aW4gZW52aXJvbm1lbnQgZm9yIFdpbjMyCiMKCiMgbm90IG90aGVyd2lzZSBzZXR0YWJs
  ZQpleGVfZXh0PScuZXhlJwpmaXJzdG1ha2VmaWxlPSdHTlVtYWtlZmlsZScKY2FzZSAiJGxkbGli
  cHRobmFtZSIgaW4KJycpIGxkbGlicHRobmFtZT1QQVRIIDs7CmVzYWMKYXJjaG9ianM9J2N5Z3dp
  bi5vJwoKIyBtYW5kYXRvcnkgKG92ZXJyaWRlcyBpbmNvcnJlY3QgZGVmYXVsdHMpCnRlc3QgLXog
  IiRjYyIgJiYgY2M9J2djYycKaWYgdGVzdCAteiAiJHBsaWJwdGgiCnRoZW4KICAgIHBsaWJwdGg9
  YGdjYyAtcHJpbnQtZmlsZS1uYW1lPWxpYmMuYWAKICAgIHBsaWJwdGg9YGRpcm5hbWUgJHBsaWJw
  dGhgCiAgICBwbGlicHRoPWBjZCAkcGxpYnB0aCAmJiBwd2RgCmZpCnNvPSdkbGwnCiMgLSBlbGlt
  aW5hdGUgLWxjLCBpbXBsaWVkIGJ5IGdjYyBhbmQgYSBzeW1saW5rIHRvIGxpYmN5Z3dpbi5hCmxp
  YnN3YW50ZWQ9YGVjaG8gIiAkbGlic3dhbnRlZCAiIHwgc2VkIC1lICdzLyBjIC8gL2cnYAojIC0g
  ZWxpbWluYXRlIC1sbSwgc3ltbGluayB0byBsaWJjeWd3aW4uYQpsaWJzd2FudGVkPWBlY2hvICIg
  JGxpYnN3YW50ZWQgIiB8IHNlZCAtZSAncy8gbSAvIC9nJ2AKIyAtIGVsaW1pbmF0ZSAtbHV0aWws
  IHN5bWJvbHMgYXJlIGFsbCBpbiBsaWJjeWd3aW4uYQpsaWJzd2FudGVkPWBlY2hvICIgJGxpYnN3
  YW50ZWQgIiB8IHNlZCAtZSAncy8gdXRpbCAvIC9nJ2AKIyAtIGFkZCBsaWJnZGJtX2NvbXBhdCAk
  bGlic3dhbnRlZApsaWJzd2FudGVkPSIkbGlic3dhbnRlZCBnZGJtX2NvbXBhdCIKdGVzdCAteiAi
  JG9wdGltaXplIiAmJiBvcHRpbWl6ZT0nLU8zJwptYW4zZXh0PSczcG0nCnRlc3QgLXogIiR1c2U2
  NGJpdGludCIgJiYgdXNlNjRiaXRpbnQ9J2RlZmluZScKdGVzdCAteiAiJHVzZWl0aHJlYWRzIiAm
  JiB1c2VpdGhyZWFkcz0nZGVmaW5lJwpjY2ZsYWdzPSIkY2NmbGFncyAtRFBFUkxfVVNFX1NBRkVf
  UFVURU5WIC1VX19TVFJJQ1RfQU5TSV9fIC1EX0dOVV9TT1VSQ0UiCiMgLSBvdGhlcndpc2UgaTY4
  Ni1jeWd3aW4KYXJjaG5hbWU9J2N5Z3dpbicKCiMgZHluYW1pYyBsb2FkaW5nCiMgLSBvdGhlcndp
  c2UgLWZwaWMKY2NjZGxmbGFncz0nICcKbGRkbGZsYWdzPScgLS1zaGFyZWQnCnRlc3QgLXogIiRs
  ZCIgJiYgbGQ9J2crKycKCmNhc2UgIiRvc3ZlcnMiIGluCiAgICAjIENvbmZpZ3VyZSBnZXRzIHRo
  ZXNlIHdyb25nIGlmIHRoZSBJUEMgc2VydmVyIGlzbid0IHlldCBydW5uaW5nOgogICAgIyBvbmx5
  IHVzZSBmb3IgMS41LjcgYW5kIG9ud2FyZHMKICAgIFsyLTldKnwxLls2LTldKnwxLlsxLTVdWzAt
  OV0qfDEuNS5bNy05XSp8MS41LlsxLTZdWzAtOV0qKQogICAgICAgIGRfc2VtY3RsX3NlbWlkX2Rz
  PSdkZWZpbmUnCiAgICAgICAgZF9zZW1jdGxfc2VtdW49J2RlZmluZScKICAgICAgICA7Owplc2Fj
  CgpjYXNlICIkb3N2ZXJzIiBpbgogICAgWzItOV0qfDEuWzYtOV0qKQogICAgICAgICMgSVB2NiBv
  bmx5IHNpbmNlIDEuNwogICAgICAgIGRfaW5ldG50b3A9J2RlZmluZScKICAgICAgICBkX2luZXRw
  dG9uPSdkZWZpbmUnCiAgICAgICAgOzsKICAgICopCiAgICAgICAgIyBJUHY2IG5vdCBpbXBsZW1l
  bnRlZCBiZWZvcmUgY3lnd2luLTEuNwogICAgICAgIGRfaW5ldG50b3A9J3VuZGVmJwogICAgICAg
  IGRfaW5ldHB0b249J3VuZGVmJwplc2FjCgojIGNvbXBpbGUgV2luMzJDT1JFICJtb2R1bGUiIGFz
  IHN0YXRpYy4gdHJ5IHRvIGF2b2lkIHRoZSBzcGFjZS4KaWYgdGVzdCAteiAiJHN0YXRpY19leHQi
  OyB0aGVuCiAgc3RhdGljX2V4dD0iV2luMzJDT1JFIgplbHNlCiAgc3RhdGljX2V4dD0iJHN0YXRp
  Y19leHQgV2luMzJDT1JFIgpmaQoKIyBXaW45eCBwcm9ibGVtIHdpdGggbm9uLWJsb2NraW5nIHJl
  YWQgZnJvbSBhIGNsb3NlZCBwaXBlCmRfZW9mbmJsaz0nZGVmaW5lJwoKIyBzdXBwcmVzcyBhdXRv
  LWltcG9ydCB3YXJuaW5ncwpsZGZsYWdzPSIkbGRmbGFncyAtV2wsLS1lbmFibGUtYXV0by1pbXBv
  cnQgLVdsLC0tZXhwb3J0LWFsbC1zeW1ib2xzIC1XbCwtLWVuYWJsZS1hdXRvLWltYWdlLWJhc2Ui
  CmxkZGxmbGFncz0iJGxkZGxmbGFncyAkbGRmbGFncyIKCiMgc3RyaXAgZXhlJ3MgYW5kIGRsbCdz
  LCBiZXR0ZXIgZG8gaXQgYWZ0ZXJ3YXJkcwojbGRmbGFncz0iJGxkZmxhZ3MgLXMiCiNjY2RsZmxh
  Z3M9IiRjY2RsZmxhZ3MgLXMiCiNsZGRsZmxhZ3M9IiRsZGRsZmxhZ3MgLXMiCg==',
  'darwin' =>
  'IyMKIyBEYXJ3aW4gKE1hYyBPUykgaGludHMKIyBXaWxmcmVkbyBTYW5jaGV6IDx3c2FuY2hlekB3
  c2FuY2hlei5uZXQ+CiMjCgojIwojIFBhdGhzCiMjCgojIENvbmZpZ3VyZSBoYXNuJ3QgZmlndXJl
  ZCBvdXQgdGhlIHZlcnNpb24gbnVtYmVyIHlldC4gIEJ1bW1lci4KcGVybF9yZXZpc2lvbj1gYXdr
  ICcvZGVmaW5lWyAJXStQRVJMX1JFVklTSU9OLyB7cHJpbnQgJDN9JyAkc3JjL3BhdGNobGV2ZWwu
  aGAKcGVybF92ZXJzaW9uPWBhd2sgJy9kZWZpbmVbIAldK1BFUkxfVkVSU0lPTi8ge3ByaW50ICQz
  fScgJHNyYy9wYXRjaGxldmVsLmhgCnBlcmxfc3VidmVyc2lvbj1gYXdrICcvZGVmaW5lWyAJXStQ
  RVJMX1NVQlZFUlNJT04vIHtwcmludCAkM30nICRzcmMvcGF0Y2hsZXZlbC5oYAp2ZXJzaW9uPSIk
  e3BlcmxfcmV2aXNpb259LiR7cGVybF92ZXJzaW9ufS4ke3Blcmxfc3VidmVyc2lvbn0iCgojIFBy
  ZXRlbmQgdGhhdCBEYXJ3aW4gZG9lc24ndCBrbm93IGFib3V0IHRob3NlIHN5c3RlbSBjYWxscyBp
  biBUaWdlcgojICgxMC40L2RhcndpbiA4KSBhbmQgZWFybGllciBbcGVybCAjMjQxMjJdCmNhc2Ug
  IiRvc3ZlcnMiIGluClsxLThdLiopCiAgICBkX3NldHJlZ2lkPSd1bmRlZicKICAgIGRfc2V0cmV1
  aWQ9J3VuZGVmJwogICAgZF9zZXRyZ2lkPSd1bmRlZicKICAgIGRfc2V0cnVpZD0ndW5kZWYnCiAg
  ICA7Owplc2FjCgojIGZpbml0ZSgpIGRlcHJlY2F0ZWQgaW4gMTAuOSwgdXNlIGlzZmluaXRlKCkg
  aW5zdGVhZC4KY2FzZSAiJG9zdmVycyIgaW4KWzEtOF0uKikgOzsKKikgZF9maW5pdGU9J3VuZGVm
  JyA7Owplc2FjCgojIFRoaXMgd2FzIHByZXZpb3VzbHkgdXNlZCBpbiBhbGwgYnV0IGNhdXNlcyB0
  aHJlZSBjYXNlcwojIChubyAtRGRwcmVmaXg9LCAtRHByZWZpeD0vdXNyLCAtRHByZWZpeD0vc29t
  ZS90aGluZy9lbHNlKQojIGJ1dCB0aGF0IGNhdXNlZCB0b28gbXVjaCBncmllZi4KIyB2ZW5kb3Js
  aWI9Ii9TeXN0ZW0vTGlicmFyeS9QZXJsLyR7dmVyc2lvbn0iOyAjIEFwcGxlLXN1cHBsaWVkIG1v
  ZHVsZXMKCmNhc2UgIiRkYXJ3aW5fZGlzdHJpYnV0aW9uIiBpbgokZGVmaW5lKSAjIFdlIGFyZSBi
  dWlsZGluZy9yZXBsYWNpbmcgdGhlIGJ1aWx0LWluIHBlcmwKCXByZWZpeD0nL3Vzcic7CglpbnN0
  YWxscHJlZml4PScvdXNyJzsKCWJpbj0nL3Vzci9iaW4nOwoJc2l0ZXByZWZpeD0nL3Vzci9sb2Nh
  bCc7CgkjIFdlIGRvbid0IHdhbnQgL3Vzci9iaW4vSEVBRCBpc3N1ZXMuCglzaXRlYmluPScvdXNy
  L2xvY2FsL2Jpbic7CglzaXRlc2NyaXB0PScvdXNyL2xvY2FsL2Jpbic7CglpbnN0YWxsdXNyYmlu
  cGVybD0nZGVmaW5lJzsgIyBZb3Uga25ldyB3aGF0IHlvdSB3ZXJlIGRvaW5nLgoJcHJpdmxpYj0i
  L1N5c3RlbS9MaWJyYXJ5L1BlcmwvJHt2ZXJzaW9ufSI7CglzaXRlbGliPSIvTGlicmFyeS9QZXJs
  LyR7dmVyc2lvbn0iOwoJdmVuZG9ycHJlZml4PScvJzsKCXVzZXZlbmRvcnByZWZpeD0nZGVmaW5l
  JzsKCXZlbmRvcmJpbj0nL3Vzci9iaW4nOwoJdmVuZG9yc2NyaXB0PScvdXNyL2Jpbic7Cgl2ZW5k
  b3JsaWI9Ii9OZXR3b3JrL0xpYnJhcnkvUGVybC8ke3ZlcnNpb259IjsKCSMgNEJTRCB1c2VzICR7
  cHJlZml4fS9zaGFyZS9tYW4sIG5vdCAke3ByZWZpeH0vbWFuLgoJbWFuMWRpcj0nL3Vzci9zaGFy
  ZS9tYW4vbWFuMSc7CgltYW4zZGlyPScvdXNyL3NoYXJlL21hbi9tYW4zJzsKCSMgQnV0IHVzZXJz
  JyBpbnN0YWxscyBzaG91bGRuJ3QgdG91Y2ggdGhlIHN5c3RlbSBtYW4gcGFnZXMuCgkjIFRyYW5z
  aWVudCBvYnNvbGV0ZWQgc3R5bGUuCglzaXRlbWFuMT0nL3Vzci9sb2NhbC9zaGFyZS9tYW4vbWFu
  MSc7CglzaXRlbWFuMz0nL3Vzci9sb2NhbC9zaGFyZS9tYW4vbWFuMyc7CgkjIE5ldyBzdHlsZS4K
  CXNpdGVtYW4xZGlyPScvdXNyL2xvY2FsL3NoYXJlL21hbi9tYW4xJzsKCXNpdGVtYW4zZGlyPScv
  dXNyL2xvY2FsL3NoYXJlL21hbi9tYW4zJzsKCTs7CmVzYWMKCiMjCiMgVG9vbCBjaGFpbiBzZXR0
  aW5ncwojIwoKIyBTaW5jZSB3ZSBjYW4gYnVpbGQgZmF0LCB0aGUgYXJjaG5hbWUgZG9lc24ndCBu
  ZWVkIHRoZSBwcm9jZXNzb3IgdHlwZQphcmNobmFtZT0nZGFyd2luJzsKCiMgbm0gaXNuJ3Qga25v
  d24gdG8gd29yayBhZnRlciBTbm93IExlb3BhcmQgYW5kIFhDb2RlIDQ7IHRlc3Rpbmcgd2l0aCBP
  UyBYIDEwLjUKIyBhbmQgWGNvZGUgMyBzaG93cyBhIHdvcmtpbmcgbm0sIGJ1dCBwcmV0ZW5kaW5n
  IGl0IGRvZXNuJ3Qgd29yayBwcm9kdWNlcyBubwojIHByb2JsZW1zLgp1c2VubT0nZmFsc2UnOwoK
  Y2FzZSAiJG9wdGltaXplIiBpbgonJykKIyAgICBPcHRpbWl6aW5nIGZvciBzaXplIGFsc28gbWVh
  biBsZXNzIHJlc2lkZW50IG1lbW9yeSB1c2FnZSBvbiB0aGUgcGFydAojIG9mIFBlcmwuICBBcHBs
  ZSBhc3NlcnRzIHRoYXQgdGhpcyBpcyBhIG1vcmUgaW1wb3J0YW50IG9wdGltaXphdGlvbiB0aGFu
  CiMgc2F2aW5nIG9uIENQVSBjeWNsZXMuICBHaXZlbiB0aGF0IG1lbW9yeSBzcGVlZCBoYXMgbm90
  IGluY3JlYXNlZCBhdAojIHBhY2Ugd2l0aCBDUFUgc3BlZWQgb3ZlciB0aW1lIChvbiBhbnkgcGxh
  dGZvcm0pLCB0aGlzIGlzIHByb2JhYmx5IGEKIyByZWFzb25hYmxlIGFzc2VydGlvbi4KaWYgWyAt
  eiAiJHtvcHRpbWl6ZX0iIF07IHRoZW4KICBjYXNlICJgJHtjYzotZ2NjfSAtdiAyPiYxYCIgaW4K
  ICAgICoiZ2NjIHZlcnNpb24gMy4iKikgb3B0aW1pemU9Jy1PcycgOzsKICAgICopIG9wdGltaXpl
  PSctTzMnIDs7CiAgZXNhYwplbHNlCiAgb3B0aW1pemU9Jy1PMycKZmkKOzsKZXNhYwoKIyAtZm5v
  LWNvbW1vbiBiZWNhdXNlIGNvbW1vbiBzeW1ib2xzIGFyZSBub3QgYWxsb3dlZCBpbiBNSF9EWUxJ
  QgojIC1EUEVSTF9EQVJXSU46IGFwcGFyZW50bHkgdGhlIF9fQVBQTEVfXyBpcyBub3Qgc2FuY3Rp
  b25lZCBieSBBcHBsZQojIGFzIHRoZSB3YXkgdG8gZGlmZmVyZW50aWF0ZSBNYWMgT1MgWC4gIChU
  aGUgb2ZmaWNpYWwgbGluZSBpcyB0aGF0CiMgKm5vKiBjcHAgc3ltYm9sIGRvZXMgZGlmZmVyZW50
  aWF0ZSBNYWMgT1MgWC4pCmNjZmxhZ3M9IiR7Y2NmbGFnc30gLWZuby1jb21tb24gLURQRVJMX0RB
  UldJTiIKCiMgQXQgbGVhc3Qgb24gRGFyd2luIDEuMy54OgojCiMgIyBkZWZpbmUgSU5UMzJfTUlO
  IC0yMTQ3NDgzNjQ4CiMgaW50IG1haW4gKCkgewojICBkb3VibGUgYSA9IElOVDMyX01JTjsKIyAg
  cHJpbnRmICgiSU5UMzJfTUlOPSVnXG4iLCBhKTsKIyAgcmV0dXJuIDA7CiMgfQojIHdpbGwgb3V0
  cHV0OgojIElOVDMyX01JTj0yLjE0NzQ4ZSswOQojIE5vdGUgdGhhdCB0aGUgSU5UMzJfTUlOIGhh
  cyBiZWNvbWUgcG9zaXRpdmUuCiMgSU5UMzJfTUlOIGlzIHNldCBpbiAvdXNyL2luY2x1ZGUvc3Rk
  aW50LmggYnk6CiMgI2RlZmluZSBJTlQzMl9NSU4gICAgICAgIC0yMTQ3NDgzNjQ4CiMgd2hpY2gg
  c2VlbXMgdG8gYnJlYWsgdGhlIGdjYy4gIERlZmluaW5nIElOVDMyX01JTiBhcyAoLTIxNDc0ODM2
  NDctMSkKIyBzZWVtcyB0byB3b3JrLiAgSU5UNjRfTUlOIHNlZW1zIHRvIGJlIHNpbWlsYXJseSBi
  cm9rZW4uCiMgLS0gTmljaG9sYXMgQ2xhcmssIEtlbiBXaWxsaWFtcywgYW5kIEVkd2FyZCBNb3kK
  IwojIFRoaXMgc2VlbXMgdG8gaGF2ZSBiZWVuIGZpeGVkIHNpbmNlIGF0IGxlYXN0IE1hYyBPUyBY
  IDEwLjEuMywKIyBzdGRpbnQuaCBkZWZpbmluZyBJTlQzMl9NSU4gYXMgKC1JTlQzMl9NQVgtMSkK
  IyAtLSBFZHdhcmQgTW95CiMKaWYgdGVzdCAtZiAvdXNyL2luY2x1ZGUvc3RkaW50Lmg7IHRoZW4K
  ICBjYXNlICIkKGdyZXAgJ14jZGVmaW5lIElOVDMyX01JTicgL3Vzci9pbmNsdWRlL3N0ZGludC5o
  KSIgaW4KICAqLTIxNDc0ODM2NDgpIGNjZmxhZ3M9IiR7Y2NmbGFnc30gLURJTlQzMl9NSU5fQlJP
  S0VOIC1ESU5UNjRfTUlOX0JST0tFTiIgOzsKICBlc2FjCmZpCgojIEF2b2lkIEFwcGxlJ3MgY3Bw
  IHByZWNvbXBpbGVyLCBiZXR0ZXIgZm9yIGV4dGVuc2lvbnMKaWYgWyAiWGBlY2hvIHwgJHtjY30g
  LW5vLWNwcC1wcmVjb21wIC1FIC0gMj4mMSA+L2Rldi9udWxsYCIgPSAiWCIgXTsgdGhlbgogICAg
  Y3BwZmxhZ3M9IiR7Y3BwZmxhZ3N9IC1uby1jcHAtcHJlY29tcCIKCiAgICAjIFRoaXMgaXMgbmVj
  ZXNzYXJ5IGJlY2F1c2UgcGVybCdzIGJ1aWxkIHN5c3RlbSBkb2Vzbid0CiAgICAjIGFwcGx5IGNw
  cGZsYWdzIHRvIGNjIGNvbXBpbGUgbGluZXMgYXMgaXQgc2hvdWxkLgogICAgY2NmbGFncz0iJHtj
  Y2ZsYWdzfSAke2NwcGZsYWdzfSIKZmkKCiMgS25vd24gb3B0aW1pemVyIHByb2JsZW1zLgpjYXNl
  ICJgY2MgLXYgMj4mMWAiIGluCiAgKiIzLjEgMjAwMjAxMDUiKikgdG9rZV9jZmxhZ3M9J29wdGlt
  aXplPSIiJyA7Owplc2FjCgojIFNoYXJlZCBsaWJyYXJ5IGV4dGVuc2lvbiBpcyAuZHlsaWIuCiMg
  QnVuZGxlIGV4dGVuc2lvbiBpcyAuYnVuZGxlLgpzbz0nZHlsaWInOwpkbGV4dD0nYnVuZGxlJzsK
  dXNlZGw9J2RlZmluZSc7CgojIDEwLjQgY2FuIHVzZSBkbG9wZW4uCiMgMTAuNCBicm9rZSBwb2xs
  KCkuCmNhc2UgIiRvc3ZlcnMiIGluClsxLTddLiopCiAgICBkbHNyYz0nZGxfZHlsZC54cyc7CiAg
  ICA7OwoqKQogICAgZGxzcmM9J2RsX2Rsb3Blbi54cyc7CiAgICBkX3BvbGw9J3VuZGVmJzsKICAg
  IGlfcG9sbD0ndW5kZWYnOwogICAgOzsKZXNhYwoKY2FzZSAiJGNjZGxmbGFncyIgaW4JCSMgSWYg
  cGFzc2VkIGluIGZyb20gY29tbWFuZCBsaW5lLCBwcmVzdW1lIHVzZXIga25vd3MgYmVzdAonJykK
  ICAgY2NjZGxmbGFncz0nICc7ICMgc3BhY2UsIG5vdCBlbXB0eSwgYmVjYXVzZSBvdGhlcndpc2Ug
  d2UgZ2V0IC1mcGljCjs7CmVzYWMKCiMgQWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgbGQsIGJ1
  dCBtb2RpZnkgaXQgYXMgbmVjZXNzYXJ5IGJlbG93CmNhc2UgIiRsZCIgaW4KICAgICcnKSBjYXNl
  ICIkY2MiIGluCiAgICAgICAgIyBJZiB0aGUgY2MgaXMgZXhwbGljaXRseSBzb21ldGhpbmcgZWxz
  ZSB0aGFuIGNjIChvciBlbXB0eSksCiAgICAgICAgIyBzZXQgdGhlIGxkIHRvIGJlIHRoYXQgZXhw
  bGljaXRseSBzb21ldGhpbmcgZWxzZS4gIENvbnZlcnNlbHksCiAgICAgICAgIyBpZiB0aGUgY2Mg
  aXMgJ2NjJyAob3IgZW1wdHkpLCBzZXQgdGhlIGxkIHRvIGJlICdjYycuCiAgICAgICAgY2N8Jycp
  IGxkPSdjYyc7OwogICAgICAgICopIGxkPSIkY2MiIDs7CiAgICAgICAgZXNhYwogICAgICAgIDs7
  CmVzYWMKCiMgRnJvbSBodHRwOi8vZnRwLm5ldGJzZC5vcmcvcHViL3BrZ3NyYy9jdXJyZW50L3Br
  Z3NyYy9tay9wbGF0Zm9ybS9EYXJ3aW4ubWsKIyBhbmQgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9y
  Zy93aWtpL1hjb2RlVmVyc2lvbkluZm8KIyBhbmQgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9yZy93
  aWtpL1VzaW5nVGhlUmlnaHRDb21waWxlcgojIGFuZCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS95
  YW1heWEvMjkyNDI5MgojIGFuZCBodHRwOi8vb3BlbnNvdXJjZS5hcHBsZS5jb20vc291cmNlL2Ns
  YW5nLwojCiMgTm90ZSB0aGF0IFhjb2RlIGdldHMgdXBkYXRlcyBvbiBvbGRlciBzeXN0ZW1zIHNv
  bWV0aW1lcywgYW5kIGluCiMgZ2VuZXJhbCB0aGF0IHRoZSBPUyBsZXZlbHMgYW5kIFhDb2RlIGxl
  dmVscyBhcmUgbm90IHN5bmNocm9uaXplZAojIHNpbmNlIG5ldyByZWxlYXNlcyBvZiBYQ29kZSB1
  c3VhbGx5IHN1cHBvcnQgYm90aCBzb21lIG5ldyBhbmQgc29tZQojIG9sZCBPUyByZWxlYXNlcy4K
  IwojIE5vdGUgdGhhdCBBcHBsZSBoaWphY2tzIHRoZSBjbGFuZyBwcmVwcm9jZXNzb3Igc3ltYm9s
  cyBfX2NsYW5nX21ham9yX18KIyBhbmQgX19jbGFuZ19taW5vcl9fIHNvIHRoZXkgY2Fubm90IGJl
  IHVzZWQgKGVhc2lseSkgdG8gZGV0ZWN0IHRoZQojIGFjdHVhbCBjbGFuZyByZWxlYXNlLiAgRm9y
  IGV4YW1wbGU6CiMKIyAiWW9zZW1pdGUgMTAuMTAueCAxNC54LnkgNi4zIChjbGFuZyAzLjYgYXMg
  Ni4xLzYwMi4wLjQ5KSIKIwojIG1lYW5zIHRoYXQgdGhlIFhjb2RlIDYuMyBwcm92aWRlZCB0aGUg
  Y2xhbmcgNi4zIGJ1dCBjYWxsZWQgaXQgNi4xCiMgKF9fY2xhbmdfbWFqb3JfXywgX19jbGFuZ19t
  aW5vcl9fKSBhbmQgaW4gYWRkaXRpb24gdGhlIHByZXByb2Nlc3NvcgojIHN5bWJvbCBfX2FwcGxl
  X2J1aWxkX3ZlcnNpb25fXyB3YXMgNjAyMDA0OS4KIwojIENvZGVuYW1lICAgICAgICBPUyAgICAg
  IEtlcm5lbCAgWGNvZGUKIwojIENoZWV0YWggICAgICAgICAxMC4wLnggIDEuMy4xCiMgUHVtYSAg
  ICAgICAgICAgIDEwLjEgICAgMS40LjEKIyAgICAgICAgICAgICAgICAgMTAuMS54ICA1LngueQoj
  IEphZ3VhciAgICAgICAgICAxMC4yLnggIDYueC55CiMgUGFudGhlciAgICAgICAgIDEwLjMueCAg
  Ny54LnkKIyBUaWdlciAgICAgICAgICAgMTAuNC54ICA4LngueSAgIDIuMCAgIChnY2M0IDQuMC4w
  KQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMi4yICAgKGdjYzQgNC4wLjEpCiMg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLjIuMSAoZ2NjIDMuMykKIyAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgIDIuNSA/CiMgTGVvcGFyZCAgICAgICAgIDEwLjUueCAg
  OS54LnkgICAzLjAgICAoZ2NjIDQuMC4xIGRlZmF1bHQpCiMgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAzLjEgICAoZ2NjIDQuMi4xKQojIFNub3cgTGVvcGFyZCAgICAxMC42LnggIDEw
  LngueSAgMy4yICAgKGxsdm0gZ2NjIDQuMiwgY2xhbmcgMi4zIGFzIDEuMCkKIyAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgIDMuMi4xIChjbGFuZyAxLjAuMSBhcyAxLjAuMS8yNCkKIyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMuMi4yIChjbGFuZyAxLjAuMiBhcyAxLjAu
  Mi8zMikKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMuMi4zIChjbGFuZyAxLjUg
  YXMgMS41LzYwKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNC4wLjEgKGNsYW5n
  IDIuOSBhcyAyLjAvMTM4KQojIExpb24gICAgICAgICAgICAxMC43LnggIDExLngueSAgNC4xICAg
  KGxsdm0gZ2NjIDQuMi4xLCBjbGFuZyAzLjAgYXMgMi4xLzE2My43LjEpCiMgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICA0LjIgICAoY2xhbmcgMy4wIGFzIDMuMC8yMTEuMTAuMSkKIyAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQuMy4zIChjbGFuZyAzLjEgYXMgMy4xLzMx
  OC4wLjYxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNC40ICAgKGNsYW5nIDMu
  MSBhcyA0LjAvNDIxLjAuNTcpCiMgTW91bnRhaW4gTGlvbiAgIDEwLjgueCAgMTIueC55ICA0LjUg
  ICAoY2xhbmcgMy4xIGFzIDQuMS80MjEuMTEuNjUsIHJlYWwgZ2NjIHJlbW92ZWQsIHRoZXJlIGlz
  IGdjYyBidXQgaXQncyByZWFsbHkgY2xhbmcpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICA0LjYgICAoY2xhbmcgMy4yIGFzIDQuMi80MjUuMC4yNCkKIyAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICAgIDUuMCAgIChjbGFuZyAzLjMgYXMgNS4wLzUwMC4yLjc1KQojICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgNS4xICAgKGNsYW5nIDMuNCBhcyA1LjEvNTAzLjAu
  MzgpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1LjEuMSAoY2xhbmcgMy40IGFz
  IDUuMS81MDMuMC40MCkKIyBNYXZlcmlja3MgICAgICAgMTAuOS54ICAxMy54LnkgIDYuMC4xIChj
  bGFuZyAzLjUgYXMgNi4wLzYwMC4wLjUxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgNi4xICAgKGNsYW5nIDMuNSBhcyA2LjAvNjAwLjAuNTQpCiMgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgICA2LjEuMSAoY2xhbmcgMy41IGFzIDYuMC82MDAuMC41NikKIyAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgIDYuMiAgIChjbGFuZyAzLjUgYXMgNi4wLzYwMC4wLjU3
  KQojIFlvc2VtaXRlICAgICAgICAxMC4xMC54IDE0LngueSAgNi4zICAgKGNsYW5nIDMuNiBhcyA2
  LjEvNjAyLjAuNDkpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2LjMuMSAoY2xh
  bmcgMy42IGFzIDYuMS82MDIuMC40OSkKIyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  IDYuMy4yIChjbGFuZyAzLjYgYXMgNi4xLzYwMi4wLjUzKQojIEVsIENhcGl0YW4gICAgICAxMC4x
  MS54IDE1LngueSAgNy4wICAgKGNsYW5nIDMuNyBhcyA3LjAvNzAwLjAuNzIpCiMgICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICA3LjEgICAoY2xhbmcgMy43IGFzIDcuMC83MDAuMS43NikK
  IyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcuMiAgIChjbGFuZyAzLjcgYXMgNy4w
  LjIvNzAwLjEuODEpCiMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3LjIuMSAoY2xh
  bmcgMy43IGFzIDcuMC4yLzcwMC4xLjgxKQojICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgNy4zICAgKGNsYW5nIDMuOCBhcyA3LjMuMC83MDMuMC4yOSkKIyBTaWVycmEgICAgICAgICAg
  MTAuMTIueCAxNi54LnkgIDguMC4wIChjbGFuZyAzLjggYXMgOC4wLzgwMC4wLjM4KQojCgojIFBy
  b2Nlc3NvcnMgU3VwcG9ydGVkCiMKIyBQb3dlclBDIChQUEMpOiAgICAgICAxMC4wLnggLSAxMC41
  LjggKGZpbmFsIDEwLjUueCkKIyBQb3dlclBDIHZpYSBSb3NldHRhOiAxMC40LjQgLSAxMC42Ljgg
  KGZpbmFsIDEwLjYueCkKIyBJQS0zMjogICAgICAgICAgICAgICAxMC40LjQgLSAxMC42LjggKHRo
  b3VnaCBzdGlsbCBzdXBwb3J0ZWQgb24geDg2LTY0KQojIHg4Ni02NDogICAgICAgICAgICAgIDEw
  LjQuNyAtIGN1cnJlbnQKCiMgTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUIHNlbGVjdHMgdGhlIG1p
  bmltdW0gT1MgbGV2ZWwgd2Ugd2FudCB0byBzdXBwb3J0CiMKIyBJdCBpcyBuZWVkZWQgZm9yIE9T
  IHJlbGVhc2VzIGJlZm9yZSAxMC42LgojCiMgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xp
  YnJhcnkvbWFjL2RvY3VtZW50YXRpb24vRGV2ZWxvcGVyVG9vbHMvQ29uY2VwdHVhbC9jcm9zc19k
  ZXZlbG9wbWVudC9Db25maWd1cmluZy9jb25maWd1cmluZy5odG1sCiMKIyBJZiBpdCBpcyBzZXQs
  IHdlIGFsc28gcHJvcGFnYXRlIGl0cyB2YWx1ZSB0byBjY2ZsYWdzIGFuZCBsZGZsYWdzCiMgdXNp
  bmcgdGhlIC1tbWFjb3N4LXZlcnNpb24tbWluIGZsYWcuICBJZiBpdCBpcyBub3Qgc2V0LCB3ZSB1
  c2UKIyB0aGUgT1MgWCByZWxlYXNlIGFzIHRoZSBtaW4gdmFsdWUgZm9yIHRoZSBmbGFnLgoKIyBB
  ZGRzICItbW1hY29zeC12ZXJzaW9uLW1pbj0kMiIgdG8gIiQxIiB1bmxlc3MgaXQgYWxyZWFkeSBp
  cyB0aGVyZS4KYWRkX21hY29zeF92ZXJzaW9uX21pbiAoKSB7CiAgbG9jYWwgdgogIGV2YWwgInY9
  XCQkMSIKICBjYXNlICIgJHYgIiBpbgogICoiLW1tYWNvc3gtdmVyc2lvbi1taW4iKikKICAgICBl
  Y2hvICJOT1QgYWRkaW5nIC1tbWFjb3N4LXZlcnNpb24tbWluPSQyIHRvICQxICgkdikiID4mNAog
  ICAgIDs7CiAgKikgZWNobyAiQWRkaW5nIC1tbWFjb3N4LXZlcnNpb24tbWluPSQyIHRvICQxIiA+
  JjQKICAgICBldmFsICIkMT0nJHYgLW1tYWNvc3gtdmVyc2lvbi1taW49JDInIgogICAgIDs7CiAg
  ZXNhYwp9CgojIFBlcmwgYnVuZGxlcyBkbyBub3QgZXhwZWN0IHR3by1sZXZlbCBuYW1lc3BhY2Us
  IGFkZGVkIGluIERhcndpbiAxLjQuCiMgQnV0IHN0YXJ0aW5nIGZyb20gcGVybCA1LjguMS9EYXJ3
  aW4gNyB0aGUgZGVmYXVsdCBpcyB0aGUgdHdvLWxldmVsLgpjYXNlICIkb3N2ZXJzIiBpbiAgIyBO
  b3RlOiBvc3ZlcnMgaXMgdGhlIGtlcm5lbCB2ZXJzaW9uLCBub3QgdGhlIDEwLngKMS5bMC0zXS4q
  KSAjIE9TIFggMTAuMC54CiAgIGxkZGxmbGFncz0iJHtsZGZsYWdzfSAtYnVuZGxlIC11bmRlZmlu
  ZWQgc3VwcHJlc3MiCiAgIDs7CjEuKikgICAgICAgIyBPUyBYIDEwLjEKICAgbGRmbGFncz0iJHts
  ZGZsYWdzfSAtZmxhdF9uYW1lc3BhY2UiCiAgIGxkZGxmbGFncz0iJHtsZGZsYWdzfSAtYnVuZGxl
  IC11bmRlZmluZWQgc3VwcHJlc3MiCiAgIDs7ClsyLTZdLiopICAgIyBPUyBYIDEwLjEueCAtIDEw
  LjIueCAodGhvdWdoIFsyLTRdIG5ldmVyIGV4aXN0ZWQgcHVibGljbHkpCiAgIGxkZmxhZ3M9IiR7
  bGRmbGFnc30gLWZsYXRfbmFtZXNwYWNlIgogICBsZGRsZmxhZ3M9IiR7bGRmbGFnc30gLWJ1bmRs
  ZSAtdW5kZWZpbmVkIHN1cHByZXNzIgogICA7OwpbNy05XS4qKSAgICMgT1MgWCAxMC4zLnggLSAx
  MC41LngKICAgbGRkbGZsYWdzPSIke2xkZmxhZ3N9IC1idW5kbGUgLXVuZGVmaW5lZCBkeW5hbWlj
  X2xvb2t1cCIKICAgY2FzZSAiJGxkIiBpbgogICAgICAgKk1BQ09TWF9ERVBMT1lNRU5UX1RBUkdF
  VCopIDs7CiAgICAgICAqKSBsZD0iZW52IE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVD0xMC4zICR7
  bGR9IiA7OwogICBlc2FjCiAgIDs7CiopICAgICAgICAjIE9TIFggMTAuNi54IC0gY3VycmVudAog
  ICAjIFRoZSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJHRVQgaXMgbm90IG5lZWRlZCwKICAgIyBidXQg
  dGhlIC1tbWFjb3N4LXZlcnNpb24tbWluIG9wdGlvbiBpcyBhbHdheXMgdXNlZC4KCiAgICMgV2Ug
  bm93IHVzZSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJHRVQsIGlmIHNldCwgYXMgYW4gb3ZlcnJpZGUg
  YnkKICAgIyBjYXB0dXJpbmcgaXRzIHZhbHVlIGFuZCBhZGRpbmcgaXQgdG8gdGhlIGZsYWdzLgog
  ICAgY2FzZSAiJE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVCIgaW4KICAgIDEwLiopCiAgICAgIGFk
  ZF9tYWNvc3hfdmVyc2lvbl9taW4gY2NmbGFncyAkTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUCiAg
  ICAgIGFkZF9tYWNvc3hfdmVyc2lvbl9taW4gbGRmbGFncyAkTUFDT1NYX0RFUExPWU1FTlRfVEFS
  R0VUCiAgICAgIDs7CiAgICAnJykKICAgICAgIyBFbXB0eSBNQUNPU1hfREVQTE9ZTUVOVF9UQVJH
  RVQgaXMgb2theS4KICAgICAgOzsKICAgICopCiAgICAgIGNhdCA8PEVPTSA+JjQKCioqKiBVbmV4
  cGVjdGVkIE1BQ09TWF9ERVBMT1lNRU5UX1RBUkdFVD0kTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VU
  CioqKgoqKiogUGxlYXNlIGVpdGhlciBzZXQgaXQgdG8gMTAuc29tZXRoaW5nLCBvciB0byBlbXB0
  eS4KCkVPTQogICAgICBleGl0IDEKICAgICAgOzsKICAgIGVzYWMKCiAgICAjIEtlZXAgdGhlIHBy
  b2R2ZXJzIGxlYWRpbmcgd2hpdGVzcGFjZSAoQ29uZmlndXJlIG1hZ2ljKS4KICAgICMgQ2Fubm90
  IHVzZSAkb3N2ZXJzIGhlcmUgc2luY2UgdGhhdCBpcyB0aGUga2VybmVsIHZlcnNpb24uCiAgICAj
  IHN3X3ZlcnMgb3V0cHV0ICAgICAgICAgICAgICAgICB3aGF0IHdlIHdhbnQKICAgICMgIlByb2R1
  Y3RWZXJzaW9uOiAgICAxMC4xMC41IiAgICIxMC4xMCIKICAgICMgIlByb2R1Y3RWZXJzaW9uOiAg
  ICAxMC4xMSIgICAgICIxMC4xMSIKICAgICAgICBwcm9kdmVycz1gc3dfdmVyc3xhd2sgJy9eUHJv
  ZHVjdFZlcnNpb246L3twcmludCAkMn0nfGF3ayAtRi4gJ3twcmludCAkMSIuIiQyfSdgCiAgICBj
  YXNlICIkcHJvZHZlcnMiIGluCiAgICAxMC4qKQogICAgICBhZGRfbWFjb3N4X3ZlcnNpb25fbWlu
  IGNjZmxhZ3MgJHByb2R2ZXJzCiAgICAgIGFkZF9tYWNvc3hfdmVyc2lvbl9taW4gbGRmbGFncyAk
  cHJvZHZlcnMKICAgICAgOzsKICAgICopCiAgICAgIGNhdCA8PEVPTSA+JjQKCioqKiBVbmV4cGVj
  dGVkIHByb2R1Y3QgdmVyc2lvbiAkcHJvZHZlcnMuCioqKgoqKiogVHJ5IHJ1bm5pbmcgc3dfdmVy
  cyBhbmQgc2VlIHdoYXQgaXRzIFByb2R1Y3RWZXJzaW9uIHNheXMuCgpFT00KICAgICAgZXhpdCAx
  CiAgICBlc2FjCgogICAgIyBUaGUgWCBpbiAxMC5YCiAgICBwcm9kdmVyc19taW5vcj0kKGVjaG8g
  JHByb2R2ZXJzfGF3ayAtRi4gJ3twcmludCAkMn0nKQoKICAgICMgbWFjT1MgKDEwLjEyKSBkZXBy
  ZWNhdGVkIHN5c2NhbGwoKS4KICAgIGlmIFsgIiRwcm9kdmVyc19taW5vciIgLWdlIDEyIF07IHRo
  ZW4KICAgICAgICBkX3N5c2NhbGw9J3VuZGVmJwogICAgICAgICMgSWYgZGVwbG95aW5nIHRvIHBy
  ZS0xMC4xMiwgc3VwcHJlc3MgVGltZTo6SGlSZXMncyBkZXRlY3Rpb24gb2YgdGhlIHN5c3RlbSBj
  bG9ja19nZXR0aW1lKCkKICAgICAgICBjYXNlICIkTUFDT1NYX0RFUExPWU1FTlRfVEFSR0VUIiBp
  bgogICAgICAgICAgMTAuWzYtOV18MTAuMTB8MTAuMTEpCiAgICAgICAgICBjY2ZsYWdzPSIkY2Nm
  bGFncyAtV2Vycm9yPXBhcnRpYWwtYXZhaWxhYmlsaXR5IC1EX0RBUldJTl9GRUFUVVJFX0NMT0NL
  X0dFVFRJTUU9MCIKICAgICAgICAgIDs7CiAgICAgICAgKikKICAgICAgICAgIDs7CiAgICAgICAg
  ZXNhYwogICAgZmkKCiAgIGxkZGxmbGFncz0iJHtsZGZsYWdzfSAtYnVuZGxlIC11bmRlZmluZWQg
  ZHluYW1pY19sb29rdXAiCiAgIDs7CmVzYWMKCmxkbGlicHRobmFtZT0nRFlMRF9MSUJSQVJZX1BB
  VEgnOwoKIyB1c2VzaHJwbGliPXRydWUgcmVzdWx0cyBpbiBtdWNoIHNsb3dlciBzdGFydHVwIHRp
  bWVzLgojICdmYWxzZScgaXMgdGhlIGRlZmF1bHQgdmFsdWUuICBVc2UgQ29uZmlndXJlIC1EdXNl
  c2hycGxpYiB0byBvdmVycmlkZS4KCmNhdCA+IFVVL2FyY2huYW1lLmNidSA8PCdFT0NCVScKIyBU
  aGlzIHNjcmlwdCBVVS9hcmNobmFtZS5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25m
  aWd1cmUgCiMgYWZ0ZXIgaXQgaGFzIG90aGVyd2lzZSBkZXRlcm1pbmVkIHRoZSBhcmNoaXRlY3R1
  cmUgbmFtZS4KY2FzZSAiJGxkZmxhZ3MiIGluCioiLWZsYXRfbmFtZXNwYWNlIiopIDs7ICMgQmFj
  a3dhcmQgY29tcGF0LCBiZSBmbGF0LgojIElmIHdlIGFyZSB1c2luZyB0d28tbGV2ZWwgbmFtZXNw
  YWNlLCB3ZSB3aWxsIG11bmdlIHRoZSBhcmNobmFtZSB0byBzaG93IGl0LgoqKSBhcmNobmFtZT0i
  JHthcmNobmFtZX0tMmxldmVsIiA7Owplc2FjCkVPQ0JVCgojIDY0LWJpdCBhZGRyZXNzaW5nIHN1
  cHBvcnQuIEN1cnJlbnRseSBzdHJpY3RseSBleHBlcmltZW50YWwuIERGRCAyMDA1LTA2LTA2CmNh
  c2UgIiR1c2U2NGJpdGFsbCIgaW4KJGRlZmluZXx0cnVlfFt5WV0qKQpjYXNlICIkb3N2ZXJzIiBp
  bgpbMS03XS4qKQogICAgIGNhdCA8PEVPTSA+JjQKCgoKKioqIDY0LWJpdCBhZGRyZXNzaW5nIGlz
  IG5vdCBzdXBwb3J0ZWQgZm9yIE1hYyBPUyBYIHZlcnNpb25zCioqKiBiZWxvdyAxMC40ICgiVGln
  ZXIiKSBvciBEYXJ3aW4gdmVyc2lvbnMgYmVsb3cgOC4gUGxlYXNlIHRyeQoqKiogYWdhaW4gd2l0
  aG91dCAtRHVzZTY0Yml0YWxsLiAoLUR1c2U2NGJpdGludCB3aWxsIHdvcmssIGhvd2V2ZXIuKQoK
  RU9NCiAgICAgZXhpdCAxCiAgOzsKKikKICAgIGNhc2UgIiRvc3ZlcnMiIGluCiAgICA4LiopCiAg
  ICAgICAgY2F0IDw8RU9NID4mNAoKCgoqKiogUGVybCA2NC1iaXQgYWRkcmVzc2luZyBzdXBwb3J0
  IGlzIGV4cGVyaW1lbnRhbCBmb3IgTWFjIE9TIFgKKioqIDEwLjQgKCJUaWdlciIpIGFuZCBEYXJ3
  aW4gdmVyc2lvbiA4LiBTeXN0ZW0gViBJUEMgaXMgZGlzYWJsZWQKKioqIGR1ZSB0byBwcm9ibGVt
  cyB3aXRoIHRoZSA2NC1iaXQgdmVyc2lvbnMgb2YgbXNnY3RsLCBzZW1jdGwsCioqKiBhbmQgc2ht
  Y3RsLiBZb3Ugc2hvdWxkIGFsc28gZXhwZWN0IHRoZSBmb2xsb3dpbmcgdGVzdCBmYWlsdXJlczoK
  KioqCioqKiAgICBleHQvdGhyZWFkcy1zaGFyZWQvdC93YWl0ICh0aHJlYWRlZCBidWlsZHMgb25s
  eSkKCkVPTQoKICAgICAgICBbICIkZF9tc2djdGwiIF0gfHwgZF9tc2djdGw9J3VuZGVmJwogICAg
  ICAgIFsgIiRkX3NlbWN0bCIgXSB8fCBkX3NlbWN0bD0ndW5kZWYnCiAgICAgICAgWyAiJGRfc2ht
  Y3RsIiBdIHx8IGRfc2htY3RsPSd1bmRlZicKICAgIDs7CiAgICBlc2FjCgogICAgY2FzZSBgdW5h
  bWUgLXBgIGluIAogICAgcG93ZXJwYykgYXJjaD1wcGM2NCA7OwogICAgaTM4NikgYXJjaD14ODZf
  NjQgOzsKICAgICopIGNhdCA8PEVPTSA+JjQKCioqKiBEb24ndCByZWNvZ25pemUgcHJvY2Vzc29y
  LCBjYW4ndCBzcGVjaWZ5IDY0IGJpdCBjb21waWxhdGlvbi4KCkVPTQogICAgOzsKICAgIGVzYWMK
  ICAgIGZvciB2YXIgaW4gY2NmbGFncyBjcHBmbGFncyBsZCBsZGZsYWdzCiAgICBkbwogICAgICAg
  ZXZhbCAkdmFyPSJcJCR7dmFyfVwgLWFyY2hcICRhcmNoIgogICAgZG9uZQoKICAgIDs7CmVzYWMK
  OzsKZXNhYwoKIyMKIyBTeXN0ZW0gbGlicmFyaWVzCiMjCgojIHZmb3JrIHdvcmtzCnVzZXZmb3Jr
  PSd0cnVlJzsKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicn
  KSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMKCiMgb3VyIG1hbGxvYyB3b3JrcyAoYnV0
  IGFsbG93IHVzZXJzIHRvIG92ZXJyaWRlKQpjYXNlICIkdXNlbXltYWxsb2MiIGluCicnKSB1c2Vt
  eW1hbGxvYz0nbicgOzsKZXNhYwojIEhvd2V2ZXIgc2JyaygpIHJldHVybnMgLTEgKGZhaWx1cmUp
  IHNvbWV3aGVyZSBpbiBsaWIvdW5pY29yZS9ta3RhYmxlcyBhdAojIGFyb3VuZCAxNE0sIHNvIHdl
  IG5lZWQgdG8gdXNlIHN5c3RlbSBtYWxsb2MoKSBhcyBvdXIgc2JyaygpCiMKIyBzYnJrKCkgaW4g
  RGFyd2luIGRlcHJlY2F0ZWQgc2luY2UgTWF2ZXJpY2tzICgxMC45KSwgaXQgc3RpbGwgZXhpc3Rz
  CiMgaW4gWW9zZW1pdGUgKDEwLjEwKSBidXQgdGhhdCBpcyBqdXN0IGFuIGVtdWxhdGlvbiwgYW5k
  IGZhaWxzIGZvcgojIGFsbG9jYXRpb25zIGJleW9uZCA0TUIuICBPbmUgc2hvdWxkIHVzZSBlLmcu
  IG1tYXAgaW5zdGVhZCAob3Igc3lzdGVtCiMgbWFsbG9jLCBhcyBzdWdnZXN0ZWQgYWJvdmUsIHRo
  YXQgYnV0IGlzIGtpbmQgb2YgYmFja3dhcmQpLgptYWxsb2NfY2ZsYWdzPSdjY2ZsYWdzPSItRFVT
  RV9QRVJMX1NCUksgLURQRVJMX1NCUktfVklBX01BTExPQyAkY2NmbGFncyInCgojIExvY2FsZXMg
  YXJlbid0IGZlZWxpbmcgd2VsbC4KTENfQUxMPUM7IGV4cG9ydCBMQ19BTEw7CkxBTkc9QzsgZXhw
  b3J0IExBTkc7CgojCiMgVGhlIGxpYnJhcmllcyBhcmUgbm90IHRocmVhZHNhZmUgYXMgb2YgT1Mg
  WCAxMC4xLgojCiMgRml4IHdoZW4gQXBwbGUgZml4ZXMgbGliYy4KIwpjYXNlICIkdXNldGhyZWFk
  cyR1c2VpdGhyZWFkcyIgaW4KICAqZGVmaW5lKikKICBjYXNlICIkb3N2ZXJzIiBpbgogICAgWzEy
  MzQ1XS4qKSAgICAgY2F0IDw8RU9NID4mNAoKCgoqKiogV2FybmluZywgdGhlcmUgbWlnaHQgYmUg
  cHJvYmxlbXMgd2l0aCB5b3VyIGxpYnJhcmllcyB3aXRoCioqKiByZWdhcmRzIHRvIHRocmVhZGlu
  Zy4gIFRoZSB0ZXN0IGV4dC90aHJlYWRzL3QvbGliYy50IGlzIGxpa2VseQoqKiogdG8gZmFpbC4K
  CkVPTQogICAgOzsKICAgICopIHVzZXJlZW50cmFudD0nZGVmaW5lJzs7CiAgZXNhYwoKZXNhYwoK
  IyBGaW5rIGNhbiBpbnN0YWxsIGEgR0RCTSBsaWJyYXJ5IHRoYXQgY2xhaW1zIHRvIGhhdmUgdGhl
  IE9EQk0gaW50ZXJmYWNlcwojIGJ1dCBQZXJsIGR5bmFsb2FkZXIgY2Fubm90IGZvciBzb21lIHJl
  YXNvbiB1c2UgdGhhdCBsaWJyYXJ5LiAgV2UgZG9uJ3QKIyByZWFsbHkgbmVlZCBPREJNX0ZJbGUs
  IHRob3VnaCwgc28gbGV0J3MganVzdCBoaW50IE9EQk0gYXdheS4KaV9kYm09dW5kZWY7CgojIENv
  bmZpZ3VyZSBkb2Vzbid0IGRldGVjdCByYW5saWIgb24gVGlnZXIgcHJvcGVybHkuCiMgTmVpbFcg
  c2F5cyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIG9uIGFsbCBkYXJ3aW4gdmVyc2lvbnMuCnJh
  bmxpYj0ncmFubGliJwoKIyBDYXRjaCBNYWNQb3J0cyBnY2MvZysrIGV4dHJhIGxpYmRpcgpjYXNl
  ICIkKCRjYyAtdiAyPiYxKSIgaW4KKiJNYWNQb3J0cyBnY2MiKikgbG9jbGlicHRoPSIkbG9jbGli
  cHRoIC9vcHQvbG9jYWwvbGliL2xpYmdjYyIgOzsKZXNhYwoKIyMKIyBCdWlsZCBwcm9jZXNzCiMj
  CgojIENhc2UtaW5zZW5zaXRpdmUgZmlsZXN5c3RlbXMgZG9uJ3QgZ2V0IGFsb25nIHdpdGggTWFr
  ZWZpbGUgYW5kCiMgbWFrZWZpbGUgaW4gdGhlIHNhbWUgcGxhY2UuICBTaW5jZSBEYXJ3aW4gdXNl
  cyBHTlUgbWFrZSwgdGhpcyBkb2RnZXMKIyB0aGUgcHJvYmxlbS4KZmlyc3RtYWtlZmlsZT1HTlVt
  YWtlZmlsZTsKCiMgUGFydHMgb2YgdGhlIHN5c3RlbSBjYWxsIHNldGVudigpLCBpbiBwYXJ0aWN1
  bGFyIGluIGFuIGF0Zm9yayBoYW5kbGVyLgojIFRoaXMgY2F1c2VzIHByb2JsZW1zIHdoZW4gdGhl
  IGNoaWxkIHRyaWVzIHRvIGNsZWFuIHVwIGVudmlyb25bXSwgc28KIyBsZXQgbGliYyBtYW5hZ2Ug
  ZW52aXJvbltdLgpjYXQgPj4gY29uZmlnLm92ZXIgPDwnRU9PVkVSJwppZiB0ZXN0ICIkZF91bnNl
  dGVudiIgPSAiJGRlZmluZSIgLWEgXAogICAgYGV4cHIgIiRjY2ZsYWdzIiA6ICcuKi1EUEVSTF9V
  U0VfU0FGRV9QVVRFTlYnYCAtZXEgMDsgdGhlbgogICAgICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1E
  UEVSTF9VU0VfU0FGRV9QVVRFTlYiCmZpCkVPT1ZFUgoKIyBpZiB5b3UgdXNlIGEgbmV3ZXIgdG9v
  bGNoYWluIGJlZm9yZSBPUyBYIDEwLjkgdGhlc2UgZnVuY3Rpb25zIG1heSBiZQojIGluY29ycmVj
  dGx5IGRldGVjdGVkLCBzbyBkaXNhYmxlIHRoZW0KIyBPUyBYIDEwLjEwLnggY29ycmVzcG9uZHMg
  dG8ga2VybmVsIDE0LngKY2FzZSAiJG9zdmVycyIgaW4KICAgIFsxLTldLip8MVswLTNdLiopCglk
  X2xpbmthdD11bmRlZgoJZF9vcGVuYXQ9dW5kZWYKCWRfcmVuYW1lYXQ9dW5kZWYKCWRfdW5saW5r
  YXQ9dW5kZWYKCWRfZmNobW9kYXQ9dW5kZWYKCTs7CmVzYWMKCiMgbWtvc3RlbXAoKSB3YXMgYXV0
  b2RldGVjdGVkIGFzIHByZXNlbnQgYnV0IGZvdW5kIHRvIG5vdCBiZSBsaW5rYWJsZQojIG9uIDE1
  LjYuMC4gIFVua25vd24gd2hhdCBvdGhlciBPUyB2ZXJzaW9ucyBhcmUgYWZmZWN0ZWQuCmRfbWtv
  c3RlbXA9dW5kZWYK',
  'dragonfly' =>
  'IyBoaW50cy9kcmFnb25mbHkuc2gKIwojIFRoaXMgZmlsZSBpcyBtb3N0bHkgY29waWVkIGZyb20g
  aGludHMvZnJlZWJzZC5zaCB3aXRoIHRoZSBPUyB2ZXJzaW9uCiMgaW5mb3JtYXRpb24gdGFrZW4g
  b3V0IGFuZCBvbmx5IHRoZSBGcmVlQlNELTQgaW5mb3JtYXRpb24gaW50YWN0LgojIFBsZWFzZSBj
  aGVjayB3aXRoIFRvZGQgV2lsbGV5IDx4dG9kZHhAZ21haWwuY29tPiBiZWZvcmUgbWFraW5nCiMg
  bW9kaWZpY2F0aW9ucyB0byB0aGlzIGZpbGUuIFNlZSBodHRwOi8vd3d3LmRyYWdvbmZseWJzZC5v
  cmcvCgpjYXNlICIkb3N2ZXJzIiBpbgoqKSAgdXNldmZvcms9J3RydWUnCiAgICBjYXNlICIkdXNl
  bXltYWxsb2MiIGluCgkiIikgdXNlbXltYWxsb2M9J24nCgkgICAgOzsKICAgIGVzYWMKICAgIGxp
  YnN3YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQgJ3MvIG1hbGxvYyAvIC8nYAogICAgOzsK
  ZXNhYwoKIyBEeW5hbWljIExvYWRpbmcgZmxhZ3MgaGF2ZSBub3QgY2hhbmdlZCBtdWNoLCBzbyB0
  aGV5IGFyZSBzZXBhcmF0ZWQKIyBvdXQgaGVyZSB0byBhdm9pZCBkdXBsaWNhdGluZyB0aGVtIGV2
  ZXJ5d2hlcmUuCmNhc2UgIiRvc3ZlcnMiIGluCiopICBvYmpmb3JtYXQ9YC91c3IvYmluL29iamZv
  cm1hdGAKICAgIGxpYnB0aD0iL3Vzci9saWIgL3Vzci9sb2NhbC9saWIiCiAgICBnbGlicHRoPSIv
  dXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIKICAgIGxkZmxhZ3M9Ii1XbCwtRSAiCiAgICBsZGRsZmxh
  Z3M9Ii1zaGFyZWQgIgogICAgY2NjZGxmbGFncz0nLURQSUMgLWZQSUMnCiAgICA7Owplc2FjCgpj
  YXNlICIkb3N2ZXJzIiBpbgoqKSAgY2NmbGFncz0iJHtjY2ZsYWdzfSAtREhBU19GUFNFVE1BU0sg
  LURIQVNfRkxPQVRJTkdQT0lOVF9IIgogICAgaWYgL3Vzci9iaW4vZmlsZSAtTCAvdXNyL2xpYi9s
  aWJjLnNvIHwgL3Vzci9iaW4vZ3JlcCAtdnEgIm5vdCBzdHJpcHBlZCIgOyB0aGVuCgl1c2VubT1m
  YWxzZQogICAgZmkKICAgIDs7CmVzYWMKCmNhdCA8PCdFT00nID4mNAoKU29tZSB1c2VycyBoYXZl
  IHJlcG9ydGVkIHRoYXQgQ29uZmlndXJlIGhhbHRzIHdoZW4gdGVzdGluZyBmb3IKdGhlIE9fTk9O
  QkxPQ0sgc3ltYm9sIHdpdGggYSBzeW50YXggZXJyb3IuICBUaGlzIGlzIGFwcGFyZW50bHkgYQpz
  aCBlcnJvci4gIFJlcnVubmluZyBDb25maWd1cmUgd2l0aCBrc2ggYXBwYXJlbnRseSBmaXhlcyB0
  aGUKcHJvYmxlbS4gIFRyeQogICAgICAga3NoIENvbmZpZ3VyZSBbeW91ciBvcHRpb25zXQoKRU9N
  CgojIEZyb206IEFudG9uIEJlcmV6aW4gPHRvYmV6QHBsYWIua3UuZGs+CiMgVG86IHBlcmw1LXBv
  cnRlcnNAcGVybC5vcmcKIyBTdWJqZWN0OiBbUEFUQ0ggNS4wMDVfNTRdIENvbmZpZ3VyZSAtIGhp
  bnRzL2ZyZWVic2Quc2ggc2lnbmFsIGhhbmRsZXIgdHlwZQojIERhdGU6IDMwIE5vdiAxOTk4IDE5
  OjQ2OjI0ICswMTAwCiMgTWVzc2FnZS1JRDogPDg2NHNyaGh2Y3YuZnNmQGxpb24ucGxhYi5rdS5k
  az4KCnNpZ25hbF90PSd2b2lkJwpkX3ZvaWRzaWc9J2RlZmluZScKCiMgVGhpcyBzY3JpcHQgVVUv
  dXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRl
  ciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNh
  dCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRl
  ZmluZXx0cnVlfFt5WV0qKQogICAgY2FzZSAiJG9zdmVycyIgaW4KICAgICopICBsZGZsYWdzPSIt
  cHRocmVhZCAkbGRmbGFncyIKCgkjIEJvdGggaW4gNC54IGFuZCA1LnggZ2V0aG9zdGJ5YWRkcl9y
  IGV4aXN0cyBidXQKCSMgaXQgaXMgIlRlbXBvcmFyeSBmdW5jdGlvbiwgbm90IHRocmVhZHNhZmUi
  Li4uCgkjIFByZXN1bWFibHkgZWFybGllciBpdCBkaWRuJ3QgZXZlbiBleGlzdC4KCWRfZ2V0aG9z
  dGJ5YWRkcl9yPSJ1bmRlZiIKCWRfZ2V0aG9zdGJ5YWRkcl9yX3Byb3RvPSIwIgoKCTs7CiAgICBl
  c2FjCmVzYWMKRU9DQlUKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAi
  IGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMKCnRlc3QgIiRvcHRpbWl6ZSIg
  fHwgb3B0aW1pemU9Jy1PMicK',
  'freebsd' =>
  'IyBPcmlnaW5hbCBiYXNlZCBvbiBpbmZvIGZyb20KIyBDYXJsIE0uIEZvbmdoZWlzZXIgPGNtZkBp
  bnMuaW5mb25ldC5uZXQ+CiMgRGF0ZTogVGh1LCAyOCBKdWwgMTk5NCAxOToxNzowNSAtMDUwMCAo
  Q0RUKQojCiMgQWRkaXRpb25hbCAxLjEuNSBkZWZpbmVzIGZyb20gCiMgT2xsaXZpZXIgUm9iZXJ0
  IDxPbGxpdmllci5Sb2JlcnRAa2VsdGlhLmZybXVnLmZyLm5ldD4KIyBEYXRlOiBXZWQsIDI4IFNl
  cCAxOTk0IDAwOjM3OjQ2ICswMTAwIChNRVQpCiMKIyBBZGRpdGlvbmFsIDIuKiBkZWZpbmVzIGZy
  b20KIyBPbGxpdmllciBSb2JlcnQgPE9sbGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0
  PgojIERhdGU6IFNhdCwgOCBBcHIgMTk5NSAyMDo1Mzo0MSArMDIwMCAoTUVUIERTVCkKIwojIEFk
  ZGl0aW9uYWwgMi4wLjUgYW5kIDIuMSBkZWZpbmVkIGZyb20KIyBPbGxpdmllciBSb2JlcnQgPE9s
  bGl2aWVyLlJvYmVydEBrZWx0aWEuZnJtdWcuZnIubmV0PgojIERhdGU6IEZyaSwgMTIgTWF5IDE5
  OTUgMTQ6MzA6MzggKzAyMDAgKE1FVCBEU1QpCiMKIyBBZGRpdGlvbmFsIDIuMiBkZWZpbmVzIGZy
  b20KIyBNYXJrIE11cnJheSA8bWFya0Bncm9uZGFyLnphPgojIERhdGU6IFdlZCwgNiBOb3YgMTk5
  NiAwOTo0NDo1OCArMDIwMCAoTUVUKQojCiMgTW9kaWZpZWQgdG8gZW5zdXJlIHdlIHJlcGxhY2Ug
  LWxjIHdpdGggLWxjX3IsIGFuZAojIHRvIHB1dCBpbiBwbGFjZS1ob2xkZXJzIGZvciB2YXJpb3Vz
  IHNwZWNpZmljIGhpbnRzLgojIEFuZHkgRG91Z2hlcnR5IDxkb3VnaGVyYUBsYWZheWV0dGUuZWR1
  PgojIERhdGU6IFR1ZSBNYXIgMTAgMTY6MDc6MDAgRVNUIDE5OTgKIwojIFN1cHBvcnQgZm9yIEZy
  ZWVCU0QvRUxGCiMgT2xsaXZpZXIgUm9iZXJ0IDxyb2JlcnRvQGtlbHRpYS5mcmVlbml4LmZyPgoj
  IERhdGU6IFdlZCBTZXAgIDIgMTY6MjI6MTIgQ0VTVCAxOTk4CiMKIyBUaGUgdHdvIGZsYWdzICIt
  ZnBpYyAtRFBJQyIgYXJlIHVzZWQgdG8gaW5kaWNhdGUgYQojIHdpbGwtYmUtc2hhcmVkIG9iamVj
  dC4gIENvbmZpZ3VyZSB3aWxsIGd1ZXNzIHRoZSAtZnBpYywgKGFuZCB0aGUKIyAtRFBJQyBpcyBu
  b3QgdXNlZCBieSBwZXJsIHByb3BlcikgYnV0IHRoZSBmdWxsIGRlZmluZSBpcyBpbmNsdWRlZCB0
  byAKIyBiZSBjb25zaXN0ZW50IHdpdGggdGhlIEZyZWVCU0QgZ2VuZXJhbCBzaGFyZWQgbGlicyBi
  dWlsZGluZyBwcm9jZXNzLgojCiMgc2V0cmV1aWQgYW5kIGZyaWVuZHMgYXJlIGluaGVyZW50bHkg
  YnJva2VuIGluIGFsbCB2ZXJzaW9ucyBvZiBGcmVlQlNECiMgYmVmb3JlIDIuMS1jdXJyZW50IChi
  ZWZvcmUgYXBwcm94IGRhdGUgNC8xNS85NSkuIEl0IGlzIGZpeGVkIGluIDIuMC41CiMgYW5kIHdo
  YXQtd2lsbC1iZS0yLjEKIwoKY2FzZSAiJG9zdmVycyIgaW4KMC4qfDEuMCopCgl1c2VkbD0iJHVu
  ZGVmIgoJOzsKMS4xKikKCW1hbGxvY3R5cGU9J3ZvaWQgKicKCWdyb3Vwc3R5cGU9J2ludCcKCWRf
  c2V0cmVnaWQ9J3VuZGVmJwoJZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJ
  ZF9zZXRydWlkPSd1bmRlZicKCTs7CjIuMC1yZWxlYXNlKikKCWRfc2V0cmVnaWQ9J3VuZGVmJwoJ
  ZF9zZXRyZXVpZD0ndW5kZWYnCglkX3NldHJnaWQ9J3VuZGVmJwoJZF9zZXRydWlkPSd1bmRlZicK
  CTs7CiMKIyBUcnlpbmcgdG8gY292ZXIgMi4wLjUsIDIuMS1jdXJyZW50IGFuZCBmdXR1cmUgMi4x
  LzIuMgojIEl0IGRvZXMgbm90IGNvdmVydCBhbGwgMi4xLWN1cnJlbnQgdmVyc2lvbnMgYXMgdGhl
  IG91dHB1dCBvZiB1bmFtZQojIGNoYW5nZWQgYSBmZXcgdGltZXMuCiMKIyBFdmVuIHRob3VnaCBz
  ZXRldWlkL3NldGVnaWQgYXJlIGF2YWlsYWJsZSwgdGhleSd2ZSBiZWVuIHR1cm5lZCBvZmYKIyBi
  ZWNhdXNlIHBlcmwgaXNuJ3QgY29kZWQgd2l0aCBzYXZlZCBzZXRbdWddaWQgdmFyaWFibGVzIGlu
  IG1pbmQuCiMgSW4gYWRkaXRpb24sIGEgc21hbGwgcGF0Y2ggaXMgcmVxdWlyZWQgdG8gc3VpZHBl
  cmwgdG8gYXZvaWQgYSBzZWN1cml0eQojIHByb2JsZW0gd2l0aCBGcmVlQlNELgojCjIuMC41Knwy
  LjAtYnVpbHQqfDIuMSopCiAJdXNldmZvcms9J3RydWUnCgljYXNlICIkdXNlbXltYWxsb2MiIGlu
  CgkgICAgIiIpIHVzZW15bWFsbG9jPSduJwoJICAgICAgICA7OwoJZXNhYwoJZF9zZXRyZWdpZD0n
  ZGVmaW5lJwoJZF9zZXRyZXVpZD0nZGVmaW5lJwoJZF9zZXRlZ2lkPSd1bmRlZicKCWRfc2V0ZXVp
  ZD0ndW5kZWYnCgl0ZXN0IC1yIC4vYnJva2VuLWRiLm1zZyAmJiAuIC4vYnJva2VuLWRiLm1zZwoJ
  OzsKIwojIDIuMiBhbmQgYWJvdmUgaGF2ZSBwaGttYWxsb2MoMykuCiMgZG9uJ3QgdXNlIC1sbWFs
  bG9jIChtYXliZSB0aGVyZSdzIGFuIG9sZCBvbmUgZnJvbSAxLjEuNS4xIGZsb2F0aW5nIGFyb3Vu
  ZCkKMi4yKikKIAl1c2V2Zm9yaz0ndHJ1ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAi
  IikgdXNlbXltYWxsb2M9J24nCgkgICAgICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRs
  aWJzd2FudGVkIHwgc2VkICdzLyBtYWxsb2MgLyAvJ2AKCWxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3
  YW50ZWQgfCBzZWQgJ3MvIGJpbmQgLyAvJ2AKCSMgaWNvbnYgZ29uZSBpbiBQZXJsIDUuOC4xLCBi
  dXQgaWYgc29tZW9uZSBjb21waWxlcyA1LjguMCBvciBlYXJsaWVyLgoJbGlic3dhbnRlZD1gZWNo
  byAkbGlic3dhbnRlZCB8IHNlZCAncy8gaWNvbnYgLyAvJ2AKCWRfc2V0cmVnaWQ9J2RlZmluZScK
  CWRfc2V0cmV1aWQ9J2RlZmluZScKCWRfc2V0ZWdpZD0nZGVmaW5lJwoJZF9zZXRldWlkPSdkZWZp
  bmUnCgkjIGRfZG9zdWlkPSdkZWZpbmUnICMgT2Jzb2xldGUuCgk7OwoqKQl1c2V2Zm9yaz0ndHJ1
  ZScKCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4KCSAgICAiIikgdXNlbXltYWxsb2M9J24nCgkgICAg
  ICAgIDs7Cgllc2FjCglsaWJzd2FudGVkPWBlY2hvICRsaWJzd2FudGVkIHwgc2VkICdzLyBtYWxs
  b2MgLyAvJ2AKCTs7CmVzYWMKCmNhc2UgIiRvc3ZlcnMiIGluCjEwLiopCgkjIGR0cmFjZSBvbiAx
  MC54IG5lZWRzIGxpYmVsZiBzeW1ib2xzLCBidXQgd2UgZG9uJ3Qga25vdyBpZiB0aGUKCSMgdXNl
  ciBpcyBnb2luZyB0byByZXF1ZXN0IHVzZWR0cmFjZSBhbmQgdGhlcmUncyBubyAuY2J1IGZvciB1
  c2VkdHJhY2UKCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIGVsZiIKCTs7CmVzYWMKCiMgRHluYW1p
  YyBMb2FkaW5nIGZsYWdzIGhhdmUgbm90IGNoYW5nZWQgbXVjaCwgc28gdGhleSBhcmUgc2VwYXJh
  dGVkCiMgb3V0IGhlcmUgdG8gYXZvaWQgZHVwbGljYXRpbmcgdGhlbSBldmVyeXdoZXJlLgpjYXNl
  ICIkb3N2ZXJzIiBpbgowLip8MS4wKikgOzsKCjEuKnwyLiopCgljY2NkbGZsYWdzPSctRFBJQyAt
  ZnBpYycKCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxkZGxmbGFncyIKCTs7CgozKnw0Knw1Knw2
  KikKICAgICAgICBvYmpmb3JtYXQ9YC91c3IvYmluL29iamZvcm1hdGAKICAgICAgICBpZiBbIHgk
  b2JqZm9ybWF0ID0geGFvdXQgXTsgdGhlbgogICAgICAgICAgICBpZiBbIC1lIC91c3IvbGliL2Fv
  dXQgXTsgdGhlbgogICAgICAgICAgICAgICAgbGlicHRoPSIvdXNyL2xpYi9hb3V0IC91c3IvbG9j
  YWwvbGliIC91c3IvbGliIgogICAgICAgICAgICAgICAgZ2xpYnB0aD0iL3Vzci9saWIvYW91dCAv
  dXNyL2xvY2FsL2xpYiAvdXNyL2xpYiIKICAgICAgICAgICAgZmkKICAgICAgICAgICAgbGRkbGZs
  YWdzPSctQnNoYXJlYWJsZScKICAgICAgICBlbHNlCiAgICAgICAgICAgIGxpYnB0aD0iL3Vzci9s
  aWIgL3Vzci9sb2NhbC9saWIiCiAgICAgICAgICAgIGdsaWJwdGg9Ii91c3IvbGliIC91c3IvbG9j
  YWwvbGliIgogICAgICAgICAgICBsZGZsYWdzPSItV2wsLUUgIgogICAgICAgICAgICBsZGRsZmxh
  Z3M9Ii1zaGFyZWQgIgogICAgICAgIGZpCiAgICAgICAgY2NjZGxmbGFncz0nLURQSUMgLWZQSUMn
  CiAgICAgICAgOzsKKikKICAgICAgIGxpYnB0aD0iL3Vzci9saWIgL3Vzci9sb2NhbC9saWIiCiAg
  ICAgICBnbGlicHRoPSIvdXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIKICAgICAgIGxkZmxhZ3M9Ii1X
  bCwtRSAiCiAgICAgICAgbGRkbGZsYWdzPSItc2hhcmVkICIKICAgICAgICBjY2NkbGZsYWdzPSct
  RFBJQyAtZlBJQycKICAgICAgIDs7CmVzYWMKCmNhc2UgIiRvc3ZlcnMiIGluCjAuKnwxLip8Mi4q
  fDMuKikgOzsKCiopCgljY2ZsYWdzPSIke2NjZmxhZ3N9IC1ESEFTX0ZQU0VUTUFTSyAtREhBU19G
  TE9BVElOR1BPSU5UX0giCglpZiAvdXNyL2Jpbi9maWxlIC1MIC91c3IvbGliL2xpYmMuc28gfCAv
  dXNyL2Jpbi9ncmVwIC12cSAibm90IHN0cmlwcGVkIiA7IHRoZW4KCSAgICB1c2VubT1mYWxzZQoJ
  ZmkKICAgICAgICA7Owplc2FjCgpjYXQgPDwnRU9NJyA+JjQKClNvbWUgdXNlcnMgaGF2ZSByZXBv
  cnRlZCB0aGF0IENvbmZpZ3VyZSBoYWx0cyB3aGVuIHRlc3RpbmcgZm9yCnRoZSBPX05PTkJMT0NL
  IHN5bWJvbCB3aXRoIGEgc3ludGF4IGVycm9yLiAgVGhpcyBpcyBhcHBhcmVudGx5IGEKc2ggZXJy
  b3IuICBSZXJ1bm5pbmcgQ29uZmlndXJlIHdpdGgga3NoIGFwcGFyZW50bHkgZml4ZXMgdGhlCnBy
  b2JsZW0uICBUcnkKCWtzaCBDb25maWd1cmUgW3lvdXIgb3B0aW9uc10KCkVPTQoKIyBGcm9tOiBB
  bnRvbiBCZXJlemluIDx0b2JlekBwbGFiLmt1LmRrPgojIFRvOiBwZXJsNS1wb3J0ZXJzQHBlcmwu
  b3JnCiMgU3ViamVjdDogW1BBVENIIDUuMDA1XzU0XSBDb25maWd1cmUgLSBoaW50cy9mcmVlYnNk
  LnNoIHNpZ25hbCBoYW5kbGVyIHR5cGUKIyBEYXRlOiAzMCBOb3YgMTk5OCAxOTo0NjoyNCArMDEw
  MAojIE1lc3NhZ2UtSUQ6IDw4NjRzcmhodmN2LmZzZkBsaW9uLnBsYWIua3UuZGs+CgpzaWduYWxf
  dD0ndm9pZCcKZF92b2lkc2lnPSdkZWZpbmUnCgojIHNldCBsaWJwZXJsLnNvLlguWCBmb3IgMi4y
  LlgKY2FzZSAiJG9zdmVycyIgaW4KMi4yKikKICAgICMgdW5mb3J0dW5hdGVseSB0aGlzIGNvZGUg
  Z2V0cyBleGVjdXRlZCBiZWZvcmUKICAgICMgdGhlIGVxdWl2YWxlbnQgaW4gdGhlIG1haW4gQ29u
  ZmlndXJlIHNvIHdlIGNvcHkgYSBsaXR0bGUKICAgICMgZnJvbSBDb25maWd1cmUgWFhYIENvbmZp
  Z3VyZSBzaG91bGQgYmUgZml4ZWQuCiAgICBpZiAkdGVzdCAtciAkc3JjL3BhdGNobGV2ZWwuaDt0
  aGVuCiAgICAgICBwYXRjaGxldmVsPWBhd2sgJy9kZWZpbmVbIAldK1BFUkxfVkVSU0lPTi8ge3By
  aW50ICQzfScgJHNyYy9wYXRjaGxldmVsLmhgCiAgICAgICBzdWJ2ZXJzaW9uPWBhd2sgJy9kZWZp
  bmVbIAldK1BFUkxfU1VCVkVSU0lPTi8ge3ByaW50ICQzfScgJHNyYy9wYXRjaGxldmVsLmhgCiAg
  ICBlbHNlCiAgICAgICBwYXRjaGxldmVsPTAKICAgICAgIHN1YnZlcnNpb249MAogICAgZmkKICAg
  IGxpYnBlcmw9ImxpYnBlcmwuc28uJHBhdGNobGV2ZWwuJHN1YnZlcnNpb24iCiAgICB1bnNldCBw
  YXRjaGxldmVsCiAgICB1bnNldCBzdWJ2ZXJzaW9uCiAgICA7Owplc2FjCgojIFRoaXMgc2NyaXB0
  IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIAoj
  IGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgdGhyZWFk
  cy4KY2F0ID4gVVUvdXNldGhyZWFkcy5jYnUgPDwnRU9DQlUnCmNhc2UgIiR1c2V0aHJlYWRzIiBp
  bgokZGVmaW5lfHRydWV8W3lZXSopCiAgICAgICAgbGNfcj1gL3NiaW4vbGRjb25maWcgLXJ8Z3Jl
  cCAnOi1sY19yJ3xhd2sgJ3twcmludCAkTkZ9J3xzZWQgLW4gJyRwJ2AKICAgICAgICBjYXNlICIk
  b3N2ZXJzIiBpbiAgCgkwLip8MS4qfDIuMCp8Mi4xKikgICBjYXQgPDxFT00gPiY0CkkgZGlkIG5v
  dCBrbm93IHRoYXQgRnJlZUJTRCAkb3N2ZXJzIHN1cHBvcnRzIFBPU0lYIHRocmVhZHMuCgpGZWVs
  IGZyZWUgdG8gdGVsbCBwZXJsYnVnQHBlcmwub3JnIG90aGVyd2lzZS4KRU9NCgkgICAgICBleGl0
  IDEKCSAgICAgIDs7CgogICAgICAgIDIuMi5bMC03XSopCiAgICAgICAgICAgICAgY2F0IDw8RU9N
  ID4mNApQT1NJWCB0aHJlYWRzIGFyZSBub3Qgc3VwcG9ydGVkIHdlbGwgYnkgRnJlZUJTRCAkb3N2
  ZXJzLgoKUGxlYXNlIGNvbnNpZGVyIHVwZ3JhZGluZyB0byBhdCBsZWFzdCBGcmVlQlNEIDIuMi44
  LApvciBwcmVmZXJhYmx5IHRvIHRoZSBtb3N0IHJlY2VudCAtUkVMRUFTRSBvciAtU1RBQkxFCnZl
  cnNpb24gKHNlZSBodHRwOi8vd3d3LmZyZWVic2Qub3JnL3JlbGVhc2VzLykuCgooV2hpbGUgMi4y
  LjcgZG9lcyBoYXZlIHB0aHJlYWRzLCBpdCBoYXMgc29tZSBwcm9ibGVtcwogd2l0aCB0aGUgY29t
  YmluYXRpb24gb2YgdGhyZWFkcyBhbmQgcGlwZXMgYW5kIHRoZXJlZm9yZQogbWFueSBQZXJsIHRl
  c3RzIHdpbGwgZWl0aGVyIGhhbmcgb3IgZmFpbC4pCkVPTQoJICAgICAgZXhpdCAxCgkgICAgICA7
  OwoKCVszLTVdLiopCgkgICAgICBpZiBbICEgLXIgIiRsY19yIiBdOyB0aGVuCgkgICAgICBjYXQg
  PDxFT00gPiY0ClBPU0lYIHRocmVhZHMgc2hvdWxkIGJlIHN1cHBvcnRlZCBieSBGcmVlQlNEICRv
  c3ZlcnMgLS0KYnV0IHlvdXIgc3lzdGVtIGlzIG1pc3NpbmcgdGhlIHNoYXJlZCBsaWJjX3IuCigv
  c2Jpbi9sZGNvbmZpZyAtciBkb2Vzbid0IGZpbmQgYW55KS4KCkNvbnNpZGVyIHVzaW5nIHRoZSBs
  YXRlc3QgU1RBQkxFIHJlbGVhc2UuCkVPTQoJCSBleGl0IDEKCSAgICAgIGZpCgkgICAgICAjIDUw
  MDAxNiBpcyB0aGUgZmlyc3Qgb3NyZWxkYXRlIGluIHdoaWNoIG9uZSBjb3VsZAoJICAgICAgIyBq
  dXN0IGxpbmsgYWdhaW5zdCBsaWJjX3Igd2l0aG91dCBkaXNwb3Npbmcgb2YgbGliYwoJICAgICAg
  IyBhdCB0aGUgc2FtZSB0aW1lLiAgNTAwMDE2IC4uLiB1cCB0byB3aGF0ZXZlciBpdCB3YXMKCSAg
  ICAgICMgb24gdGhlIDMxc3Qgb2YgQXVndXN0IDIwMDMgY2FuIHN0aWxsIGJlIHVzZWQgd2l0aCAt
  cHRocmVhZCwKCSAgICAgICMgYnV0IGl0IGlzIG5vdCBuZWNlc3NhcnkuCgoJICAgICAgIyBBbnRv
  biBCZXJlemluIHNheXMgdGhhdCBwb3N0IDUwMHNvbWV0aGluZyB3ZSdyZSB3cm9uZyB0byBiZQoJ
  ICAgICAgIyB0byBiZSB1c2luZyAtbGNfciwgYW5kIHNob3VsZCBqdXN0IGJlIHVzaW5nIC1wdGhy
  ZWFkIG9uIHRoZQoJICAgICAgIyBsaW5rZXIgbGluZS4KCSAgICAgICMgU28gcHJlc3VtYWJseSBy
  ZWFsbHkgd2Ugc2hvdWxkIGJlIGNoZWNraW5nIHRoYXQgJG9zdmVyIGlzIDUuKikKCSAgICAgICMg
  YW5kIHRoYXQgYC9zYmluL3N5c2N0bCAtbiBrZXJuLm9zcmVsZGF0ZWAgLWdlIDUwMDAxNgoJICAg
  ICAgIyBvciAtbHQgNTAwc29tZXRoaW5nIGFuZCBvbmx5IGluIHRoYXQgcmFuZ2Ugbm90IGRvaW5n
  IHRoaXM6CgkgICAgICBsZGZsYWdzPSItcHRocmVhZCAkbGRmbGFncyIKCgkgICAgICAjIEJvdGgg
  aW4gNC54IGFuZCA1LnggZ2V0aG9zdGJ5YWRkcl9yIGV4aXN0cyBidXQKCSAgICAgICMgaXQgaXMg
  IlRlbXBvcmFyeSBmdW5jdGlvbiwgbm90IHRocmVhZHNhZmUiLi4uCgkgICAgICAjIFByZXN1bWFi
  bHkgZWFybGllciBpdCBkaWRuJ3QgZXZlbiBleGlzdC4KCSAgICAgIGRfZ2V0aG9zdGJ5YWRkcl9y
  PSJ1bmRlZiIKCSAgICAgIGRfZ2V0aG9zdGJ5YWRkcl9yX3Byb3RvPSIwIgoJICAgICAgOzsKCgkq
  KQoJICAgICAgIyA3LnggZG9lc24ndCBpbnN0YWxsIGxpYmNfciBieSBkZWZhdWx0LCBhbmQgQ29u
  ZmlndXJlCgkgICAgICAjIHdvdWxkIGZhaWwgaW4gdGhlIGNvZGUgZm9sbG93aW5nCgkgICAgICAj
  CgkgICAgICAjIGdldGhvc3RieWFkZHJfcigpIGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGltcGxlbWVu
  dGVkIGluIDYueCsKCSAgICAgIGxkZmxhZ3M9Ii1wdGhyZWFkICRsZGZsYWdzIgoJICAgICAgOzsK
  Cgllc2FjCgogICAgICAgIGNhc2UgIiRvc3ZlcnMiIGluCiAgICAgICAgWzEtNF0qKQoJICAgIHNl
  dCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGMgLyBjX3IgLydgCgkgICAgc2hp
  ZnQKCSAgICBsaWJzd2FudGVkPSIkKiIKCSAgICA7OwogICAgICAgICopCgkgICAgc2V0IGBlY2hv
  IFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvLydgCgkgICAgc2hpZnQKCSAgICBsaWJz
  d2FudGVkPSIkKiIKCSAgICA7OwoJZXNhYwoJICAgIAoJIyBDb25maWd1cmUgd2lsbCBwcm9iYWJs
  eSBwaWNrIHRoZSB3cm9uZyBsaWJjIHRvIHVzZSBmb3Igbm0gc2Nhbi4KCSMgVGhlIHNhZmVzdCBx
  dWljay1maXggaXMganVzdCB0byBub3QgdXNlIG5tIGF0IGFsbC4uLgoJdXNlbm09ZmFsc2UKCiAg
  ICAgICAgY2FzZSAiJG9zdmVycyIgaW4KICAgICAgICAyLjIuOCopCiAgICAgICAgICAgICMgLi4u
  IGJ1dCB0aGlzIGRvZXMgbm90IGFwcGx5IGZvciAyLjIuOCAtIHdlIGtub3cgaXQncyBzYWZlCiAg
  ICAgICAgICAgIGxpYmM9IiRsY19yIgogICAgICAgICAgICB1c2VubT10cnVlCiAgICAgICAgICAg
  OzsKICAgICAgICBlc2FjCgogICAgICAgIHVuc2V0IGxjX3IKCgkjIEV2ZW4gd2l0aCB0aGUgbWFs
  bG9jIG11dGV4ZXMgdGhlIFBlcmwgbWFsbG9jIGRvZXMgbm90CgkjIHNlZW0gdG8gYmUgdGhyZWFk
  c2FmZSBpbiBGcmVlQlNEPwoJY2FzZSAiJHVzZW15bWFsbG9jIiBpbgoJJycpIHVzZW15bWFsbG9j
  PW4gOzsKCWVzYWMKZXNhYwpFT0NCVQoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFs
  bG9jd3JhcCIgaW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBYWFggVW5k
  ZXIgRnJlZUJTRCA2LjAgKGFuZCBwcm9iYWJseSBtb3N0IG90aGVyIHNpbWlsYXIgdmVyc2lvbnMp
  CiMgUGVybF9kaWUoTlVMTCkgZ2VuZXJhdGVzIGEgd2FybmluZzoKIyAgICBwcF9zeXMuYzo0OTE6
  IHdhcm5pbmc6IG51bGwgZm9ybWF0IHN0cmluZwojIENvbmZpZ3VyZSBzdXBwb3NlZGx5IHRlc3Rz
  IGZvciB0aGlzLCBidXQgYXBwYXJlbnRseSB0aGUgdGVzdCBkb2Vzbid0CiMgd29yay4gIFZvbHVu
  dGVlcnMgd2l0aCBGcmVlQlNEIGFyZSBuZWVkZWQgdG8gaW1wcm92aW5nIHRoZSBDb25maWd1cmUg
  dGVzdC4KIyBNZWFud2hpbGUsIHRoZSBmb2xsb3dpbmcgd29ya2Fyb3VuZCBzaG91bGQgYmUgc2Fm
  ZSBvbiBhbGwgdmVyc2lvbnMKIyBvZiBGcmVlQlNELgpkX3ByaW50Zl9mb3JtYXRfbnVsbD0ndW5k
  ZWYnCgojIFNlZSBbcGVybCAjMTI4ODY3XQojIEludGVycHJldGluZzogaHR0cHM6Ly9idWdzLmZy
  ZWVic2Qub3JnL2J1Z3ppbGxhL3Nob3dfYnVnLmNnaT9pZD0yMTE3NDMjYzEwCiMga2h3IHdvcmth
  cm91bmQgbm8gbG9uZ2VyIG5lZWRlZCBpbiB0aGUgZm9sbG93aW5nIEZSRUVCU0RfS0VSTkVMX1ZF
  UlNJT05zCiMxMjAwMDA0IGFuZCB1cAojMTEwMDUwMiA+PSB2ZXJzaW9uIDwgMTIwMDAwMAojMTAw
  MzUwNyA+PSB2ZXJzaW9uIDwgMTEwMDAwMAojIEV4cGVyaW1lbnRzIGhhdmUgc2hvd24gdGhhdCB0
  aGlzIGRvZXNuJ3QgZnVsbHkgd29yay4gIFRoZSBmaXJzdCBrZXJuZWwgd2Uga25vdyBpdCB3b3Jr
  cyBpcyAxMjAwMDU2CgpGUkVFQlNEX0tFUk5FTF9WRVJTSU9OPWB1bmFtZSAtVWAKI2lmICBbICRG
  UkVFQlNEX0tFUk5FTF9WRVJTSU9OIC1sdCAxMDAzNTA3IF0gfHwgXAojICAgIFsgJEZSRUVCU0Rf
  S0VSTkVMX1ZFUlNJT04gLWdlIDExMDAwMDAgXSAmJiBbICRGUkVFQlNEX0tFUk5FTF9WRVJTSU9O
  IC1sdCAxMTAwNTAyIF0gfHwgXAojICAgIFsgJEZSRUVCU0RfS0VSTkVMX1ZFUlNJT04gLWdlIDEy
  MDAwMDAgXSAmJiBbICRGUkVFQlNEX0tFUk5FTF9WRVJTSU9OIC1sdCAxMjAwMDA0IF0KaWYgIFsg
  JEZSRUVCU0RfS0VSTkVMX1ZFUlNJT04gLWx0IDEyMDAwNTYgXQp0aGVuCiAgICBkX3VzZWxvY2Fs
  ZT0ndW5kZWYnCmZpCgojIGh0dHBzOi8vcnQucGVybC5vcmcvVGlja2V0L0Rpc3BsYXkuaHRtbD9p
  ZD0xMzEzMzcKIyBSZXBvcnRlZCBpbiAxMS4wLUNVUlJFTlQgd2l0aCBnKystNC44LjU6CiMgSWYg
  dXNpbmcgZysrLCB0aGUgQ29uZmlndXJlIHNjYW4gZm9yIGRsb3BlbigpIGZhaWxzLgojIEVhc2ll
  ciBmb3Igbm93IHRvIGp1c3QgdG8gZm9yY2libHkgc2V0IGl0LgpjYXNlICIkY2MiIGluCipnKysq
  KQogIGRfZGxvcGVuPSdkZWZpbmUnCiAgOzsKZXNhYwoKY2FzZSBgdW5hbWUgLXBgIGluCmFybXxt
  aXBzKQogIDs7CiopCiAgdGVzdCAiJG9wdGltaXplIiB8fCBvcHRpbWl6ZT0nLU8yJwogIDs7CmVz
  YWMK',
  'gnu' =>
  'IyBoaW50cy9nbnUuc2gKIyBPcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5OiAgTWFyayBLZXR0ZW5p
  cyA8a2V0dGVuaXNAcGh5cy51dmEubmw+IERlYyAxMCAxOTk4CgojIGxpYm5zbCBpcyB1bnVzYWJs
  ZSBvbiB0aGUgSHVyZC4KIyBYWFggcmVtb3ZlIHRoaXMgb25jZSBTVU5SUEMgaXMgaW1wbGVtZW50
  ZWQuCnNldCBgZWNobyBYICIkbGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGJzZCAvIC8nIC1lICdz
  LyBuc2wgLyAvJyAtZSAncy8gYyAvIHB0aHJlYWQgLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoK
  IyBEZWJpYW4gNC4wIHB1dHMgbmRibSBpbiB0aGUgLWxnZGJtX2NvbXBhdCBsaWJyYXJ5LgpsaWJz
  d2FudGVkPSIkbGlic3dhbnRlZCBnZGJtX2NvbXBhdCIKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2Fz
  ZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMK
  CiMgVGhlIHN5c3RlbSBtYWxsb2MoKSBpcyBhYm91dCBhcyBmYXN0IGFuZCBhcyBmcnVnYWwgYXMg
  cGVybCdzLgojIFNpbmNlIHRoZSBzeXN0ZW0gbWFsbG9jKCkgaGFzIGJlZW4gdGhlIGRlZmF1bHQg
  c2luY2UgYXQgbGVhc3QKIyA1LjAwMSwgd2UgbWlnaHQgYXMgd2VsbCBsZWF2ZSBpdCB0aGF0IHdh
  eS4gIC0tQUQgIDEwIEphbiAyMDAyCmNhc2UgIiR1c2VteW1hbGxvYyIgaW4KJycpIHVzZW15bWFs
  bG9jPSduJyA7Owplc2FjCgpjYXNlICIkb3B0aW1pemUiIGluCicnKSBvcHRpbWl6ZT0nLU8yJyA7
  Owplc2FjCgpjYXNlICIkcGxpYnB0aCIgaW4KJycpIHBsaWJwdGg9YGdjYyAtcHJpbnQtc2VhcmNo
  LWRpcnMgfCBncmVwIGxpYnJhcmllcyB8CiAgICAgICAgY3V0IC1mMi0gLWQ9IHwgdHIgJzonICR0
  cm5sIHwgZ3JlcCAtdiAnZ2NjJyB8IHNlZCAtZSAnczovJDo6J2AKICAgIHNldCBYICRwbGlicHRo
  ICMgQ29sbGFwc2UgYWxsIGVudHJpZXMgb24gb25lIGxpbmUKICAgIHNoaWZ0CiAgICBwbGlicHRo
  PSIkKiIKICAgIDs7CmVzYWMKCmNhc2UgIiRsaWJjIiBpbgonJykKIyBJZiB5b3UgaGF2ZSBnbGli
  YywgdGhlbiByZXBvcnQgdGhlIHZlcnNpb24gZm9yIC4vbXljb25maWcgYnVnIHJlcG9ydGluZy4K
  IyAoQ29uZmlndXJlIGRvZXNuJ3QgbmVlZCB0byBrbm93IHRoZSBzcGVjaWZpYyB2ZXJzaW9uIHNp
  bmNlIGl0IGp1c3QgdXNlcwojIGdjYyB0byBsb2FkIHRoZSBsaWJyYXJ5IGZvciBhbGwgdGVzdHMu
  KQojIFdlIGRvbid0IHVzZSBfX0dMSUJDX18gYW5kICBfX0dMSUJDX01JTk9SX18gYmVjYXVzZSB0
  aGV5CiMgYXJlIGluc3VmZmljaWVudGx5IHByZWNpc2UgdG8gZGlzdGluZ3Vpc2ggdGhpbmdzIGxp
  a2UKIyBsaWJjLTIuMC42IGFuZCBsaWJjLTIuMC43LgogICAgZm9yIHAgaW4gJHBsaWJwdGgKICAg
  IGRvCiAgICAgICAgZm9yIHRyeWxpYiBpbiBsaWJjLnNvLjAuMyBsaWJjLnNvCiAgICAgICAgZG8K
  ICAgICAgICAgICAgaWYgJHRlc3QgLWUgJHAvJHRyeWxpYjsgdGhlbgogICAgICAgICAgICAgICAg
  bGliYz1gbHMgLWwgJHAvJHRyeWxpYiB8IGF3ayAne3ByaW50ICRORn0nYAogICAgICAgICAgICAg
  ICAgaWYgJHRlc3QgIlgkbGliYyIgIT0gWDsgdGhlbgogICAgICAgICAgICAgICAgICAgIGJyZWFr
  CiAgICAgICAgICAgICAgICBmaQogICAgICAgICAgICBmaQogICAgICAgIGRvbmUKICAgICAgICBp
  ZiAkdGVzdCAiWCRsaWJjIiAhPSBYOyB0aGVuCiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZmkK
  ICAgIGRvbmUKICAgIDs7CmVzYWMKCiMgRmxhZ3MgbmVlZGVkIHRvIHByb2R1Y2Ugc2hhcmVkIGxp
  YnJhcmllcy4KbGRkbGZsYWdzPSctc2hhcmVkJwoKIyBGbGFncyBuZWVkZWQgYnkgcHJvZ3JhbXMg
  dGhhdCB1c2UgZHluYW1pYyBsaW5raW5nLgpjY2RsZmxhZ3M9Jy1XbCwtRScKCiMgVGhpcyBzY3Jp
  cHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUK
  IyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVh
  ZHMuCmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIg
  aW4KJGRlZmluZXx0cnVlfFt5WV0qKQogICAgICAgIGNjZmxhZ3M9Ii1EX1JFRU5UUkFOVCAtRF9H
  TlVfU09VUkNFICRjY2ZsYWdzIgogICAgICAgIGlmIGVjaG8gJGxpYnN3YW50ZWQgfCBncmVwIC12
  IHB0aHJlYWQgPi9kZXYvbnVsbAogICAgICAgIHRoZW4KICAgICAgICAgICAgc2V0IGBlY2hvIFgg
  IiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvIHB0aHJlYWQgYyAvJ2AKICAgICAgICAgICAg
  c2hpZnQKICAgICAgICAgICAgbGlic3dhbnRlZD0iJCoiCiAgICAgICAgZmkKCgkjIFNvbWVob3cg
  YXQgbGVhc3QgaW4gRGViaWFuIDIuMiB0aGVzZSBtYW5hZ2UgdG8gZXNjYXBlCgkjIHRoZSAjZGVm
  aW5lIGZvcmVzdCBvZiA8ZmVhdHVyZXMuaD4gYW5kIDx0aW1lLmg+IHNvIHRoYXQKCSMgdGhlIGhh
  c3Byb3RvIG1hY3JvIG9mIENvbmZpZ3VyZSBkb2Vzbid0IHNlZSB0aGVzZSBwcm90b3MsCgkjIGV2
  ZW4gd2l0aCB0aGUgLURfR05VX1NPVVJDRS4KCglkX2FzY3RpbWVfcl9wcm90bz0iJGRlZmluZSIK
  CWRfY3J5cHRfcl9wcm90bz0iJGRlZmluZSIKCWRfY3RpbWVfcl9wcm90bz0iJGRlZmluZSIKCWRf
  Z210aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2xvY2FsdGltZV9yX3Byb3RvPSIkZGVmaW5lIgoJ
  ZF9yYW5kb21fcl9wcm90bz0iJGRlZmluZSIKCgk7Owplc2FjCkVPQ0JVCgpjYXQgPiBVVS91c2Vs
  YXJnZWZpbGVzLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJnZWZpbGVzLmNi
  dSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9t
  cHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCmNhc2UgIiR1c2Vs
  YXJnZWZpbGVzIiBpbgonJ3wkZGVmaW5lfHRydWV8W3lZXSopCiMgS2VlcCB0aGlzIGluIHRoZSBs
  ZWZ0IG1hcmdpbi4KY2NmbGFnc191c2VsYXJnZWZpbGVzPSItRF9MQVJHRUZJTEVfU09VUkNFIC1E
  X0ZJTEVfT0ZGU0VUX0JJVFM9NjQiCgoJY2NmbGFncz0iJGNjZmxhZ3MgJGNjZmxhZ3NfdXNlbGFy
  Z2VmaWxlcyIKCTs7CmVzYWMKRU9DQlUKCiMgVGhlIGZvbGxvd2luZyByb3V0aW5lcyBhcmUgb25s
  eSBhdmFpbGFibGUgYXMgc3R1YnMgaW4gR05VIGxpYmMuCiMgWFhYIHJlbW92ZSB0aGlzIG9uY2Ug
  bWV0YWNvbmYgZGV0ZWN0cyB0aGUgR05VIGxpYmMgc3R1YnMuCmRfbXNnY3RsPSd1bmRlZicKZF9t
  c2dnZXQ9J3VuZGVmJwpkX21zZ3Jjdj0ndW5kZWYnCmRfbXNnc25kPSd1bmRlZicKZF9zZW1jdGw9
  J3VuZGVmJwpkX3NlbWdldD0ndW5kZWYnCmRfc2Vtb3A9J3VuZGVmJwpkX3NobWF0PSd1bmRlZicK
  ZF9zaG1jdGw9J3VuZGVmJwpkX3NobWR0PSd1bmRlZicKZF9zaG1nZXQ9J3VuZGVmJwo=',
  'gnukfreebsd' =>
  'IyEgL2Jpbi9zaAoKIyBTdXBwb3J0IGZvciBEZWJpYW4gR05VL2tGcmVlQlNEIChrZnJlZWJzZC1n
  bnUpCiMgQSBwb3J0IG9mIHRoZSBEZWJpYW4gR05VIHN5c3RlbSB1c2luZyB0aGUgRnJlZUJTRCBr
  ZXJuZWwuCgouIC4vaGludHMvbGludXguc2gKCg==',
  'hpux' =>
  'IyEvdXNyL2Jpbi9zaAoKIyMjIFNZU1RFTSBBUkNISVRFQ1RVUkUKCiMgRGV0ZXJtaW5lIHRoZSBh
  cmNoaXRlY3R1cmUgdHlwZSBvZiB0aGlzIHN5c3RlbS4KIyBLZWVwIGxlYWRpbmcgdGFiIGJlbG93
  IC0tIENvbmZpZ3VyZSBCbGFjayBNYWdpYyAtLSBSQU0sIDAzLzAyLzk3Cgl4eE9zUmV2TWFqb3I9
  YHVuYW1lIC1yIHwgc2VkIC1lICdzL15bXjAtOV0qLy8nIHwgY3V0IC1kLiAtZjFgOwoJeHhPc1Jl
  dk1pbm9yPWB1bmFtZSAtciB8IHNlZCAtZSAncy9eW14wLTldKi8vJyB8IGN1dCAtZC4gLWYyYDsK
  CXh4T3NSZXY9YGV4cHIgMTAwIFwqICR4eE9zUmV2TWFqb3IgKyAkeHhPc1Jldk1pbm9yYAppZiBb
  ICIkeHhPc1Jldk1ham9yIiAtZ2UgMTAgXTsgdGhlbgogICAgIyBUaGlzIHN5c3RlbSBpcyBydW5u
  aW5nID49IDEwLngKCiAgICAjIFRlc3RlZCBvbiAxMC4wMSBQQTEueCBhbmQgMTAuMjAgUEFbMTJd
  LnguCiAgICAjIElkZWE6IFNjYW4gL3Vzci9pbmNsdWRlL3N5cy91bmlzdGQuaCBmb3IgbWF0Y2hl
  cyB3aXRoCiAgICAjICIjZGVmaW5lIENQVV8qIGBnZXRjb25mICMgQ1BVX1ZFUlNJT05gIiB0byBk
  ZXRlcm1pbmUgQ1BVIHR5cGUuCiAgICAjIE5vdGUgdGhlIHRleHQgZm9sbG93aW5nICJDUFVfIiBp
  cyB1c2VkLCAqTk9UKiB0aGUgY29tbWVudC4KICAgICMKICAgICMgQVNTVU1QVElPTlM6IE51bWJl
  cnMgd2lsbCBjb250aW51ZSB0byBiZSBkZWZpbmVkIGluIGhleCAtLSBhbmQgaW4KICAgICMgL3Vz
  ci9pbmNsdWRlL3N5cy91bmlzdGQuaCAtLSBhbmQgdGhlIENQVV8qICNkZWZpbmVzIHdpbGwgYmUg
  a2VwdAogICAgIyB1cCB0byBkYXRlIHdpdGggbmV3IENQVS9PUyByZWxlYXNlcy4KICAgIHh4Y3B1
  PWBnZXRjb25mIENQVV9WRVJTSU9OYDsgIyBHZXQgdGhlIG51bWJlci4KICAgIHh4Y3B1PWBwcmlu
  dGYgJzB4JXgnICR4eGNwdWA7ICMgY29udmVydCB0byBoZXgKICAgIGFyY2huYW1lPWBzZWQgLW4g
  LWUgInMvXiNbWzpzcGFjZTpdXSpkZWZpbmVbWzpzcGFjZTpdXSpDUFVfLy9wIiAvdXNyL2luY2x1
  ZGUvc3lzL3VuaXN0ZC5oIHwKCXNlZCAtbiAtZSAicy9bWzpzcGFjZTpdXSokeHhjcHVbWzpzcGFj
  ZTpdXS4qLy9wIiB8CglzZWQgLWUgcy9fUklTQy8tUklTQy8gLWUgcy9IUF8vLyAtZSBzL18vLi8g
  LWUgInMvW1s6c3BhY2U6XV0qLy9nImA7CmVsc2UKICAgICMgVGhpcyBzeXN0ZW0gaXMgcnVubmlu
  ZyA8PSA5LngKICAgICMgVGVzdGVkIG9uIDkuMFs1N10gUEEgYW5kIFs3OF0uMCBNQzY4MFsyM10w
  LiAgSWRlYTogQWZ0ZXIgcmVtb3ZpbmcKICAgICMgTUM2ODg4WzEyXSBmcm9tIGNvbnRleHQgc3Ry
  aW5nLCB1c2UgZmlyc3QgQ1BVIGlkZW50aWZpZXIuCiAgICAjCiAgICAjIEFTU1VNUFRJT046IE9u
  bHkgQ1BVIGlkZW50aWZpZXJzIGNvbnRhaW4gbm8gbG93ZXJjYXNlIGxldHRlcnMuCiAgICBhcmNo
  bmFtZT1gZ2V0Y29udGV4dCB8IHRyICcgJyAnXDAxMicgfCBncmVwIC12ICdbYS16XScgfCBncmVw
  IC12IE1DNjg4IHwKCXNlZCAtZSAncy9IUC0vLycgLWUgMXFgOwogICAgc2VsZWN0dHlwZT0naW50
  IConCiAgICBmaQoKIyBGb3Igc29tZSBzdHJhbmdlIHJlYXNvbiwgdGhlIHUzMmFsaWduIHRlc3Qg
  ZnJvbSBDb25maWd1cmUgaGFuZ3MgaW4KIyBIUC1VWCAxMC4yMCBzaW5jZSB0aGUgRGVjZW1iZXIg
  MjAwMSBwYXRjaGVzLiAgU28gaGludCBpdCB0byBhdm9pZAojIHRoZSB0ZXN0LgppZiBbICIkeHhP
  c1Jldk1ham9yIiAtbGUgMTAgXTsgdGhlbgogICAgZF91MzJhbGlnbj0kZGVmaW5lCiAgICBmaQoK
  ZWNobyAiQXJjaG5hbWUgaXMgJGFyY2huYW1lIgoKIyBGaXggWFNsaWIgKENQQU4pIGNvbmZ1c2lv
  biB3aGVuIHJlLXVzaW5nIGEgcHJlZml4IGJ1dCBjaGFuZ2luZyBmcm9tIElMUDMyCiMgdG8gTFA2
  NCBidWlsZHMuICBUaGV5J3JlIE5PVCBiaW5hcnkgY29tcGF0aWJsZSwgc28gcXVpdCBjbGFpbWlu
  ZyB0aGV5IGFyZS4KYXJjaG5hbWU2ND1MUDY0CgoKIyMjIEhQLVVYIE9TIHNwZWNpZmljIGJlaGF2
  aW91cgoKIyAtbGRibSBpcyBvYnNvbGV0ZSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkCiMgLWxCU0Qg
  Y29udGFpbnMgQlNELXN0eWxlIGR1cGxpY2F0ZXMgb2YgU1ZSNCByb3V0aW5lcyB0aGF0IGNhdXNl
  IGNvbmZ1c2lvbgojIC1sUFcgaXMgb2Jzb2xldGUgYW5kIHNob3VsZCBub3QgYmUgdXNlZAojIFRo
  ZSBsaWJyYXJpZXMgY3J5cHQsIG1hbGxvYywgbmRpciwgYW5kIG5ldCBhcmUgZW1wdHkuCnNldCBg
  ZWNobyAiWCAkbGlic3dhbnRlZCAiIHwgc2VkIC1lICdzLyBsZCAvIC8nIC1lICdzLyBkYm0gLyAv
  JyAtZSAncy8gQlNEIC8gLycgLWUgJ3MvIFBXIC8gLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoK
  Y2M9JHtjYzotY2N9CmFyPS91c3IvYmluL2FyCSMgWWVzLCB0cnVseSBvdmVycmlkZS4gIFdlIGRv
  IG5vdCB3YW50IHRoZSBHTlUgYXIuCmZ1bGxfYXI9JGFyCSMgSSByZXBlYXQsIG5vIEdOVSBhci4g
  IGFycnIuCgpzZXQgYGVjaG8gIlggJGNjZmxhZ3MgIiB8IHNlZCAtZSAncy8gLUFbZWFdIC8gLycg
  LWUgJ3MvIC1EX0hQVVhfU09VUkNFIC8gLydgCnNoaWZ0CgljY19jcHBmbGFncz0iJCogLURfSFBV
  WF9TT1VSQ0UiCmNwcGZsYWdzPSItQWEgLURfX1NURENfRVhUX18gJGNjX2NwcGZsYWdzIgoKY2Fz
  ZSAiJHByZWZpeCIgaW4KICAgICIiKSBwcmVmaXg9Jy9vcHQvcGVybDUnIDs7CiAgICBlc2FjCgog
  ICAgZ251X2FzPW5vCiAgICBnbnVfbGQ9bm8KY2FzZSBgJGNjIC12IDI+JjFgIiIgaW4KICAgICpn
  Y2MqKSAgY2Npc2djYz0iJGRlZmluZSIKCSAgICBjY2ZsYWdzPSIkY2NfY3BwZmxhZ3MiCgkgICAg
  aWYgWyAiWCRnY2N2ZXJzaW9uIiA9ICJYIiBdOyB0aGVuCgkJIyBEb25lIHRvbyBsYXRlIGluIENv
  bmZpZ3VyZSBpZiBoaW50ZWQKCQlnY2N2ZXJzaW9uPWAkY2MgLWR1bXB2ZXJzaW9uYAoJCWZpCgkg
  ICAgY2FzZSAiJGdjY3ZlcnNpb24iIGluCgkJWzAxMl0qKSAjIEhQLVVYIGFuZCBnY2MtMi4qIGJy
  ZWFrIFVJTlQzMl9NQVggOi0oCgkJICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1EVUlOVDMyX01BWF9C
  Uk9LRU4iCgkJICAgIDs7CgkJWzM0XSopICMgR0NDIChib3RoIDMyYml0IGFuZCA2NGJpdCkgd2ls
  bCBkZWZpbmUgX19TVERDX0VYVF9fCiAgICAgICAgICAgICAgICAgICAgICAgIyBieSBkZWZhdWx0
  IHdoZW4gdXNpbmcgR0NDIDMuMCBhbmQgbmV3ZXIgdmVyc2lvbnMgb2YKICAgICAgICAgICAgICAg
  ICAgICAgICAjIHRoZSBjb21waWxlci4KCQkgICBjcHBmbGFncz0iJGNjX2NwcGZsYWdzIgoJCSAg
  IDs7CgkJZXNhYwoJICAgIGNhc2UgImBnZXRjb25mIEtFUk5FTF9CSVRTIDI+L2Rldi9udWxsYCIg
  aW4KCQkqNjQqKQoJCSAgICBlY2hvICJtYWluKCl7fSI+dHJ5LmMKCQkgICAgY2FzZSAiJGdjY3Zl
  cnNpb24iIGluCgkJCVszNF0qKQoJCQkgICAgY2FzZSAiJGFyY2huYW1lIiBpbgogICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgUEEtUklTQyopCiAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgY2FzZSAiJGNjZmxhZ3MiIGluCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICotbXBhLXJpc2MqKSA7OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAqKSBjY2ZsYWdzPSIkY2NmbGFncyAtbXBhLXJpc2MtMi0wIiA7OwogICAgICAgICAg
  ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2FjCiAgICAgICAgICAgICAgICAgICAgICAg
  ICAgICAgICAgICAgOzsKCQkJCWVzYWMKCQkJICAgIDs7CgkJCSopICAjIGdjYyB3aXRoIGdhcyB3
  aWxsIG5vdCBhY2NlcHQgK0RBMi4wCgkJCSAgICBjYXNlICJgJGNjIC1jIC1XYSwrREEyLjAgdHJ5
  LmMgMj4mMWAiIGluCgkJCQkqIitEQTIuMCIqKQkJIyBnYXMKCQkJCSAgICBnbnVfYXM9eWVzCgkJ
  CQkgICAgOzsKCQkJCSopCQkJIyBIUGFzCgkJCQkgICAgY2NmbGFncz0iJGNjZmxhZ3MgLVdhLCtE
  QTIuMCIKCQkJCSAgICA7OwoJCQkJZXNhYwoJCQkgICAgOzsKCQkJZXNhYwoJCSAgICAjIGdjYyB3
  aXRoIGdsZCB3aWxsIG5vdCBhY2NlcHQgK3Zub2NvbXBhdHdhcm5pbmdzCgkJICAgIGNhc2UgImAk
  Y2MgLW8gdHJ5IC1XbCwrdm5vY29tcGF0d2FybmluZ3MgdHJ5LmMgMj4mMWAiIGluCgkJCSoiK3Zu
  b2NvbXBhdCIqKQkJIyBnbGQKCQkJICAgIGdudV9sZD15ZXMKCQkJICAgIDs7CgkJCSopCQkJIyBI
  UGxkCgkJCSAgIGNhc2UgIiRnY2N2ZXJzaW9uIiBpbgoJCQkgICAgICAgWzEyXSopCgkJCQkgICAj
  IFdoeSBub3QgMyBhcyB3ZWxsIGhlcmU/CgkJCQkgICAjIFNpbmNlIG5vdCByZWxldmFudCB0byBJ
  QTY0LCBub3QgY2hhbmdlZC4KCQkJCSAgIGxkZmxhZ3M9IiRsZGZsYWdzIC1XbCwrdm5vY29tcGF0
  d2FybmluZ3MiCgkJCQkgICBjY2ZsYWdzPSIkY2NmbGFncyAtV2wsK3Zub2NvbXBhdHdhcm5pbmdz
  IgoJCQkJICAgOzsKCQkJICAgICAgIGVzYWMKCQkJICAgIDs7CgkJCWVzYWMKCQkgICAgcm0gLWYg
  dHJ5LmMKCQkgICAgOzsKCQllc2FjCgkgICAgOzsKICAgICopICAgICAgY2Npc2djYz0nJwoJICAg
  ICMgV2hhdCBjYW5ub3QgYmUgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGggY2NhY2hlIGxpbmtzIDoo
  CgkgICAgY2NfZm91bmQ9IiIKCSAgICBmb3IgcCBpbiBgZWNobyAkUEFUSCB8IHRyIDogJyAnJ2Ag
  OyBkbwoJCXg9IiRwL2NjIgoJCWlmIFsgLWYgJHggXSAmJiBbIC14ICR4IF07IHRoZW4KCQkgICAg
  aWYgWyAtaCAkeCBdOyB0aGVuCgkJCWw9YGxzIC1sICR4IHwgc2VkICdzLC4qLT4gLCwnYAoJCQlj
  YXNlICRsIGluCgkJCSAgICAvKikgeD0kbAkJOzsKCQkJICAgICopICB4PSIkcC8kbCIJOzsKCQkJ
  ICAgIGVzYWMKCQkJZmkKCQkgICAgeD1gZWNobyAkeCB8IHNlZCAncywvXC4vLC8sZydgCgkJICAg
  IGNhc2UgJHggaW4KCQkJKmNjYWNoZSopIDs7CgkJCSopIFsgLXogIiRjY19mb3VuZCIgXSAmJiBj
  Y19mb3VuZD0keCA7OwoJCQllc2FjCgkJICAgIGZpCgkJZG9uZQoJICAgIFsgLXogIiRjY19mb3Vu
  ZCIgXSAmJiBjY19mb3VuZD1gd2hpY2ggY2NgCgkgICAgd2hhdCAkY2NfZm91bmQgPiY0CgkgICAg
  Y2N2ZXJzaW9uPWB3aGF0ICRjY19mb3VuZCB8IGF3ayAnL0NvbXBpbGVyL3twcmludCAkMn0vSXRh
  bml1bS97cHJpbnQgJDYsJDd9L2ZvciBJbnRlZ3JpdHkve3ByaW50ICQ2LCQ3fSdgCgkgICAgY2Fz
  ZSAiJGNjZmxhZ3MiIGluCiAgICAgICAgICAgICAgICItQWUgIiopIDs7CgkJKikgIGNjZmxhZ3M9
  Ii1BZSAtV3AsLUg2NTAwMCAkY2NfY3BwZmxhZ3MiCgkJICAgICMgK3Zub2NvbXBhdHdhcm5pbmdz
  IG5vdCBrbm93biBpbiAxMC4xMCBhbmQgb2xkZXIKCQkgICAgaWYgWyAkeHhPc1JldiAtZ2UgMTAy
  MCBdOyB0aGVuCgkJCWNjZmxhZ3M9IiRjY2ZsYWdzIC1XbCwrdm5vY29tcGF0d2FybmluZ3MiCgkJ
  CWZpCgkJICAgIDs7CiAgICAgICAgICAgICAgIGVzYWMKCSAgICAjIE5lZWRlZCBiZWNhdXNlIGNw
  cCBkb2VzIG9ubHkgc3VwcG9ydCAtQWEgKG5vdCAtQWUpCgkgICAgY3BwbGFzdD0nLScKCSAgICBj
  cHBtaW51cz0nLScKCSAgICBjcHBzdGRpbj0nY2MgLUUgLUFhIC1EX19TVERDX0VYVF9fJwoJICAg
  IGNwcHJ1bj0kY3Bwc3RkaW4KIwkgICAgY2FzZSAiJGRfY2FzdGkzMiIgaW4KIwkJIiIpIGRfY2Fz
  dGkzMj0ndW5kZWYnIDs7CiMJCWVzYWMKCSAgICA7OwogICAgZXNhYwoKIyBXaGVuIEhQLVVYIHJ1
  bnMgYSBzY3JpcHQgd2l0aCAiIyEiLCBpdCBzZXRzIGFyZ3ZbMF0gdG8gdGhlIHNjcmlwdCBuYW1l
  Lgp0b2tlX2NmbGFncz0nY2NmbGFncz0iJGNjZmxhZ3MgLURBUkdfWkVST19JU19TQ1JJUFQiJwoK
  IyMjIDY0IEJJVE5FU1MKCiMgU29tZSBnY2MgdmVyc2lvbnMgZG8gbmF0aXZlIDY0IGJpdCBsb25n
  IChlLmcuIDIuOS1ocHBhLTAwMDMxMCBhbmQgZ2NjLTMuMCkKIyBXZSBoYXZlIHRvIGZvcmNlIDY0
  Yml0bmVzcyB0byBnbyBzZWFyY2ggdGhlIHJpZ2h0IGxpYnJhcmllcwogICAgZ2NjXzY0bmF0aXZl
  PW5vCmNhc2UgIiRjY2lzZ2NjIiBpbgogICAgJGRlZmluZXx0cnVlfFtZeV0pCgllY2hvICcjaW5j
  bHVkZSA8c3RkaW8uaD5cbmludCBtYWluKCl7bG9uZyBsO3ByaW50ZigiJWRcXG4iLHNpemVvZihs
  KSk7fSc+dHJ5LmMKCSRjYyAtbyB0cnkgJGNjZmxhZ3MgJGxkZmxhZ3MgdHJ5LmMKCWlmIFsgImB0
  cnlgIiA9ICI4IiBdOyB0aGVuCgkgICAgY2FzZSAiJHVzZTY0Yml0YWxsIiBpbgoJCSRkZWZpbmV8
  dHJ1ZXxbWXldKSA7OwoJCSopICBjYXQgPDxFT00gPiY0CgoqKiogVGhpcyB2ZXJzaW9uIG9mIGdj
  YyB1c2VzIDY0IGJpdCBsb25ncy4gLUR1c2U2NGJpdGFsbCBpcwoqKiogaW1wbGljaXRseSBzZXQg
  dG8gZW5hYmxlIGNvbnRpbnVhdGlvbgpFT00KCQllc2FjCgkgICAgdXNlNjRiaXRhbGw9JGRlZmlu
  ZQoJICAgIGdjY182NG5hdGl2ZT15ZXMKCSAgICBmaQoJOzsKICAgIGVzYWMKCmNhc2UgIiR1c2U2
  NGJpdGFsbCIgaW4KICAgICRkZWZpbmV8dHJ1ZXxbeVldKikgdXNlNjRiaXRpbnQ9IiRkZWZpbmUi
  IDs7CiAgICBlc2FjCgpjYXNlICIkdXNlbW9yZWJpdHMiIGluCiAgICAkZGVmaW5lfHRydWV8W3lZ
  XSopIHVzZTY0Yml0aW50PSIkZGVmaW5lIjsgdXNlbG9uZ2RvdWJsZT0iJGRlZmluZSIgOzsKICAg
  IGVzYWMKCiMgVGhlcmUgaXMgYSB3ZWlyZCBwcmUtQzk5IGxvbmcgZG91YmxlIChhIHN0cnVjdCBv
  ZiBmb3VyIHVpbjMyX3QpCiMgaW4gSFAtVVggMTAuMjAgYnV0IGJleW9uZCBzdHJ0b2xkKCkgdGhl
  cmUncyBubyBzdXBwb3J0IGZvciB0aGVtCiMgZm9yIGV4YW1wbGUgaW4gPG1hdGguaD4uCmNhc2Ug
  IiR1c2Vsb25nZG91YmxlIiBpbgogICAgJGRlZmluZXx0cnVlfFt5WV0qKQoJaWYgWyAiJHh4T3NS
  ZXZNYWpvciIgLWx0IDExIF07IHRoZW4KCSAgICBjYXQgPDxFT00gPiY0CgoqKiogdXNlbG9uZ2Rv
  dWJsZSAob3IgdXNlbW9yZWJpdHMpIGlzIG5vdCBzdXBwb3J0ZWQgb24gSFAtVVggJHh4T3NSZXZN
  YWpvci4KKioqIFlvdSBuZWVkIGF0IGxlYXN0IEhQLVVYIDExLjAuCioqKiBDYW5ub3QgY29udGlu
  dWUsIGFib3J0aW5nLgpFT00KCSAgICBleGl0IDEKCWZpCgk7OwogICAgZXNhYwoKIyBDb25maWd1
  cmUgbG9uZyBkb3VibGUgc2NhbiB3aWxsIGRldGVjdCB0aGUgSFAtVVggMTAuMjAgImxvbmcgZG91
  YmxlIgojIChhIHN0cnVjdCBvZiBmb3VyIHVpbjMyX3QpIGFuZCB0aGluayBpdCBpcyBJRUVFIHF1
  YWQuICBNYWtlIGl0IG5vdCBzby4KaWYgWyAiJHh4T3NSZXZNYWpvciIgLWx0IDExIF07IHRoZW4K
  ICAgIGRfbG9uZ2RibD0iJHVuZGVmIgogICAgbG9uZ2RibHNpemU9OCAjIE1ha2UgaXQgZG91Ymxl
  LgpmaQoKY2FzZSAiJGFyY2huYW1lIiBpbgogICAgSUE2NCopCgkjIFdoaWxlIGhlcmUsIG92ZXJy
  aWRlIHNvPXNsIGF1dG8tZGV0ZWN0aW9uCglzbz0nc28nCgk7OwogICAgZXNhYwoKY2FzZSAiJHVz
  ZTY0Yml0YWxsIiBpbgogICAgJGRlZmluZXx0cnVlfFtZeV0pCgoJaWYgWyAiJHh4T3NSZXZNYWpv
  ciIgLWx0IDExIF07IHRoZW4KCSAgICBjYXQgPDxFT00gPiY0CgoqKiogNjQtYml0IGNvbXBpbGF0
  aW9uIGlzIG5vdCBzdXBwb3J0ZWQgb24gSFAtVVggJHh4T3NSZXZNYWpvci4KKioqIFlvdSBuZWVk
  IGF0IGxlYXN0IEhQLVVYIDExLjAuCioqKiBDYW5ub3QgY29udGludWUsIGFib3J0aW5nLgpFT00K
  CSAgICBleGl0IDEKCSAgICBmaQoKCWlmIFsgJHh4T3NSZXYgLWVxIDExMDAgXTsgdGhlbgoJICAg
  ICMgSFAtVVggMTEuMDAgdXNlcyBvbmx5IDQ4IGJpdHMgaW50ZXJuYWxseSBpbiA2NGJpdCBtb2Rl
  LCBub3QgNjQKCSAgICAjIGZvcmNlIG1pbi9tYXggdG8gMioqNDctMQoJICAgIHNHTVRJTUVfbWF4
  PTE0MDczNzQ4ODM1NTMyNwoJICAgIHNHTVRJTUVfbWluPS02MjE2NzIxOTIwMAoJICAgIHNMT0NB
  TFRJTUVfbWF4PTE0MDczNzQ4ODM1NTMyNwoJICAgIHNMT0NBTFRJTUVfbWluPS02MjE2NzIxOTIw
  MAoJICAgIGZpCgoJIyBTZXQgbGliYyBhbmQgdGhlIGxpYnJhcnkgcGF0aHMKCWNhc2UgIiRhcmNo
  bmFtZSIgaW4KCSAgICBQQS1SSVNDKikKCQlsb2NsaWJwdGg9IiRsb2NsaWJwdGggL2xpYi9wYTIw
  XzY0IgoJCWxpYmM9Jy9saWIvcGEyMF82NC9saWJjLnNsJyA7OwoJICAgIElBNjQqKQoJCWxvY2xp
  YnB0aD0iJGxvY2xpYnB0aCAvdXNyL2xpYi9ocHV4NjQiCgkJbGliYz0nL3Vzci9saWIvaHB1eDY0
  L2xpYmMuc28nIDs7CgkgICAgZXNhYwoJaWYgWyAhIC1mICIkbGliYyIgXTsgdGhlbgoJICAgIGNh
  dCA8PEVPTSA+JjQKCioqKiBZb3UgZG8gbm90IHNlZW0gdG8gaGF2ZSB0aGUgNjQtYml0IGxpYmMu
  CioqKiBJIGNhbm5vdCBmaW5kIHRoZSBmaWxlICRsaWJjLgoqKiogQ2Fubm90IGNvbnRpbnVlLCBh
  Ym9ydGluZy4KRU9NCgkgICAgZXhpdCAxCgkgICAgZmkKCgljYXNlICIkY2Npc2djYyIgaW4KCSAg
  ICAkZGVmaW5lfHRydWV8W1l5XSkKCQkjIFRoZSBmaXhlZCBzb2NrZXQuaCBoZWFkZXIgZmlsZSBp
  cyB3cm9uZyBmb3IgZ2NjLTQueAoJCSMgb24gUEEtUklTQzIuMFcsIHNvIFNvY2tfdHlwZV90IGlz
  IHNpemVfdCB3aGljaCBpcwoJCSMgdW5zaWduZWQgbG9uZyB3aGljaCBpcyA2NGJpdCB3aGljaCBp
  cyB0b28gbG9uZwoJCWNhc2UgIiRnY2N2ZXJzaW9uIiBpbgoJCSAgICA0KikgY2FzZSAiJGFyY2hu
  YW1lIiBpbgoJCQkgICAgUEEtUklTQyopIHNvY2tzaXpldHlwZT1pbnQgOzsKCQkJICAgIGVzYWMK
  CQkJOzsKCQkgICAgZXNhYwoKCQkjIEZvciB0aGUgbW9tZW50LCBkb24ndCBjYXJlIHRoYXQgaXQg
  YWluJ3Qgc3VwcG9ydGVkICh5ZXQpCgkJIyBieSBnY2MgKHVwIHRvIGFuZCBpbmNsdWRpbmcgMi45
  NS4zKSwgY2F1c2UgaXQnbGwgY3Jhc2gKCQkjIGFueXdheS4gRXhwZWN0IGF1dG8tZGV0ZWN0aW9u
  IG9mIDY0LWJpdCBlbmFibGVkIGdjYyBvbgoJCSMgSFAtVVggc29vbiwgaW5jbHVkaW5nIGEgdXNl
  ci1mcmllbmRseSBleGl0CgkJY2FzZSAkZ2NjXzY0bmF0aXZlIGluCgkJICAgIG5vKSBjYXNlICIk
  Z2NjdmVyc2lvbiIgaW4KCQkJICAgIFsxMjM0XSopCgkJCQljY2ZsYWdzPSIkY2NmbGFncyAtbWxw
  NjQiCgkJCQljYXNlICIkYXJjaG5hbWUiIGluCgkJCQkgICAgUEEtUklTQyopCgkJCQkJbGRmbGFn
  cz0iJGxkZmxhZ3MgLVdsLCtERDY0IgoJCQkJCTs7CgkJCQkgICAgSUE2NCopCgkJCQkJbGRmbGFn
  cz0iJGxkZmxhZ3MgLW1scDY0IgoJCQkJCTs7CgkJCQkgICAgZXNhYwoJCQkJOzsKCQkJICAgIGVz
  YWMKCQkJOzsKCQkgICAgZXNhYwoJCTs7CgkgICAgKikKCQljYXNlICIkdXNlNjRiaXRhbGwiIGlu
  CgkJICAgICRkZWZpbmV8dHJ1ZXxbeVldKikKCQkJY2NmbGFncz0iJGNjZmxhZ3MgK0RENjQiCgkJ
  CWxkZmxhZ3M9IiRsZGZsYWdzICtERDY0IgoJCQk7OwoJCSAgICBlc2FjCgkJOzsKCSAgICBlc2Fj
  CgoJIyBSZXNldCB0aGUgbGlicmFyeSBjaGVja2VyIHRvIG1ha2Ugc3VyZSBsaWJyYXJpZXMKCSMg
  YXJlIHRoZSByaWdodCB0eXBlCgkjIChOT1RFOiBvbiBJQTY0LCB0aGlzIGRvZXNuJ3Qgd29yayB3
  aXRoIC5hIGZpbGVzLikKCWxpYnNjaGVjaz0nY2FzZSAiYC91c3IvYmluL2ZpbGUgJHh4eGAiIGlu
  CgkJICAgICAgICpFTEYtNjQqfCpMUDY0KnwqUEEtUklTQzIuMCopIDs7CgkJICAgICAgICopIHh4
  eD0vbm8vNjQtYml0JHh4eCA7OwoJCSAgICAgICBlc2FjJwoKCTs7CgogICAgKikJIyBOb3QgaW4g
  NjQtYml0IG1vZGUKCgljYXNlICIkYXJjaG5hbWUiIGluCgkgICAgUEEtUklTQyopCgkJbGliYz0n
  L2xpYi9saWJjLnNsJyA7OwoJICAgIElBNjQqKQoJCWxvY2xpYnB0aD0iJGxvY2xpYnB0aCAvdXNy
  L2xpYi9ocHV4MzIiCgkJbGliYz0nL3Vzci9saWIvaHB1eDMyL2xpYmMuc28nIDs7CgkgICAgZXNh
  YwoJOzsKICAgIGVzYWMKCiMgQnkgc2V0dGluZyB0aGUgZGVmZXJyZWQgZmxhZyBiZWxvdywgdGhp
  cyBtZWFucyB0aGF0IGlmIHlvdSBydW4gcGVybAojIG9uIGEgc3lzdGVtIHRoYXQgZG9lcyBub3Qg
  aGF2ZSB0aGUgcmVxdWlyZWQgc2hhcmVkIGxpYnJhcnkgdGhhdCB5b3UKIyBsaW5rZWQgaXQgd2l0
  aCwgaXQgd2lsbCBkaWUgd2hlbiB5b3UgdHJ5IHRvIGFjY2VzcyBhIHN5bWJvbCBpbiB0aGUKIyAo
  bWlzc2luZykgc2hhcmVkIGxpYnJhcnkuICBJZiB5b3Ugd291bGQgcmF0aGVyIGtub3cgYXQgcGVy
  bCBzdGFydHVwCiMgdGltZSB0aGF0IHlvdSBhcmUgbWlzc2luZyBhbiBpbXBvcnRhbnQgc2hhcmVk
  IGxpYnJhcnksIHN3aXRjaCB0aGUKIyBjb21tZW50cyBzbyB0aGF0IGltbWVkaWF0ZSwgcmF0aGVy
  IHRoYW4gZGVmZXJyZWQgbG9hZGluZyBpcwojIHBlcmZvcm1lZC4gIEV2ZW4gd2l0aCBpbW1lZGlh
  dGUgbG9hZGluZywgeW91IGNhbiBwb3N0cG9uZSBlcnJvcnMgZm9yCiMgdW5kZWZpbmVkIChvciBt
  dWx0aXBseSBkZWZpbmVkKSByb3V0aW5lcyB1bnRpbCBhY3R1YWwgYWNjZXNzIGJ5CiMgYWRkaW5n
  IHRoZSAibm9uZmF0YWwiIG9wdGlvbi4KIyBjY2RsZmxhZ3M9Ii1XbCwtRSAtV2wsLUIsaW1tZWRp
  YXRlICRjY2RsZmxhZ3MiCiMgY2NkbGZsYWdzPSItV2wsLUUgLVdsLC1CLGltbWVkaWF0ZSwtQixu
  b25mYXRhbCAkY2NkbGZsYWdzIgppZiBbICIkZ251X2xkIiA9ICJ5ZXMiIF07IHRoZW4KICAgIGNj
  ZGxmbGFncz0iLVdsLC1FICRjY2RsZmxhZ3MiCmVsc2UKICAgIGNjZGxmbGFncz0iLVdsLC1FIC1X
  bCwtQixkZWZlcnJlZCAkY2NkbGZsYWdzIgogICAgZmkKCgojIyMgQ09NUElMRVIgU1BFQ0lGSUNT
  CgojIyBMb2NhbCByZXN0cmljdGlvbnMgKHBvaW50IHRvIFJFQURNRS5ocHV4IHRvIGxpZnQgdGhl
  c2UpCgojIyBPcHRpbWl6YXRpb24gbGltaXRzCmNhdCA+dHJ5LmMgPDxFT0YKI2luY2x1ZGUgPHN0
  ZGlvLmg+CiNpbmNsdWRlIDxzeXMvcmVzb3VyY2UuaD4KCmludCBtYWluICgpCnsKICAgIHN0cnVj
  dCBybGltaXQgcmw7CiAgICBpbnQgaSA9IGdldHJsaW1pdCAoUkxJTUlUX0RBVEEsICZybCk7CiAg
  ICBwcmludGYgKCIlZFxuIiwgKGludCkocmwucmxpbV9jdXIgLyAoMTAyNCAqIDEwMjQpKSk7CiAg
  ICB9IC8qIG1haW4gKi8KRU9GCiRjYyAtbyB0cnkgJGNjZmxhZ3MgJGxkZmxhZ3MgdHJ5LmMKCW1h
  eGRzaXo9YHRyeWAKcm0gLWYgdHJ5IHRyeS5jIGNvcmUKaWYgWyAkbWF4ZHNpeiAtbGUgNjQgXTsg
  dGhlbgogICAgIyA2NCBNYiBpcyBwcm9iYWJseSBub3QgZW5vdWdoIHRvIG9wdGltaXplIHRva2Uu
  YwogICAgIyBhbmQgcmVnZXhwLmMgd2l0aCAtTzIKICAgIGNhdCA8PEVPTSA+JjQKWW91ciBrZXJu
  ZWwgbGltaXRzIHRoZSBkYXRhIHNlY3Rpb24gb2YgeW91ciBwcm9ncmFtcyB0byAkbWF4ZHNpeiBN
  YiwKd2hpY2ggaXMgKHNhZGx5KSBub3QgZW5vdWdoIHRvIGZ1bGx5IG9wdGltaXplIHNvbWUgcGFy
  dHMgb2YgdGhlCnBlcmwgYmluYXJ5LiBJJ2xsIHRyeSB0byB1c2UgYSBsb3dlciBvcHRpbWl6YXRp
  b24gbGV2ZWwgZm9yCnRob3NlIHBhcnRzLiBJZiB5b3UgYXJlIGEgc3lzYWRtaW4sIGFuZCB5b3Ug
  KmRvKiB3YW50IGZ1bGwKb3B0aW1pemF0aW9uLCByYWlzZSB0aGUgJ21heGRzaXonIGtlcm5lbCBj
  b25maWd1cmF0aW9uIHBhcmFtZXRlcgp0byBhdCBsZWFzdCAweDA4MDAwMDAwICgxMjggTWIpIGFu
  ZCByZWJ1aWxkIHlvdXIga2VybmVsLgpFT00KcmVnZXhlY19jZmxhZ3M9JycKZG9vcF9jZmxhZ3M9
  JycKb3BfY2ZsYWdzPScnCm9wbWluaV9jZmxhZ3M9JycKcGVybG1haW5fY2ZsYWdzPScnCnBwX3Bh
  Y2tfY2ZsYWdzPScnCiAgICBmaQoKY2FzZSAiJGNjaXNnY2MiIGluCiAgICAkZGVmaW5lfHRydWV8
  W1l5XSkKCgljYXNlICIkb3B0aW1pemUiIGluCgkgICAgIiIpICAgICAgICAgICBvcHRpbWl6ZT0i
  LWcgLU8iIDs7CgkgICAgKk9bMzQ1Njc4OV0qKSBvcHRpbWl6ZT1gZWNobyAiJG9wdGltaXplIiB8
  IHNlZCAtZSAncy9PWzMtOV0vTzIvJ2AgOzsKCSAgICBlc2FjCgkjbGQ9IiRjYyIKCWxkPS91c3Iv
  YmluL2xkCgljY2NkbGZsYWdzPSctZlBJQycKCSNsZGRsZmxhZ3M9Jy1zaGFyZWQnCglsZGRsZmxh
  Z3M9Jy1iJwoJY2FzZSAiJG9wdGltaXplIiBpbgoJICAgICotZyotTyp8Ki1PKi1nKikKCQkjIGdj
  YyB3aXRob3V0IGdhcyB3aWxsIG5vdCBhY2NlcHQgLWcKCQllY2hvICJtYWluKCl7fSI+dHJ5LmMK
  CQljYXNlICJgJGNjICRvcHRpbWl6ZSAtYyB0cnkuYyAyPiYxYCIgaW4KCQkgICAgKiItZyBvcHRp
  b24gZGlzYWJsZWQiKikKCQkJc2V0IGBlY2hvICJYICRvcHRpbWl6ZSAiIHwgc2VkIC1lICdzLyAt
  ZyAvIC8nYAoJCQlzaGlmdAoJCQlvcHRpbWl6ZT0iJCoiCgkJCTs7CgkJICAgIGVzYWMKCQk7OwoJ
  ICAgIGVzYWMKCWlmIFsgJG1heGRzaXogLWxlIDY0IF07IHRoZW4KCSAgICBjYXNlICIkb3B0aW1p
  emUiIGluCgkJKk8yKikKCQkgICAgb3B0PWBlY2hvICIkb3B0aW1pemUiIHwgc2VkIC1lICdzL08y
  L08xLydgCgkJICAgIHRva2VfY2ZsYWdzPSIkdG9rZV9jZmxhZ3M7b3B0aW1pemU9XCIkb3B0XCIi
  CgkJICAgIHJlZ2V4ZWNfY2ZsYWdzPSJvcHRpbWl6ZT1cIiRvcHRcIiIKCQkgICAgOzsKCQllc2Fj
  CgkgICAgZmkKCTs7CgogICAgKikKCWNhc2UgIiRvcHRpbWl6ZSIgaW4KCSAgICAiIikgICAgICAg
  ICAgIG9wdGltaXplPSIrTzIgK09ub2xpbWl0IiA7OwoJICAgICpPWzM0NTY3ODldKikgb3B0aW1p
  emU9YGVjaG8gIiRvcHRpbWl6ZSIgfCBzZWQgLWUgJ3MvT1szLTldL08yLydgIDs7CgkgICAgZXNh
  YwoJY2FzZSAiJG9wdGltaXplIiBpbgoJICAgICotTyp8XAoJICAgICpPMiopICAgb3B0PWBlY2hv
  ICIkb3B0aW1pemUiIHwgc2VkIC1lICdzLy1PLytPMi8nIC1lICdzL08yL08xLycgLWUgJ3MvICor
  T25vbGltaXQvLydgCgkJICAgIDs7CgkgICAgKikgICAgICBvcHQ9IiRvcHRpbWl6ZSIKCQkgICAg
  OzsKCSAgICBlc2FjCgljYXNlICIkYXJjaG5hbWUiIGluCgkgICAgUEEtUklTQzIuMCkKCQljYXNl
  ICIkY2N2ZXJzaW9uIiBpbgoJCSAgICBCLjExLjExLiopCgkJCSMgb3BtaW5pLmMgYW5kIG9wLmMg
  d2l0aCArTzIgbWFrZXMgdGhlIGNvbXBpbGVyIGRpZQoJCQkjIG9mIGludGVybmFsIGVycm9yLCBm
  b3IgcGVybG1haW4uYyBvbmx5ICtPMCAobm8gb3B0KQogICAgICAgICAgICAgICAgICAgICAgICAj
  IHdvcmtzLiBEaXNhYmxlICtPeCBmb3IgcHBfcGFjaywgYXMgdGhlIG9wdGltaXplcgogICAgICAg
  ICAgICAgICAgICAgICAgICAjIGNhdXNlcyB0aGlzIHVuaXQgdG8gZmFpbCAobm90IGEgbGltaXQg
  aXNzdWUpCgkJCWNhc2UgIiRvcHRpbWl6ZSIgaW4KCQkJKk9bMTJdKikKCQkJICAgIG9wdD1gZWNo
  byAiJG9wdGltaXplIiB8IHNlZCAtZSAncy9PMi9PMS8nIC1lICdzLyAqK09ub2xpbWl0Ly8nYAoJ
  CQkgICAgb3BtaW5pX2NmbGFncz0ib3B0aW1pemU9XCIkb3B0XCIiCgkJCSAgICBvcF9jZmxhZ3M9
  Im9wdGltaXplPVwiJG9wdFwiIgoJCQkgICAgcGVybG1haW5fY2ZsYWdzPSJvcHRpbWl6ZT1cIlwi
  IgoJCQkgICAgcHBfcGFja19jZmxhZ3M9Im9wdGltaXplPVwiXCIiCgkJCSAgICA7OwoJCQllc2Fj
  CgkJICAgIGVzYWMKCQk7OwoJICAgIElBNjQqKQoJCWNhc2UgIiRjY3ZlcnNpb24iIGluCgkJICAg
  IEIzOTEwQipBLjA2LjBbMTIzNDVdKQoJCQkjID4gY2MgLS12ZXJzaW9uCgkJCSMgY2M6IEhQIGFD
  KysvQU5TSSBDIEIzOTEwQiBBLjA2LjA1IFtKdWwgMjUgMjAwNV0KCQkJIyBIYXMgb3B0aW1pemlu
  ZyBwcm9ibGVtcyB3aXRoIC1PMiBhbmQgdXAgZm9yIGJvdGgKCQkJIyBtYWludCAoNS44LjgrKSBh
  bmQgYmxlYWQgKDUuOS4zKykKCQkJIyAtTzEvK08xIHBhc3NlZCBhbGwgdGVzdHMgKG0pJzA1IFsg
  MTAgSmFuIDIwMDUgXQoJCQlvcHRpbWl6ZT0iJG9wdCIJCQk7OwoJCQlCMzkxMEIqQS4wNi4xNSkK
  CQkJIyA+IGNjIC0tdmVyc2lvbgoJCQkjIGNjOiBIUCBDL2FDKysgQjM5MTBCIEEuMDYuMTUgW01h
  eSAxNiAyMDA3XQoJCQkjIEhhcyBvcHRpbWl6aW5nIHByb2JsZW1zIHdpdGggK08yIGZvciBibGVh
  ZCAoNS4xNy40KSwKCQkJIyBzZWUgaHR0cHM6Ly9ydC5wZXJsLm9yZzo0NDMvcnQzL1RpY2tldC9E
  aXNwbGF5Lmh0bWw/aWQ9MTAzNjY4LgoJCQkjCgkJCSMgK08yICtPbm9saW1pdCArT25vcHJvY2Vs
  aW0gICtPc3RvcmVfb3JkZXJpbmcgXAoJCQkjICtPbm9saWJjYWxscz1zdHJjbXAKCQkJIyBwYXNz
  ZXMgYWxsIHRlc3RzICh3aXRoL3dpdGhvdXQgLURERUJVR0dJTkcpIFtOb3YgMTcgMjAxMV0KCQkJ
  Y2FzZSAiJG9wdGltaXplIiBpbgoJCQkgICAgKk8yKikgb3B0aW1pemU9IiRvcHRpbWl6ZSArT25v
  cHJvY2VsaW0gK09zdG9yZV9vcmRlcmluZyArT25vbGliY2FsbHM9c3RyY21wIiA7OwoJCQkgICAg
  ZXNhYwoJCQk7OwoJCSAgICAqKSAgZG9vcF9jZmxhZ3M9Im9wdGltaXplPVwiJG9wdFwiIgoJCQlv
  cF9jZmxhZ3M9Im9wdGltaXplPVwiJG9wdFwiIgoJCQkjb3B0PWBlY2hvICIkb3B0aW1pemUiIHwg
  c2VkIC1lICdzL08xL08wLydgCgkJCWdsb2JhbHNfY2ZsYWdzPSJvcHRpbWl6ZT1cIiRvcHRcIiIJ
  OzsKCQkgICAgZXNhYwoJCTs7CgkgICAgZXNhYwoJaWYgWyAkbWF4ZHNpeiAtbGUgNjQgXTsgdGhl
  bgoJICAgIHRva2VfY2ZsYWdzPSIkdG9rZV9jZmxhZ3M7b3B0aW1pemU9XCIkb3B0XCIiCgkgICAg
  cmVnZXhlY19jZmxhZ3M9Im9wdGltaXplPVwiJG9wdFwiIgoJICAgIGZpCglsZD0vdXNyL2Jpbi9s
  ZAoJY2NjZGxmbGFncz0nK1onCglsZGRsZmxhZ3M9Jy1iICt2bm9jb21wYXR3YXJuaW5ncycKCTs7
  CiAgICBlc2FjCgojIyBMQVJHRUZJTEVTCmlmIFsgJHh4T3NSZXYgLWx0IDEwMjAgXTsgdGhlbgog
  ICAgdXNlbGFyZ2VmaWxlcz0iJHVuZGVmIgogICAgZmkKCiNjYXNlICIkdXNlbGFyZ2VmaWxlcy0k
  Y2Npc2djYyIgaW4KIyAgICAiJGRlZmluZS0kZGVmaW5lInwnLWRlZmluZScpCiMJY2F0IDw8RU9N
  ID4mNAojCiMqKiogSSdtIGlnbm9yaW5nIGxhcmdlIGZpbGVzIGZvciB0aGlzIGJ1aWxkIGJlY2F1
  c2UKIyoqKiBJIGRvbid0IGtub3cgaG93IHRvIGRvIHVzZSBsYXJnZSBmaWxlcyBpbiBIUC1VWCB1
  c2luZyBnY2MuCiMKI0VPTQojCXVzZWxhcmdlZmlsZXM9IiR1bmRlZiIKIwk7OwojICAgIGVzYWMK
  CiMgT25jZSB3ZSBoYXZlIHRoZSBjb21waWxlciBmbGFncyBkZWZpbmVkLCBDb25maWd1cmUgd2ls
  bAojIGV4ZWN1dGUgdGhlIGZvbGxvd2luZyBjYWxsLWJhY2sgc2NyaXB0LiBTZWUgaGludHMvUkVB
  RE1FLmhpbnRzCiMgZm9yIGRldGFpbHMuCmNhdCA+IFVVL2NjLmNidSA8PCdFT0NCVScKIyBUaGlz
  IHNjcmlwdCBVVS9jYy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUgYWZ0
  ZXIgaXQKIyBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHRoZSBDIGNvbXBpbGVyIHRvIHVzZS4K
  CiMgQ29tcGlsZSBhbmQgcnVuIHRoZSBhIHRlc3QgY2FzZSB0byBzZWUgaWYgYSBjZXJ0YWluIGdj
  YyBidWcgaXMKIyBwcmVzZW50LiBJZiBzbywgbG93ZXIgdGhlIG9wdGltaXphdGlvbiBsZXZlbCB3
  aGVuIGNvbXBpbGluZwojIHBwX3BhY2suYy4gIFRoaXMgd29ya3MgYXJvdW5kIGEgYnVnIGluIHVu
  cGFjay4KCmlmIHRlc3QgLXogIiRjY2lzZ2NjIiAtYSAteiAiJGdjY3ZlcnNpb24iOyB0aGVuCiAg
  ICA6IG5vIHRlc3RzIG5lZWRlZCBmb3IgSFBjCmVsc2UKICAgIGVjaG8gIiAiCiAgICBlY2hvICJU
  ZXN0aW5nIGZvciBhIGNlcnRhaW4gZ2NjIGJ1ZyBpcyBmaXhlZCBpbiB5b3VyIGNvbXBpbGVyLi4u
  IgoKICAgICMgVHJ5IGNvbXBpbGluZyB0aGUgdGVzdCBjYXNlLgogICAgaWYgJGNjIC1vIHQwMDEg
  LU8gJGNjZmxhZ3MgJGxkZmxhZ3MgLWxtIC4uL2hpbnRzL3QwMDEuYzsgdGhlbgogICAgICAgZ2Nj
  YnVnPWAkcnVuIC4vdDAwMWAKICAgICAgIGNhc2UgIiRnY2NidWciIGluCiAgICAgICAgICAgKmZh
  aWxzKikKICAgICAgICAgICAgICAgY2F0ID4mNCA8PEVPRgpUaGlzIEMgY29tcGlsZXIgKCRnY2N2
  ZXJzaW9uKSBpcyBrbm93biB0byBoYXZlIG9wdGltaXplcgpwcm9ibGVtcyB3aGVuIGNvbXBpbGlu
  ZyBwcF9wYWNrLmMuCgpEaXNhYmxpbmcgb3B0aW1pemF0aW9uIGZvciBwcF9wYWNrLmMuCkVPRgog
  ICAgICAgICAgICAgICBjYXNlICIkcHBfcGFja19jZmxhZ3MiIGluCiAgICAgICAgICAgICAgICAg
  ICAnJykgcHBfcGFja19jZmxhZ3M9J29wdGltaXplPScKICAgICAgICAgICAgICAgICAgICAgICBl
  Y2hvICJwcF9wYWNrX2NmbGFncz0nb3B0aW1pemU9XCJcIiciID4+IGNvbmZpZy5zaCA7OwogICAg
  ICAgICAgICAgICAgICAgKikgIGVjaG8gIllvdSBzcGVjaWZpZWQgcHBfcGFja19jZmxhZ3MgeW91
  cnNlbGYsIHNvIHdlJ2xsIGdvIHdpdGggeW91ciB2YWx1ZS4iID4mNCA7OwogICAgICAgICAgICAg
  ICAgICAgZXNhYwogICAgICAgICAgICAgICA7OwogICAgICAgICAgICopICBlY2hvICJZb3VyIGNv
  bXBpbGVyIGlzIG9rLiIgPiY0CiAgICAgICAgICAgICAgIDs7CiAgICAgICAgICAgZXNhYwogICAg
  ZWxzZQogICAgICAgZWNobyAiICIKICAgICAgIGVjaG8gIioqKiBXSE9BIFRIRVJFISEhICoqKiIg
  PiY0CiAgICAgICBlY2hvICIgICAgWW91ciBDIGNvbXBpbGVyIFwiJGNjXCIgZG9lc24ndCBzZWVt
  IHRvIGJlIHdvcmtpbmchIiA+JjQKICAgICAgIGNhc2UgIiRrbm93aXRhbGwiIGluCiAgICAgICAg
  ICAgJycpIGVjaG8gIiAgICBZb3UnZCBiZXR0ZXIgc3RhcnQgaHVudGluZyBmb3Igb25lIGFuZCBs
  ZXQgbWUga25vdyBhYm91dCBpdC4iID4mNAogICAgICAgICAgICAgICBleGl0IDEKICAgICAgICAg
  ICAgICAgOzsKICAgICAgICAgICBlc2FjCiAgICAgICBmaQoKICAgIHJtIC1mIHQwMDEkX28gdDAw
  MSRfZXhlCiAgICBmaQpFT0NCVQoKY2F0ID5jb25maWcuYXJjaCA8PCdFT0NCVScKIyBUaGlzIHNj
  cmlwdCBVVS9jb25maWcuYXJjaCB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZSBh
  ZnRlcgojIGFsbCBvdGhlciBjb25maWd1cmF0aW9ucyBhcmUgZG9uZSBqdXN0IGJlZm9yZSBjb25m
  aWcuaCBpcyBnZW5lcmF0ZWQKY2FzZSAiJGFyY2huYW1lOiRvcHRpbWl6ZSIgaW4KICBQQSo6Ki1n
  KlstK11PKnxQQSo6KlstK11PKi1nKikKICAgIGNhc2UgIiRjY2ZsYWdzIiBpbgogICAgICAqREQ2
  NCopIDs7CiAgICAgICopIGNhc2UgIiRjY3ZlcnNpb24iIGluCgkgICMgT25seSBvbiBQQS1SSVND
  LiBCMzkxMEIgKGFDQykgaXMgbm90IGZhdWx0eQoJICAjIEIuMTEuKiBhbmQgQS4xMC4qIGFyZQoJ
  ICBbQUJdLjEqKQoJICAgICAgIyBjYzogZXJyb3IgMTQxNDogQ2FuJ3QgaGFuZGxlIHByZXByb2Nl
  c3NlZCBmaWxlIGZvby5pIGlmIC1nIGFuZCAtTyBzcGVjaWZpZWQuCgkgICAgICBlY2hvICJIUC1V
  WCBDLUFOU0ktQyBvbiBQQS1SSVNDIGRvZXMgbm90IGFjY2VwdCBib3RoIC1nIGFuZCAtTyBvbiBw
  cmVwcm9jZXNzZWQgZmlsZXMiID4mNAoJICAgICAgZWNobyAid2hlbiBjb21waWxpbmcgaW4gMzJi
  aXQgbW9kZS4gVGhlIG9wdGltaXplciB3aWxsIGJlIGRpc2FibGVkLiIgPiY0CgkgICAgICBvcHRp
  bWl6ZT1gZWNobyAiJG9wdGltaXplIiB8IHNlZCAtZSAncy9bLStdT1swLTldKi8vJyAtZSAncy8r
  T25vbGltaXQvLycgLWUgJ3MvXiAqLy8nYAoJICAgICAgOzsKCSAgZXNhYwogICAgICBlc2FjCiAg
  ZXNhYwpFT0NCVQoKY2F0ID5VVS91c2VsYXJnZWZpbGVzLmNidSA8PCdFT0NCVScKIyBUaGlzIHNj
  cmlwdCBVVS91c2VsYXJnZWZpbGVzLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZp
  Z3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2Ug
  bGFyZ2UgZmlsZXMuCgpjYXNlICIkYXJjaG5hbWU6JHVzZTY0Yml0YWxsOiR1c2U2NGJpdGludCIg
  aW4KICAgICotTFA2NCo6dW5kZWY6ZGVmaW5lKQoJYXJjaG5hbWU9YGVjaG8gIiRhcmNobmFtZSIg
  fCBzZWQgJ3MvLUxQNjQvLTY0aW50LydgCgllY2hvICJBcmNobmFtZSBjaGFuZ2VkIHRvICRhcmNo
  bmFtZSIKCTs7CiAgICBlc2FjCgpjYXNlICIkdXNlbGFyZ2VmaWxlcyIgaW4KICAgICIifCRkZWZp
  bmV8dHJ1ZXxbeVldKikKCSMgdGhlcmUgYXJlIGxhcmdlZmlsZSBmbGFncyBhdmFpbGFibGUgdmlh
  IGdldGNvbmYoMSkKCSMgYnV0IHdlIGNoZWF0IGZvciBub3cuICAoS2VlcCB0aGF0IGluIHRoZSBs
  ZWZ0IG1hcmdpbi4pCmNjZmxhZ3NfdXNlbGFyZ2VmaWxlcz0iLURfTEFSR0VGSUxFX1NPVVJDRSAt
  RF9GSUxFX09GRlNFVF9CSVRTPTY0IgoKCWNhc2UgIiAkY2NmbGFncyAiIGluCgkqIiAkY2NmbGFn
  c191c2VsYXJnZWZpbGVzICIqKSA7OwoJKikgY2NmbGFncz0iJGNjZmxhZ3MgJGNjZmxhZ3NfdXNl
  bGFyZ2VmaWxlcyIgOzsKCWVzYWMKCglpZiB0ZXN0IC16ICIkY2Npc2djYyIgLWEgLXogIiRnY2N2
  ZXJzaW9uIjsgdGhlbgoJICAgICMgVGhlIHN0cmljdCBBTlNJIG1vZGUgKC1BYSkgZG9lc24ndCBs
  aWtlIGxhcmdlIGZpbGVzLgoJICAgIGNjZmxhZ3M9YGVjaG8gIiAkY2NmbGFncyAifHNlZCAnc0Ag
  LUFhIEAgQGcnYAoJICAgIGNhc2UgIiRjY2ZsYWdzIiBpbgoJCSotQWUqKSA7OwoJCSopICAgICBj
  Y2ZsYWdzPSIkY2NmbGFncyAtQWUiIDs7CgkJZXNhYwoJICAgIGZpCgk7OwogICAgZXNhYwpFT0NC
  VQoKIyBUSFJFQURJTkcKCiMgVGhpcyBzY3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQg
  J2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVz
  ZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNhdCA+VVUvdXNldGhyZWFkcy5jYnUgPDwn
  RU9DQlUnCmNhc2UgIiR1c2V0aHJlYWRzIiBpbgogICAgJGRlZmluZXx0cnVlfFt5WV0qKQoJaWYg
  WyAiJHh4T3NSZXZNYWpvciIgLWx0IDEwIF07IHRoZW4KCSAgICBjYXQgPDxFT00gPiY0CgpIUC1V
  WCAkeHhPc1Jldk1ham9yIGNhbm5vdCBzdXBwb3J0IFBPU0lYIHRocmVhZHMuCkNvbnNpZGVyIHVw
  Z3JhZGluZyB0byBhdCBsZWFzdCBIUC1VWCAxMS4KQ2Fubm90IGNvbnRpbnVlLCBhYm9ydGluZy4K
  RU9NCgkgICAgZXhpdCAxCgkgICAgZmkKCglpZiBbICIkeHhPc1Jldk1ham9yIiAtZXEgMTAgXTsg
  dGhlbgoJICAgICMgVW5kZXIgMTAuWCwgYSB0aHJlYWRlZCBwZXJsIGNhbiBiZSBidWlsdAoJICAg
  IGlmIFsgLWYgL3Vzci9pbmNsdWRlL3B0aHJlYWQuaCBdOyB0aGVuCgkJaWYgWyAtZiAvdXNyL2xp
  Yi9saWJjbWEuc2wgXTsgdGhlbgoJCSAgICAjIERDRSAoZnJvbSBDb3JlIE9TIENEKSBpcyBpbnN0
  YWxsZWQKCgkJICAgIyBDaGVjayBpZiBpdCBpcyBwcmlzdGluZSwgb3IgcGF0Y2hlZAoJCSAgIGNt
  YXZzbj1gd2hhdCAvdXNyL2xpYi9saWJjbWEuc2wgMj4mMSB8IGdyZXAgMTk5NmAKCQkgICBpZiBb
  ICEgLXogIiRjbWF2c24iIF07IHRoZW4KCQkgICAgICAgY2F0IDw8RU9NID4mNAoHCioqKioqKioq
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
  KioqKioqKioqKgoKUGVybCB3aWxsIHN1cHBvcnQgdGhyZWFkaW5nIHRocm91Z2ggL3Vzci9saWIv
  bGliY21hLnNsIGZyb20KdGhlIEhQIERDRSBwYWNrYWdlLCBidXQgdGhlIHZlcnNpb24gZm91bmQg
  aXMgdG9vIG9sZCB0byBiZQpyZWxpYWJsZS4KCklmIHlvdSBhcmUgbm90IGRlcGVuZGluZyBvbiB0
  aGlzIHNwZWNpZmljIHZlcnNpb24gb2YgdGhlIGxpYnJhcnksCmNvbnNpZGVyIHRvIHVwZ3JhZGUg
  dXNpbmcgcGF0Y2ggUEhTU18yMzY3MiAocmVhZCBSRUFETUUuaHB1eCkKCioqKioqKioqKioqKioq
  KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
  KioqKgoKKHNsZWVwaW5nIGZvciAxMCBzZWNvbmRzLi4uKQpFT00KCQkgICAgICAgc2xlZXAgMTAK
  CQkgICAgICAgZmkKCgkJICAgICMgSXQgbmVlZHMgIyBsaWJjbWEgYW5kIE9MRF9QVEhSRUFEU19B
  UEkuIEFsc28KCQkgICAgIyA8cHRocmVhZC5oPiBuZWVkcyB0byBiZSAjaW5jbHVkZWQgYmVmb3Jl
  IGFueQoJCSAgICAjIG90aGVyIGluY2x1ZGVzIChpbiBwZXJsLmgpCgoJCSAgICAjIEhQLVVYIDEw
  LlggdXNlcyB0aGUgb2xkIHB0aHJlYWRzIEFQSQoJCSAgICBkX29sZHB0aHJlYWRzPSIkZGVmaW5l
  IgoKCQkgICAgIyBpbmNsdWRlIGxpYmNtYSBiZWZvcmUgYWxsIHRoZSBvdGhlcnMKCQkgICAgbGli
  c3dhbnRlZD0iY21hICRsaWJzd2FudGVkIgoKCQkgICAgIyB0ZWxsIHBlcmwuaCB0byBpbmNsdWRl
  IDxwdGhyZWFkLmg+IGJlZm9yZSBvdGhlcgoJCSAgICAjIGluY2x1ZGUgZmlsZXMKCQkgICAgY2Nm
  bGFncz0iJGNjZmxhZ3MgLURQVEhSRUFEX0hfRklSU1QiCiMgRmlyc3QgY29sdW1uIG9uIHB1cnBv
  c2U6CiMgdGhpcyBpcyBub3QgYSBzdGFuZGFyZCBDb25maWd1cmUgdmFyaWFibGUKIyBidXQgd2Ug
  bmVlZCB0byBnZXQgdGhpcyBub3RpY2VkLgpwdGhyZWFkX2hfZmlyc3Q9IiRkZWZpbmUiCgoJCSAg
  ICAjIEhQLVVYIDEwLlggc2VlbXMgdG8gaGF2ZSBubyBlYXN5CgkJICAgICMgd2F5IG9mIGRldGVj
  dGluZyB0aGVzZSAqdGltZV9yIHByb3Rvcy4KCQkgICAgZF9nbXRpbWVfcl9wcm90bz0nZGVmaW5l
  JwoJCSAgICBnbXRpbWVfcl9wcm90bz0nUkVFTlRSQU5UX1BST1RPX0lfVFMnCgkJICAgIGRfbG9j
  YWx0aW1lX3JfcHJvdG89J2RlZmluZScKCQkgICAgbG9jYWx0aW1lX3JfcHJvdG89J1JFRU5UUkFO
  VF9QUk9UT19JX1RTJwoKCQkgICAgIyBBdm9pZCB0aGUgcG9pc29ub3VzIGNvbmZsaWN0aW5nIChh
  bmQgaXJyZWxldmFudCkKCQkgICAgIyBwcm90b3R5cGVzIG9mIHNldGtleSAoKS4KCQkgICAgaV9j
  cnlwdD0iJHVuZGVmIgoKCQkgICAgIyBDTUEgcmVkZWZpbmVzIHNlbGVjdCB0byBjbWFfc2VsZWN0
  LCBhbmQgY21hX3NlbGVjdAoJCSAgICAjIGV4cGVjdHMgaW50ICogaW5zdGVhZCBvZiBmZF9zZXQg
  KiAoanVzdCBsaWtlIDkuWCkKCQkgICAgc2VsZWN0dHlwZT0naW50IConCgoJCWVsaWYgWyAtZiAv
  dXNyL2xpYi9saWJwdGhyZWFkLnNsIF07IHRoZW4KCQkgICAgIyBQVEggcGFja2FnZSBpcyBpbnN0
  YWxsZWQKCQkgICAgbGlic3dhbnRlZD0icHRocmVhZCAkbGlic3dhbnRlZCIKCQllbHNlCgkJICAg
  IGxpYnN3YW50ZWQ9Im5vX3RocmVhZHNfYXZhaWxhYmxlIgoJCSAgICBmaQoJICAgIGVsc2UKCQls
  aWJzd2FudGVkPSJub190aHJlYWRzX2F2YWlsYWJsZSIKCQlmaQoKCSAgICBpZiBbICRsaWJzd2Fu
  dGVkID0gIm5vX3RocmVhZHNfYXZhaWxhYmxlIiBdOyB0aGVuCgkJY2F0IDw8RU9NID4mNAoKSW4g
  SFAtVVggMTAuWCBmb3IgUE9TSVggdGhyZWFkcyB5b3UgbmVlZCBib3RoIG9mIHRoZSBmaWxlcwov
  dXNyL2luY2x1ZGUvcHRocmVhZC5oIGFuZCBlaXRoZXIgL3Vzci9saWIvbGliY21hLnNsIG9yIC91
  c3IvbGliL2xpYnB0aHJlYWQuc2wuCkVpdGhlciB5b3UgbXVzdCB1cGdyYWRlIHRvIEhQLVVYIDEx
  IG9yIGluc3RhbGwgYSBwb3NpeCB0aHJlYWQgbGlicmFyeToKCiAgICBEQ0UtQ29yZVRvb2xzIGZy
  b20gSFAtVVggMTAuMjAgSGFyZHdhcmUgRXh0ZW5zaW9ucyAzLjAgQ0QgKEIzOTIwLTEzOTQxKQoK
  b3IKCiAgICBQVEggcGFja2FnZSBmcm9tIGUuZy4gaHR0cDovL2hwdXguY29ubmVjdC5vcmcudWsv
  aHBwZC9ocHV4L0dudS9wdGgtMi4wLjcvCgpDYW5ub3QgY29udGludWUsIGFib3J0aW5nLgpFT00K
  CQlleGl0IDEKCQlmaQoJZWxzZQoJICAgICMgMTIgbWF5IHdhbnQgdXBwaW5nIHRoZSBfUE9TSVhf
  Q19TT1VSQ0UgZGF0ZXN0YW1wLi4uCgkgICAgY2NmbGFncz0iIC1EX1BPU0lYX0NfU09VUkNFPTE5
  OTUwNkwgLURfUkVFTlRSQU5UICRjY2ZsYWdzIgoJICAgIHNldCBgZWNobyBYICIkbGlic3dhbnRl
  ZCAifCBzZWQgLWUgJ3MvIGMgLyBwdGhyZWFkIGMgLydgCgkgICAgc2hpZnQKCSAgICBsaWJzd2Fu
  dGVkPSIkKiIKCgkgICAgIyBIUC1VWCAxMS5YIHNlZW1zIHRvIGhhdmUgbm8gZWFzeQoJICAgICMg
  d2F5IG9mIGRldGVjdGluZyB0aGVzZSAqdGltZV9yIHByb3Rvcy4KCSAgICBkX2dtdGltZV9yX3By
  b3RvPSdkZWZpbmUnCgkgICAgZ210aW1lX3JfcHJvdG89J1JFRU5UUkFOVF9QUk9UT19TX1RTJwoJ
  ICAgIGRfbG9jYWx0aW1lX3JfcHJvdG89J2RlZmluZScKCSAgICBsb2NhbHRpbWVfcl9wcm90bz0n
  UkVFTlRSQU5UX1BST1RPX1NfVFMnCgkgICAgZmkKCTs7CiAgICBlc2FjCkVPQ0JVCgojIFRoZXJl
  IHVzZWQgdG8gYmU6CiMgIFRoZSBteXN0ZXJpb3VzIGlvX3hzIG1lbW9yeSBjb3JydXB0aW9uIGlu
  IDExLjAwIDMyYml0IHNlZW1zIHRvIGdldAojICBmaXhlZCBieSBub3QgdXNpbmcgUGVybCdzIG1h
  bGxvYy4gIEZsaXAgc2lkZSBpcyBwZXJmb3JtYW5jZSBsb3NzLgojICBTbyB3ZSB3YW50IG15bWFs
  bG9jIGZvciBhbGwgc2l0dWF0aW9ucyBwb3NzaWJsZQojIFRoYXQgc2V0IHVzZW15bWFsbG9jIHRv
  ICduJyBmb3IgdGhyZWFkZWQgYnVpbGRzIGFuZCBub24tZ2NjIDMyYml0CiMgIG5vbi1kZWJ1Z2dp
  bmcgYnVpbGRzIGFuZCAneScgZm9yIGFsbCBvdGhlcnMKCnVzZW15bWFsbG9jPSduJwpjYXNlICIk
  dXNlcGVybGlvIiBpbgogICAgJHVuZGVmfGZhbHNlfFtuTl0qKSB1c2VteW1hbGxvYz0neScgOzsK
  ICAgIGVzYWMKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCiAg
  ICAnJykgdXNlbWFsbG9jd3JhcD0nZGVmaW5lJyA7OwogICAgZXNhYwoKIyBjdGltZV9yICgpIGFu
  ZCBhc2N0aW1lX3IgKCkgc2VlbSB0byBoYXZlIGlzc3VlcyBmb3IgdmVyc2lvbnMgYmVmb3JlCiMg
  SFAtVVggMTEKaWYgWyAkeHhPc1Jldk1ham9yIC1sdCAxMSBdOyB0aGVuCiAgICBkX2N0aW1lX3I9
  IiR1bmRlZiIKICAgIGRfYXNjdGltZV9yPSIkdW5kZWYiCiAgICBmaQoKIyBmcGNsYXNzaWZ5ICgp
  IGlzIGEgbWFjcm8sIHRoZSBsaWJyYXJ5IGNhbGwgaXMgRnBjbGFzc2lmeQojIFNpbWlsYXJseSB3
  aXRoIHRoZSBvdGhlcnMgYmVsb3cuCmRfZnBjbGFzc2lmeT0nZGVmaW5lJwpkX2lzbmFuPSdkZWZp
  bmUnCmRfaXNpbmY9J2RlZmluZScKZF9pc2Zpbml0ZT0nZGVmaW5lJwpkX3Vub3JkZXJlZD0nZGVm
  aW5lJwojIE5leHQgb25lKHMpIG5lZWQgdGhlIGxlYWRpbmcgdGFiLiAgVGhlc2UgYXJlIHNwZWNp
  YWwgJ2hpbnQnIHN5bWJvbHMgdGhhdAojIGFyZSBub3QgdG8gYmUgcHJvcGFnYXRlZCB0byBjb25m
  aWcuc2gsIGFsbCByZWxhdGVkIHRvIHB0aHJlYWRzIGRyYWZ0IDQKIyBpbnRlcmZhY2VzLgpjYXNl
  ICIkZF9vbGRwdGhyZWFkcyIgaW4KICAgICcnfCR1bmRlZikKCWRfY3J5cHRfcl9wcm90bz0ndW5k
  ZWYnCglkX2dldGdyZW50X3JfcHJvdG89J3VuZGVmJwoJZF9nZXRwd2VudF9yX3Byb3RvPSd1bmRl
  ZicKCWRfc3RyZXJyb3Jfcl9wcm90bz0ndW5kZWYnCgk7OwogICAgZXNhYwoKIyBILk1lcmlqbiBz
  YXlzIGl0J3Mgbm90IDE5OTggYW55bW9yZTogT0RCTSBpcyBub3QgbmVlZGVkLAojIGFuZCBpdCBz
  ZWVtcyB0byBiZSBidWdneSBpbiBIUC1VWCBhbnl3YXkuCmlfZGJtPXVuZGVmCgojIEluIEhQLVVY
  ZXMgcHJpb3IgdG8gMTEuMjMgc3RydG9sZCgpIHJldHVybmVkIGEgSFAtVVgKIyBzcGVjaWZpYyB1
  bmlvbiBjYWxsZWQgbG9uZ19kb3VibGUsIG5vdCBhIEM5OSBsb25nIGRvdWJsZS4KY2FzZSAiYGdy
  ZXAgJ2RvdWJsZSBzdHJ0b2xkLmNvbnN0JyAvdXNyL2luY2x1ZGUvc3RkbGliLmhgIiBpbgoqImxv
  bmcgZG91YmxlIHN0cnRvbGQiKikgOzsgIyBzdHJ0b2xkIHNob3VsZCBiZSBzYWZlLgoqKSBlY2hv
  ICJMb29rcyBsaWtlIHlvdXIgc3RydG9sZCgpIGlzIG5vbi1zdGFuZGFyZC4uLiIgPiY0CiAgIGRf
  c3RydG9sZD11bmRlZiA7Owplc2FjCgojIEluIHByZS0xMSBIUC1VWGVzIHRoZXJlIHJlYWxseSBp
  c24ndCBpc2Zpbml0ZSgpLCBkZXNwaXRlIHdoYXQKIyBDb25maWd1cmUgbWlnaHQgdGhpbmsuIChU
  aGVyZSBpcyBmaW5pdGUoKSwgdGhvdWdoLikKY2FzZSAiYGdyZXAgJ2lzZmluaXRlJyAvdXNyL2lu
  Y2x1ZGUvbWF0aC5oYCIgaW4KKiJpc2Zpbml0ZSIqKSA7OwoqKSBkX2lzZmluaXRlPXVuZGVmIDs7
  CmVzYWMKCiMgMTEuMjMgc2F5cyBpdCBoYXMgbWJybGVuIGFuZCBtYnJ0b3djLCBidXQgY29tcGls
  aW5nIHRoZW0gZmFpbHMgYXMgaXQgY2FuJ3QKIyBmaW5kIHRoZSB0eXBlIGRlZmluaXRpb24gZm9y
  IG1ic3RhdGVfdCB3aGljaCBvbmUgb2YgdGhlIHBhcmFtZXRlcnMgaXMuICBJdCdzCiMgbm90IGlu
  IHRoZSBoZHIgdGhlIG1hbiBwYWdlIHNheXMgaXQgaXMuICBQZXJoYXBzIGEgYmV0dGVyIENvbmZp
  Z3VyZSBwcm9iZSBpcwojIG5lZWRlZCwgYnV0IGZvciBub3cgc2ltcGx5IHVuZGVmaW5lIHRoZW0K
  ZF9tYnJsZW49J3VuZGVmJwpkX21icnRvd2M9J3VuZGVmJwo=',
  'linux' =>
  'IyBoaW50cy9saW51eC5zaAojIE9yaWdpbmFsIHZlcnNpb24gYnkgcnNhbmRlcnMKIyBBZGRpdGlv
  bmFsIHN1cHBvcnQgYnkgS2VubmV0aCBBbGJhbm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwoj
  IEVMRiBzdXBwb3J0IGJ5IEguSi4gTHUgPGhqbEBueW5leHN0LmNvbT4KIyBBZGRpdGlvbmFsIGlu
  Zm8gZnJvbSBOaWdlbCBIZWFkIDxuaGVhZEBFU09DLmJpdG5ldD4KIyBhbmQgS2VubmV0aCBBbGJh
  bm93c2tpIDxramFoZHNAa2phaGRzLmNvbT4KIwojIENvbnNvbGlkYXRlZCBieSBBbmR5IERvdWdo
  ZXJ0eSA8ZG91Z2hlcmFAbGFmYXlldHRlLmVkdT4KIwojIFVwZGF0ZWQgVGh1IEZlYiAgOCAxMTo1
  NjoxMCBFU1QgMTk5NgoKIyBVcGRhdGVkIFRodSBNYXkgMzAgMTA6NTA6MjIgRURUIDE5OTYgYnkg
  PGRvdWdoZXJhQGxhZmF5ZXR0ZS5lZHU+CgojIFVwZGF0ZWQgRnJpIEp1biAyMSAxMTowNzo1NCBF
  RFQgMTk5NgojIE5EQk0gc3VwcG9ydCBmb3IgRUxGIHJlLWVuYWJsZWQgYnkgPGtqYWhkc0BramFo
  ZHMuY29tPgoKIyBObyB2ZXJzaW9uIG9mIExpbnV4IHN1cHBvcnRzIHNldHVpZCBzY3JpcHRzLgpk
  X3N1aWRzYWZlPSd1bmRlZicKCiMgTm8gdmVyc2lvbiBvZiBMaW51eCBuZWVkcyBsaWJ1dGlsIGZv
  ciBwZXJsLgppX2xpYnV0aWw9J3VuZGVmJwoKIyBEZWJpYW4gYW5kIFJlZCBIYXQsIGFuZCBwZXJo
  YXBzIG90aGVyIHZlbmRvcnMsIHByb3ZpZGUgYm90aCBydW50aW1lIGFuZAojIGRldmVsb3BtZW50
  IHBhY2thZ2VzIGZvciBzb21lIGxpYnJhcmllcy4gIFRoZSBydW50aW1lIHBhY2thZ2VzIGNvbnRh
  aW4gc2hhcmVkCiMgbGlicmFyaWVzIHdpdGggdmVyc2lvbiBpbmZvcm1hdGlvbiBpbiB0aGVpciBu
  YW1lcyAoZS5nLiwgbGliZ2RibS5zby4xLjcuMyk7CiMgdGhlIGRldmVsb3BtZW50IHBhY2thZ2Vz
  IHN1cHBsZW1lbnQgdGhpcyB3aXRoIHZlcnNpb25sZXNzIHNoYXJlZCBsaWJyYXJpZXMKIyAoZS5n
  LiwgbGliZ2RibS5zbykuCiMKIyBJZiB5b3Ugd2FudCB0byBsaW5rIGFnYWluc3Qgc3VjaCBhIGxp
  YnJhcnksIHlvdSBtdXN0IGluc3RhbGwgdGhlIGRldmVsb3BtZW50CiMgdmVyc2lvbiBvZiB0aGUg
  cGFja2FnZS4KIwojIFRoZXNlIHBhY2thZ2VzIHVzZSBhIC1kZXYgbmFtaW5nIGNvbnZlbnRpb24g
  aW4gYm90aCBEZWJpYW4gYW5kIFJlZCBIYXQ6CiMgICBsaWJnZGJtZzEgIChub24tZGV2ZWxvcG1l
  bnQgdmVyc2lvbiBvZiBHTlUgbGliYyAyLWxpbmtlZCBHREJNIGxpYnJhcnkpCiMgICBsaWJnZGJt
  ZzEtZGV2IChkZXZlbG9wbWVudCB2ZXJzaW9uIG9mIEdOVSBsaWJjIDItbGlua2VkIEdEQk0gbGli
  cmFyeSkKIyBTbyBtYWtlIHN1cmUgdGhhdCBmb3IgYW55IGxpYnJhcmllcyB5b3Ugd2lzaCB0byBs
  aW5rIFBlcmwgd2l0aCB1bmRlcgojIERlYmlhbiBvciBSZWQgSGF0IHlvdSBoYXZlIHRoZSAtZGV2
  IHBhY2thZ2VzIGluc3RhbGxlZC4KCiMgU3VTRSBMaW51eCBjYW4gYmUgdXNlZCBhcyBjcm9zcy1j
  b21waWxhdGlvbiBob3N0IGZvciBDcmF5IFhUNCBDYXRhbW91bnQvUWsuCmlmIHRlc3QgLWQgL29w
  dC94dC1wZQp0aGVuCiAgY2FzZSAiYCR7Y2M6LWNjfSAtViAyPiYxYCIgaW4KICAqY2F0YW1vdW50
  KikgLiBoaW50cy9jYXRhbW91bnQuc2g7IHJldHVybiA7OwogIGVzYWMKZmkKCiMgU29tZSBvcGVy
  YXRpbmcgc3lzdGVtcyAoZS5nLiwgU29sYXJpcyAyLjYpIHdpbGwgbGluayB0byBhIHZlcnNpb25l
  ZCBzaGFyZWQKIyBsaWJyYXJ5IGltcGxpY2l0bHkuICBGb3IgZXhhbXBsZSwgb24gU29sYXJpcywg
  YGxkIGZvby5vIC1sZ2RibScgd2lsbCBmaW5kIGFuCiMgYXBwcm9wcmlhdGUgdmVyc2lvbiBvZiBs
  aWJnZGJtLCBpZiBvbmUgaXMgYXZhaWxhYmxlOyBMaW51eCwgaG93ZXZlciwgZG9lc24ndAojIGRv
  IHRoZSBpbXBsaWNpdCBtYXBwaW5nLgppZ25vcmVfdmVyc2lvbmVkX3NvbGlicz0neScKCiMgQlNE
  IGNvbXBhdGliaWxpdHkgbGlicmFyeSBubyBsb25nZXIgbmVlZGVkCiMgJ2thZmZlJyBoYXMgYSAv
  dXNyL2xpYi9saWJuZXQuc28gd2hpY2ggaXMgbm90IGF0IGFsbCByZWxldmFudCBmb3IgcGVybC4K
  IyBiaW5kIGNhdXNlcyBpc3N1ZXMgd2l0aCBzZXZlcmFsIHJlZW50cmFudCBmdW5jdGlvbnMKc2V0
  IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYnNkIC8gLycgLWUgJ3MvIG5ldCAv
  IC8nIC1lICdzLyBiaW5kIC8gLydgCnNoaWZ0CmxpYnN3YW50ZWQ9IiQqIgoKIyBEZWJpYW4gNC4w
  IHB1dHMgbmRibSBpbiB0aGUgLWxnZGJtX2NvbXBhdCBsaWJyYXJ5LgplY2hvICRsaWJzCmlmIGVj
  aG8gIiAkbGlic3dhbnRlZCAiIHwgZ3JlcCAtcSAnIGdkYm0gJzsgdGhlbgogICAgIyBPbmx5IGFk
  ZCBpZiBnZGJtIGlzIGluIGxpYnN3YW50ZWQuCiAgICBsaWJzd2FudGVkPSIkbGlic3dhbnRlZCBn
  ZGJtX2NvbXBhdCIKZmkKCiMgQ29uZmlndXJlIG1heSBmYWlsIHRvIGZpbmQgbHN0YXQoKSBzaW5j
  ZSBpdCdzIGEgc3RhdGljL2lubGluZQojIGZ1bmN0aW9uIGluIDxzeXMvc3RhdC5oPi4KZF9sc3Rh
  dD1kZWZpbmUKCiMgbWFsbG9jIHdyYXAgd29ya3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicn
  KSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7CmVzYWMKCiMgVGhlIHN5c3RlbSBtYWxsb2MoKSBp
  cyBhYm91dCBhcyBmYXN0IGFuZCBhcyBmcnVnYWwgYXMgcGVybCdzLgojIFNpbmNlIHRoZSBzeXN0
  ZW0gbWFsbG9jKCkgaGFzIGJlZW4gdGhlIGRlZmF1bHQgc2luY2UgYXQgbGVhc3QKIyA1LjAwMSwg
  d2UgbWlnaHQgYXMgd2VsbCBsZWF2ZSBpdCB0aGF0IHdheS4gIC0tQUQgIDEwIEphbiAyMDAyCmNh
  c2UgIiR1c2VteW1hbGxvYyIgaW4KJycpIHVzZW15bWFsbG9jPSduJyA7Owplc2FjCgp1bmFtZV9t
  aW51c19tPSJgJHJ1biB1bmFtZSAtbSAyPi9kZXYvbnVsbGAiCnVuYW1lX21pbnVzX209IiR7dW5h
  bWVfbWludXNfbTotIiR0YXJnZXRhcmNoIn0iCgojIENoZWNrIGlmIHdlJ3JlIGFib3V0IHRvIHVz
  ZSBJbnRlbCdzIElDQyBjb21waWxlcgpjYXNlICJgJHtjYzotY2N9IC1WIDI+JjFgIiBpbgoqIklu
  dGVsKFIpIEMrKyBDb21waWxlciIqfCoiSW50ZWwoUikgQyBDb21waWxlciIqKQogICAgIyByZWNv
  cmQgdGhlIHZlcnNpb24sIGZvcm1hdHM6CiAgICAjIGljYyAoSUNDKSAxMC4xIDIwMDgwODAxCiAg
  ICAjIGljcGMgKElDQykgMTAuMSAyMDA4MDgwMQogICAgIyBmb2xsb3dlZCBieSBhIGNvcHlyaWdo
  dCBvbiB0aGUgc2Vjb25kIGxpbmUKICAgIGNjdmVyc2lvbj1gJHtjYzotY2N9IC0tdmVyc2lvbiB8
  IHNlZCAtbiAtZSAncy9eaWNwXD9jIFwoKElDQykgXClcPy8vcCdgCiAgICAjIFRoaXMgaXMgbmVl
  ZGVkIGZvciBDb25maWd1cmUncyBwcm90b3R5cGUgY2hlY2tzIHRvIHdvcmsgY29ycmVjdGx5CiAg
  ICAjIFRoZSAtbXAgZmxhZyBpcyBuZWVkZWQgdG8gcGFzcyB2YXJpb3VzIGZsb2F0aW5nIHBvaW50
  IHJlbGF0ZWQgdGVzdHMKICAgICMgVGhlIC1uby1nY2MgZmxhZyBpcyBuZWVkZWQgb3RoZXJ3aXNl
  LCBpY2MgcHJldGVuZHMgKHBvb3JseSkgdG8gYmUgZ2NjCiAgICBjY2ZsYWdzPSItd2UxNDcgLW1w
  IC1uby1nY2MgJGNjZmxhZ3MiCiAgICAjIFByZXZlbnQgcmVsb2NhdGlvbiBlcnJvcnMgb24gNjRi
  aXRzIGFyY2gKICAgIGNhc2UgIiR1bmFtZV9taW51c19tIiBpbgoJKmlhNjQqfCp4ODZfNjQqKQoJ
  ICAgIGNjY2RsZmxhZ3M9Jy1mUElDJwoJOzsKICAgIGVzYWMKICAgICMgSWYgd2UncmUgdXNpbmcg
  SUNDLCB3ZSB1c3VhbGx5IHdhbnQgdGhlIGJlc3QgcGVyZm9ybWFuY2UKICAgIGNhc2UgIiRvcHRp
  bWl6ZSIgaW4KICAgICcnKSBvcHRpbWl6ZT0nLU8zJyA7OwogICAgZXNhYwogICAgOzsKKiIgU3Vu
  ICIqIkMiKikKICAgICMgU3VuJ3MgQyBjb21waWxlciwgd2hpY2ggbWlnaHQgaGF2ZSBhICd0YWcn
  IG5hbWUgYmV0d2VlbgogICAgIyAnU3VuJyBhbmQgdGhlICdDJzogIEV4YW1wbGVzOgogICAgIyBj
  YzogU3VuIEMgNS45IExpbnV4X2kzODYgUGF0Y2ggMTI0ODcxLTAxIDIwMDcvMDcvMzEKICAgICMg
  Y2M6IFN1biBDZXJlcyBDIDUuMTAgTGludXhfaTM4NiAyMDA4LzA3LzEwCiAgICB0ZXN0ICIkb3B0
  aW1pemUiIHx8IG9wdGltaXplPScteE8yJwogICAgY2NjZGxmbGFncz0nLUtQSUMnCiAgICBsZGRs
  ZmxhZ3M9Jy1HIC1CZHluYW1pYycKICAgICMgU3VuIEMgZG9lc24ndCBzdXBwb3J0IGdjYyBhdHRy
  aWJ1dGVzLCBidXQsIGluIG1hbnkgY2FzZXMsIGRvZXNuJ3QKICAgICMgY29tcGxhaW4gZWl0aGVy
  LiAgTm90IGFsbCBjYXNlcywgdGhvdWdoLgogICAgZF9hdHRyaWJ1dGVfZm9ybWF0PSd1bmRlZicK
  ICAgIGRfYXR0cmlidXRlX21hbGxvYz0ndW5kZWYnCiAgICBkX2F0dHJpYnV0ZV9ub25udWxsPSd1
  bmRlZicKICAgIGRfYXR0cmlidXRlX25vcmV0dXJuPSd1bmRlZicKICAgIGRfYXR0cmlidXRlX3B1
  cmU9J3VuZGVmJwogICAgZF9hdHRyaWJ1dGVfdW51c2VkPSd1bmRlZicKICAgIGRfYXR0cmlidXRl
  X3dhcm5fdW51c2VkX3Jlc3VsdD0ndW5kZWYnCiAgICA7Owplc2FjCgpjYXNlICIkb3B0aW1pemUi
  IGluCiMgdXNlIC1PMiBieSBkZWZhdWx0IDsgLU8zIGRvZXNuJ3Qgc2VlbSB0byBicmluZyBzaWdu
  aWZpY2FudCBiZW5lZml0cyB3aXRoIGdjYwonJykKICAgIG9wdGltaXplPSctTzInCiAgICBjYXNl
  ICIkdW5hbWVfbWludXNfbSIgaW4KICAgICAgICBwcGMqKQogICAgICAgICAgICAjIG9uIHBwYywg
  aXQgc2VlbXMgdGhhdCBnY2MgKGF0IGxlYXN0IGdjYyAzLjMuMikgaXNuJ3QgaGFwcHkKICAgICAg
  ICAgICAgIyB3aXRoIC1PMiA7IHNvIGRvd25ncmFkZSB0byAtTzEuCiAgICAgICAgICAgIG9wdGlt
  aXplPSctTzEnCiAgICAgICAgOzsKICAgICAgICBpYTY0KikKICAgICAgICAgICAgIyBUaGlzIGFy
  Y2hpdGVjdHVyZSBoYXMgaGFkIHZhcmlvdXMgcHJvYmxlbXMgd2l0aCBnY2MncwogICAgICAgICAg
  ICAjIGluIHRoZSAzLjIsIDMuMywgYW5kIDMuNCByZWxlYXNlcyB3aGVuIG9wdGltaXplZCB0byAt
  TzIuICBTZWUKICAgICAgICAgICAgIyBSVCAjMzcxNTYgZm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGUg
  cHJvYmxlbS4KICAgICAgICAgICAgY2FzZSAiYCR7Y2M6LWdjY30gLXYgMj4mMWAiIGluCiAgICAg
  ICAgICAgICoidmVyc2lvbiAzLjIiKnwqInZlcnNpb24gMy4zIip8KiJ2ZXJzaW9uIDMuNCIqKQog
  ICAgICAgICAgICAgICAgY2NmbGFncz0iLWZuby1kZWxldGUtbnVsbC1wb2ludGVyLWNoZWNrcyAk
  Y2NmbGFncyIKICAgICAgICAgICAgOzsKICAgICAgICAgICAgZXNhYwogICAgICAgIDs7CiAgICBl
  c2FjCiAgICA7Owplc2FjCgojIFVidW50dSAxMS4wNCAoYW5kIGxhdGVyLCBwcmVzdW1hYmx5KSBk
  b2Vzbid0IGtlZXAgbW9zdCBsaWJyYXJpZXMKIyAoc3VjaCBhcyAtbG0pIGluIC9saWIgb3IgL3Vz
  ci9saWIuICBTbyB3ZSBoYXZlIHRvIGFzayBnY2MgdG8gdGVsbCB1cwojIHdoZXJlIHRvIGxvb2su
  ICBXZSBkb24ndCB3YW50IGdjYydzIG93biBsaWJyYXJpZXMsIGhvd2V2ZXIsIHNvIHdlCiMgZmls
  dGVyIHRob3NlIG91dC4KIyBUaGlzIGNvdWxkIGJlIGNvbmRpdGlvbmFsIG9uIFVuYnVudHUsIGJ1
  dCBvdGhlciBkaXN0cmlidXRpb25zIG1heQojIGZvbGxvdyBzdWl0LCBhbmQgdGhpcyBzY2hlbWUg
  c2VlbXMgdG8gd29yayBldmVuIG9uIHJhdGhlciBvbGQgZ2NjJ3MuCiMgVGhpcyB1bmNvbmRpdGlv
  bmFsbHkgdXNlcyBnY2MgYmVjYXVzZSBldmVuIGlmIHRoZSB1c2VyIGlzIHVzaW5nIGFub3RoZXIK
  IyBjb21waWxlciwgd2Ugc3RpbGwgbmVlZCB0byBmaW5kIHRoZSBtYXRoIGxpYnJhcnkgYW5kIGZy
  aWVuZHMsIGFuZCBJIGRvbid0CiMga25vdyBob3cgb3RoZXIgY29tcGlsZXJzIHdpbGwgY29wZSB3
  aXRoIHRoYXQgc2l0dWF0aW9uLgojIE1vcmV2ZXIsIGlmIHRoZSB1c2VyIGhhcyB0aGVpciBvd24g
  Z2NjIGVhcmxpZXIgaW4gJFBBVEggdGhhbiB0aGUgc3lzdGVtIGdjYywKIyB3ZSBkb24ndCB3YW50
  IGl0cyBsaWJyYXJpZXMuIFNvIHdlIHRyeSB0byBwcmVmZXIgdGhlIHN5c3RlbSBnY2MKIyBTdGls
  bCwgYXMgYW4gZXNjYXBlIGhhdGNoLCBhbGxvdyBDb25maWd1cmUgY29tbWFuZCBsaW5lIG92ZXJy
  aWRlcyB0bwojIHBsaWJwdGggdG8gYnlwYXNzIHRoaXMgY2hlY2suCmlmIFsgLXggL3Vzci9iaW4v
  Z2NjIF0gOyB0aGVuCiAgICBnY2M9L3Vzci9iaW4vZ2NjCiMgY2xhbmcgYWxzbyBwcm92aWRlcyAt
  cHJpbnQtc2VhcmNoLWRpcnMKZWxpZiAke2NjOi1jY30gLS12ZXJzaW9uIDI+L2Rldi9udWxsIHwg
  Z3JlcCAtcSAnXmNsYW5nICcgOyB0aGVuCiAgICBnY2M9JHtjYzotY2N9CmVsc2UKICAgIGdjYz1n
  Y2MKZmkKCmNhc2UgIiRwbGlicHRoIiBpbgonJykgcGxpYnB0aD1gTEFORz1DIExDX0FMTD1DICRn
  Y2MgJGNjZmxhZ3MgJGxkZmxhZ3MgLXByaW50LXNlYXJjaC1kaXJzIHwgZ3JlcCBsaWJyYXJpZXMg
  fAoJY3V0IC1mMi0gLWQ9IHwgdHIgJzonICR0cm5sIHwgZ3JlcCAtdiAnZ2NjJyB8IHNlZCAtZSAn
  czovJDo6J2AKICAgIHNldCBYICRwbGlicHRoICMgQ29sbGFwc2UgYWxsIGVudHJpZXMgb24gb25l
  IGxpbmUKICAgIHNoaWZ0CiAgICBwbGlicHRoPSIkKiIKICAgIDs7CmVzYWMKCiMgRm9yIHRoZSBt
  dXNsIGxpYmMsIHBlcmwgc2hvdWxkICNkZWZpbmUgX0dOVV9TT1VSQ0UuICBPdGhlcndpc2UsIHNv
  bWUKIyBhdmFpbGFibGUgZnVuY3Rpb25zLCBsaWtlIG1lbWVtLCB3b24ndCBiZSB1c2VkLiAgU2Vl
  IHRoZSBkaXNjdXNzaW9uIGluCiMgW3BlcmwgIzEzMzc2MF0uICBtdXNsIGRvZXNuJ3Qgb2ZmZXIg
  YW4gZWFzeSB3YXkgdG8gaWRlbnRpZnkgaXQsIGJ1dCwKIyBhdCBsZWFzdCBvbiBhbHBpbmUgbGlu
  dXgsIHRoZSBsZGQgLS12ZXJzaW9uIG91dHB1dCBjb250YWlucyB0aGUKIyBzdHJpbmcgJ211c2wu
  JwpjYXNlIGBsZGQgLS12ZXJzaW9uIDI+JjFgIGluCiAgICBtdXNsKikgIGNjZmxhZ3M9IiRjY2Zs
  YWdzIC1EX0dOVV9TT1VSQ0UiIDs7CiAgICAgICAgKikgOzsKZXNhYwoKIyBsaWJxdWFkbWF0aCBp
  cyBzb21ldGltZXMgaW5zdGFsbGVkIGFzIGdjYyBpbnRlcm5hbCBsaWJyYXJ5LAojIHNvIGNvbnRy
  YXJ5IHRvIG91ciB1c3VhbCBwb2xpY3kgb2YgKm5vdCogbG9va2luZyBhdCBnY2MgaW50ZXJuYWwK
  IyBkaXJlY3RvcmllcyB3ZSBub3cgKmRvKiBsb29rIGF0IHRoZW0sIGluIGNhc2UgdGhleSBjb250
  YWluCiMgdGhlIHF1YWRtYXRoIGxpYnJhcnkuCiMgWFhYIFRoaXMgbWF5IGFwcGx5IHRvIG90aGVy
  IGdjYyBpbnRlcm5hbCBsaWJyYXJpZXMsIGlmIHN1Y2ggZXhpc3QuCiMgWFhYIFRoaXMgY291bGQg
  YmUgYXQgQ29uZmlndXJlIGxldmVsLCBidXQgdGhlbiB0aGUgJGdjYyBpcyBtZXNzeS4KY2FzZSAi
  JHVzZXF1YWRtYXRoIiBpbgoiJGRlZmluZSIpCiAgZm9yIGQgaW4gYExBTkc9QyBMQ19BTEw9QyAk
  Z2NjICRjY2ZsYWdzICRsZGZsYWdzIC1wcmludC1zZWFyY2gtZGlycyB8IGdyZXAgbGlicmFyaWVz
  IHwgY3V0IC1mMi0gLWQ9IHwgdHIgJzonICR0cm5sIHwgZ3JlcCAnZ2NjJyB8IHNlZCAtZSAnczov
  JDo6J2AKICBkbwogICAgY2FzZSBgbHMgJGQvKmxpYnF1YWRtYXRoKiRzbyogMj4vZGV2L251bGxg
  IGluCiAgICAkZC8qbGlicXVhZG1hdGgqJHNvKikgeGxpYnB0aD0iJHhsaWJwdGggJGQiIDs7CiAg
  ICBlc2FjCiAgZG9uZQogIDs7CmVzYWMKCmNhc2UgIiRsaWJjIiBpbgonJykKIyBJZiB5b3UgaGF2
  ZSBnbGliYywgdGhlbiByZXBvcnQgdGhlIHZlcnNpb24gZm9yIC4vbXljb25maWcgYnVnIHJlcG9y
  dGluZy4KIyAoQ29uZmlndXJlIGRvZXNuJ3QgbmVlZCB0byBrbm93IHRoZSBzcGVjaWZpYyB2ZXJz
  aW9uIHNpbmNlIGl0IGp1c3QgdXNlcwojIGdjYyB0byBsb2FkIHRoZSBsaWJyYXJ5IGZvciBhbGwg
  dGVzdHMuKQojIFdlIGRvbid0IHVzZSBfX0dMSUJDX18gYW5kICBfX0dMSUJDX01JTk9SX18gYmVj
  YXVzZSB0aGV5CiMgYXJlIGluc3VmZmljaWVudGx5IHByZWNpc2UgdG8gZGlzdGluZ3Vpc2ggdGhp
  bmdzIGxpa2UKIyBsaWJjLTIuMC42IGFuZCBsaWJjLTIuMC43LgogICAgZm9yIHAgaW4gJHBsaWJw
  dGgKICAgIGRvCiAgICAgICAgZm9yIHRyeWxpYiBpbiBsaWJjLnNvLjYgbGliYy5zbwogICAgICAg
  IGRvCiAgICAgICAgICAgIGlmICR0ZXN0IC1lICRwLyR0cnlsaWI7IHRoZW4KICAgICAgICAgICAg
  ICAgIGxpYmM9YGxzIC1sICRwLyR0cnlsaWIgfCBhd2sgJ3twcmludCAkTkZ9J2AKICAgICAgICAg
  ICAgICAgIGlmICR0ZXN0ICJYJGxpYmMiICE9IFg7IHRoZW4KICAgICAgICAgICAgICAgICAgICBi
  cmVhawogICAgICAgICAgICAgICAgZmkKICAgICAgICAgICAgZmkKICAgICAgICBkb25lCiAgICAg
  ICAgaWYgJHRlc3QgIlgkbGliYyIgIT0gWDsgdGhlbgogICAgICAgICAgICBicmVhawogICAgICAg
  IGZpCiAgICBkb25lCiAgICA7Owplc2FjCgppZiAke3NoOi0vYmluL3NofSAtYyBleGl0OyB0aGVu
  CiAgZWNobyAnJwogIGVjaG8gJ1lvdSBhcHBlYXIgdG8gaGF2ZSBhIHdvcmtpbmcgYmFzaC4gIEdv
  b2QuJwplbHNlCiAgY2F0IDw8ICdFT00nID4mNAoKKioqKioqKioqKioqKioqKioqKioqKiogV2Fy
  bmluZyEgKioqKioqKioqKioqKioqKioqKioqCkl0IHdvdWxkIGFwcGVhciB5b3UgaGF2ZSBhIGRl
  ZmVjdGl2ZSBiYXNoIHNoZWxsIGluc3RhbGxlZC4gVGhpcyBpcyBsaWtlbHkgdG8KZ2l2ZSB5b3Ug
  YSBmYWlsdXJlIG9mIG9wL2V4ZWMgdGVzdCAjNSBkdXJpbmcgdGhlIHRlc3QgcGhhc2Ugb2YgdGhl
  IGJ1aWxkLApVcGdyYWRpbmcgdG8gYSByZWNlbnQgdmVyc2lvbiAoMS4xNC40IG9yIGxhdGVyKSBz
  aG91bGQgZml4IHRoZSBwcm9ibGVtLgoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
  KioqKioqKioqKioqKioqKioqKioKRU9NCgpmaQoKIyBPbiBTUEFSQ2xpbnV4LAojIFRoZSBmb2xs
  b3dpbmcgY3NoIGNvbnNpc3RlbnRseSBjb3JlZHVtcGVkIGluIHRoZSB0ZXN0IGRpcmVjdG9yeQoj
  ICIvaG9tZS9taWtlZGxyL3Blcmw1LjAwM185NC90IiwgdGhvdWdoIG5vdCBtb3N0IG90aGVyIGRp
  cmVjdG9yaWVzLgoKI05hbWUgICAgICAgIDogY3NoICAgICAgICAgICAgICAgICAgICBEaXN0cmli
  dXRpb246IFJlZCBIYXQgTGludXggKFJlbWJyYW5kdCkKI1ZlcnNpb24gICAgIDogNS4yLjYgICAg
  ICAgICAgICAgICAgICAgICAgICBWZW5kb3I6IFJlZCBIYXQgU29mdHdhcmUKI1JlbGVhc2UgICAg
  IDogMyAgICAgICAgICAgICAgICAgICAgICAgIEJ1aWxkIERhdGU6IEZyaSBNYXkgMjQgMTk6NDI6
  MTQgMTk5NgojSW5zdGFsbCBkYXRlOiBUaHUgSnVsIDExIDE2OjIwOjE0IDE5OTYgQnVpbGQgSG9z
  dDogaXRjaHkucmVkaGF0LmNvbQojR3JvdXAgICAgICAgOiBTaGVsbHMgICAgICAgICAgICAgICAg
  ICAgU291cmNlIFJQTTogY3NoLTUuMi42LTMuc3JjLnJwbQojU2l6ZSAgICAgICAgOiAxODQ0MTcK
  I0Rlc2NyaXB0aW9uIDogQlNEIGMtc2hlbGwKCiMgRm9yIHRoaXMgcmVhc29uIEkgc3VnZ2VzdCB1
  c2luZyB0aGUgbXVjaCBidWctZml4ZWQgdGNzaCBmb3IgZ2xvYmJpbmcKIyB3aGVyZSBhdmFpbGFi
  bGUuCgojIE5vdmVtYmVyIDIwMDE6ICBUaGF0IHdhcm5pbmcncyBwcmV0dHkgb2xkIG5vdyBhbmQg
  cHJvYmFibHkgbm90IHNvCiMgcmVsZXZhbnQsIGVzcGVjaWFsbHkgc2luY2UgcGVybCBub3cgdXNl
  cyBGaWxlOjpHbG9iIGZvciBnbG9iYmluZy4KIyBXZSdsbCBzdGlsbCBsb29rIGZvciB0Y3NoLCBi
  dXQgdG9uZSBkb3duIHRoZSB3YXJuaW5ncy4KIyBBbmR5IERvdWdoZXJ0eSwgTm92LiA2LCAyMDAx
  CmlmICRjc2ggLWMgJ2VjaG8gJHZlcnNpb24nID4vZGV2L251bGwgMj4mMTsgdGhlbgogICAgZWNo
  byAnWW91ciBjc2ggaXMgcmVhbGx5IHRjc2guICBHb29kLicKZWxzZQogICAgaWYgeHh4PWAuL1VV
  L2xvYyB0Y3NoIGJsdXJmbCAkcHRoYDsgJHRlc3QgLWYgIiR4eHgiOyB0aGVuCgllY2hvICJGb3Vu
  ZCB0Y3NoLiAgSSdsbCB1c2UgaXQgZm9yIGdsb2JiaW5nLiIKCSMgV2UgY2FuJ3QgY2hhbmdlIENv
  bmZpZ3VyZSdzIHNldHRpbmcgb2YgJGNzaCwgZHVlIHRvIHRoZSB3YXkKCSMgQ29uZmlndXJlIGhh
  bmRsZXMgJGRfcG9ydGFibGUgYW5kIGNvbW1hbmRzIGZvdW5kIGluICRsb2NsaXN0LgoJIyBXZSBj
  YW4gc2V0IHRoZSB2YWx1ZSBmb3IgQ1NIIGluIGNvbmZpZy5oIGJ5IHNldHRpbmcgZnVsbF9jc2gu
  CglmdWxsX2NzaD0keHh4CiAgICBlbGlmIFsgLWYgIiRjc2giIF07IHRoZW4KCWVjaG8gIkNvdWxk
  bid0IGZpbmQgdGNzaC4gIENzaC1iYXNlZCBnbG9iYmluZyBtaWdodCBiZSBicm9rZW4uIgogICAg
  ZmkKZmkKCiMgU2hpbXBlaSBZYW1hc2hpdGEgPHNoaW1wZWlAc29jcmF0ZXMucGF0bmV0LmNhbHRl
  Y2guZWR1PgojIE1lc3NhZ2UtSWQ6IDwzM0VGMTYzNC5CMzZCNjUwMEBwb2JveC5jb20+CiMKIyBU
  aGUgRFIyIG9mIE1rTGludXggKG9zbmFtZT1saW51eCxhcmNobmFtZT1wcGMtbGludXgpIG1heSBu
  ZWVkCiMgc3BlY2lhbCBmbGFncyBwYXNzZWQgaW4gb3JkZXIgZm9yIGR5bmFtaWMgbG9hZGluZyB0
  byB3b3JrLgojIGluc3RlYWQgb2YgdGhlIHJlY29tbWVuZGVkOgojCiMgY2NkbGZsYWdzPSctcmR5
  bmFtaWMnCiMKIyBpdCBzaG91bGQgYmU6CiMgY2NkbGZsYWdzPSctV2wsLUUnCiMKIyBTbyBpZiB5
  b3VyIERSMiAoRFIzIGNhbWUgb3V0IHN1bW1lciAxOTk4LCBjb25zaWRlciB1cGdyYWRpbmcpCiMg
  aGFzIHByb2JsZW1zIHdpdGggZHluYW1pYyBsb2FkaW5nLCB1bmNvbW1lbnQgdGhlCiMgZm9sbG93
  aW5nIHRocmVlIGxpbmVzLCBtYWtlIGRpc3RjbGVhbiwgYW5kIHJlLUNvbmZpZ3VyZToKI2Nhc2Ug
  ImB1bmFtZSAtciB8IHNlZCAncy9eWzAtOS4tXSovLydgYGFyY2hgIiBpbgojJ29zZm1hY2gzcHBj
  JykgY2NkbGZsYWdzPSctV2wsLUUnIDs7CiNlc2FjCgpjYXNlICIkdW5hbWVfbWludXNfbSIgaW4K
  c3BhcmMqKQoJY2FzZSAiJGNjY2RsZmxhZ3MiIGluCgkqLWZwaWMqKSBjY2NkbGZsYWdzPSJgZWNo
  byAkY2NjZGxmbGFnc3xzZWQgJ3MvLWZwaWMvLWZQSUMvJ2AiIDs7CgkqLWZQSUMqKSA7OwoJKikJ
  IGNjY2RsZmxhZ3M9IiRjY2NkbGZsYWdzIC1mUElDIiA7OwoJZXNhYwoJOzsKZXNhYwoKIyBTdVNF
  OC4yIGhhcyAvdXNyL2xpYi9saWJuZGJtKiB3aGljaCBhcmUgbGQgc2NyaXB0cyByYXRoZXIgdGhh
  bgojIHRydWUgbGlicmFyaWVzLiBUaGUgc2NyaXB0cyBjYXVzZSBiaW5kaW5nIGFnYWluc3Qgc3Rh
  dGljCiMgdmVyc2lvbiBvZiAtbGdkYm0gd2hpY2ggaXMgYSBiYWQgaWRlYS4gU28gaWYgd2UgaGF2
  ZSAnbm0nCiMgbWFrZSBzdXJlIGl0IGNhbiByZWFkIHRoZSBmaWxlCiMgTkktUyAyMDAzLzA4LzA3
  CmNhc2UgIiRubSIgaW4KICAgICcnKSA7OwogICAgKikKICAgIGZvciBwIGluICRwbGlicHRoCiAg
  ICBkbwogICAgICAgIGlmICR0ZXN0IC1yICRwL2xpYm5kYm0uc287IHRoZW4KICAgICAgICAgICAg
  aWYgJG5tICRwL2xpYm5kYm0uc28gPi9kZXYvbnVsbCAyPiYxIDsgdGhlbgogICAgICAgICAgICAg
  ICAgZWNobyAnWW91ciBzaGFyZWQgLWxuZGJtIHNlZW1zIHRvIGJlIGEgcmVhbCBsaWJyYXJ5LicK
  ICAgICAgICAgICAgICAgIF9saWJuZGJtX3JlYWw9MQogICAgICAgICAgICAgICAgYnJlYWsKICAg
  ICAgICAgICAgZmkKICAgICAgICBmaQogICAgZG9uZQogICAgaWYgJHRlc3QgIlgkX2xpYm5kYm1f
  cmVhbCIgPSBYOyB0aGVuCiAgICAgICAgZWNobyAnWW91ciBzaGFyZWQgLWxuZGJtIGlzIG5vdCBh
  IHJlYWwgbGlicmFyeS4nCiAgICAgICAgc2V0IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAt
  ZSAncy8gbmRibSAvIC8nYAogICAgICAgIHNoaWZ0CiAgICAgICAgbGlic3dhbnRlZD0iJCoiCiAg
  ICBmaQogICAgOzsKZXNhYwoKIyBMaW51eCBvbiBTeW5vbG9neS4KaWYgWyAtZiAvZXRjL3N5bm9p
  bmZvLmNvbmYgLWEgLWQgL3Vzci9zeW5vIF07IHRoZW4KICAgICMgVGVzdGVkIG9uIFN5bm9sb2d5
  IERTMjEzIGFuZCBEUzQxMwogICAgIyAgT1MgdmVyc2lvbiBpbmZvIGluIC9ldGMuZGVmYXVsdHMv
  VkVSU0lPTgogICAgIyAgaHR0cDovL2ZvcnVtLnN5bm9sb2d5LmNvbS93aWtpL2luZGV4LnBocC9X
  aGF0X2tpbmRfb2ZfQ1BVX2RvZXNfbXlfTkFTX2hhdmUKICAgICMgU3lub2xvZ3kgRFMyMTMgcnVu
  bmluZyBEU00gNC4zLTM4MTAtMCAoMjAxMy0xMS0wNikKICAgICMgIENQVSBtb2RlbCBNYXJ2ZWxs
  IEtpcmt3b29kIG12NjI4MiBBUk12NXRlCiAgICAjICBMaW51eCAyLjYuMzIuMTIgIzM4MTAgV2Vk
  IE5vdiA2IDA1OjEzOjQxIENTVCAyMDEzIGFybXY1dGVsIEdOVS9MaW51eAogICAgIyBTeW5vbG9n
  eSBEUzQxMyBydW5uaW5nIERTTSA0LjMtMzgxMC0wICgyMDEzLTExLTA2KQogICAgIyAgQ1BVIG1v
  ZGVsIEZyZWVzY2FsZSBRb3JJUSBQMTAyMiBwcGMgKGU1MDB2MikKICAgICMgIGxpbnV4IDIuNi4z
  Mi4xMiAjMzgxMCBwcGMgR05VL0xpbnV4CiAgICAjIEFsbCBkZXZlbG9wbWVudCBzdHVmZiBpbnN0
  YWxsZWQgd2l0aCBpcGtnIGlzIGluIC9vcHQKICAgIGlmIFsgIiRMQU5HIiA9ICIiIC1vICIkTEFO
  RyIgPSAiQyIgXTsgdGhlbgoJZWNobyAnWW91ciBMQU5HIGlzIHNhZmUnCiAgICBlbHNlCgllY2hv
  ICdQbGVhc2Ugc2V0ICRMQU5HIHRvICJDIi4gQWxsIG90aGVyICRMQU5HIHNldHRpbmdzIHdpbGwg
  Y2F1c2UgaGF2b2MnID4mNAoJTEFORz1DCiAgICBmaQogICAgZWNobyAnU2V0dGluZyB1cCB0byB1
  c2UgL29wdC8qJyA+JjQKICAgIGxvY2luY3B0aD0iL29wdC9pbmNsdWRlICRsb2NpbmNwdGgiCiAg
  ICBsaWJwdGg9Ii9vcHQvbGliICRsaWJwdGgiCiAgICBsaWJzcHRoPSIvb3B0L2xpYiAkbGlic3B0
  aCIKICAgIGxvY2xpYnB0aD0iL29wdC9saWIgJGxvY2xpYnB0aCIKICAgICMgUE9TSVggd2lsbCBu
  b3QgbGluayB3aXRob3V0IHRoZSBwdGhyZWFkIGxpYgogICAgbGlic3dhbnRlZD0iJGxpYnN3YW50
  ZWQgcHRocmVhZCIKICAgIGVjaG8gIiRsaWJzd2FudGVkIiA+JjQKZmkKCiMgVGhpcyBzY3JpcHQg
  VVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUKIyBh
  ZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMu
  CmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4K
  JGRlZmluZXx0cnVlfFt5WV0qKQogICAgICAgIGNjZmxhZ3M9Ii1EX1JFRU5UUkFOVCAtRF9HTlVf
  U09VUkNFICRjY2ZsYWdzIgogICAgICAgIGlmIGVjaG8gJGxpYnN3YW50ZWQgfCBncmVwIC12IHB0
  aHJlYWQgPi9kZXYvbnVsbAogICAgICAgIHRoZW4KICAgICAgICAgICAgc2V0IGBlY2hvIFggIiRs
  aWJzd2FudGVkICJ8IHNlZCAtZSAncy8gYyAvIHB0aHJlYWQgYyAvJ2AKICAgICAgICAgICAgc2hp
  ZnQKICAgICAgICAgICAgbGlic3dhbnRlZD0iJCoiCiAgICAgICAgZmkKCgkjIFNvbWVob3cgYXQg
  bGVhc3QgaW4gRGViaWFuIDIuMiB0aGVzZSBtYW5hZ2UgdG8gZXNjYXBlCgkjIHRoZSAjZGVmaW5l
  IGZvcmVzdCBvZiA8ZmVhdHVyZXMuaD4gYW5kIDx0aW1lLmg+IHNvIHRoYXQKCSMgdGhlIGhhc3By
  b3RvIG1hY3JvIG9mIENvbmZpZ3VyZSBkb2Vzbid0IHNlZSB0aGVzZSBwcm90b3MsCgkjIGV2ZW4g
  d2l0aCB0aGUgLURfR05VX1NPVVJDRS4KCglkX2FzY3RpbWVfcl9wcm90bz0iJGRlZmluZSIKCWRf
  Y3J5cHRfcl9wcm90bz0iJGRlZmluZSIKCWRfY3RpbWVfcl9wcm90bz0iJGRlZmluZSIKCWRfZ210
  aW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2xvY2FsdGltZV9yX3Byb3RvPSIkZGVmaW5lIgoJZF9y
  YW5kb21fcl9wcm90bz0iJGRlZmluZSIKCgk7Owplc2FjCkVPQ0JVCgpjYXQgPiBVVS91c2VsYXJn
  ZWZpbGVzLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJnZWZpbGVzLmNidSB3
  aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRl
  ZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCmNhc2UgIiR1c2VsYXJn
  ZWZpbGVzIiBpbgonJ3wkZGVmaW5lfHRydWV8W3lZXSopCiMgS2VlcCB0aGlzIGluIHRoZSBsZWZ0
  IG1hcmdpbi4KY2NmbGFnc191c2VsYXJnZWZpbGVzPSItRF9MQVJHRUZJTEVfU09VUkNFIC1EX0ZJ
  TEVfT0ZGU0VUX0JJVFM9NjQiCgoJY2NmbGFncz0iJGNjZmxhZ3MgJGNjZmxhZ3NfdXNlbGFyZ2Vm
  aWxlcyIKCTs7CmVzYWMKRU9DQlUKCiMgUHVyaWZ5IGZhaWxzIHRvIGxpbmsgUGVybCBpZiBhICIt
  bGMiIGlzIHBhc3NlZCBpbnRvIGl0cyBsaW5rZXIKIyBkdWUgdG8gZHVwbGljYXRlIHN5bWJvbHMu
  CmNhc2UgIiRQVVJJRlkiIGluCiRkZWZpbmV8dHJ1ZXxbeVldKikKICAgIHNldCBgZWNobyBYICIk
  bGlic3dhbnRlZCAifCBzZWQgLWUgJ3MvIGMgLyAvJ2AKICAgIHNoaWZ0CiAgICBsaWJzd2FudGVk
  PSIkKiIKICAgIDs7CmVzYWMKCiMgSWYgdXNpbmcgZysrLCB0aGUgQ29uZmlndXJlIHNjYW4gZm9y
  IGRsb3BlbigpIGFuZCAoZXNwZWNpYWxseSkKIyBkbGVycm9yKCkgbWlnaHQgZmFpbCwgZWFzaWVy
  IGp1c3QgdG8gZm9yY2libHkgaGludCB0aGVtIGluLgpjYXNlICIkY2MiIGluCipnKysqKQogIGRf
  ZGxvcGVuPSdkZWZpbmUnCiAgZF9kbGVycm9yPSdkZWZpbmUnCiAgOzsKZXNhYwoKIyBVbmRlciBz
  b21lIGNpcmN1bXN0YW5jZXMgbGliZGIgY2FuIGdldCBidWlsdCBpbiBzdWNoIGEgd2F5IGFzIHRv
  CiMgbmVlZCBwdGhyZWFkIGV4cGxpY2l0bHkgbGlua2VkLgoKbGliZGJfbmVlZHNfcHRocmVhZD0i
  TiIKCmlmIGVjaG8gIiAkbGlic3dhbnRlZCAiIHwgZ3JlcCAtdiAiIHB0aHJlYWQgIiA+L2Rldi9u
  dWxsCnRoZW4KICAgaWYgZWNobyAiICRsaWJzd2FudGVkICIgfCBncmVwICIgZGIgIiA+L2Rldi9u
  dWxsCiAgIHRoZW4KICAgICBmb3IgREJESVIgaW4gJGdsaWJwdGgKICAgICBkbwogICAgICAgREJM
  SUI9IiREQkRJUi9saWJkYi5zbyIKICAgICAgIGlmIFsgLWYgJERCTElCIF0KICAgICAgIHRoZW4K
  ICAgICAgICAgaWYgJHtubTotbm19IC11ICREQkxJQiAyPi9kZXYvbnVsbCB8IGdyZXAgcHRocmVh
  ZCA+L2Rldi9udWxsCiAgICAgICAgIHRoZW4KICAgICAgICAgICBpZiBsZGQgJERCTElCIHwgZ3Jl
  cCBwdGhyZWFkID4vZGV2L251bGwKICAgICAgICAgICB0aGVuCiAgICAgICAgICAgICBsaWJkYl9u
  ZWVkc19wdGhyZWFkPSJOIgogICAgICAgICAgIGVsc2UKICAgICAgICAgICAgIGxpYmRiX25lZWRz
  X3B0aHJlYWQ9IlkiCiAgICAgICAgICAgZmkKICAgICAgICAgZmkKICAgICAgIGZpCiAgICAgZG9u
  ZQogICBmaQpmaQoKY2FzZSAiJGxpYmRiX25lZWRzX3B0aHJlYWQiIGluCiAgIlkiKQogICAgbGli
  c3dhbnRlZD0iJGxpYnN3YW50ZWQgcHRocmVhZCIKICAgIDs7CmVzYWMK',
  'midnightbsd' =>
  'dXNldmZvcms9J3RydWUnCmNhc2UgIiR1c2VteW1hbGxvYyIgaW4KICAgICIiKSB1c2VteW1hbGxv
  Yz0nbicKICAgICAgICA7Owplc2FjCmxpYnN3YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQg
  J3MvIG1hbGxvYyAvIC8nYAoKb2JqZm9ybWF0PWAvdXNyL2Jpbi9vYmpmb3JtYXRgCmlmIFsgeCRv
  Ympmb3JtYXQgPSB4YW91dCBdOyB0aGVuCiAgICBpZiBbIC1lIC91c3IvbGliL2FvdXQgXTsgdGhl
  bgogICAgICAgIGxpYnB0aD0iL3Vzci9saWIvYW91dCAvdXNyL2xvY2FsL2xpYiAvdXNyL2xpYiIK
  ICAgICAgICBnbGlicHRoPSIvdXNyL2xpYi9hb3V0IC91c3IvbG9jYWwvbGliIC91c3IvbGliIgog
  ICAgZmkKICAgIGxkZGxmbGFncz0nLUJzaGFyZWFibGUnCmVsc2UKICAgIGxpYnB0aD0iL3Vzci9s
  aWIgL3Vzci9sb2NhbC9saWIiCiAgICBnbGlicHRoPSIvdXNyL2xpYiAvdXNyL2xvY2FsL2xpYiIK
  ICAgIGxkZmxhZ3M9Ii1XbCwtRSAiCiAgICBsZGRsZmxhZ3M9Ii1zaGFyZWQgIgpmaQpjY2NkbGZs
  YWdzPSctRFBJQyAtZlBJQycKCmNjZmxhZ3M9IiR7Y2NmbGFnc30gLURIQVNfRlBTRVRNQVNLIC1E
  SEFTX0ZMT0FUSU5HUE9JTlRfSCIKaWYgL3Vzci9iaW4vZmlsZSAtTCAvdXNyL2xpYi9saWJjLnNv
  IHwgL3Vzci9iaW4vZ3JlcCAtdnEgIm5vdCBzdHJpcHBlZCIgOyB0aGVuCiAgICB1c2VubT1mYWxz
  ZQpmaQoKc2lnbmFsX3Q9J3ZvaWQnCmRfdm9pZHNpZz0nZGVmaW5lJwoKIyBUaGlzIHNjcmlwdCBV
  VS91c2V0aHJlYWRzLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZSAKIyBh
  ZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9yIHdoZXRoZXIgdG8gdXNlIHRocmVhZHMu
  CmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JVJwpjYXNlICIkdXNldGhyZWFkcyIgaW4K
  JGRlZmluZXx0cnVlfFt5WV0qKQoJbGRmbGFncz0iLXB0aHJlYWQgJGxkZmxhZ3MiCglzZXQgYGVj
  aG8gWCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICdzLyBjIC8vJ2AKCXNoaWZ0CglsaWJzd2FudGVk
  PSIkKiIKCSMgQ29uZmlndXJlIHdpbGwgcHJvYmFibHkgcGljayB0aGUgd3JvbmcgbGliYyB0byB1
  c2UgZm9yIG5tIHNjYW4uCgkjIFRoZSBzYWZlc3QgcXVpY2stZml4IGlzIGp1c3QgdG8gbm90IHVz
  ZSBubSBhdCBhbGwuLi4KCXVzZW5tPWZhbHNlCgogICAgICAgIHVuc2V0IGxjX3IKCgkjIEV2ZW4g
  d2l0aCB0aGUgbWFsbG9jIG11dGV4ZXMgdGhlIFBlcmwgbWFsbG9jIGRvZXMgbm90CgkjIHNlZW0g
  dG8gYmUgdGhyZWFkc2FmZSBpbiBNaWRuaWdodEJTRD8KCWNhc2UgIiR1c2VteW1hbGxvYyIgaW4K
  CScnKSB1c2VteW1hbGxvYz1uIDs7Cgllc2FjCmVzYWMKRU9DQlUKCiMgbWFsbG9jIHdyYXAgd29y
  a3MKY2FzZSAiJHVzZW1hbGxvY3dyYXAiIGluCicnKSB1c2VtYWxsb2N3cmFwPSdkZWZpbmUnIDs7
  CmVzYWMK',
  'netbsd' =>
  'IyBoaW50cy9uZXRic2Quc2gKIwojIFBsZWFzZSBjaGVjayB3aXRoIHBhY2thZ2VzQG5ldGJzZC5v
  cmcgYmVmb3JlIG1ha2luZyBtb2RpZmljYXRpb25zCiMgdG8gdGhpcyBmaWxlLgoKY2FzZSAiJGFy
  Y2huYW1lIiBpbgonJykKICAgIGFyY2huYW1lPWB1bmFtZSAtbWAtJHtvc25hbWV9CiAgICA7Owpl
  c2FjCgojIE5ldEJTRCBrZWVwcyBkeW5hbWljIGxvYWRpbmcgZGwqKCkgZnVuY3Rpb25zIGluIC91
  c3IvbGliL2NydDAubywKIyBzbyBDb25maWd1cmUgZG9lc24ndCBmaW5kIHRoZW0gKHVubGVzcyB5
  b3UgYWJhbmRvbiB0aGUgbm0gc2NhbikuCiMgQWxzbywgTmV0QlNEIDAuOWEgd2FzIHRoZSBmaXJz
  dCByZWxlYXNlIHRvIGludHJvZHVjZSBzaGFyZWQKIyBsaWJyYXJpZXMuCiMKY2FzZSAiJG9zdmVy
  cyIgaW4KMC45fDAuOCopCgl1c2VkbD0iJHVuZGVmIgoJOzsKKikKCWNhc2UgYHVuYW1lIC1tYCBp
  bgoJcG1heCkKCQkjIE5ldEJTRCAxLjMgYW5kIDEuMy4xIG9uIHBtYXggc2hpcHBlZCBhbiBgb2xk
  JyBsZC5zbywKCQkjIHdoaWNoIHdpbGwgbm90IHdvcmsuCgkJY2FzZSAiJG9zdmVycyIgaW4KCQkx
  LjN8MS4zLjEpCgkJCWRfZGxvcGVuPSR1bmRlZgoJCQk7OwoJCWVzYWMKCQk7OwoJZXNhYwoJaWYg
  dGVzdCAtZiAvdXNyL2xpYmV4ZWMvbGQuZWxmX3NvOyB0aGVuCgkJIyBFTEYKCQlkX2Rsb3Blbj0k
  ZGVmaW5lCgkJZF9kbGVycm9yPSRkZWZpbmUKCQljY2NkbGZsYWdzPSItRFBJQyAtZlBJQyAkY2Nj
  ZGxmbGFncyIKCQlsZGRsZmxhZ3M9Ii1zaGFyZWQgJGxkZGxmbGFncyIKCQljYXQgPlVVL2NjLmNi
  dSA8PCdFT0NCVScKIyBnY2MgNC42IGRvZXNuJ3Qgc3VwcG9ydCAtLXdob2xlLWFyY2hpdmUsIGJ1
  dCBpdCdzIHJlcXVpcmVkIGZvciB0aGUKIyBzeXN0ZW0gZ2NjIHRvIGJ1aWxkIGNvcnJlY3RseSwg
  c28gY2hlY2sgZm9yIGl0CmVjaG8gJ2ludCBmKHZvaWQpIHsgcmV0dXJuIDA7IH0nID50cnkuYwpp
  ZiAke2NjOi1jY30gJGNjY2RsZmxhZ3MgLWMgdHJ5LmMgLW90cnkubyAyPiYxICYmCiAgICR7Y2M6
  LWNjfSAtLXdob2xlLWFyY2hpdmUgJGxkZGxmbGFncyB0cnkubyAtb3RyeS5zbyAyPiYxIDsgdGhl
  bgogICAgbGRkbGZsYWdzPSItLXdob2xlLWFyY2hpdmUgJGxkZGxmbGFncyIKZmkKcm0gdHJ5LmMg
  dHJ5Lm8gdHJ5LnNvIDI+L2Rldi9udWxsCkVPQ0JVCgkJcnBhdGhmbGFnPSItV2wsLXJwYXRoLCIK
  CQljYXNlICIkb3N2ZXJzIiBpbgoJCTEuWzAtNV0qKQoJCQkjCgkJCSMgSW5jbHVkZSB0aGUgd2hv
  bGUgbGliZ2NjLmEgaW50byB0aGUgcGVybCBleGVjdXRhYmxlCgkJCSMgc28gdGhhdCBjZXJ0YWlu
  IHN5bWJvbHMgbmVlZGVkIGJ5IGxvYWRhYmxlIG1vZHVsZXMKCQkJIyBidWlsdCBhcyBDKysgb2Jq
  ZWN0cyAoX19laF9hbGxvYywgX19wdXJlX3ZpcnR1YWwsCgkJCSMgZXRjLikgd2lsbCBhbHdheXMg
  YmUgZGVmaW5lZC4KCQkJIwoJCQljY2RsZmxhZ3M9Ii1XbCwtd2hvbGUtYXJjaGl2ZSAtbGdjYyBc
  CgkJCQktV2wsLW5vLXdob2xlLWFyY2hpdmUgLVdsLC1FICRjY2RsZmxhZ3MiCgkJCTs7CgkJKikK
  CQkJY2NkbGZsYWdzPSItV2wsLUUgJGNjZGxmbGFncyIKCQkJOzsKCQllc2FjCgllbGlmIHRlc3Qg
  LWYgL3Vzci9saWJleGVjL2xkLnNvOyB0aGVuCgkJIyBhLm91dAoJCWRfZGxvcGVuPSRkZWZpbmUK
  CQlkX2RsZXJyb3I9JGRlZmluZQoJCWNjY2RsZmxhZ3M9Ii1EUElDIC1mUElDICRjY2NkbGZsYWdz
  IgoJCWxkZGxmbGFncz0iLUJzaGFyZWFibGUgJGxkZGxmbGFncyIKCQlycGF0aGZsYWc9Ii1SIgoJ
  ZWxzZQoJCWRfZGxvcGVuPSR1bmRlZgoJCXJwYXRoZmxhZz0KCWZpCgk7Owplc2FjCgojIG5ldGJz
  ZCBoYWQgdGhlc2UgYnV0IHRoZXkgZG9uJ3QgcmVhbGx5IHdvcmsgYXMgYWR2ZXJ0aXNlZCwgaW4g
  dGhlCiMgdmVyc2lvbnMgbGlzdGVkIGJlbG93LiAgaWYgdGhleSBhcmUgZGVmaW5lZCwgdGhlbiB0
  aGVyZSBpc24ndCBhCiMgd2F5IHRvIG1ha2UgcGVybCBjYWxsIHNldHVpZCgpIG9yIHNldGdpZCgp
  LiAgaWYgdGhleSBhcmVuJ3QsIHRoZW4KIyAoJDwsICQ+KSA9ICgkdSwgJHUpOyB3aWxsIHdvcmsg
  KHNhbWUgZm9yICQoLyQpKS4gIHRoaXMgaXMgYmVjYXVzZQojIHlvdSBjYW4gbm90IGNoYW5nZSB0
  aGUgcmVhbCB1c2VyaWQgb2YgYSBwcm9jZXNzIHVuZGVyIDQuNEJTRC4KIyBuZXRic2QgZml4ZWQg
  dGhpcyBpbiAxLjMuMi4KY2FzZSAiJG9zdmVycyIgaW4KMC45KnwxLlswMTJdKnwxLjN8MS4zLjEp
  CglkX3NldHJlZ2lkPSIkdW5kZWYiCglkX3NldHJldWlkPSIkdW5kZWYiCgk7Owplc2FjCmNhc2Ug
  IiRvc3ZlcnMiIGluCjAuOCopCgk7OwoqKQoJZF9nZXRwcm90b2VudF9yPSIkdW5kZWYiCglkX2dl
  dHByb3RvYnluYW1lX3I9IiR1bmRlZiIKCWRfZ2V0cHJvdG9ieW51bWJlcl9yPSIkdW5kZWYiCglk
  X3NldHByb3RvZW50X3I9IiR1bmRlZiIKCWRfZW5kcHJvdG9lbnRfcj0iJHVuZGVmIgoJZF9nZXRz
  ZXJ2ZW50X3I9IiR1bmRlZiIKCWRfZ2V0c2VydmJ5bmFtZV9yPSIkdW5kZWYiCglkX2dldHNlcnZi
  eXBvcnRfcj0iJHVuZGVmIgoJZF9zZXRzZXJ2ZW50X3I9IiR1bmRlZiIKCWRfZW5kc2VydmVudF9y
  PSIkdW5kZWYiCglkX2dldGhvc3RieW5hbWVfcj0iJHVuZGVmIgoJZF9nZXRob3N0YnlhZGRyMl9y
  PSIkdW5kZWYiCglkX2dldGhvc3RieWFkZHJfcj0iJHVuZGVmIgoJZF9zZXRob3N0ZW50X3I9IiR1
  bmRlZiIKCWRfZ2V0aG9zdGVudF9yPSIkdW5kZWYiCglkX2VuZGhvc3RlbnRfcj0iJHVuZGVmIgoJ
  ZF9nZXRwcm90b2VudF9yX3Byb3RvPSIwIgoJZF9nZXRwcm90b2J5bmFtZV9yX3Byb3RvPSIwIgoJ
  ZF9nZXRwcm90b2J5bnVtYmVyX3JfcHJvdG89IjAiCglkX3NldHByb3RvZW50X3JfcHJvdG89IjAi
  CglkX2VuZHByb3RvZW50X3JfcHJvdG89IjAiCglkX2dldHNlcnZlbnRfcl9wcm90bz0iMCIKCWRf
  Z2V0c2VydmJ5bmFtZV9yX3Byb3RvPSIwIgoJZF9nZXRzZXJ2Ynlwb3J0X3JfcHJvdG89IjAiCglk
  X3NldHNlcnZlbnRfcl9wcm90bz0iMCIKCWRfZW5kc2VydmVudF9yX3Byb3RvPSIwIgoJZF9nZXRo
  b3N0YnluYW1lX3JfcHJvdG89IjAiCglkX2dldGhvc3RieWFkZHIyX3JfcHJvdG89IjAiCglkX2dl
  dGhvc3RieWFkZHJfcl9wcm90bz0iMCIKCWRfc2V0aG9zdGVudF9yX3Byb3RvPSIwIgoJZF9lbmRo
  b3N0ZW50X3JfcHJvdG89IjAiCglkX2dldGhvc3RlbnRfcl9wcm90bz0iMCIKCTs7CmVzYWMKCiMg
  VGhlc2UgYXJlIG9ic29sZXRlIGluIGFueSBuZXRic2QuCmRfc2V0cmdpZD0iJHVuZGVmIgpkX3Nl
  dHJ1aWQ9IiR1bmRlZiIKCiMgdGhlcmUncyBubyBwcm9ibGVtIHdpdGggdmZvcmsuCnVzZXZmb3Jr
  PXRydWUKCiMgVGhpcyBpcyB0aGVyZSBidXQgaW4gbWFjaGluZS9pZWVlZnBfaC4KaWVlZWZwX2g9
  ImRlZmluZSIKCiMgVGhpcyBzY3JpcHQgVVUvdXNldGhyZWFkcy5jYnUgd2lsbCBnZXQgJ2NhbGxl
  ZC1iYWNrJyBieSBDb25maWd1cmUKIyBhZnRlciBpdCBoYXMgcHJvbXB0ZWQgdGhlIHVzZXIgZm9y
  IHdoZXRoZXIgdG8gdXNlIHRocmVhZHMuCmNhdCA+IFVVL3VzZXRocmVhZHMuY2J1IDw8J0VPQ0JV
  JwpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRlZmluZXx0cnVlfFt5WV0qKQoJbHB0aHJlYWQ9Cglm
  b3IgeHh4IGluIHB0aHJlYWQ7IGRvCgkJZm9yIHl5eSBpbiAkbG9jbGlicHRoICRwbGlicHRoICRn
  bGlicHRoIGR1bW15OyBkbwoJCQl6eno9JHl5eS9saWIkeHh4LmEKCQkJaWYgdGVzdCAtZiAiJHp6
  eiI7IHRoZW4KCQkJCWxwdGhyZWFkPSR4eHgKCQkJCWJyZWFrOwoJCQlmaQoJCQl6eno9JHl5eS9s
  aWIkeHh4LnNvCgkJCWlmIHRlc3QgLWYgIiR6enoiOyB0aGVuCgkJCQlscHRocmVhZD0keHh4CgkJ
  CQlicmVhazsKCQkJZmkKCQkJenp6PWBscyAkeXl5L2xpYiR4eHguc28uKiAyPi9kZXYvbnVsbGAK
  CQkJaWYgdGVzdCAiWCR6enoiICE9IFg7IHRoZW4KCQkJCWxwdGhyZWFkPSR4eHgKCQkJCWJyZWFr
  OwoJCQlmaQoJCWRvbmUKCQlpZiB0ZXN0ICJYJGxwdGhyZWFkIiAhPSBYOyB0aGVuCgkJCWJyZWFr
  OwoJCWZpCglkb25lCglpZiB0ZXN0ICJYJGxwdGhyZWFkIiAhPSBYOyB0aGVuCgkJIyBBZGQgLWxw
  dGhyZWFkLgoJCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkICRscHRocmVhZCIKCQkjIFRoZXJlIGlz
  IG5vIGxpYmNfciBhcyBvZiBOZXRCU0QgMS41LjIsIHNvIG5vIGMgLT4gY19yLgoJCSMgVGhpcyB3
  aWxsIGJlIHJldmlzaXRlZCB3aGVuIE5ldEJTRCBnYWlucyBhIG5hdGl2ZSBwdGhyZWFkcwoJCSMg
  aW1wbGVtZW50YXRpb24uCgllbHNlCgkJZWNobyAiJDA6IE5vIFBPU0lYIHRocmVhZHMgbGlicmFy
  eSAoLWxwdGhyZWFkKSBmb3VuZC4gICIgXAoJCSAgICAgIllvdSBtYXkgd2FudCB0byBpbnN0YWxs
  IEdOVSBwdGguICBBYm9ydGluZy4iID4mNAoJCWV4aXQgMQoJZmkKCXVuc2V0IGxwdGhyZWFkCgoJ
  IyBzZXZlcmFsIHJlZW50cmFudCBmdW5jdGlvbnMgYXJlIGVtYmVkZGVkIGluIGxpYmMsIGJ1dCBo
  YXZlbid0CgkjIGJlZW4gYWRkZWQgdG8gdGhlIGhlYWRlciBmaWxlcyB5ZXQuICBMZXQncyBob2xk
  IG9mZiBvbiB1c2luZwoJIyB0aGVtIHVudGlsIHRoZXkgYXJlIGEgdmFsaWQgcGFydCBvZiB0aGUg
  QVBJCgljYXNlICIkb3N2ZXJzIiBpbgoJWzAxMl0uKnwzLlswLTFdKQoJCWRfZ2V0cHJvdG9ieW5h
  bWVfcj0kdW5kZWYKCQlkX2dldHByb3RvYnludW1iZXJfcj0kdW5kZWYKCQlkX2dldHByb3RvZW50
  X3I9JHVuZGVmCgkJZF9nZXRzZXJ2YnluYW1lX3I9JHVuZGVmCgkJZF9nZXRzZXJ2Ynlwb3J0X3I9
  JHVuZGVmCgkJZF9nZXRzZXJ2ZW50X3I9JHVuZGVmCgkJZF9zZXRwcm90b2VudF9yPSR1bmRlZgoJ
  CWRfc2V0c2VydmVudF9yPSR1bmRlZgoJCWRfZW5kcHJvdG9lbnRfcj0kdW5kZWYKCQlkX2VuZHNl
  cnZlbnRfcj0kdW5kZWYgOzsKCWVzYWMKCTs7Cgplc2FjCkVPQ0JVCgojIFNldCBzZW5zaWJsZSBk
  ZWZhdWx0cyBmb3IgTmV0QlNEOiBsb29rIGZvciBsb2NhbCBzb2Z0d2FyZSBpbgojIC91c3IvcGtn
  IChOZXRCU0QgUGFja2FnZXMgQ29sbGVjdGlvbikgYW5kIGluIC91c3IvbG9jYWwuCiMKbG9jbGli
  cHRoPSIvdXNyL3BrZy9saWIgL3Vzci9sb2NhbC9saWIiCmxvY2luY3B0aD0iL3Vzci9wa2cvaW5j
  bHVkZSAvdXNyL2xvY2FsL2luY2x1ZGUiCmNhc2UgIiRycGF0aGZsYWciIGluCicnKQoJbGRmbGFn
  cz0KCTs7CiopCglsZGZsYWdzPQoJZm9yIHl5eSBpbiAkbG9jbGlicHRoOyBkbwoJCWxkZmxhZ3M9
  IiRsZGZsYWdzICRycGF0aGZsYWckeXl5IgoJZG9uZQoJOzsKZXNhYwoKY2FzZSBgdW5hbWUgLW1g
  IGluCmFscGhhKQogICAgZWNobyAnaW50IG1haW4oKSB7fScgPiB0cnkuYwogICAgZ2NjPWAke2Nj
  Oi1jY30gLXYgLWMgdHJ5LmMgMj4mMXxncmVwICdnY2MgdmVyc2lvbiBlZ2NzLTInYAogICAgY2Fz
  ZSAiJGdjYyIgaW4KICAgICcnIHwgImdjYyB2ZXJzaW9uIGVnY3MtMi45NS4iWzMtOV0qKSA7OyAj
  IDIuOTUuMyBvciBiZXR0ZXIgb2theQogICAgKikJY2F0ID4mNCA8PEVPRgoqKioKKioqIFlvdXIg
  Z2NjICgkZ2NjKSBpcyBrbm93biB0byBiZQoqKiogdG9vIGJ1Z2d5IG9uIG5ldGJzZC9hbHBoYSB0
  byBjb21waWxlIFBlcmwgd2l0aCBvcHRpbWl6YXRpb24uCioqKiBJdCBpcyBzdWdnZXN0ZWQgeW91
  IGluc3RhbGwgdGhlIGxhbmcvZ2NjIHBhY2thZ2Ugd2hpY2ggc2hvdWxkCioqKiBoYXZlIGF0IGxl
  YXN0IGdjYyAyLjk1LjMgd2hpY2ggc2hvdWxkIHdvcmsgb2theTogdXNlIGZvciBleGFtcGxlCioq
  KiBDb25maWd1cmUgLURjYz0vdXNyL3BrZy9nY2MtMi45NS4zL2Jpbi9jYy4gIFlvdSBjb3VsZCBh
  bHNvCioqKiBDb25maWd1cmUgLURvcHRpbWl6ZT0tTzAgdG8gY29tcGlsZSBQZXJsIHdpdGhvdXQg
  YW55IG9wdGltaXphdGlvbgoqKiogYnV0IHRoYXQgaXMgbm90IHJlY29tbWVuZGVkLgoqKioKRU9G
  CglleGl0IDEKCTs7CiAgICBlc2FjCiAgICBybSAtZiB0cnkuKgogICAgOzsKZXNhYwoKIyBOZXRC
  U0Qvc3BhcmMgMS41LjMvMS42LjEgZHVtcHMgY29yZSBpbiB0aGUgc2VtaWRfZHMgdGVzdCBvZiBD
  b25maWd1cmUuCmNhc2UgYHVuYW1lIC1tYCBpbgpzcGFyYykgZF9zZW1jdGxfc2VtaWRfZHM9dW5k
  ZWYgOzsKZXNhYwoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4K
  JycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBkb24ndCB1c2UgcGVybCBtYWxs
  b2MgYnkgZGVmYXVsdApjYXNlICIkdXNlbXltYWxsb2MiIGluCicnKSB1c2VteW1hbGxvYz1uIDs7
  CmVzYWMKCiMgTmV0QlNEIDYgZGVmaW5lcyB0aGUgKmF0KCkgZnVuY3Rpb25zIGluIGxpYmMsIGJ1
  dCBlaXRoZXIgZG9lc24ndAojIGltcGxlbWVudCB0aGVtLCBvciBpbXBsZW1lbnRzIHRoZW0gb25s
  eSBmb3IgQVRfRkRDV0QKY2FzZSAiJG9zdmVyIiBpbgpbMS02XS4qKQogICAgICAgIGRfdW5saW5r
  YXQ9IiR1bmRlZiIKICAgICAgICBkX3JlbmFtZWF0PSIkdW5kZWYiCiAgICAgICAgZF9saW5rYXQ9
  IiR1bmRlZiIKICAgICAgICBkX2ZjaG1vZGF0PSIkdW5kZWYiCiAgICAgICAgOzsKZXNhYwo=',
  'openbsd' =>
  'IyBoaW50cy9vcGVuYnNkLnNoCiMKIyBoaW50cyBmaWxlIGZvciBPcGVuQlNEOyBUb2RkIE1pbGxl
  ciA8bWlsbGVydEBvcGVuYnNkLm9yZz4KIyBFZGl0ZWQgdG8gYWxsb3cgQ29uZmlndXJlIGNvbW1h
  bmQtbGluZSBvdmVycmlkZXMgYnkKIyAgQW5keSBEb3VnaGVydHkgPGRvdWdoZXJhQGxhZmF5ZXR0
  ZS5lZHU+CiMKIyBUbyBidWlsZCB3aXRoIGRpc3RyaWJ1dGlvbiBwYXRocywgdXNlOgojCS4vQ29u
  ZmlndXJlIC1kZXMgLURvcGVuYnNkX2Rpc3RyaWJ1dGlvbj1kZWZpbmVkCiMKCiMgT3BlbkJTRCBo
  YXMgYSBiZXR0ZXIgbWFsbG9jIHRoYW4gcGVybC4uLgp0ZXN0ICIkdXNlbXltYWxsb2MiIHx8IHVz
  ZW15bWFsbG9jPSduJwoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIg
  aW4KJycpIHVzZW1hbGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBDdXJyZW50bHksIHZmb3Jr
  KDIpIGlzIG5vdCBhIHJlYWwgd2luIG92ZXIgZm9yaygyKS4KdXNldmZvcms9IiR1bmRlZiIKCiMg
  SW4gT3BlbkJTRCA8IDMuMywgdGhlIHNldHJlP1t1Z11pZCgpIGFyZSBlbXVsYXRlZCB1c2luZyB0
  aGUKIyBfUE9TSVhfU0FWRURfSURTIGZ1bmN0aW9uYWxpdHkgd2hpY2ggZG9lcyBub3QgaGF2ZSB0
  aGUgc2FtZQojIHNlbWFudGljcyBhcyA0LjNCU0QuICBTdGFydGluZyB3aXRoIE9wZW5CU0QgMy4z
  LCB0aGUgb3JpZ2luYWwKIyBzZW1hbnRpY3MgaGF2ZSBiZWVuIHJlc3RvcmVkLgpjYXNlICIkb3N2
  ZXJzIiBpbgpbMC0yXS4qfDMuWzAtMl0pCglkX3NldHJlZ2lkPSR1bmRlZgoJZF9zZXRyZXVpZD0k
  dW5kZWYKCWRfc2V0cmdpZD0kdW5kZWYKCWRfc2V0cnVpZD0kdW5kZWYKZXNhYwoKIwojIE5vdCBh
  bGwgcGxhdGZvcm1zIHN1cHBvcnQgZHluYW1pYyBsb2FkaW5nLi4uCiMgRm9yIHRoZSBjYXNlIG9m
  ICIkb3BlbmJzZF9kaXN0cmlidXRpb24iLCB0aGUgaGludHMgZmlsZQojIG5lZWRzIHRvIGtub3cg
  d2hldGhlciB3ZSBhcmUgdXNpbmcgZHluYW1pYyBsb2FkaW5nIHNvIHRoYXQKIyBpdCBjYW4gc2V0
  IHRoZSBsaWJwZXJsIG5hbWUgYXBwcm9wcmlhdGVseS4KIyBBbGxvdyBjb21tYW5kIGxpbmUgb3Zl
  cnJpZGVzLgojCkFSQ0g9YGFyY2ggfCBzZWQgJ3MvXk9wZW5CU0QuLy8nYApjYXNlICIke0FSQ0h9
  LSR7b3N2ZXJzfSIgaW4KYWxwaGEtMi5bMC04XXxtaXBzLTIuWzAtOF18cG93ZXJwYy0yLlswLTdd
  fG04OGstWzItNF0uKnxtODhrLTUuWzAtMl18aHBwYS0zLlswLTVdfHZheC0qKQoJdGVzdCAteiAi
  JHVzZWRsIiAmJiB1c2VkbD0kdW5kZWYKCTs7CiopCgl0ZXN0IC16ICIkdXNlZGwiICYmIHVzZWRs
  PSRkZWZpbmUKCSMgV2UgdXNlIC1mUElDIGhlcmUgYmVjYXVzZSAtZnBpYyBpcyAqTk9UKiBlbm91
  Z2ggZm9yIHNvbWUgb2YgdGhlCgkjIGV4dGVuc2lvbnMgbGlrZSBUayBvbiBzb21lIE9wZW5CU0Qg
  cGxhdGZvcm1zIChpZTogc3BhcmMpCgljY2NkbGZsYWdzPSItRFBJQyAtZlBJQyAkY2NjZGxmbGFn
  cyIKCWNhc2UgIiRvc3ZlcnMiIGluCglbMDFdLip8Mi5bMC03XXwyLlswLTddLiopCgkJbGRkbGZs
  YWdzPSItQnNoYXJlYWJsZSAkbGRkbGZsYWdzIgoJCTs7CgkyLls4LTldfDMuMCkKCQlsZD0ke2Nj
  Oi1jY30KCQlsZGRsZmxhZ3M9Ii1zaGFyZWQgLWZQSUMgJGxkZGxmbGFncyIKCQk7OwoJKikgIyBm
  cm9tIDMuMSBvbndhcmRzCgkJbGQ9JHtjYzotY2N9CgkJbGRkbGZsYWdzPSItc2hhcmVkIC1mUElD
  ICRsZGRsZmxhZ3MiCgkJbGlic3dhbnRlZD1gZWNobyAkbGlic3dhbnRlZCB8IHNlZCAncy8gZGwg
  LyAvJ2AKCQk7OwoJZXNhYwoKCSMgV2UgbmVlZCB0byBmb3JjZSBsZCB0byBleHBvcnQgc3ltYm9s
  cyBvbiBFTEYgcGxhdGZvcm1zLgoJIyBXaXRob3V0IHRoaXMsIGRsb3BlbigpIGlzIGNyaXBwbGVk
  LgoJRUxGPWAke2NjOi1jY30gLWRNIC1FIC0gPC9kZXYvbnVsbCB8IGdyZXAgX19FTEZfX2AKCXRl
  c3QgLW4gIiRFTEYiICYmIGxkZmxhZ3M9Ii1XbCwtRSAkbGRmbGFncyIKCTs7CmVzYWMKCiMKIyBU
  d2Vha3MgZm9yIHZhcmlvdXMgdmVyc2lvbnMgb2YgT3BlbkJTRAojCmNhc2UgIiRvc3ZlcnMiIGlu
  CjIuNSkKCSMgT3BlbkJTRCAyLjUgaGFzIGJyb2tlbiBvZGJtIHN1cHBvcnQKCWlfZGJtPSR1bmRl
  ZgoJOzsKZXNhYwoKIyBPcGVuQlNEIGRvZXNuJ3QgbmVlZCBsaWJjcnlwdCBidXQgbWFueSBmb2xr
  cyBrZWVwIGEgc3R1YiBsaWIKIyBhcm91bmQgZm9yIG9sZCBOZXRCU0QgYmluYXJpZXMuCmxpYnN3
  YW50ZWQ9YGVjaG8gJGxpYnN3YW50ZWQgfCBzZWQgJ3MvIGNyeXB0IC8gLydgCgojIENvbmZpZ3Vy
  ZSBjYW4ndCBmaWd1cmUgdGhpcyBvdXQgbm9uLWludGVyYWN0aXZlbHkKZF9zdWlkc2FmZT0kZGVm
  aW5lCgojIGNjIGlzIGdjYyBzbyB3ZSBjYW4gZG8gYmV0dGVyIHRoYW4gLU8KIyBBbGxvdyBhIGNv
  bW1hbmQtbGluZSBvdmVycmlkZSwgc3VjaCBhcyAtRG9wdGltaXplPS1nCmNhc2UgIiR7QVJDSH0t
  JHtvc3ZlcnN9IiBpbgpocHBhLTMuM3xtODhrLTIuKnxtODhrLTMuWzAtM10pCiAgIHRlc3QgIiRv
  cHRpbWl6ZSIgfHwgb3B0aW1pemU9Jy1PMCcKICAgOzsKbTg4ay0zLjQpCiAgIHRlc3QgIiRvcHRp
  bWl6ZSIgfHwgb3B0aW1pemU9Jy1PMScKICAgOzsKKikKICAgdGVzdCAiJG9wdGltaXplIiB8fCBv
  cHRpbWl6ZT0nLU8yJwogICA7Owplc2FjCgojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1
  IHdpbGwgZ2V0ICdjYWxsZWQtYmFjaycgYnkgQ29uZmlndXJlIAojIGFmdGVyIGl0IGhhcyBwcm9t
  cHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgdGhyZWFkcy4KY2F0ID4gVVUvdXNldGhy
  ZWFkcy5jYnUgPDwnRU9DQlUnCmNhc2UgIiR1c2V0aHJlYWRzIiBpbgokZGVmaW5lfHRydWV8W3lZ
  XSopCgkjIGFueSBvcGVuYnNkIHZlcnNpb24gZGVwZW5kZW5jaWVzIHdpdGggcHRocmVhZHM/Cglj
  Y2ZsYWdzPSItcHRocmVhZCAkY2NmbGFncyIKCWxkZmxhZ3M9Ii1wdGhyZWFkICRsZGZsYWdzIgoJ
  Y2FzZSAiJG9zdmVycyIgaW4KCVswLTJdLip8My5bMC0yXSkKCQkjIENoYW5nZSBmcm9tIC1sYyB0
  byAtbGNfcgoJCXNldCBgZWNobyAiWCAkbGlic3dhbnRlZCAiIHwgc2VkICdzLyBjIC8gY19yIC8n
  YAoJCXNoaWZ0CgkJbGlic3dhbnRlZD0iJCoiCgk7OwoJZXNhYwoJY2FzZSAiJG9zdmVycyIgaW4K
  CVswMTJdLip8My5bMC02XSkKICAgICAgICAJIyBCcm9rZW4gdXAgdG8gT3BlbkJTRCAzLjYsIGZp
  eGVkIGluIE9wZW5CU0QgMy43CgkJZF9nZXRzZXJ2YnluYW1lX3I9JHVuZGVmIDs7Cgllc2FjCmVz
  YWMKRU9DQlUKCiMgV2hlbiBidWlsZGluZyBpbiB0aGUgT3BlbkJTRCB0cmVlIHdlIHVzZSBkaWZm
  ZXJlbnQgcGF0aHMKIyBUaGlzIGlzIG9ubHkgcGFydCBvZiB0aGUgc3RvcnksIHRoZSByZXN0IGNv
  bWVzIGZyb20gY29uZmlnLm92ZXIKY2FzZSAiJG9wZW5ic2RfZGlzdHJpYnV0aW9uIiBpbgonJ3wk
  dW5kZWZ8ZmFsc2UpIDs7CiopCgkjIFdlIHB1dCB0aGluZ3MgaW4gL3Vzciwgbm90IC91c3IvbG9j
  YWwKCXByZWZpeD0nL3VzcicKCXByZWZpeGV4cD0nL3VzcicKCXN5c21hbj0nL3Vzci9zaGFyZS9t
  YW4vbWFuMScKCWxpYnB0aD0nL3Vzci9saWInCglnbGlicHRoPScvdXNyL2xpYicKCSMgTG9jYWwg
  dGhpbmdzLCBob3dldmVyLCBkbyBnbyBpbiAvdXNyL2xvY2FsCglzaXRlcHJlZml4PScvdXNyL2xv
  Y2FsJwoJc2l0ZXByZWZpeGV4cD0nL3Vzci9sb2NhbCcKCSMgUG9ydHMgaW5zdGFsbHMgbm9uLXN0
  ZCBsaWJzIGluIC91c3IvbG9jYWwvbGliIHNvIGxvb2sgdGhlcmUgdG9vCglsb2NpbmNwdGg9Jy91
  c3IvbG9jYWwvaW5jbHVkZScKCWxvY2xpYnB0aD0nL3Vzci9sb2NhbC9saWInCgkjIExpbmsgcGVy
  bCB3aXRoIHNoYXJlZCBsaWJwZXJsCglpZiBbICIkdXNlZGwiID0gIiRkZWZpbmUiIC1hIC1yIHNo
  bGliX3ZlcnNpb24gXTsgdGhlbgoJCXVzZXNocnBsaWI9dHJ1ZQoJCWxpYnBlcmw9YC4gLi9zaGxp
  Yl92ZXJzaW9uOyBlY2hvIGxpYnBlcmwuc28uJHttYWpvcn0uJHttaW5vcn1gCglmaQoJOzsKZXNh
  YwoKIyBvcGVuYnNkIGhhcyBhIHByb2JsZW0gcmVnYXJkaW5nIG5ld2xvY2FsZSgpCiMgaHR0cHM6
  Ly9tYXJjLmluZm8vP2w9b3BlbmJzZC1idWdzJm09MTU1MzY0NTY4NjA4NzU5Jnc9MgojIHdoaWNo
  IGlzIGJlaW5nIGZpeGVkLiAgSW4gdGhlIG1lYW50aW1lLCBmb3JiaWQgUE9TSVggMjAwOCBsb2Nh
  bGVzCmRfbmV3bG9jYWxlPSIkdW5kZWYiCgojIGVuZAo=',
  'solaris' =>
  'IyBoaW50cy9zb2xhcmlzXzIuc2gKIyBDb250cmlidXRpb25zIGJ5IChpbiBhbHBoYWJldGljYWwg
  b3JkZXIpIEFsYW4gQnVybGlzb24sIEFuZHkgRG91Z2hlcnR5LAojIERlYW4gUm9laHJpY2gsIEph
  cmtrbyBIaWV0YW5pZW1pLCBMdXBlIENocmlzdG9waCwgUmljaGFyZCBTb2RlcmJlcmcgYW5kCiMg
  bWFueSBvdGhlcnMuCiMKIyBTZWUgUkVBRE1FLnNvbGFyaXMgZm9yIGFkZGl0aW9uYWwgaW5mb3Jt
  YXRpb24uCiMKIyBGb3IgY29uc2lzdGVuY3kgd2l0aCBnY2MsIHdlIGRvIG5vdCBhZG9wdCBTdW4g
  TWFya2V0aW5nJ3MKIyByZW1vdmFsIG9mIHRoZSAnMi4nIHByZWZpeCBmcm9tIHRoZSBTb2xhcmlz
  IHZlcnNpb24gbnVtYmVyLgojIChDb25maWd1cmUgdHJpZXMgdG8gZGV0ZWN0IGFuIG9sZCBmaXhp
  bmNsdWRlcyBhbmQgbmVlZHMKIyB0aGlzIGluZm9ybWF0aW9uLikKCiMgSWYgcGVybCBmYWlscyB0
  ZXN0cyB0aGF0IGludm9sdmUgZHluYW1pYyBsb2FkaW5nIG9mIGV4dGVuc2lvbnMsIGFuZAojIHlv
  dSBhcmUgdXNpbmcgZ2NjLCBiZSBzdXJlIHRoYXQgeW91IGFyZSBOT1QgdXNpbmcgR05VIGFzIGFu
  ZCBsZC4gIE9uZQojIHdheSB0byBkbyB0aGF0IGlzIHRvIGludm9rZSBDb25maWd1cmUgd2l0aAoj
  CiMgICAgIHNoIENvbmZpZ3VyZSAtRGNjPSdnY2MgLUIvdXNyL2Njcy9iaW4vJwojCiMgIChOb3Rl
  IHRoYXQgdGhlIHRyYWlsaW5nIHNsYXNoIGlzICpyZXF1aXJlZCouKQojICBnY2Mgd2lsbCBvY2Nh
  c2lvbmFsbHkgZW1pdCB3YXJuaW5ncyBhYm91dCAidW51c2VkIHByZWZpeCIsIGJ1dAojICB0aGVz
  ZSBvdWdodCB0byBiZSBoYXJtbGVzcy4gIFNlZSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLgoKIyBT
  b2xhcmlzIGhhcyBzZWN1cmUgU1VJRCBzY3JpcHRzCmRfc3VpZHNhZmU9JHtkX3N1aWRzYWZlOi1k
  ZWZpbmV9CgojIEJlIHBhcmFub2lkIGFib3V0IG5tIGZhaWxpbmcgdG8gZmluZCBzeW1ib2xzCm1p
  c3RydXN0bm09JHttaXN0cnVzdG5tOi1ydW59CgojIFNldmVyYWwgcGVvcGxlIHJlcG9ydGVkIHBy
  b2JsZW1zIHdpdGggcGVybCdzIG1hbGxvYywgZXNwZWNpYWxseQojIHdoZW4gdXNlNjRiaXRhbGwg
  aXMgZGVmaW5lZCBvciB3aGVuIHVzaW5nIGdjYy4KIyAgICAgaHR0cDovL3d3dy54cmF5Lm1wZS5t
  cGcuZGUvbWFpbGluZy1saXN0cy9wZXJsNS1wb3J0ZXJzLzIwMDEtMDEvbXNnMDEzMTguaHRtbAoj
  ICAgICBodHRwOi8vd3d3LnhyYXkubXBlLm1wZy5kZS9tYWlsaW5nLWxpc3RzL3Blcmw1LXBvcnRl
  cnMvMjAwMS0wMS9tc2cwMDQ2NS5odG1sCnVzZW15bWFsbG9jPSR7dXNlbXltYWxsb2M6LWZhbHNl
  fQoKIyBtYWxsb2Mgd3JhcCB3b3JrcwpjYXNlICIkdXNlbWFsbG9jd3JhcCIgaW4KJycpIHVzZW1h
  bGxvY3dyYXA9J2RlZmluZScgOzsKZXNhYwoKIyBBdm9pZCBhbGwgbGlicmFyaWVzIGluIC91c3Iv
  dWNibGliLgojIC9saWIgaXMganVzdCBhIHN5bWxpbmsgdG8gL3Vzci9saWIKc2V0IGBlY2hvICRn
  bGlicHRoIHwgc2VkIC1lICdzQC91c3IvdWNibGliQEAnIC1lICdzQCAvbGliIEAgQCdgCmdsaWJw
  dGg9IiQqIgoKIyBTdGFydGluZyB3aXRoIFNvbGFyaXMgMTAsIHdlIGRvbid0IHdhbnQgdmVyc2lv
  bmVkIHNoYXJlZCBsaWJyYXJpZXMgYmVjYXVzZQojIHRob3NlIG9mdGVuIGluZGljYXRlIGEgcHJp
  dmF0ZSB1c2Ugb25seSBsaWJyYXJ5LiAgRXNwZWNpYWxseSBiYWRseSB0aGF0IHdvdWxkCiMgYnJl
  YWsgdGhpbmdzIHdpdGggU1VOV2JkYiAoQmVya2VsZXkgREIpIGJlaW5nIGluc3RhbGxlZCwgd2hp
  Y2ggYnJpbmdzIGluCiMgL3Vzci9saWIvbGliZGIuc28uMSwgYnV0IHRoYXQgaXMgbm90IHJlYWxs
  eSBtZWFudCBmb3IgcHVibGljIGNvbnN1bXB0aW9uLgojICBYWFggUmV2aXNpdCBhZnRlciBwZXJs
  IDUuMTAgLS0gc2hvdWxkIHdlIGFwcGx5IHRoaXMgdG8gb2xkZXIgU29sYXJpcwojIHZlcnNpb25z
  IHRvbz8gIChBLkQuIDExLzIwMDcpLgpjYXNlICJgJHJ1biB1bmFtZSAtcmAiIGluCjUuWzAtOV0p
  IDs7CiopIGlnbm9yZV92ZXJzaW9uZWRfc29saWJzPXkgOzsKZXNhYwoKIyBSZW1vdmUgdW53YW50
  ZWQgbGlicmFyaWVzLiAgLWx1Y2IgY29udGFpbnMgaW5jb21wYXRpYmxlIHJvdXRpbmVzLgojIC1s
  bGQgYW5kIC1sc2VjIGRvbid0IGRvIGFueXRoaW5nIHVzZWZ1bC4gLWxjcnlwdCBkb2VzIG5vdAoj
  IHJlYWxseSBwcm92aWRlIGFueXRoaW5nIHdlIG5lZWQgb3ZlciAtbGMsIHNvIHdlIGRyb3AgaXQs
  IHRvby4KIyAtbG1hbGxvYyBjYW4gY2F1c2UgYSBwcm9ibGVtIHdpdGggR05VIENDICYgU29sYXJp
  cy4gIFNwZWNpZmljYWxseSwKIyBsaWJtYWxsb2MuYSBtYXkgYWxsb2NhdGUgbWVtb3J5IHRoYXQg
  aXMgb25seSA0IGJ5dGUgYWxpZ25lZCwgYnV0CiMgR05VIENDIG9uIHRoZSBTcGFyYyBhc3N1bWVz
  IHRoYXQgZG91YmxlcyBhcmUgOCBieXRlIGFsaWduZWQuCiMgVGhhbmtzIHRvICBIYWxsdmFyZCBC
  LiBGdXJ1c2V0aCA8aC5iLmZ1cnVzZXRoQHVzaXQudWlvLm5vPgpzZXQgYGVjaG8gIiAkbGlic3dh
  bnRlZCAiIHwgc2VkIC1lICdzQCBsZCBAIEAnIC1lICdzQCBtYWxsb2MgQCBAJyAtZSAnc0AgdWNi
  IEAgQCcgLWUgJ3NAIHNlYyBAIEAnIC1lICdzQCBjcnlwdCBAIEAnYApsaWJzd2FudGVkPSIkKiIK
  CiMgTG9vayBmb3IgYXJjaGl0ZWN0dXJlIG5hbWUuICBXZSB3YW50IHRvIHN1Z2dlc3QgYSB1c2Vm
  dWwgZGVmYXVsdC4KY2FzZSAiJGFyY2huYW1lIiBpbgonJykKICAgIGlmIHRlc3QgLWYgL3Vzci9i
  aW4vYXJjaDsgdGhlbgoJYXJjaG5hbWU9YC91c3IvYmluL2FyY2hgCglhcmNobmFtZT0iJHthcmNo
  bmFtZX0tJHtvc25hbWV9IgogICAgZWxpZiB0ZXN0IC1mIC91c3IvdWNiL2FyY2g7IHRoZW4KCWFy
  Y2huYW1lPWAvdXNyL3VjYi9hcmNoYAoJYXJjaG5hbWU9IiR7YXJjaG5hbWV9LSR7b3NuYW1lfSIK
  ICAgIGZpCiAgICA7Owplc2FjCgojCiMgVGhpcyBleHRyYWN0cyB0aGUgbGlicmFyeSBkaXJlY3Rv
  cmllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQgYnkgdGhlIFN1bgojIFdvcmtzaG9wIGNvbXBpbGVy
  LCBnaXZlbiB0aGUgY29tbWFuZC1saW5lIHN1cHBsaWVkIGluICR0cnl3b3Jrc2hvcGNjLgojIFVz
  ZSB0aHVzbHk6IGxvY2xpYnB0aD0iYCRnZXR3b3Jrc2hvcGxpYnNgICRsb2NsaWJwdGgiCiMKCWdl
  dHdvcmtzaG9wbGlicz1gY2F0IDw8J0VORCcKZXZhbCAkdHJ5d29ya3Nob3BjYyAtIyMjIDI+JjEg
  fCBcCnNlZCAtbiAnLyAtWSAvcyEuKiAtWSAiUCxcKFteIl0qXCkiLiohXDEhcCcgfCB0ciAnOicg
  JyAnIHwgXApzZWQgLWUgJ3MhL3Vzci9saWIvc3BhcmN2OSEhJyAtZSAncyEvdXNyL2Njcy9saWIv
  c3BhcmN2OSEhJyBcCiAgICAtZSAncyEvdXNyL2xpYiEhZycgLWUgJ3MhL3Vzci9jY3MvbGliISFn
  JwpFTkQKYAoKY2FzZSAiJGNjIiBpbgonJykgICAgZm9yIGkgaW4gYGxzIC1yIC9vcHQvc29sKnN0
  dWRpbyovYmluL2NjYCAvb3B0L1NVTldzcHJvL2Jpbi9jYwogICAgICAgZG8KCSAgICAgICBpZiB0
  ZXN0IC1mICIkaSI7IHRoZW4KCQkgICAgICAgY2M9JGkKCQkgICAgICAgY2F0IDw8RU9GID4mNAoK
  WW91IHNwZWNpZmllZCBubyBjYyBidXQgeW91IHNlZW0gdG8gaGF2ZSB0aGUgV29ya3Nob3AgY29t
  cGlsZXIKKCRjYykgaW5zdGFsbGVkLCB1c2luZyB0aGF0LgpJZiB5b3Ugd2FudCBzb21ldGhpbmcg
  ZWxzZSwgc3BlY2lmeSB0aGF0IGluIHRoZSBjb21tYW5kIGxpbmUsCmUuZy4gQ29uZmlndXJlIC1E
  Y2M9Z2NjCgpFT0YKCQkJYnJlYWsKCQlmaQoJZG9uZQoJOzsKZXNhYwoKIyMjIyMjIyMjIyMjIyMj
  IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR2VuZXJhbCBzYW5pdHkg
  dGVzdGluZy4gIFNlZSBiZWxvdyBmb3IgZXhjZXJwdHMgZnJvbSB0aGUgU29sYXJpcyBGQVEuCiMK
  IyBGcm9tIHJvZWhyaWNoQGlyb253b29kLWZkZGkuY3JheS5jb20gV2VkIFNlcCAyNyAxMjo1MTo0
  NiAxOTk1CiMgRGF0ZTogVGh1LCA3IFNlcCAxOTk1IDE2OjMxOjQwIC0wNTAwCiMgRnJvbTogRGVh
  biBSb2VocmljaCA8cm9laHJpY2hAaXJvbndvb2QtZmRkaS5jcmF5LmNvbT4KIyBUbzogcGVybDUt
  cG9ydGVyc0BhZnJpY2Eubmljb2guY29tCiMgU3ViamVjdDogUmU6IE9uIHBlcmw1L3NvbGFyaXMv
  Z2NjCiMKIyBIZXJlJ3MgYW5vdGhlciBkcmFmdCBvZiB0aGUgcGVybDUvc29sYXJpcy9nY2Mgc2Fu
  aXR5LWNoZWNrZXIuCgpjYXNlIGB0eXBlICR7Y2M6LWNjfWAgaW4KKi91c3IvdWNiL2NjKikgY2F0
  IDw8RU5EID4mNAoKTk9URTogIFNvbWUgcGVvcGxlIGhhdmUgcmVwb3J0ZWQgcHJvYmxlbXMgd2l0
  aCAvdXNyL3VjYi9jYy4KSWYgeW91IGhhdmUgZGlmZmljdWx0aWVzLCBwbGVhc2UgbWFrZSBzdXJl
  IHRoZSBkaXJlY3RvcnkKY29udGFpbmluZyB5b3VyIEMgY29tcGlsZXIgaXMgYmVmb3JlIC91c3Iv
  dWNiIGluIHlvdXIgUEFUSC4KCkVORAo7Owplc2FjCgoKIyBDaGVjayB0aGF0IC9kZXYvZmQgaXMg
  bW91bnRlZC4gIElmIGl0IGlzIG5vdCBtb3VudGVkLCBsZXQgdGhlCiMgdXNlciBrbm93IHRoYXQg
  c3VpZCBzY3JpcHRzIG1heSBub3Qgd29yay4KJHJ1biBtb3VudCB8IGdyZXAgJ14vZGV2L2ZkICcg
  Mj4mMSA+IC9kZXYvbnVsbApjYXNlICQ/IGluCjApIDs7CiopCgljYXQgPDxFTkQgPiY0CgpOT1RF
  OiBZb3VyIHN5c3RlbSBkb2VzIG5vdCBoYXZlIC9kZXYvZmQgbW91bnRlZC4gIElmIHlvdSB3YW50
  IHRvCmJlIGFibGUgdG8gdXNlIHNldC11aWQgc2NyaXB0cyB5b3UgbXVzdCBhc2sgeW91ciBzeXN0
  ZW0gYWRtaW5pc3RyYXRvcgp0byBtb3VudCAvZGV2L2ZkLgoKRU5ECgk7Owplc2FjCgoKIyBTZWUg
  aWYgbGlidWNiIGNhbiBiZSBmb3VuZCBpbiAvdXNyL2xpYi4gIElmIGl0IGlzLCB3YXJuIHRoZSB1
  c2VyCiMgdGhhdCB0aGlzIG1heSBjYXVzZSBwcm9ibGVtcyB3aGlsZSBidWlsZGluZyBQZXJsIGV4
  dGVuc2lvbnMuCmZvdW5kX2xpYnVjYj0nJwpjYXNlICIkcnVuIiBpbgonJykgL3Vzci9iaW4vbHMg
  L3Vzci9saWIvbGlidWNiKiA+L2Rldi9udWxsIDI+JjEKICAgIGZvdW5kX2xpYnVjYj0kPwogICAg
  OzsKKikgICRydW4gL3Vzci9iaW4vbHMgJy91c3IvbGliL2xpYnVjYionID4vZGV2L251bGwgMj4m
  MQogICAgZm91bmRfbGlidWNiPSQ/CiAgICA7Owplc2FjCgpjYXNlICRmb3VuZF9saWJ1Y2IgaW4K
  MCkKCWNhdCA8PEVORCA+JjQKCk5PVEU6IGxpYnVjYiBoYXMgYmVlbiBmb3VuZCBpbiAvdXNyL2xp
  Yi4gIGxpYnVjYiBzaG91bGQgcmVzaWRlIGluCi91c3IvdWNibGliLiAgWW91IG1heSBoYXZlIHRy
  b3VibGUgd2hpbGUgYnVpbGRpbmcgUGVybCBleHRlbnNpb25zLgoKRU5ECjs7CmVzYWMKCiMgVXNl
  IHNoZWxsIGJ1aWx0LWluICd0eXBlJyBjb21tYW5kIGluc3RlYWQgb2YgL3Vzci9iaW4vd2hpY2gg
  dG8KIyBhdm9pZCBwb3NzaWJsZSBjc2ggc3RhcnQtdXAgcHJvYmxlbXMgYW5kIGFsc28gdG8gdXNl
  IHRoZSBzYW1lIHNoZWxsCiMgd2UnbGwgYmUgdXNpbmcgdG8gQ29uZmlndXJlIGFuZCBtYWtlIHBl
  cmwuCiMgVGhlIHBhdGggbmFtZSBpcyB0aGUgbGFzdCBmaWVsZCBpbiB0aGUgb3V0cHV0LCBidXQg
  dGhlIHR5cGUgY29tbWFuZAojIGhhcyBhbiBhbm5veWluZyBhcnJheSBvZiBwb3NzaWJsZSBvdXRw
  dXRzLCBlLmcuOgojCW1ha2UgaXMgaGFzaGVkICgvb3B0L2dudS9iaW4vbWFrZSkKIwljYyBpcyAv
  dXNyL3VjYi9jYwojCWZvbyBub3QgZm91bmQKIyB1c2UgYSBjb21tYW5kIGxpa2UgdHlwZSBtYWtl
  IHwgYXdrICd7cHJpbnQgJE5GfScgfCBzZWQgJ3MvWygpXS8vZycKCiMgU2VlIGlmIG1ha2UoMSkg
  aXMgR05VIG1ha2UoMSkuCiMgSWYgaXQgaXMsIG1ha2Ugc3VyZSB0aGUgc2V0Z2lkIGJpdCBpcyBu
  b3Qgc2V0LgptYWtlIC12ID4gbWFrZS52ZXJzIDI+JjEKaWYgZ3JlcCBHTlUgbWFrZS52ZXJzID4g
  L2Rldi9udWxsIDI+JjE7IHRoZW4KICAgIHRtcD1gdHlwZSBtYWtlIHwgYXdrICd7cHJpbnQgJE5G
  fScgfCBzZWQgJ3MvWygpXS8vZydgCiAgICBjYXNlICJgJHtsczotJy91c3IvYmluL2xzJ30gLWxM
  ICR0bXBgIiBpbgogICAgPz8/Pz8/cyopCgkgICAgY2F0IDw8RU5EID4mMgoKTk9URTogWW91ciBQ
  QVRIIHBvaW50cyB0byBHTlUgbWFrZSwgYW5kIHlvdXIgR05VIG1ha2UgaGFzIHRoZSBzZXQtZ3Jv
  dXAtaWQKYml0IHNldC4gIFlvdSBtdXN0IGVpdGhlciByZWFycmFuZ2UgeW91ciBQQVRIIHRvIHB1
  dCAvdXNyL2Njcy9iaW4gYmVmb3JlIHRoZQpHTlUgdXRpbGl0aWVzIG9yIHlvdSBtdXN0IGFzayB5
  b3VyIHN5c3RlbSBhZG1pbmlzdHJhdG9yIHRvIGRpc2FibGUgdGhlCnNldC1ncm91cC1pZCBiaXQg
  b24gR05VIG1ha2UuCgpFTkQKCSAgICA7OwogICAgZXNhYwpmaQpybSAtZiBtYWtlLnZlcnMKCmNh
  dCA+IFVVL2NjLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS9jYy5jYnUgd2lsbCBnZXQg
  J2NhbGxlZC1iYWNrJyBieSBDb25maWd1cmUgYWZ0ZXIgaXQKIyBoYXMgcHJvbXB0ZWQgdGhlIHVz
  ZXIgZm9yIHRoZSBDIGNvbXBpbGVyIHRvIHVzZS4KCiMgSWYgdGhlIEMgY29tcGlsZXIgaXMgZ2Nj
  OgojICAgLSBjaGVjayB0aGUgZml4ZWQtaW5jbHVkZXMKIyAgIC0gY2hlY2sgYXMoMSkgYW5kIGxk
  KDEpLCB0aGV5IHNob3VsZCBub3QgYmUgR05VCiMJKEdOVSBhcyBhbmQgbGQgMi44LjEgYW5kIGxh
  dGVyIGFyZSByZXBvcnRlZGx5IG9rLCBob3dldmVyLikKIyBJZiB0aGUgQyBjb21waWxlciBpcyBu
  b3QgZ2NjOgojICAgLSBDaGVjayBpZiBpdCBpcyB0aGUgV29ya3Nob3AvRm9ydGUgY29tcGlsZXIu
  CiMgICAgIElmIGl0IGlzLCBwcmVwYXJlIGZvciA2NCBiaXQgYW5kIGxvbmcgZG91Ymxlcy4KIyAg
  IC0gY2hlY2sgYXMoMSkgYW5kIGxkKDEpLCB0aGV5IHNob3VsZCBub3QgYmUgR05VCiMJKEdOVSBh
  cyBhbmQgbGQgMi44LjEgYW5kIGxhdGVyIGFyZSByZXBvcnRlZGx5IG9rLCBob3dldmVyLikKIwoj
  IFdhdGNoIG91dCBpbiBjYXNlIHRoZXkgaGF2ZSBub3Qgc2V0ICRjYy4KCiMgUGVybCBjb21waWxl
  ZCB3aXRoIHNvbWUgY29tYmluYXRpb25zIG9mIEdOVSBhcyBhbmQgbGQgbWF5IG5vdAojIGJlIGFi
  bGUgdG8gcGVyZm9ybSBkeW5hbWljIGxvYWRpbmcgb2YgZXh0ZW5zaW9ucy4gIElmIHlvdSBoYXZl
  IGEKIyBwcm9ibGVtIHdpdGggZHluYW1pYyBsb2FkaW5nLCBiZSBzdXJlIHRoYXQgeW91IGFyZSB1
  c2luZyB0aGUgU29sYXJpcwojIC91c3IvY2NzL2Jpbi9hcyBhbmQgL3Vzci9jY3MvYmluL2xkLiAg
  WW91IGNhbiBkbyB0aGF0IHdpdGgKIwlzaCBDb25maWd1cmUgLURjYz0nZ2NjIC1CL3Vzci9jY3Mv
  YmluLycKIyAobm90ZSB0aGUgdHJhaWxpbmcgc2xhc2ggaXMgcmVxdWlyZWQpLgojIENvbWJpbmF0
  aW9ucyB0aGF0IGFyZSBrbm93biB0byB3b3JrIHdpdGggdGhlIGZvbGxvd2luZyBoaW50czoKIwoj
  ICBnY2MtMi43LjIsIEdOVSBhcyAyLjcsIEdOVSBsZCAyLjcKIyAgZWdjcy0xLjAuMywgR05VIGFz
  IDIuOS4xIGFuZCBHTlUgbGQgMi45LjEKIwktLUFuZHkgRG91Z2hlcnR5ICA8ZG91Z2hlcmFAbGFm
  YXlldHRlLmVkdT4KIwlUdWUgQXByIDEzIDE3OjE5OjQzIEVEVCAxOTk5CgojIEdldCBnY2MgdG8g
  c2hhcmUgaXRzIHNlY3JldHMuCmVjaG8gJ2ludCBtYWluKCkgeyByZXR1cm4gMDsgfScgPiB0cnku
  YwoJIyBJbmRlbnQgdG8gYXZvaWQgcHJvcGFnYXRpb24gdG8gY29uZmlnLnNoCgl2ZXJib3NlPWAk
  e2NjOi1jY30gJGNjZmxhZ3MgLXYgLW8gdHJ5IHRyeS5jIDI+JjFgCgojIFhYWCBUT0RPOiAgJ3Nw
  ZWNzJyBvdXRwdXQgY2hhbmdlZCBmcm9tICdSZWFkaW5nIHNwZWNzIGZyb20nIGluIGdjYy1bMjNd
  IHRvICdVc2luZwojIGJ1aWx0LWluIHNwZWNzJyBpbiBnY2MtNC4gIFBlcmhhcHMgd2Ugc2hvdWxk
  IGp1c3QgdXNlIHRoZSBzYW1lIGdjYyB0ZXN0IGFzCiMgaW4gQ29uZmlndXJlIHRvIHNlZSBpZiB3
  ZSdyZSB1c2luZyBnY2MuCmlmIGVjaG8gIiR2ZXJib3NlIiB8IGVncmVwICcoUmVhZGluZyBzcGVj
  cyBmcm9tKXwoVXNpbmcgYnVpbHQtaW4gc3BlY3MpJyA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCSMK
  CSMgVXNpbmcgZ2NjLgoJIwoJY2NfbmFtZT0nZ2NjJwoKCSMgU2VlIGlmIGFzKDEpIGlzIEdOVSBh
  cygxKS4gIEdOVSBhcygxKSBtaWdodCBub3Qgd29yayBmb3IgdGhpcyBqb2IuCglpZiBlY2hvICIk
  dmVyYm9zZSIgfCBncmVwICcgL3Vzci9jY3MvYmluL2FzICcgPi9kZXYvbnVsbCAyPiYxOyB0aGVu
  CgkgICAgOgoJZWxzZQoJICAgIGNhdCA8PEVORCA+JjIKCk5PVEU6IFlvdSBhcmUgdXNpbmcgR05V
  IGFzKDEpLiAgR05VIGFzKDEpIG1pZ2h0IG5vdCBidWlsZCBQZXJsLiAgSWYgeW91CmhhdmUgdHJv
  dWJsZSwgeW91IGNhbiB1c2UgL3Vzci9jY3MvYmluL2FzIGJ5IGluY2x1ZGluZyAtQi91c3IvY2Nz
  L2Jpbi8KaW4geW91ciAke2NjOi1jY30gY29tbWFuZC4gIChOb3RlIHRoYXQgdGhlIHRyYWlsaW5n
  ICIvIiBpcyByZXF1aXJlZC4pCgpFTkQKCSAgICAjIEFwcGFyZW50bHkgbm90IG5lZWRlZCwgYXQg
  bGVhc3QgZm9yIGFzIDIuNyBhbmQgbGF0ZXIuCgkgICAgIyBjYz0iJHtjYzotY2N9ICRjY2ZsYWdz
  IC1CL3Vzci9jY3MvYmluLyIKCWZpCgoJIyBTZWUgaWYgbGQoMSkgaXMgR05VIGxkKDEpLiAgR05V
  IGxkKDEpIG1pZ2h0IG5vdCB3b3JrIGZvciB0aGlzIGpvYi4KCSMgUmVjb21wdXRlICR2ZXJib3Nl
  IHNpbmNlIHdlIG1heSBoYXZlIGp1c3QgY2hhbmdlZCAkY2MuCgl2ZXJib3NlPWAke2NjOi1jY30g
  JGNjZmxhZ3MgLXYgLW8gdHJ5IHRyeS5jIDI+JjEgfCBncmVwIGxkIDI+JjFgCgoJaWYgZWNobyAi
  JHZlcmJvc2UiIHwgZ3JlcCAnIC91c3IvY2NzL2Jpbi9sZCAnID4vZGV2L251bGwgMj4mMTsgdGhl
  bgoJICAgICMgT2ssIGdjYyBkaXJlY3RseSBjYWxscyB0aGUgU29sYXJpcyAvdXNyL2Njcy9iaW4v
  bGQuCgkgICAgOgoJZWxpZiBlY2hvICIkdmVyYm9zZSIgfCBncmVwICJsZDogU29mdHdhcmUgR2Vu
  ZXJhdGlvbiBVdGlsaXRpZXMiID4vZGV2L251bGwgMj4mMTsgdGhlbgoJICAgICMgSG1tLiAgZ2Nj
  IGRvZXNuJ3QgY2FsbCAvdXNyL2Njcy9iaW4vbGQgZGlyZWN0bHksIGJ1dCBpdAoJICAgICMgZG9l
  cyBhcHBlYXIgdG8gYmUgdXNpbmcgaXQgZXZlbnR1YWxseS4gIGVnY3MtMS4wLjMncyBsZAoJICAg
  ICMgd3JhcHBlciBkb2VzIHRoaXMuCgkgICAgIyBNb3N0IFNvbGFyaXMgdmVyc2lvbnMgb2YgbGQg
  SSd2ZSBzZWVuIGNvbnRhaW4gdGhlIG1hZ2ljCgkgICAgIyBzdHJpbmcgdXNlZCBpbiB0aGUgZ3Jl
  cC4KCSAgICA6CgllbGlmIGVjaG8gIiR2ZXJib3NlIiB8IGdyZXAgIlNvbGFyaXMgTGluayBFZGl0
  b3JzIiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCSAgICAjIEhvd2V2ZXIgc29tZSBTb2xhcmlzIDgg
  dmVyc2lvbnMgcHJpb3IgdG8gbGQgNS44LTEuMjg2IGNvbnRhaW4KCSAgICAjIHRoaXMgc3RyaW5n
  IGluc3RlYWQuCgkgICAgOgoJZWxzZQoJICAgICMgTm8gZXZpZGVuY2UgeWV0IG9mIC91c3IvY2Nz
  L2Jpbi9sZC4gIFNvbWUgdmVyc2lvbnMKCSAgICAjIG9mIGVnY3MncyBsZCB3cmFwcGVyIGNhbGwg
  L3Vzci9jY3MvYmluL2xkIGluIHR1cm4gYnV0CgkgICAgIyBhcHBhcmVudGx5IGRvbid0IHJldmVh
  bCB0aGF0IHVubGVzcyB5b3UgcGFzcyBpbiAtVi4KCSAgICAjIChUaGlzIG1heSBhbGwgZGVwZW5k
  IG9uIGxvY2FsIGNvbmZpZ3VyYXRpb25zIHRvby4pCgoJICAgICMgUmVjb21wdXRlIHZlcmJvc2Ug
  d2l0aCAtV2wsLXYgdG8gZmluZCBHTlUgbGQgaWYgcHJlc2VudAoJICAgIHZlcmJvc2U9YCR7Y2M6
  LWNjfSAkY2NmbGFncyAtV2wsLXYgLW8gdHJ5IHRyeS5jIDI+JjEgfCBncmVwIC9sZCAyPiYxYAoK
  CSAgICBteWxkPWBlY2hvICR2ZXJib3NlIHwgYXdrICcvXC9sZC8ge3ByaW50ICQxfSdgCgkgICAg
  IyBUaGlzIGFzc3VtZXMgdGhhdCBnY2MncyBvdXRwdXQgd2lsbCBub3QgY2hhbmdlLCBhbmQgdGhh
  dAoJICAgICMgL2Z1bGwvcGF0aC90by9sZCB3aWxsIGJlIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBv
  dXRwdXQuCgkgICAgIyBUaHVzIG15bGQgaXMgc29tZXRoaW5nIGxpa2UgL29wdC9nbnUvc3BhcmMt
  c3VuLXNvbGFyaXMyLjUvYmluL2xkCgoJICAgICMgQWxsb3cgdGhhdCAkbXlsZCBtYXkgYmUgJycs
  IGR1ZSB0byBjaGFuZ2VzIGluIGdjYydzIG91dHB1dAoJICAgIGlmICR7bXlsZDotbGR9IC1WIDI+
  JjEgfAoJCWdyZXAgImxkOiBTb2Z0d2FyZSBHZW5lcmF0aW9uIFV0aWxpdGllcyIgPi9kZXYvbnVs
  bCAyPiYxOyB0aGVuCgkJIyBPaywgL3Vzci9jY3MvYmluL2xkIGV2ZW50dWFsbHkgZG9lcyBnZXQg
  Y2FsbGVkLgoJCToKCSAgICBlbGlmICR7bXlsZDotbGR9IC1WIDI+JjEgfAoJCWdyZXAgIlNvbGFy
  aXMgTGluayBFZGl0b3JzIiA+L2Rldi9udWxsIDI+JjE7IHRoZW4KCQkjIE9rLCAvdXNyL2Njcy9i
  aW4vbGQgZXZlbnR1YWxseSBkb2VzIGdldCBjYWxsZWQuCgkJOgoJICAgIGVsc2UKCQllY2hvICJG
  b3VuZCBHTlUgbGQ9JyRteWxkJyIgPiY0CgkJY2F0IDw8RU5EID4mMgoKTk9URTogWW91IGFyZSB1
  c2luZyBHTlUgbGQoMSkuICBHTlUgbGQoMSkgbWlnaHQgbm90IGJ1aWxkIFBlcmwuICBJZiB5b3UK
  aGF2ZSB0cm91YmxlLCB5b3UgY2FuIHVzZSAvdXNyL2Njcy9iaW4vbGQgYnkgaW5jbHVkaW5nIC1C
  L3Vzci9jY3MvYmluLwppbiB5b3VyICR7Y2M6LWNjfSBjb21tYW5kLiAgKE5vdGUgdGhhdCB0aGUg
  dHJhaWxpbmcgIi8iIGlzIHJlcXVpcmVkLikKCkkgd2lsbCB0cnkgdG8gdXNlIEdOVSBsZCBieSBw
  YXNzaW5nIGluIHRoZSAtV2wsLUUgZmxhZywgYnV0IGlmIHRoYXQKZG9lc24ndCB3b3JrLCB5b3Ug
  c2hvdWxkIHVzZSAtQi91c3IvY2NzL2Jpbi8gaW5zdGVhZC4KCkVORAoJCWNjZGxmbGFncz0iJGNj
  ZGxmbGFncyAtV2wsLUUiCgkJbGRkbGZsYWdzPSIkbGRkbGZsYWdzIC1XbCwtRSAtc2hhcmVkIgoJ
  ICAgIGZpCglmaQoKZWxzZQoJIwoJIyBOb3QgdXNpbmcgZ2NjLgoJIwoJY2F0ID4gdHJ5LmMgPDwg
  J0VPTScKI2luY2x1ZGUgPHN0ZGlvLmg+CmludCBtYWluKCkgewojaWYgZGVmaW5lZChfX1NVTlBS
  T19DKQoJcHJpbnRmKCJ3b3Jrc2hvcFxuIik7CiNlbHNlCiNpZiBkZWZpbmVkKF9fU1VOUFJPX0ND
  KQoJcHJpbnRmKCJ3b3Jrc2hvcCBDQ1xuIik7CiNlbHNlCglwcmludGYoIlxuIik7CiNlbmRpZgoj
  ZW5kaWYKcmV0dXJuKDApOwp9CkVPTQoJdHJ5d29ya3Nob3BjYz0iJHtjYzotY2N9ICRjY2ZsYWdz
  IHRyeS5jIC1vIHRyeSIKCWlmICR0cnl3b3Jrc2hvcGNjID4vZGV2L251bGwgMj4mMTsgdGhlbgoJ
  CWNjX25hbWU9YCRydW4gLi90cnlgCgkJaWYgdGVzdCAiJGNjX25hbWUiID0gIndvcmtzaG9wIjsg
  dGhlbgoJCQljY3ZlcnNpb249ImAke2NjOi1jY30gLVYgMj4mMXxzZWQgLW4gLWUgJzFzL15bQ2Nd
  W0NjOV05KjogLy9wJ2AiCgkJZmkKCQlpZiB0ZXN0ICIkY2NfbmFtZSIgPSAid29ya3Nob3AgQ0Mi
  OyB0aGVuCgkJCWNjdmVyc2lvbj0iYCR7Y2M6LUNDfSAtViAyPiYxfHNlZCAtbiAtZSAnMXMvXltD
  Y11bQ106IC8vcCdgIgoJCWZpCgkJY2FzZSAiJGNjX25hbWUiIGluCgkJd29ya3Nob3AqKQoJCQkj
  IFNldHRpbmdzIGZvciBlaXRoZXIgY2Mgb3IgQ0MKCQkJaWYgdGVzdCAhICIkdXNlNjRiaXRhbGxf
  ZG9uZSI7IHRoZW4KCQkJCWxvY2xpYnB0aD0iL3Vzci9saWIgL3Vzci9jY3MvbGliIGAkZ2V0d29y
  a3Nob3BsaWJzYCAkbG9jbGlicHRoIgoJCQlmaQoJCQkjIFN1biBDQy9jYyBkb24ndCBzdXBwb3J0
  IGdjYyBhdHRyaWJ1dGVzCgkJCWRfYXR0cmlidXRlX2Zvcm1hdD0ndW5kZWYnCgkJCWRfYXR0cmli
  dXRlX21hbGxvYz0ndW5kZWYnCgkJCWRfYXR0cmlidXRlX25vbm51bGw9J3VuZGVmJwoJCQlkX2F0
  dHJpYnV0ZV9ub3JldHVybj0ndW5kZWYnCgkJCWRfYXR0cmlidXRlX3B1cmU9J3VuZGVmJwoJCQlk
  X2F0dHJpYnV0ZV91bnVzZWQ9J3VuZGVmJwoJCQlkX2F0dHJpYnV0ZV93YXJuX3VudXNlZF9yZXN1
  bHQ9J3VuZGVmJwoJCQljYXNlICIkY2MiIGluCgkJCSpjOTkpCSMgYzk5IHJlamVjdHMgYmFyZSAn
  LU8nLgoJCQkJY2FzZSAiJG9wdGltaXplIiBpbgoJCQkJJyd8LU8pIG9wdGltaXplPS1PMyA7OwoJ
  CQkJZXNhYwoJCQkJIyBXaXRob3V0IC1YYSBjOTkgZG9lc24ndCBzZWUKCQkJCSMgbWFueSBPUyBp
  bnRlcmZhY2VzLgoJCQkJY2FzZSAiJGNjZmxhZ3MiIGluCgkJCQkqLVhhKikJOzsKCQkJCSopIGNj
  ZmxhZ3M9IiRjY2ZsYWdzIC1YYSIgOzsKCQkJCWVzYWMKCQkJCTs7CgkJCWVzYWMKCQkJOzsKCQll
  c2FjCglmaQoKCSMgU2VlIGlmIGFzKDEpIGlzIEdOVSBhcygxKS4gIEdOVSBtaWdodCBub3Qgd29y
  ayBmb3IgdGhpcyBqb2IuCgljYXNlIGBhcyAtLXZlcnNpb24gPCAvZGV2L251bGwgMj4mMWAgaW4K
  CSpHTlUqKQoJCWNhdCA8PEVORCA+JjIKCk5PVEU6IFlvdSBhcmUgdXNpbmcgR05VIGFzKDEpLiAg
  R05VIGFzKDEpIG1pZ2h0IG5vdCBidWlsZCBQZXJsLgpZb3UgbXVzdCBhcnJhbmdlIHRvIHVzZSAv
  dXNyL2Njcy9iaW4vYXMsIHBlcmhhcHMgYnkgYWRkaW5nIC91c3IvY2NzL2Jpbgp0byB0aGUgYmVn
  aW5uaW5nIG9mIHlvdXIgUEFUSC4KCkVORAoJCTs7Cgllc2FjCgoJIyBTZWUgaWYgbGQoMSkgaXMg
  R05VIGxkKDEpLiAgR05VIGxkKDEpIG1pZ2h0IG5vdCB3b3JrIGZvciB0aGlzIGpvYi4KCSMgbGQg
  LS12ZXJzaW9uIGRvZXNuJ3QgcHJvcGVybHkgcmVwb3J0IGl0c2VsZiBhcyBhIEdOVSB0b29sLAoJ
  IyBhcyBvZiBsZCB2ZXJzaW9uIDIuNiwgc28gd2UgbmVlZCB0byBiZSBtb3JlIHN0cmljdC4gVFdQ
  IDkvNS85NgoJIyBTdW4ncyBsZCBhbHdheXMgZW1pdHMgdGhlICJTb2Z0d2FyZSBHZW5lcmF0aW9u
  IFV0aWxpdGllcyIgc3RyaW5nLgoJaWYgbGQgLVYgMj4mMSB8IGdyZXAgImxkOiBTb2Z0d2FyZSBH
  ZW5lcmF0aW9uIFV0aWxpdGllcyIgPi9kZXYvbnVsbCAyPiYxOyB0aGVuCgkgICAgIyBPaywgbGQg
  aXMgL3Vzci9jY3MvYmluL2xkLgoJICAgIDoKCWVsc2UKCSAgICBjYXQgPDxFTkQgPiYyCgpOT1RF
  OiBZb3UgYXJlIGFwcGFyZW50bHkgdXNpbmcgR05VIGxkKDEpLiAgR05VIGxkKDEpIG1pZ2h0IG5v
  dCBidWlsZCBQZXJsLgpZb3Ugc2hvdWxkIGFycmFuZ2UgdG8gdXNlIC91c3IvY2NzL2Jpbi9sZCwg
  cGVyaGFwcyBieSBhZGRpbmcgL3Vzci9jY3MvYmluCnRvIHRoZSBiZWdpbm5pbmcgb2YgeW91ciBQ
  QVRILgoKRU5ECglmaQpmaQoKIyBhcyAtLXZlcnNpb24gb3IgbGQgLS12ZXJzaW9uIG1pZ2h0IGR1
  bXAgY29yZS4Kcm0gLWYgdHJ5IHRyeS5jIGNvcmUKRU9DQlUKCmNhdCA+IFVVL3VzZXRocmVhZHMu
  Y2J1IDw8J0VPQ0JVJwojIFRoaXMgc2NyaXB0IFVVL3VzZXRocmVhZHMuY2J1IHdpbGwgZ2V0ICdj
  YWxsZWQtYmFjaycgYnkgQ29uZmlndXJlCiMgYWZ0ZXIgaXQgaGFzIHByb21wdGVkIHRoZSB1c2Vy
  IGZvciB3aGV0aGVyIHRvIHVzZSB0aHJlYWRzLgpjYXNlICIkdXNldGhyZWFkcyIgaW4KJGRlZmlu
  ZXx0cnVlfFt5WV0qKQoJY2NmbGFncz0iLURfUkVFTlRSQU5UICRjY2ZsYWdzIgoKCSMgLWxwdGhy
  ZWFkIG92ZXJyaWRlcyBzb21lIGxpYiBDIGZ1bmN0aW9ucywgc28gcHV0IGl0IGJlZm9yZSBjLgoJ
  c2V0IGBlY2hvIFggIiRsaWJzd2FudGVkICJ8IHNlZCAtZSAicy8gYyAvIHB0aHJlYWQgYyAvImAK
  CXNoaWZ0CglsaWJzd2FudGVkPSIkKiIKCgkjIHNjaGVkX3lpZWxkIGlzIGF2YWlsYWJsZSBpbiB0
  aGUgLWxydCBsaWJyYXJ5LiAgSG93ZXZlciwKCSMgd2UgY2FuIGFsc28gcGljayB1cCB0aGUgZXF1
  aXZhbGVudCB5aWVsZCgpIGZ1bmN0aW9uIGluIHRoZQoJIyBub3JtYWwgQyBsaWJyYXJ5LiAgVG8g
  YXZvaWQgcHVsbGluZyBpbiB1bm5lY2Vzc2FyeQoJIyBsaWJyYXJpZXMsIHdlJ2xsIG5vcm1hbGx5
  IGF2b2lkIHNjaGVkX3lpZWxkKCkvLWxydCBhbmQKCSMganVzdCB1c2UgeWllbGQoKS4gIEhvd2V2
  ZXIsIHdlJ2xsIGhvbm9yIGEgY29tbWFuZC1saW5lCgkjIG92ZXJyaWRlIDogIi1Ec2NoZWRfeWll
  bGQ9c2NoZWRfeWllbGQiLgoJIyBJZiB3ZSBlbmQgdXAgdXNpbmcgc2NoZWRfeWllbGQsIHdlJ3Jl
  IGdvaW5nIHRvIG5lZWQgLWxydC4KCXNjaGVkX3lpZWxkPSR7c2NoZWRfeWllbGQ6LXlpZWxkfQoJ
  aWYgdGVzdCAiJHNjaGVkX3lpZWxkIiA9ICJzY2hlZF95aWVsZCI7IHRoZW4KCSAgICBzZXQgYGVj
  aG8gWCAiJGxpYnN3YW50ZWQgInwgc2VkIC1lICJzLyBwdGhyZWFkIC8gcnQgcHRocmVhZCAvImAK
  CSAgICBzaGlmdAoJICAgIGxpYnN3YW50ZWQ9IiQqIgoJZmkKCgkjIE9uIFNvbGFyaXMgMi42IHg4
  NiB0aGVyZSBpcyBhIGJ1ZyB3aXRoIHNpZ3NldGptcCgpIGFuZCBzaWdsb25nam1wKCkKCSMgd2hl
  biBsaW5rZWQgd2l0aCB0aGUgdGhyZWFkcyBsaWJyYXJ5LCBzdWNoIHRoYXQgd2hhdGV2ZXIgcG9z
  aXRpdmUKCSMgdmFsdWUgeW91IHBhc3MgdG8gc2lnbG9uZ2ptcCgpLCBzaWdzZXRqbXAoKSByZXR1
  cm5zIDEuCgkjIFRoYW5rcyB0byBTaW1vbiBQYXJzb25zIDxTLlBhcnNvbnNAZnRlbC5jby51az4g
  Zm9yIHRoaXMgcmVwb3J0LgoJIyBTdW4gQnVnSUQgaXMgNDExNzk0NiwgInNpZ3NldGptcCBhbHdh
  eXMgcmV0dXJucyAxIHdoZW4gY2FsbGVkIGJ5CgkjIHNpZ2xvbmdqbXAgaW4gYSBNVCBwcm9ncmFt
  Ii4gQXMgb2YgMTk5ODA2MjIsIHRoZXJlIGlzIG5vIHBhdGNoCgkjIGF2YWlsYWJsZS4KCWNhdCA+
  dHJ5LmMgPDwnRU9NJwoJLyogVGVzdCBmb3Igc2lnKHNldHxsb25nKWptcCBidWcuICovCgkjaW5j
  bHVkZSA8c2V0am1wLmg+CgoJaW50IG1haW4oKQoJewoJICAgIHNpZ2ptcF9idWYgZW52OwoJICAg
  IGludCByZXQ7CgoJICAgIHJldCA9IHNpZ3NldGptcChlbnYsIDEpOwoJICAgIGlmIChyZXQpIHsg
  cmV0dXJuIHJldCA9PSAyOyB9CgkgICAgc2lnbG9uZ2ptcChlbnYsIDIpOwoJfQpFT00KCWlmIHRl
  c3QgImBhcmNoYCIgPSBpODZwYyAtYSBgdW5hbWUgLXJgID0gNS42ICYmIFwKCSAgICR7Y2M6LWNj
  fSB0cnkuYyAtbHB0aHJlYWQgPi9kZXYvbnVsbCAyPiYxICYmIC4vYS5vdXQ7IHRoZW4KCSAgICBk
  X3NpZ3NldGptcD0kdW5kZWYKCWZpCgoJIyBUaGVzZSBwcm90b3R5cGVzIHNob3VsZCBiZSB2aXNp
  YmxlIHNpbmNlIHdlIHVzaW5nCgkjIC1EX1JFRU5UUkFOVCwgYnV0IHRoYXQgZG9lcyBub3Qgc2Vl
  bSB0byB3b3JrLgoJIyBJdCBkb2VzIHNlZW0gdG8gd29yayBmb3IgZ2V0bmV0YnlhZGRyX3IsIHdl
  aXJkbHkgZW5vdWdoLAoJIyBhbmQgb3RoZXIgX3IgZnVuY3Rpb25zLiAoU29sYXJpcyA4KQoKCWRf
  Y3Rlcm1pZF9yX3Byb3RvPSIkZGVmaW5lIgoJZF9nZXRob3N0YnlhZGRyX3JfcHJvdG89IiRkZWZp
  bmUiCglkX2dldGhvc3RieW5hbWVfcl9wcm90bz0iJGRlZmluZSIKCWRfZ2V0bmV0YnluYW1lX3Jf
  cHJvdG89IiRkZWZpbmUiCglkX2dldHByb3RvYnluYW1lX3JfcHJvdG89IiRkZWZpbmUiCglkX2dl
  dHByb3RvYnludW1iZXJfcl9wcm90bz0iJGRlZmluZSIKCWRfZ2V0c2VydmJ5bmFtZV9yX3Byb3Rv
  PSIkZGVmaW5lIgoJZF9nZXRzZXJ2Ynlwb3J0X3JfcHJvdG89IiRkZWZpbmUiCgoJIyBEaXR0by4g
  KFNvbGFyaXMgNykKCWRfcmVhZGRpcl9yX3Byb3RvPSIkZGVmaW5lIgoJZF9yZWFkZGlyNjRfcl9w
  cm90bz0iJGRlZmluZSIKCWRfdG1wbmFtX3JfcHJvdG89IiRkZWZpbmUiCglkX3R0eW5hbWVfcl9w
  cm90bz0iJGRlZmluZSIKCgk7Owplc2FjCkVPQ0JVCgpjYXQgPiBVVS91c2VsYXJnZWZpbGVzLmNi
  dSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2VsYXJnZWZpbGVzLmNidSB3aWxsIGdldCAn
  Y2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNl
  ciBmb3Igd2hldGhlciB0byB1c2UgbGFyZ2UgZmlsZXMuCmNhc2UgIiR1c2VsYXJnZWZpbGVzIiBp
  bgonJ3wkZGVmaW5lfHRydWV8W3lZXSopCgojIEtlZXAgdGhlc2UgaW4gdGhlIGxlZnQgbWFyZ2lu
  LgpjY2ZsYWdzX3VzZWxhcmdlZmlsZXM9ImAkcnVuIGdldGNvbmYgTEZTX0NGTEFHUyAyPi9kZXYv
  bnVsbGAiCmxkZmxhZ3NfdXNlbGFyZ2VmaWxlcz0iYCRydW4gZ2V0Y29uZiBMRlNfTERGTEFHUyAy
  Pi9kZXYvbnVsbGAiCmxpYnN3YW50ZWRfdXNlbGFyZ2VmaWxlcz0iYCRydW4gZ2V0Y29uZiBMRlNf
  TElCUyAyPi9kZXYvbnVsbHxzZWQgLWUgJ3NAXi1sQEAnIC1lICdzQCAtbEAgQGcnYCIKCiAgICBj
  Y2ZsYWdzPSIkY2NmbGFncyAkY2NmbGFnc191c2VsYXJnZWZpbGVzIgogICAgbGRmbGFncz0iJGxk
  ZmxhZ3MgJGxkZmxhZ3NfdXNlbGFyZ2VmaWxlcyIKICAgIGxpYnN3YW50ZWQ9IiRsaWJzd2FudGVk
  ICRsaWJzd2FudGVkX3VzZWxhcmdlZmlsZXMiCiAgICA7Owplc2FjCkVPQ0JVCgojIFRoaXMgaXMg
  dHJ1bHkgYSBtZXNzLgpjYXNlICIkdXNlbW9yZWJpdHMiIGluCiIkZGVmaW5lInx0cnVlfFt5WV0q
  KQoJdXNlNjRiaXRpbnQ9IiRkZWZpbmUiCgl1c2Vsb25nZG91YmxlPSIkZGVmaW5lIgoJOzsKZXNh
  YwoKaWYgdGVzdCBgJHJ1biB1bmFtZSAtcGAgPSBpMzg2OyB0aGVuCiAgICBjYXNlICIkdXNlNjRi
  aXRpbnQiIGluCiAgICAiJGRlZmluZSJ8dHJ1ZXxbeVldKikKICAgICAgICAgICAgY2NmbGFncz0i
  JGNjZmxhZ3MgLURQVFJfSVNfTE9ORyIKICAgICAgICAgICAgOzsKICAgIGVzYWMKZmkKCmlmIHRl
  c3QgYCRydW4gdW5hbWUgLXBgID0gc3BhcmMgLW8gYCRydW4gdW5hbWUgLXBgID0gaTM4NjsgdGhl
  bgogICAgY2F0ID4gVVUvdXNlNjRiaXRpbnQuY2J1IDw8J0VPQ0JVJwojIFRoaXMgc2NyaXB0IFVV
  L3VzZTY0Yml0aW50LmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFm
  dGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgNjQgYml0IGlu
  dGVnZXJzLgpjYXNlICIkdXNlNjRiaXRpbnQiIGluCiIkZGVmaW5lInx0cnVlfFt5WV0qKQoJICAg
  IGNhc2UgImAkcnVuIHVuYW1lIC1yYCIgaW4KCSAgICA1LlswLTRdKQoJCWNhdCA+JjQgPDxFT00K
  U29sYXJpcyBgdW5hbWUgLXJ8c2VkIC1lICdzL141XC4vMi4vJ2AgZG9lcyBub3Qgc3VwcG9ydCA2
  NC1iaXQgaW50ZWdlcnMuCllvdSBzaG91bGQgdXBncmFkZSB0byBhdCBsZWFzdCBTb2xhcmlzIDIu
  NS4KRU9NCgkJZXhpdCAxCgkJOzsKCSAgICBlc2FjCgojIGdjYy0yLjguMSBvbiBTb2xhcmlzIDgg
  d2l0aCAtRHVzZTY0Yml0aW50IGZhaWxzIG9wL3BhdC50IHRlc3QgODIyCiMgaWYgd2UgY29tcGls
  ZSByZWdleGVjLmMgd2l0aCAtTy4gIFR1cm4gb2ZmIG9wdGltaXphdGlvbiBmb3IgdGhhdCBvbmUK
  IyBmaWxlLiAgU2VlIGhpbnRzL1JFQURNRS5oaW50cyAsIGVzcGVjaWFsbHkKIyA9aGVhZDIgUHJv
  cGFnYXRpbmcgdmFyaWFibGVzIHRvIGNvbmZpZy5zaCwgbWV0aG9kIDMuCiMgIEEuIERvdWdoZXJ0
  eSAgTWF5IDI0LCAyMDAyCiAgICBjYXNlICIke2djY3ZlcnNpb259LSR7b3B0aW1pemV9IiBpbgog
  ICAgMi44Ki1PKikKCSMgSG9ub3IgYSBjb21tYW5kLWxpbmUgb3ZlcnJpZGUgKHJhdGhlciB1bmxp
  a2VseSkKCWNhc2UgIiRyZWdleGVjX2NmbGFncyIgaW4KCScnKSBlY2hvICJEaXNhYmxpbmcgb3B0
  aW1pemF0aW9uIG9uIHJlZ2V4ZWMuYyBmb3IgZ2NjICRnY2N2ZXJzaW9uIiA+JjQKCSAgICByZWdl
  eGVjX2NmbGFncz0nb3B0aW1pemU9JwoJICAgIGVjaG8gInJlZ2V4ZWNfY2ZsYWdzPSdvcHRpbWl6
  ZT1cIlwiJyIgPj4gY29uZmlnLnNoCgkgICAgOzsKCWVzYWMKCTs7CiAgICBlc2FjCiAgICA7Owpl
  c2FjCkVPQ0JVCgogICAgY2F0ID4gVVUvdXNlNjRiaXRhbGwuY2J1IDw8J0VPQ0JVJwojIFRoaXMg
  c2NyaXB0IFVVL3VzZTY0Yml0YWxsLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZp
  Z3VyZQojIGFmdGVyIGl0IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byBiZSBt
  YXhpbWFsbHkgNjQgYml0dHkuCmNhc2UgIiR1c2U2NGJpdGFsbC0kdXNlNjRiaXRhbGxfZG9uZSIg
  aW4KIiRkZWZpbmUtInx0cnVlLXxbeVldKi0pCgkgICAgY2FzZSAiYCRydW4gdW5hbWUgLXJgIiBp
  bgoJICAgIDUuWzAtNl0pCgkJY2F0ID4mNCA8PEVPTQpTb2xhcmlzIGB1bmFtZSAtcnxzZWQgLWUg
  J3MvXjVcLi8yLi8nYCBkb2VzIG5vdCBzdXBwb3J0IDY0LWJpdCBwb2ludGVycy4KWW91IHNob3Vs
  ZCB1cGdyYWRlIHRvIGF0IGxlYXN0IFNvbGFyaXMgMi43LgpFT00KCQlleGl0IDEKCQk7OwoJICAg
  IGVzYWMKCSAgICBwcm9jZXNzb3I9YCRydW4gdW5hbWUgLXBgOwoJICAgIGlmIHRlc3QgIiRwcm9j
  ZXNzb3IiID0gc3BhcmM7IHRoZW4KCQlsaWJjPScvdXNyL2xpYi9zcGFyY3Y5L2xpYmMuc28nCgkJ
  aWYgdGVzdCAhIC1mICRsaWJjOyB0aGVuCgkJICAgIGNhdCA+JjQgPDxFT00KCkkgZG8gbm90IHNl
  ZSB0aGUgNjQtYml0IGxpYmMsICRsaWJjLgpDYW5ub3QgY29udGludWUsIGFib3J0aW5nLgoKRU9N
  CgkJICAgIGV4aXQgMQoJCWZpCgkgICAgZmkKCSAgICBjYXNlICIke2NjOi1jY30gLXYgMj4vZGV2
  L251bGwiIGluCgkgICAgKmdjYyopCgkJZWNobyAnaW50IG1haW4oKSB7IHJldHVybiAwOyB9JyA+
  IHRyeS5jCgkJY2FzZSAiYCR7Y2M6LWNjfSAkY2NmbGFncyAtbWNwdT12OSAtbTY0IC1TIHRyeS5j
  IDI+JjEgfCBncmVwICdtNjQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGNvbmZpZ3VyYXRpb24n
  YCIgaW4KCQkqIm02NCBpcyBub3Qgc3VwcG9ydGVkIiopCgkJICAgIGNhdCA+JjQgPDxFT00KCkZ1
  bGwgNjQtYml0IGJ1aWxkIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBnY2MgY29uZmlndXJhdGlv
  bi4KQ2hlY2sgaHR0cDovL2djYy5nbnUub3JnLyBmb3IgdGhlIGxhdGVzdCBuZXdzIG9mIGF2YWls
  YWJpbGl0eQpvZiBnY2MgZm9yIDY0LWJpdCBTcGFyYy4KCkNhbm5vdCBjb250aW51ZSwgYWJvcnRp
  bmcuCgpFT00KCQkgICAgZXhpdCAxCgkJICAgIDs7CgkJZXNhYwoJCWlmIHRlc3QgIiRwcm9jZXNz
  b3IiID0gc3BhcmM7IHRoZW4KCQkgICAgbG9jbGlicHRoPSIvdXNyL2xpYi9zcGFyY3Y5ICRsb2Ns
  aWJwdGgiCgkJICAgIGNjZmxhZ3M9IiRjY2ZsYWdzIC1tY3B1PXY5IgoJCWZpCgkJY2NmbGFncz0i
  JGNjZmxhZ3MgLW02NCIKCgkJIyBUaGlzIGFkZHMgaW4gLVdhLC14YXJjaD12OS4gIEkgc3VzcGVj
  dCB0aGF0J3Mgc3VwZXJmbHVvdXMsCgkJIyBzaW5jZSB0aGUgLW02NCBhYm92ZSBzaG91bGQgZG8g
  dGhhdCBhbHJlYWR5LiAgU29tZW9uZQoJCSMgd2l0aCBnY2MtMy54LngsIHBsZWFzZSB0ZXN0IHdp
  dGggZ2NjIC12LiAgIEEuRC4gMjAtTm92LTIwMDMKIwkJaWYgdGVzdCAkcHJvY2Vzc29yID0gc3Bh
  cmMgLWEgWGAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09GRjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAg
  IT0gWDsgdGhlbgojCQkgICAgY2NmbGFncz0iJGNjZmxhZ3MgLVdhLGAkcnVuIGdldGNvbmYgWEJT
  NV9MUDY0X09GRjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAiCiMJCWZpCgkJbGRmbGFncz0iJGxkZmxh
  Z3MgLW02NCIKCgkJIyBTZWUgW3BlcmwgIzY2NjA0XTogIE9uIFNvbGFyaXMgMTEsIGdjYyAtbTY0
  IG9uIGFtZDY0CgkJIyBhcHBlYXJzIG5vdCB0byB1bmRlcnN0YW5kIC1HLiAgKGdjYyAtRyBoYXMg
  bm90IGNhdXNlZAoJCSMgcHJvYmxlbXMgb24gb3RoZXIgcGxhdGZvcm1zIGluIHRoZSBwYXN0Likg
  IGdjYyB2ZXJzaW9ucwoJCSMgYXQgbGVhc3QgYXMgb2xkIGFzIDMuNC4zIHN1cHBvcnQgLXNoYXJl
  ZCwgc28ganVzdAoJCSMgdXNlIHRoYXQgd2l0aCBTb2xhcmlzIDExIGFuZCBsYXRlciwgYnV0IGtl
  ZXAKCQkjIHRoZSBvbGQgYmVoYXZpb3IgZm9yIG9sZGVyIFNvbGFyaXMgdmVyc2lvbnMuCgkJY2Fz
  ZSAiJG9zdmVycyIgaW4KCQkJMi4/fDIuMTApIGxkZGxmbGFncz0iJGxkZGxmbGFncyAtRyAtbTY0
  IiA7OwoJCQkqKSBsZGRsZmxhZ3M9IiRsZGRsZmxhZ3MgLXNoYXJlZCAtbTY0IiA7OwoJCWVzYWMK
  CQk7OwoJICAgICopCgkJZ2V0Y29uZmNjZmxhZ3M9ImAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09G
  RjY0X0NGTEFHUyAyPi9kZXYvbnVsbGAiCgkJZ2V0Y29uZmxkZmxhZ3M9ImAkcnVuIGdldGNvbmYg
  WEJTNV9MUDY0X09GRjY0X0xERkxBR1MgMj4vZGV2L251bGxgIgoJCWdldGNvbmZsZGRsZmxhZ3M9
  ImAkcnVuIGdldGNvbmYgWEJTNV9MUDY0X09GRjY0X0xERkxBR1MgMj4vZGV2L251bGxgIgoJCWVj
  aG8gImludCBtYWluKCkgeyByZXR1cm4oMCk7IH0gIiA+IHRyeS5jCgkJY2FzZSAiYCR7Y2M6LWNj
  fSAkZ2V0Y29uZmNjZmxhZ3MgdHJ5LmMgMj4mMSB8IGdyZXAgJ2RlcHJlY2F0ZWQnYCIgaW4KCQkq
  IiAteGFyY2g9Z2VuZXJpYzY0IGlzIGRlcHJlY2F0ZWQsIHVzZSAtbTY0ICIqKQoJCSAgICBnZXRj
  b25mY2NmbGFncz1gZWNobyAkZ2V0Y29uZmNjZmxhZ3MgfCBzZWQgLWUgJ3MveGFyY2g9Z2VuZXJp
  YzY0L202NC8nYAoJCSAgICBnZXRjb25mbGRmbGFncz1gZWNobyAkZ2V0Y29uZmxkZmxhZ3MgfCBz
  ZWQgLWUgJ3MveGFyY2g9Z2VuZXJpYzY0L202NC8nYAoJCSAgICBnZXRjb25mbGRkbGZsYWdzPWBl
  Y2hvICRnZXRjb25mbGRkbGZsYWdzIHwgc2VkIC1lICdzL3hhcmNoPWdlbmVyaWM2NC9tNjQvJ2AK
  CQkgICAgOzsKCQllc2FjCgkJY2NmbGFncz0iJGNjZmxhZ3MgJGdldGNvbmZjY2ZsYWdzIgoJCWxk
  ZmxhZ3M9IiRsZGZsYWdzICRnZXRjb25mbGRmbGFncyIKCQlsZGRsZmxhZ3M9IiRsZGRsZmxhZ3Mg
  LUcgJGdldGNvbmZsZGRsZmxhZ3MiCgoJCWVjaG8gImludCBtYWluKCkgeyByZXR1cm4oMCk7IH0g
  IiA+IHRyeS5jCgkJdHJ5d29ya3Nob3BjYz0iJHtjYzotY2N9IHRyeS5jIC1vIHRyeSAkY2NmbGFn
  cyIKCQlpZiB0ZXN0ICIkcHJvY2Vzc29yIiA9IHNwYXJjOyB0aGVuCgkJICAgIGxvY2xpYnB0aD0i
  L3Vzci9saWIvc3BhcmN2OSAvdXNyL2Njcy9saWIvc3BhcmN2OSAkbG9jbGlicHRoIgoJCWZpCgkJ
  bG9jbGlicHRoPSJgJGdldHdvcmtzaG9wbGlic2AgJGxvY2xpYnB0aCIKCQk7OwoJICAgIGVzYWMK
  CSAgICB1bnNldCBwcm9jZXNzb3IKCSAgICB1c2U2NGJpdGFsbF9kb25lPXllcwoJICAgIGFyY2hu
  YW1lNjQ9NjQKCSAgICA7Owplc2FjCkVPQ0JVCgogICAgIyBBY3R1YWxseSwgd2Ugd2FudCB0byBy
  dW4gdGhpcyBhbHJlYWR5IG5vdywgaWYgc28gcmVxdWVzdGVkLAogICAgIyBiZWNhdXNlIHdlIG5l
  ZWQgdG8gZml4IHVwIHRoaW5ncyByaWdodCBub3cuCiAgICBjYXNlICIkdXNlNjRiaXRhbGwiIGlu
  CiAgICAiJGRlZmluZSJ8dHJ1ZXxbeVldKikKCSMgQ0JVcyBleHBlY3QgdG8gYmUgcnVuIGluIFVV
  CgljZCBVVTsgLiAuL3VzZTY0Yml0YWxsLmNidTsgY2QgLi4KCTs7CiAgICBlc2FjCmZpCgpjYXQg
  PiBVVS91c2Vsb25nZG91YmxlLmNidSA8PCdFT0NCVScKIyBUaGlzIHNjcmlwdCBVVS91c2Vsb25n
  ZG91YmxlLmNidSB3aWxsIGdldCAnY2FsbGVkLWJhY2snIGJ5IENvbmZpZ3VyZQojIGFmdGVyIGl0
  IGhhcyBwcm9tcHRlZCB0aGUgdXNlciBmb3Igd2hldGhlciB0byB1c2UgbG9uZyBkb3VibGVzLgpj
  YXNlICIkdXNlbG9uZ2RvdWJsZSIgaW4KIiRkZWZpbmUifHRydWV8W3lZXSopCglpZiB0ZXN0ICIk
  Y2NfbmFtZSIgPSAid29ya3Nob3AiOyB0aGVuCgkJY2F0ID4gdHJ5LmMgPDwgJ0VPTScKI2luY2x1
  ZGUgPHN1bm1hdGguaD4KaW50IG1haW4oKSB7ICh2b2lkKSBwb3dsKDIsIDI1Nik7IHJldHVybigw
  KTsgfQpFT00KCQlpZiAke2NjOi1jY30gdHJ5LmMgLWxzdW5tYXRoIC1vIHRyeSA+IC9kZXYvbnVs
  bCAyPiYxICYmIC4vdHJ5OyB0aGVuCgkJCWxpYnN3YW50ZWQ9IiRsaWJzd2FudGVkIHN1bm1hdGgi
  CgkJZmkKCWVsc2UKCQljYXQgPiY0IDw8RU9NCgpUaGUgU3VuIFdvcmtzaG9wIG1hdGggbGlicmFy
  eSBpcyBlaXRoZXIgbm90IGF2YWlsYWJsZSBvciBub3Qgd29ya2luZywKc28gSSBkbyBub3Qga25v
  dyBob3cgdG8gZG8gbG9uZyBkb3VibGVzLCBzb3JyeS4KSSdtIHRoZXJlZm9yZSBkaXNhYmxpbmcg
  dGhlIHVzZSBvZiBsb25nIGRvdWJsZXMuCkVPTQoJCXVzZWxvbmdkb3VibGU9IiR1bmRlZiIKCWZp
  Cgk7Owplc2FjCkVPQ0JVCgojCiMgSWYgdW5zZXRlbnYgaXMgYXZhaWxhYmxlLCB1c2UgaXQgaW4g
  Y29uanVuY3Rpb24gd2l0aCBQRVJMX1VTRV9TQUZFX1BVVEVOViB0bwojIHdvcmsgYXJvdW5kIFN1
  biBidWdpZCA2MzMzODMwLiAgQm90aCB1bnNldGVudiBhbmQgNjMzMzgzMCBvbmx5IGFwcGVhciBp
  bgojIFNvbGFyaXMgMTAsIHNvIHdlIGRvbid0IG5lZWQgdG8gcHJvYmUgZXhwbGljaXRseSBmb3Ig
  YW4gT1MgdmVyc2lvbi4gIFdlIGhhdmUKIyB0byBhcHBlbmQgdGhpcyB0ZXN0IHRvIHRoZSBlbmQg
  b2YgY29uZmlnLm92ZXIgYXMgaXQgbmVlZHMgdG8gcnVuIGFmdGVyCiMgQ29uZmlndXJlIGhhcyBw
  cm9iZWQgZm9yIHVuc2V0ZW52LCBhbmQgdGhpcyBoaW50cyBmaWxlIGlzIHByb2Nlc3NlZCBiZWZv
  cmUKIyB0aGF0IGhhcyBoYXBwZW5lZC4KIwpjYXQgPj4gY29uZmlnLm92ZXIgPDwnRU9PVkVSJwpp
  ZiB0ZXN0ICIkZF91bnNldGVudiIgPSAiJGRlZmluZSIgLWEgXAogICAgYGV4cHIgIiRjY2ZsYWdz
  IiA6ICcuKi1EUEVSTF9VU0VfU0FGRV9QVVRFTlYnYCAtZXEgMDsgdGhlbgogICAgICAgIGNjZmxh
  Z3M9IiRjY2ZsYWdzIC1EUEVSTF9VU0VfU0FGRV9QVVRFTlYiCmZpCkVPT1ZFUgoKcm0gLWYgdHJ5
  LmMgdHJ5Lm8gdHJ5IGEub3V0CgojIElmIHVzaW5nIEMrKywgdGhlIENvbmZpZ3VyZSBzY2FuIGZv
  ciBkbG9wZW4oKSB3aWxsIGZhaWwgaW4gU29sYXJpcwojIGJlY2F1c2Ugb25lIG9mIHRoZSB0d28g
  KDEpIGFuIGV4dGVybiAiQyIgbGlua2FnZSBkZWZpbml0aW9uIGlzIG5lZWRlZAojICgyKSAjaW5j
  bHVkZSA8ZGxmY24uaD4gaXMgbmVlZGVkLCAqYW5kKiBhIGNhc3QgdG8gKHZvaWQqKCopKCkpCiMg
  aXMgbmVlZGVkIGZvciB0aGUgJmRsb3Blbi4gIEFkZGluZyBhbnkgb2YgdGhlc2Ugd291bGQgcmVx
  dWlyZSBjaGFuZ2luZwojIGEgZGVsaWNhdGUgc3BvdCBpbiBDb25maWd1cmUsIHNvIGVhc2llciBq
  dXN0IHRvIGZvcmNlIG91ciBndWVzcyBoZXJlCiMgZm9yIFNvbGFyaXMuICBNdWNoIHRoZSBzYW1l
  IGdvZXMgZm9yIGRsZXJyb3IoKS4KY2FzZSAiJGNjIiBpbgoqZysrKnwqQ0MqKQogIGRfZGxvcGVu
  PSdkZWZpbmUnCiAgZF9kbGVycm9yPSdkZWZpbmUnCiAgOzsKZXNhYwoKIyBPcmFjbGUvU3VuIGJ1
  aWxkcyB0aGVpciBQZXJsIHNoYXJlZCBzaW5jZSA1LjYuMSwgYW5kIHRoZXkgYWxzbwojIHN0cm9u
  Z2x5IHJlY29tbWVuZCB1c2luZyBzaGFyZWQgbGlicmFyaWVzIGluIGdlbmVyYWwuCiMKIyBGdXJ0
  aGVybW9yZSwgT3BlbkluZGlhbmEgc2VlbXMgdG8gZWZmZWN0aXZlbHkgcmVxdWlyZSBidWlsZGlu
  ZyBwZXJsCiMgc2hhcmVkLCBvciBvdGhlcndpc2UgcGVybCBzY3JpcHRzIHdvbid0IGV2ZW4gZmlu
  ZCB0aGUgUGVybCBsaWJyYXJ5Lgp1c2VzaHJwbGliPSd0cnVlJwo=',
  );
  
  my %files = (
    'freebsd' => 'freebsd.sh',
    'netbsd'  => 'netbsd.sh',
    'openbsd' => 'openbsd.sh',
    'linux'   => 'linux.sh',
    'dragonfly' => 'dragonfly.sh',
    'darwin' => 'darwin.sh',
    'hpux' => 'hpux.sh',
    'cygwin' => 'cygwin.sh',
    'midnightbsd' => 'midnightbsd.sh',
    'gnukfreebsd' => 'gnukfreebsd.sh',
    'solaris' => 'solaris_2.sh',
    'bitrig' => 'bitrig.sh',
    'gnu' => 'gnu.sh',
  );
  
  sub hint_file {
    my $os = shift;
    $os = shift if eval { $os->isa(__PACKAGE__) };
    $os = $^O unless $os;
    return unless defined $hints{ $os };
    my $content = decode_base64( $hints{ $os } );
    return $content unless wantarray;
    return ( $files{ $os }, $content );
  }
  
  sub hints {
    return sort keys %hints;
  }
  
  qq'nudge nudge wink wink';
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::PatchPerl::Hints - replacement 'hints' files
  
  =head1 VERSION
  
  version 1.78
  
  =head1 SYNOPSIS
  
    use Devel::PatchPerl::Hints;
  
    if ( my $content = Devel::PatchPerl::Hints->hint_file() ) {
      chmod 0644, 'hints/netbsd.sh' or die "$!";
      open my $hints, '>', 'hints/netbsd.sh' or die "$!";
      print $hints $content;
      close $hints;
    }
  
    # Get a list of OS for which we have hints
  
    my @os = Devel::PatchPerl::Hints->hints();
  
  =head1 DESCRIPTION
  
  Sometimes there is a problem with Perls C<hints> file for a particular
  perl port. This module provides fixed C<hints> files encoded using
  C<MIME::Base64>.
  
  =head1 FUNCTION
  
  The function is exported, but has to implicitly imported into the
  requesting package.
  
    use Devel::PatchPerl::Hints qw[hint_file];
  
  It may also be called as a class method:
  
    use Devel::PatchPerl::Hints;
  
    my $content = Devel::PatchPerl::Hints->hint_file();
  
  =over
  
  =item C<hint_file>
  
  Takes an optional argument which is the OS name ( as would be returned by C<$^O> ).
  By default it will use C<$^O>.
  
  In a scalar context, Will return the decoded content of the C<hints> file suitable for writing straight to a
  file handle or undef list if there isn't an applicable C<hints> file for the given or derived
  OS.
  
  If called in a list context, will return a list, the first item will be the name of the C<hints> file that
  will need to be amended, the second item will be a string with the decoded content of the C<hints> file suitable
  for writing straight to a file handle. Otherwise an empty list will be returned.
  
  =item C<hints>
  
  Takes no arguments, returns a list of OS names for which there are C<hints> files.
  
  =back
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2019 by Chris Williams and Marcus Holland-Moritz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DEVEL_PATCHPERL_HINTS

$fatpacked{"Devel/PatchPerl/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_PATCHPERL_PLUGIN';
  package Devel::PatchPerl::Plugin;
  $Devel::PatchPerl::Plugin::VERSION = '1.78';
  #ABSTRACT: Devel::PatchPerl plugins explained
  
  use strict;
  use warnings;
  
  qq[Plug it in];
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Devel::PatchPerl::Plugin - Devel::PatchPerl plugins explained
  
  =head1 VERSION
  
  version 1.78
  
  =head1 DESCRIPTION
  
  This document explains the L<Devel::PatchPerl> plugin system.
  
  Plugins are a mechanism for providing additional functionality to
  L<Devel::PatchPerl>.
  
  Plugins are searched for in the L<Devel::PatchPerl::Plugin> namespace.
  
  =head1 INITIALISATION
  
  The plugin constructor is C<patchperl>.
  
  A plugin is specified using the C<PERL5_PATCHPERL_PLUGIN> environment
  variable. It may either be specified in full (ie. C<Devel::PatchPerl::Plugin::Feegle>)
  or as the short part (ie. C<Feegle>).
  
    $ export PERL5_PATCHPERL_PLUGIN=Devel::PatchPerl::Plugin::Feegle
  
    $ export PERL5_PATCHPERL_PLUGIN=Feegle
  
  When L<Devel::PatchPerl> has identified the perl source patch and done its patching
  it will attempt to load the plugin identified. It will then call the class method
  C<patchperl> for the plugin package, with the following parameters:
  
    'version', the Perl version of the source tree;
    'source', the absolute path to the Perl source tree;
    'patchexe', the 'patch' utility that can be used;
  
  Plugins are called with the current working directory being the root of the
  Perl source tree, ie. C<source>.
  
  Summarised:
  
    $ENV{PERL5_PATCHPERL_PLUGIN} = 'Devel::PatchPerl::Plugin::Feegle';
  
    my $plugin = $ENV{PERL5_PATCHPERL_PLUGIN};
  
    eval "require $plugin";
  
    eval {
      $plugin->patchperl( version => $vers, source => $srcdir, patchexe => $patch );
    };
  
  =head1 WHAT CAN PLUGINS DO?
  
  Anything you desire to a Perl source tree.
  
  =head1 WHY USE AN ENVIRONMENT VARIABLE TO SPECIFY PLUGINS?
  
  So that indicating a plugin to use can be specified independently of whatever mechanism is
  calling L<Devel::PatchPerl> to do its bidding.
  
  Think L<perlbrew>.
  
  =head1 AUTHOR
  
  Chris Williams <chris@bingosnet.co.uk>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2019 by Chris Williams and Marcus Holland-Moritz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DEVEL_PATCHPERL_PLUGIN

$fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
  package Exporter;
  
  require 5.006;
  
  # Be lean.
  #use strict;
  #no strict 'refs';
  
  our $Debug = 0;
  our $ExportLevel = 0;
  our $Verbose ||= 0;
  our $VERSION = '5.73';
  our (%Cache);
  
  sub as_heavy {
    require Exporter::Heavy;
    # Unfortunately, this does not work if the caller is aliased as *name = \&foo
    # Thus the need to create a lot of identical subroutines
    my $c = (caller(1))[3];
    $c =~ s/.*:://;
    \&{"Exporter::Heavy::heavy_$c"};
  }
  
  sub export {
    goto &{as_heavy()};
  }
  
  sub import {
    my $pkg = shift;
    my $callpkg = caller($ExportLevel);
  
    if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
      *{$callpkg."::import"} = \&import;
      return;
    }
  
    # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
    my $exports = \@{"$pkg\::EXPORT"};
    # But, avoid creating things if they don't exist, which saves a couple of
    # hundred bytes per package processed.
    my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
    return export $pkg, $callpkg, @_
      if $Verbose or $Debug or $fail && @$fail > 1;
    my $export_cache = ($Cache{$pkg} ||= {});
    my $args = @_ or @_ = @$exports;
  
    if ($args and not %$export_cache) {
      s/^&//, $export_cache->{$_} = 1
        foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    }
    my $heavy;
    # Try very hard not to use {} and hence have to  enter scope on the foreach
    # We bomb out of the loop with last as soon as heavy is set.
    if ($args or $fail) {
      ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                 or $fail and @$fail and $_ eq $fail->[0])) and last
                   foreach (@_);
    } else {
      ($heavy = /\W/) and last
        foreach (@_);
    }
    return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    local $SIG{__WARN__} = 
  	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
    # shortcut for the common case of no type character
    *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  }
  
  # Default methods
  
  sub export_fail {
      my $self = shift;
      @_;
  }
  
  # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
  # *name = \&foo.  Thus the need to create a lot of identical subroutines
  # Otherwise we could have aliased them to export().
  
  sub export_to_level {
    goto &{as_heavy()};
  }
  
  sub export_tags {
    goto &{as_heavy()};
  }
  
  sub export_ok_tags {
    goto &{as_heavy()};
  }
  
  sub require_version {
    goto &{as_heavy()};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Exporter - Implements default import method for modules
  
  =head1 SYNOPSIS
  
  In module F<YourModule.pm>:
  
    package YourModule;
    require Exporter;
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  or
  
    package YourModule;
    use Exporter 'import'; # gives you Exporter's import() method directly
    our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  
  In other files which wish to use C<YourModule>:
  
    use YourModule qw(frobnicate);      # import listed symbols
    frobnicate ($left, $right)          # calls YourModule::frobnicate
  
  Take a look at L</Good Practices> for some variants
  you will like to use in modern Perl code.
  
  =head1 DESCRIPTION
  
  The Exporter module implements an C<import> method which allows a module
  to export functions and variables to its users' namespaces.  Many modules
  use Exporter rather than implementing their own C<import> method because
  Exporter provides a highly flexible interface, with an implementation optimised
  for the common case.
  
  Perl automatically calls the C<import> method when processing a
  C<use> statement for a module.  Modules and C<use> are documented
  in L<perlfunc> and L<perlmod>.  Understanding the concept of
  modules and how the C<use> statement operates is important to
  understanding the Exporter.
  
  =head2 How to Export
  
  The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
  symbols that are going to be exported into the users name space by
  default, or which they can request to be exported, respectively.  The
  symbols can represent functions, scalars, arrays, hashes, or typeglobs.
  The symbols must be given by full name with the exception that the
  ampersand in front of a function is optional, e.g.
  
      our @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
      our @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
  
  If you are only exporting function names it is recommended to omit the
  ampersand, as the implementation is faster this way.
  
  =head2 Selecting What to Export
  
  Do B<not> export method names!
  
  Do B<not> export anything else by default without a good reason!
  
  Exports pollute the namespace of the module user.  If you must export
  try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
  common symbol names to reduce the risk of name clashes.
  
  Generally anything not exported is still accessible from outside the
  module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
  syntax.  By convention you can use a leading underscore on names to
  informally indicate that they are 'internal' and not for public use.
  
  (It is actually possible to get private functions by saying:
  
    my $subref = sub { ... };
    $subref->(@args);            # Call it as a function
    $obj->$subref(@args);        # Use it as a method
  
  However if you use them for methods it is up to you to figure out
  how to make inheritance work.)
  
  As a general rule, if the module is trying to be object oriented
  then export nothing.  If it's just a collection of functions then
  C<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and
  method names use barewords in preference to names prefixed with
  ampersands for the export lists.
  
  Other module design guidelines can be found in L<perlmod>.
  
  =head2 How to Import
  
  In other files which wish to use your module there are three basic ways for
  them to load your module and import its symbols:
  
  =over 4
  
  =item C<use YourModule;>
  
  This imports all the symbols from YourModule's C<@EXPORT> into the namespace
  of the C<use> statement.
  
  =item C<use YourModule ();>
  
  This causes perl to load your module but does not import any symbols.
  
  =item C<use YourModule qw(...);>
  
  This imports only the symbols listed by the caller into their namespace.
  All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
  occurs.  The advanced export features of Exporter are accessed like this,
  but with list entries that are syntactically distinct from symbol names.
  
  =back
  
  Unless you want to use its advanced features, this is probably all you
  need to know to use Exporter.
  
  =head1 Advanced Features
  
  =head2 Specialised Import Lists
  
  If any of the entries in an import list begins with !, : or / then
  the list is treated as a series of specifications which either add to
  or delete from the list of names to import.  They are processed left to
  right. Specifications are in the form:
  
      [!]name         This name only
      [!]:DEFAULT     All names in @EXPORT
      [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array
      [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
  
  A leading ! indicates that matching names should be deleted from the
  list of names to import.  If the first specification is a deletion it
  is treated as though preceded by :DEFAULT.  If you just want to import
  extra names in addition to the default set you will still need to
  include :DEFAULT explicitly.
  
  e.g., F<Module.pm> defines:
  
      our @EXPORT      = qw(A1 A2 A3 A4 A5);
      our @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
      our %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
  
  Note that you cannot use tags in @EXPORT or @EXPORT_OK.
  
  Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
  
  An application using Module can say something like:
  
      use Module qw(:DEFAULT :T2 !B3 A3);
  
  Other examples include:
  
      use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
      use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
  
  Remember that most patterns (using //) will need to be anchored
  with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
  
  You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
  specifications are being processed and what is actually being imported
  into modules.
  
  =head2 Exporting Without Using Exporter's import Method
  
  Exporter has a special method, 'export_to_level' which is used in situations
  where you can't directly call Exporter's
  import method.  The export_to_level
  method looks like:
  
      MyPackage->export_to_level(
  	$where_to_export, $package, @what_to_export
      );
  
  where C<$where_to_export> is an integer telling how far up the calling stack
  to export your symbols, and C<@what_to_export> is an array telling what
  symbols *to* export (usually this is C<@_>).  The C<$package> argument is
  currently unused.
  
  For example, suppose that you have a module, A, which already has an
  import function:
  
      package A;
  
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;     # not a very useful import method
      }
  
  and you want to Export symbol C<$A::b> back to the module that called 
  package A.  Since Exporter relies on the import method to work, via 
  inheritance, as it stands Exporter::import() will never get called. 
  Instead, say the following:
  
      package A;
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw($b);
  
      sub import
      {
  	$A::b = 1;
  	A->export_to_level(1, @_);
      }
  
  This will export the symbols one level 'above' the current package - ie: to 
  the program or module that used package A. 
  
  Note: Be careful not to modify C<@_> at all before you call export_to_level
  - or people using your package will get very unexplained results!
  
  =head2 Exporting Without Inheriting from Exporter
  
  By including Exporter in your C<@ISA> you inherit an Exporter's import() method
  but you also inherit several other helper methods which you probably don't
  want.  To avoid this you can do:
  
    package YourModule;
    use Exporter qw(import);
  
  which will export Exporter's own import() method into YourModule.
  Everything will work as before but you won't need to include Exporter in
  C<@YourModule::ISA>.
  
  Note: This feature was introduced in version 5.57
  of Exporter, released with perl 5.8.3.
  
  =head2 Module Version Checking
  
  The Exporter module will convert an attempt to import a number from a
  module into a call to C<< $module_name->VERSION($value) >>.  This can
  be used to validate that the version of the module being used is
  greater than or equal to the required version.
  
  For historical reasons, Exporter supplies a C<require_version> method that
  simply delegates to C<VERSION>.  Originally, before C<UNIVERSAL::VERSION>
  existed, Exporter would call C<require_version>.
  
  Since the C<UNIVERSAL::VERSION> method treats the C<$VERSION> number as
  a simple numeric value it will regard version 1.10 as lower than
  1.9.  For this reason it is strongly recommended that you use numbers
  with at least two decimal places, e.g., 1.09.
  
  =head2 Managing Unknown Symbols
  
  In some situations you may want to prevent certain symbols from being
  exported.  Typically this applies to extensions which have functions
  or constants that may not exist on some systems.
  
  The names of any symbols that cannot be exported should be listed
  in the C<@EXPORT_FAIL> array.
  
  If a module attempts to import any of these symbols the Exporter
  will give the module an opportunity to handle the situation before
  generating an error.  The Exporter will call an export_fail method
  with a list of the failed symbols:
  
    @failed_symbols = $module_name->export_fail(@failed_symbols);
  
  If the C<export_fail> method returns an empty list then no error is
  recorded and all the requested symbols are exported.  If the returned
  list is not empty then an error is generated for each symbol and the
  export fails.  The Exporter provides a default C<export_fail> method which
  simply returns the list unchanged.
  
  Uses for the C<export_fail> method include giving better error messages
  for some symbols and performing lazy architectural checks (put more
  symbols into C<@EXPORT_FAIL> by default and then take them out if someone
  actually tries to use them and an expensive check shows that they are
  usable on that platform).
  
  =head2 Tag Handling Utility Functions
  
  Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
  C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
  you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
  
    our %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
    Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
  
  Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
  unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
  names being silently added to C<@EXPORT> or C<@EXPORT_OK>.  Future versions
  may make this a fatal error.
  
  =head2 Generating Combined Tags
  
  If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
  useful to create the utility ":all" to simplify "use" statements.
  
  The simplest way to do this is:
  
   our  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
  
    # add all the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
    }
  
  F<CGI.pm> creates an ":all" tag which contains some (but not really
  all) of its categories.  That could be done with one small
  change:
  
    # add some of the other ":class" tags to the ":all" class,
    # deleting duplicates
    {
      my %seen;
  
      push @{$EXPORT_TAGS{all}},
        grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
          foreach qw/html2 html3 netscape form cgi internal/;
    }
  
  Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
  
  =head2 C<AUTOLOAD>ed Constants
  
  Many modules make use of C<AUTOLOAD>ing for constant subroutines to
  avoid having to compile and waste memory on rarely used values (see
  L<perlsub> for details on constant subroutines).  Calls to such
  constant subroutines are not optimized away at compile time because
  they can't be checked at compile time for constancy.
  
  Even if a prototype is available at compile time, the body of the
  subroutine is not (it hasn't been C<AUTOLOAD>ed yet).  perl needs to
  examine both the C<()> prototype and the body of a subroutine at
  compile time to detect that it can safely replace calls to that
  subroutine with the constant value.
  
  A workaround for this is to call the constants once in a C<BEGIN> block:
  
     package My ;
  
     use Socket ;
  
     foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
     BEGIN { SO_LINGER }
     foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
  
  This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
  SO_LINGER is encountered later in C<My> package.
  
  If you are writing a package that C<AUTOLOAD>s, consider forcing
  an C<AUTOLOAD> for any constants explicitly imported by other packages
  or which are usually used when your package is C<use>d.
  
  =head1 Good Practices
  
  =head2 Declaring C<@EXPORT_OK> and Friends
  
  When using C<Exporter> with the standard C<strict> and C<warnings>
  pragmas, the C<our> keyword is needed to declare the package
  variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
  
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(munge frobnicate);
  
  If backward compatibility for Perls B<under> 5.6 is important,
  one must write instead a C<use vars> statement.
  
    use vars qw(@ISA @EXPORT_OK);
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(munge frobnicate);
  
  =head2 Playing Safe
  
  There are some caveats with the use of runtime statements
  like C<require Exporter> and the assignment to package
  variables, which can be very subtle for the unaware programmer.
  This may happen for instance with mutually recursive
  modules, which are affected by the time the relevant
  constructions are executed.
  
  The ideal (but a bit ugly) way to never have to think
  about that is to use C<BEGIN> blocks.  So the first part
  of the L</SYNOPSIS> code could be rewritten as:
  
    package YourModule;
  
    use strict;
    use warnings;
  
    our (@ISA, @EXPORT_OK);
    BEGIN {
       require Exporter;
       @ISA = qw(Exporter);
       @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    }
  
  The C<BEGIN> will assure that the loading of F<Exporter.pm>
  and the assignments to C<@ISA> and C<@EXPORT_OK> happen
  immediately, leaving no room for something to get awry
  or just plain wrong.
  
  With respect to loading C<Exporter> and inheriting, there
  are alternatives with the use of modules like C<base> and C<parent>.
  
    use base qw(Exporter);
    # or
    use parent qw(Exporter);
  
  Any of these statements are nice replacements for
  C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
  with the same compile-time effect.  The basic difference
  is that C<base> code interacts with declared C<fields>
  while C<parent> is a streamlined version of the older
  C<base> code to just establish the IS-A relationship.
  
  For more details, see the documentation and code of
  L<base> and L<parent>.
  
  Another thorough remedy to that runtime
  vs. compile-time trap is to use L<Exporter::Easy>,
  which is a wrapper of Exporter that allows all
  boilerplate code at a single gulp in the
  use statement.
  
     use Exporter::Easy (
         OK => [ qw(munge frobnicate) ],
     );
     # @ISA setup is automatic
     # all assignments happen at compile time
  
  =head2 What Not to Export
  
  You have been warned already in L</Selecting What to Export>
  to not export:
  
  =over 4
  
  =item *
  
  method names (because you don't need to
  and that's likely to not do what you want),
  
  =item *
  
  anything by default (because you don't want to surprise your users...
  badly)
  
  =item *
  
  anything you don't need to (because less is more)
  
  =back
  
  There's one more item to add to this list.  Do B<not>
  export variable names.  Just because C<Exporter> lets you
  do that, it does not mean you should.
  
    @EXPORT_OK = qw($svar @avar %hvar); # DON'T!
  
  Exporting variables is not a good idea.  They can
  change under the hood, provoking horrible
  effects at-a-distance that are too hard to track
  and to fix.  Trust me: they are not worth it.
  
  To provide the capability to set/get class-wide
  settings, it is best instead to provide accessors
  as subroutines or class methods instead.
  
  =head1 SEE ALSO
  
  C<Exporter> is definitely not the only module with
  symbol exporter capabilities.  At CPAN, you may find
  a bunch of them.  Some are lighter.  Some
  provide improved APIs and features.  Pick the one
  that fits your needs.  The following is
  a sample list of such modules.
  
      Exporter::Easy
      Exporter::Lite
      Exporter::Renaming
      Exporter::Tidy
      Sub::Exporter / Sub::Installer
      Perl6::Export / Perl6::Export::Attrs
  
  =head1 LICENSE
  
  This library is free software.  You can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
  
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
  package Exporter::Heavy;
  
  use strict;
  no strict 'refs';
  
  # On one line so MakeMaker will see it.
  require Exporter;  our $VERSION = $Exporter::VERSION;
  
  =head1 NAME
  
  Exporter::Heavy - Exporter guts
  
  =head1 SYNOPSIS
  
  (internal use only)
  
  =head1 DESCRIPTION
  
  No user-serviceable parts inside.
  
  =cut
  
  #
  # We go to a lot of trouble not to 'require Carp' at file scope,
  #  because Carp requires Exporter, and something has to give.
  #
  
  sub _rebuild_cache {
      my ($pkg, $exports, $cache) = @_;
      s/^&// foreach @$exports;
      @{$cache}{@$exports} = (1) x @$exports;
      my $ok = \@{"${pkg}::EXPORT_OK"};
      if (@$ok) {
  	s/^&// foreach @$ok;
  	@{$cache}{@$ok} = (1) x @$ok;
      }
  }
  
  sub heavy_export {
  
      # Save the old __WARN__ handler in case it was defined
      my $oldwarn = $SIG{__WARN__};
  
      # First make import warnings look like they're coming from the "use".
      local $SIG{__WARN__} = sub {
  	# restore it back so proper stacking occurs
  	local $SIG{__WARN__} = $oldwarn;
  	my $text = shift;
  	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
  	    require Carp;
  	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	    Carp::carp($text);
  	}
  	else {
  	    warn $text;
  	}
      };
      local $SIG{__DIE__} = sub {
  	require Carp;
  	local $Carp::CarpLevel = 1;	# ignore package calling us too.
  	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
  	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
      };
  
      my($pkg, $callpkg, @imports) = @_;
      my($type, $sym, $cache_is_current, $oops);
      my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                     $Exporter::Cache{$pkg} ||= {});
  
      if (@imports) {
  	if (!%$export_cache) {
  	    _rebuild_cache ($pkg, $exports, $export_cache);
  	    $cache_is_current = 1;
  	}
  
  	if (grep m{^[/!:]}, @imports) {
  	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
  	    my $tagdata;
  	    my %imports;
  	    my($remove, $spec, @names, @allexports);
  	    # negated first item implies starting with default set:
  	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
  	    foreach $spec (@imports){
  		$remove = $spec =~ s/^!//;
  
  		if ($spec =~ s/^://){
  		    if ($spec eq 'DEFAULT'){
  			@names = @$exports;
  		    }
  		    elsif ($tagdata = $tagsref->{$spec}) {
  			@names = @$tagdata;
  		    }
  		    else {
  			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
  			++$oops;
  			next;
  		    }
  		}
  		elsif ($spec =~ m:^/(.*)/$:){
  		    my $patn = $1;
  		    @allexports = keys %$export_cache unless @allexports; # only do keys once
  		    @names = grep(/$patn/, @allexports); # not anchored by default
  		}
  		else {
  		    @names = ($spec); # is a normal symbol name
  		}
  
  		warn "Import ".($remove ? "del":"add").": @names "
  		    if $Exporter::Verbose;
  
  		if ($remove) {
  		   foreach $sym (@names) { delete $imports{$sym} } 
  		}
  		else {
  		    @imports{@names} = (1) x @names;
  		}
  	    }
  	    @imports = keys %imports;
  	}
  
          my @carp;
  	foreach $sym (@imports) {
  	    if (!$export_cache->{$sym}) {
  		if ($sym =~ m/^\d/) {
  		    $pkg->VERSION($sym); # inherit from UNIVERSAL
  		    # If the version number was the only thing specified
  		    # then we should act as if nothing was specified:
  		    if (@imports == 1) {
  			@imports = @$exports;
  			last;
  		    }
  		    # We need a way to emulate 'use Foo ()' but still
  		    # allow an easy version check: "use Foo 1.23, ''";
  		    if (@imports == 2 and !$imports[1]) {
  			@imports = ();
  			last;
  		    }
  		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
  		    # Last chance - see if they've updated EXPORT_OK since we
  		    # cached it.
  
  		    unless ($cache_is_current) {
  			%$export_cache = ();
  			_rebuild_cache ($pkg, $exports, $export_cache);
  			$cache_is_current = 1;
  		    }
  
  		    if (!$export_cache->{$sym}) {
  			# accumulate the non-exports
  			push @carp,
  			  qq["$sym" is not exported by the $pkg module\n];
  			$oops++;
  		    }
  		}
  	    }
  	}
  	if ($oops) {
  	    require Carp;
  	    Carp::croak("@{carp}Can't continue after import errors");
  	}
      }
      else {
  	@imports = @$exports;
      }
  
      my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                $Exporter::FailCache{$pkg} ||= {});
  
      if (@$fail) {
  	if (!%$fail_cache) {
  	    # Build cache of symbols. Optimise the lookup by adding
  	    # barewords twice... both with and without a leading &.
  	    # (Technique could be applied to $export_cache at cost of memory)
  	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
  	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
  	    @{$fail_cache}{@expanded} = (1) x @expanded;
  	}
  	my @failed;
  	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
  	if (@failed) {
  	    @failed = $pkg->export_fail(@failed);
  	    foreach $sym (@failed) {
                  require Carp;
  		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
  			"on this architecture");
  	    }
  	    if (@failed) {
  		require Carp;
  		Carp::croak("Can't continue after import errors");
  	    }
  	}
      }
  
      warn "Importing into $callpkg from $pkg: ",
  		join(", ",sort @imports) if $Exporter::Verbose;
  
      foreach $sym (@imports) {
  	# shortcut for the common case of no type character
  	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
  	    unless $sym =~ s/^(\W)//;
  	$type = $1;
  	no warnings 'once';
  	*{"${callpkg}::$sym"} =
  	    $type eq '&' ? \&{"${pkg}::$sym"} :
  	    $type eq '$' ? \${"${pkg}::$sym"} :
  	    $type eq '@' ? \@{"${pkg}::$sym"} :
  	    $type eq '%' ? \%{"${pkg}::$sym"} :
  	    $type eq '*' ?  *{"${pkg}::$sym"} :
  	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
      }
  }
  
  sub heavy_export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;			# XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  # Utility functions
  
  sub _push_tags {
      my($pkg, $var, $syms) = @_;
      my @nontag = ();
      my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
      push(@{"${pkg}::$var"},
  	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                   : scalar(push(@nontag,$_),$_) }
  		(@$syms) ? @$syms : keys %$export_tags);
      if (@nontag and $^W) {
  	# This may change to a die one day
  	require Carp;
  	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
      }
  }
  
  sub heavy_require_version {
      my($self, $wanted) = @_;
      my $pkg = ref $self || $self;
      return ${pkg}->VERSION($wanted);
  }
  
  sub heavy_export_tags {
    _push_tags((caller)[0], "EXPORT",    \@_);
  }
  
  sub heavy_export_ok_tags {
    _push_tags((caller)[0], "EXPORT_OK", \@_);
  }
  
  1;
EXPORTER_HEAVY

$fatpacked{"ExtUtils/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND';
  package ExtUtils::Command;
  
  use 5.00503;
  use strict;
  require Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  @ISA       = qw(Exporter);
  @EXPORT    = qw(cp rm_f rm_rf mv cat eqtime mkpath touch test_f test_d chmod
                  dos2unix);
  $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  my $Is_VMS   = $^O eq 'VMS';
  my $Is_VMS_mode = $Is_VMS;
  my $Is_VMS_noefs = $Is_VMS;
  my $Is_Win32 = $^O eq 'MSWin32';
  
  if( $Is_VMS ) {
      my $vms_unix_rpt;
      my $vms_efs;
      my $vms_case;
  
      if (eval { local $SIG{__DIE__};
                 local @INC = @INC;
                 pop @INC if $INC[-1] eq '.';
                 require VMS::Feature; }) {
          $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
          $vms_efs = VMS::Feature::current("efs_charset");
          $vms_case = VMS::Feature::current("efs_case_preserve");
      } else {
          my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
          my $efs_case = $ENV{'DECC$EFS_CASE_PRESERVE'} || '';
          $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i;
          $vms_efs = $efs_charset =~ /^[ET1]/i;
          $vms_case = $efs_case =~ /^[ET1]/i;
      }
      $Is_VMS_mode = 0 if $vms_unix_rpt;
      $Is_VMS_noefs = 0 if ($vms_efs);
  }
  
  
  =head1 NAME
  
  ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.
  
  =head1 SYNOPSIS
  
    perl -MExtUtils::Command -e cat files... > destination
    perl -MExtUtils::Command -e mv source... destination
    perl -MExtUtils::Command -e cp source... destination
    perl -MExtUtils::Command -e touch files...
    perl -MExtUtils::Command -e rm_f files...
    perl -MExtUtils::Command -e rm_rf directories...
    perl -MExtUtils::Command -e mkpath directories...
    perl -MExtUtils::Command -e eqtime source destination
    perl -MExtUtils::Command -e test_f file
    perl -MExtUtils::Command -e test_d directory
    perl -MExtUtils::Command -e chmod mode files...
    ...
  
  =head1 DESCRIPTION
  
  The module is used to replace common UNIX commands.  In all cases the
  functions work from @ARGV rather than taking arguments.  This makes
  them easier to deal with in Makefiles.  Call them like this:
  
    perl -MExtUtils::Command -e some_command some files to work on
  
  and I<NOT> like this:
  
    perl -MExtUtils::Command -e 'some_command qw(some files to work on)'
  
  For that use L<Shell::Command>.
  
  Filenames with * and ? will be glob expanded.
  
  
  =head2 FUNCTIONS
  
  =over 4
  
  =cut
  
  # VMS uses % instead of ? to mean "one character"
  my $wild_regex = $Is_VMS ? '*%' : '*?';
  sub expand_wildcards
  {
   @ARGV = map(/[$wild_regex]/o ? glob($_) : $_,@ARGV);
  }
  
  
  =item cat
  
      cat file ...
  
  Concatenates all files mentioned on command line to STDOUT.
  
  =cut
  
  sub cat ()
  {
   expand_wildcards();
   print while (<>);
  }
  
  =item eqtime
  
      eqtime source destination
  
  Sets modified time of destination to that of source.
  
  =cut
  
  sub eqtime
  {
   my ($src,$dst) = @ARGV;
   local @ARGV = ($dst);  touch();  # in case $dst doesn't exist
   utime((stat($src))[8,9],$dst);
  }
  
  =item rm_rf
  
      rm_rf files or directories ...
  
  Removes files and directories - recursively (even if readonly)
  
  =cut
  
  sub rm_rf
  {
   expand_wildcards();
   require File::Path;
   File::Path::rmtree([grep -e $_,@ARGV],0,0);
  }
  
  =item rm_f
  
      rm_f file ...
  
  Removes files (even if readonly)
  
  =cut
  
  sub rm_f {
      expand_wildcards();
  
      foreach my $file (@ARGV) {
          next unless -f $file;
  
          next if _unlink($file);
  
          chmod(0777, $file);
  
          next if _unlink($file);
  
          require Carp;
          Carp::carp("Cannot delete $file: $!");
      }
  }
  
  sub _unlink {
      my $files_unlinked = 0;
      foreach my $file (@_) {
          my $delete_count = 0;
          $delete_count++ while unlink $file;
          $files_unlinked++ if $delete_count;
      }
      return $files_unlinked;
  }
  
  
  =item touch
  
      touch file ...
  
  Makes files exist, with current timestamp
  
  =cut
  
  sub touch {
      my $t    = time;
      expand_wildcards();
      foreach my $file (@ARGV) {
          open(FILE,">>$file") || die "Cannot write $file:$!";
          close(FILE);
          utime($t,$t,$file);
      }
  }
  
  =item mv
  
      mv source_file destination_file
      mv source_file source_file destination_dir
  
  Moves source to destination.  Multiple sources are allowed if
  destination is an existing directory.
  
  Returns true if all moves succeeded, false otherwise.
  
  =cut
  
  sub mv {
      expand_wildcards();
      my @src = @ARGV;
      my $dst = pop @src;
  
      if (@src > 1 && ! -d $dst) {
          require Carp;
          Carp::croak("Too many arguments");
      }
  
      require File::Copy;
      my $nok = 0;
      foreach my $src (@src) {
          $nok ||= !File::Copy::move($src,$dst);
      }
      return !$nok;
  }
  
  =item cp
  
      cp source_file destination_file
      cp source_file source_file destination_dir
  
  Copies sources to the destination.  Multiple sources are allowed if
  destination is an existing directory.
  
  Returns true if all copies succeeded, false otherwise.
  
  =cut
  
  sub cp {
      expand_wildcards();
      my @src = @ARGV;
      my $dst = pop @src;
  
      if (@src > 1 && ! -d $dst) {
          require Carp;
          Carp::croak("Too many arguments");
      }
  
      require File::Copy;
      my $nok = 0;
      foreach my $src (@src) {
          $nok ||= !File::Copy::copy($src,$dst);
  
          # Win32 does not update the mod time of a copied file, just the
          # created time which make does not look at.
          utime(time, time, $dst) if $Is_Win32;
      }
      return $nok;
  }
  
  =item chmod
  
      chmod mode files ...
  
  Sets UNIX like permissions 'mode' on all the files.  e.g. 0666
  
  =cut
  
  sub chmod {
      local @ARGV = @ARGV;
      my $mode = shift(@ARGV);
      expand_wildcards();
  
      if( $Is_VMS_mode && $Is_VMS_noefs) {
          require File::Spec;
          foreach my $idx (0..$#ARGV) {
              my $path = $ARGV[$idx];
              next unless -d $path;
  
              # chmod 0777, [.foo.bar] doesn't work on VMS, you have to do
              # chmod 0777, [.foo]bar.dir
              my @dirs = File::Spec->splitdir( $path );
              $dirs[-1] .= '.dir';
              $path = File::Spec->catfile(@dirs);
  
              $ARGV[$idx] = $path;
          }
      }
  
      chmod(oct $mode,@ARGV) || die "Cannot chmod ".join(' ',$mode,@ARGV).":$!";
  }
  
  =item mkpath
  
      mkpath directory ...
  
  Creates directories, including any parent directories.
  
  =cut
  
  sub mkpath
  {
   expand_wildcards();
   require File::Path;
   File::Path::mkpath([@ARGV],0,0777);
  }
  
  =item test_f
  
      test_f file
  
  Tests if a file exists.  I<Exits> with 0 if it does, 1 if it does not (ie.
  shell's idea of true and false).
  
  =cut
  
  sub test_f
  {
   exit(-f $ARGV[0] ? 0 : 1);
  }
  
  =item test_d
  
      test_d directory
  
  Tests if a directory exists.  I<Exits> with 0 if it does, 1 if it does
  not (ie. shell's idea of true and false).
  
  =cut
  
  sub test_d
  {
   exit(-d $ARGV[0] ? 0 : 1);
  }
  
  =item dos2unix
  
      dos2unix files or dirs ...
  
  Converts DOS and OS/2 linefeeds to Unix style recursively.
  
  =cut
  
  sub dos2unix {
      require File::Find;
      File::Find::find(sub {
          return if -d;
          return unless -w _;
          return unless -r _;
          return if -B _;
  
          local $\;
  
  	my $orig = $_;
  	my $temp = '.dos2unix_tmp';
  	open ORIG, $_ or do { warn "dos2unix can't open $_: $!"; return };
  	open TEMP, ">$temp" or
  	    do { warn "dos2unix can't create .dos2unix_tmp: $!"; return };
          binmode ORIG; binmode TEMP;
          while (my $line = <ORIG>) {
              $line =~ s/\015\012/\012/g;
              print TEMP $line;
          }
  	close ORIG;
  	close TEMP;
  	rename $temp, $orig;
  
      }, @ARGV);
  }
  
  =back
  
  =head1 SEE ALSO
  
  Shell::Command which is these same functions but take arguments normally.
  
  
  =head1 AUTHOR
  
  Nick Ing-Simmons C<ni-s@cpan.org>
  
  Maintained by Michael G Schwern C<schwern@pobox.com> within the
  ExtUtils-MakeMaker package and, as a separate CPAN package, by
  Randy Kobes C<r.kobes@uwinnipeg.ca>.
  
  =cut
  
EXTUTILS_COMMAND

$fatpacked{"ExtUtils/Command/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND_MM';
  package ExtUtils::Command::MM;
  
  require 5.006;
  
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT  = qw(test_harness pod2man perllocal_install uninstall
                    warn_if_old_packlist test_s cp_nonempty);
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  my $Is_VMS = $^O eq 'VMS';
  
  sub mtime {
    no warnings 'redefine';
    local $@;
    *mtime = (eval { require Time::HiRes } && defined &Time::HiRes::stat)
      ? sub { (Time::HiRes::stat($_[0]))[9] }
      : sub { (             stat($_[0]))[9] }
    ;
    goto &mtime;
  }
  
  =head1 NAME
  
  ExtUtils::Command::MM - Commands for the MM's to use in Makefiles
  
  =head1 SYNOPSIS
  
    perl "-MExtUtils::Command::MM" -e "function" "--" arguments...
  
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY!>  The interface is not stable.
  
  ExtUtils::Command::MM encapsulates code which would otherwise have to
  be done with large "one" liners.
  
  Any $(FOO) used in the examples are make variables, not Perl.
  
  =over 4
  
  =item B<test_harness>
  
    test_harness($verbose, @test_libs);
  
  Runs the tests on @ARGV via Test::Harness passing through the $verbose
  flag.  Any @test_libs will be unshifted onto the test's @INC.
  
  @test_libs are run in alphabetical order.
  
  =cut
  
  sub test_harness {
      require Test::Harness;
      require File::Spec;
  
      $Test::Harness::verbose = shift;
  
      # Because Windows doesn't do this for us and listing all the *.t files
      # out on the command line can blow over its exec limit.
      require ExtUtils::Command;
      my @argv = ExtUtils::Command::expand_wildcards(@ARGV);
  
      local @INC = @INC;
      unshift @INC, map { File::Spec->rel2abs($_) } @_;
      Test::Harness::runtests(sort { lc $a cmp lc $b } @argv);
  }
  
  
  
  =item B<pod2man>
  
    pod2man( '--option=value',
             $podfile1 => $manpage1,
             $podfile2 => $manpage2,
             ...
           );
  
    # or args on @ARGV
  
  pod2man() is a function performing most of the duties of the pod2man
  program.  Its arguments are exactly the same as pod2man as of 5.8.0
  with the addition of:
  
      --perm_rw   octal permission to set the resulting manpage to
  
  And the removal of:
  
      --verbose/-v
      --help/-h
  
  If no arguments are given to pod2man it will read from @ARGV.
  
  If Pod::Man is unavailable, this function will warn and return undef.
  
  =cut
  
  sub pod2man {
      local @ARGV = @_ ? @_ : @ARGV;
  
      {
          local $@;
          if( !eval { require Pod::Man } ) {
              warn "Pod::Man is not available: $@".
                   "Man pages will not be generated during this install.\n";
              return 0;
          }
      }
      require Getopt::Long;
  
      # We will cheat and just use Getopt::Long.  We fool it by putting
      # our arguments into @ARGV.  Should be safe.
      my %options = ();
      Getopt::Long::config ('bundling_override');
      Getopt::Long::GetOptions (\%options,
                  'section|s=s', 'release|r=s', 'center|c=s',
                  'date|d=s', 'fixed=s', 'fixedbold=s', 'fixeditalic=s',
                  'fixedbolditalic=s', 'official|o', 'quotes|q=s', 'lax|l',
                  'name|n=s', 'perm_rw=i', 'utf8|u'
      );
      delete $options{utf8} unless $Pod::Man::VERSION >= 2.17;
  
      # If there's no files, don't bother going further.
      return 0 unless @ARGV;
  
      # Official sets --center, but don't override things explicitly set.
      if ($options{official} && !defined $options{center}) {
          $options{center} = q[Perl Programmer's Reference Guide];
      }
  
      # This isn't a valid Pod::Man option and is only accepted for backwards
      # compatibility.
      delete $options{lax};
      my $count = scalar @ARGV / 2;
      my $plural = $count == 1 ? 'document' : 'documents';
      print "Manifying $count pod $plural\n";
  
      do {{  # so 'next' works
          my ($pod, $man) = splice(@ARGV, 0, 2);
  
          next if ((-e $man) &&
                   (mtime($man) > mtime($pod)) &&
                   (mtime($man) > mtime("Makefile")));
  
          my $parser = Pod::Man->new(%options);
          $parser->parse_from_file($pod, $man)
            or do { warn("Could not install $man\n");  next };
  
          if (exists $options{perm_rw}) {
              chmod(oct($options{perm_rw}), $man)
                or do { warn("chmod $options{perm_rw} $man: $!\n"); next };
          }
      }} while @ARGV;
  
      return 1;
  }
  
  
  =item B<warn_if_old_packlist>
  
    perl "-MExtUtils::Command::MM" -e warn_if_old_packlist <somefile>
  
  Displays a warning that an old packlist file was found.  Reads the
  filename from @ARGV.
  
  =cut
  
  sub warn_if_old_packlist {
      my $packlist = $ARGV[0];
  
      return unless -f $packlist;
      print <<"PACKLIST_WARNING";
  WARNING: I have found an old package in
      $packlist.
  Please make sure the two installations are not conflicting
  PACKLIST_WARNING
  
  }
  
  
  =item B<perllocal_install>
  
      perl "-MExtUtils::Command::MM" -e perllocal_install
          <type> <module name> <key> <value> ...
  
      # VMS only, key|value pairs come on STDIN
      perl "-MExtUtils::Command::MM" -e perllocal_install
          <type> <module name> < <key>|<value> ...
  
  Prints a fragment of POD suitable for appending to perllocal.pod.
  Arguments are read from @ARGV.
  
  'type' is the type of what you're installing.  Usually 'Module'.
  
  'module name' is simply the name of your module.  (Foo::Bar)
  
  Key/value pairs are extra information about the module.  Fields include:
  
      installed into      which directory your module was out into
      LINKTYPE            dynamic or static linking
      VERSION             module version number
      EXE_FILES           any executables installed in a space separated
                          list
  
  =cut
  
  sub perllocal_install {
      my($type, $name) = splice(@ARGV, 0, 2);
  
      # VMS feeds args as a piped file on STDIN since it usually can't
      # fit all the args on a single command line.
      my @mod_info = $Is_VMS ? split /\|/, <STDIN>
                             : @ARGV;
  
      my $pod;
      my $time = gmtime($ENV{SOURCE_DATE_EPOCH} || time);
      $pod = sprintf <<'POD', scalar($time), $type, $name, $name;
   =head2 %s: C<%s> L<%s|%s>
  
   =over 4
  
  POD
  
      do {
          my($key, $val) = splice(@mod_info, 0, 2);
  
          $pod .= <<POD
   =item *
  
   C<$key: $val>
  
  POD
  
      } while(@mod_info);
  
      $pod .= "=back\n\n";
      $pod =~ s/^ //mg;
      print $pod;
  
      return 1;
  }
  
  =item B<uninstall>
  
      perl "-MExtUtils::Command::MM" -e uninstall <packlist>
  
  A wrapper around ExtUtils::Install::uninstall().  Warns that
  uninstallation is deprecated and doesn't actually perform the
  uninstallation.
  
  =cut
  
  sub uninstall {
      my($packlist) = shift @ARGV;
  
      require ExtUtils::Install;
  
      print <<'WARNING';
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  We will show what would have been done.
  
  WARNING
  
      ExtUtils::Install::uninstall($packlist, 1, 1);
  
      print <<'WARNING';
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  Please check the list above carefully, there may be errors.
  Remove the appropriate files manually.
  Sorry for the inconvenience.
  
  WARNING
  
  }
  
  =item B<test_s>
  
     perl "-MExtUtils::Command::MM" -e test_s <file>
  
  Tests if a file exists and is not empty (size > 0).
  I<Exits> with 0 if it does, 1 if it does not.
  
  =cut
  
  sub test_s {
    exit(-s $ARGV[0] ? 0 : 1);
  }
  
  =item B<cp_nonempty>
  
    perl "-MExtUtils::Command::MM" -e cp_nonempty <srcfile> <dstfile> <perm>
  
  Tests if the source file exists and is not empty (size > 0). If it is not empty
  it copies it to the given destination with the given permissions.
  
  =back
  
  =cut
  
  sub cp_nonempty {
    my @args = @ARGV;
    return 0 unless -s $args[0];
    require ExtUtils::Command;
    {
      local @ARGV = @args[0,1];
      ExtUtils::Command::cp(@ARGV);
    }
    {
      local @ARGV = @args[2,1];
      ExtUtils::Command::chmod(@ARGV);
    }
  }
  
  
  1;
EXTUTILS_COMMAND_MM

$fatpacked{"ExtUtils/Liblist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST';
  package ExtUtils::Liblist;
  
  use strict;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  use File::Spec;
  require ExtUtils::Liblist::Kid;
  our @ISA = qw(ExtUtils::Liblist::Kid File::Spec);
  
  # Backwards compatibility with old interface.
  sub ext {
      goto &ExtUtils::Liblist::Kid::ext;
  }
  
  sub lsdir {
    shift;
    my $rex = qr/$_[1]/;
    opendir my $dir_fh, $_[0];
    my @out = grep /$rex/, readdir $dir_fh;
    closedir $dir_fh;
    return @out;
  }
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Liblist - determine libraries to use and how to use them
  
  =head1 SYNOPSIS
  
    require ExtUtils::Liblist;
  
    $MM->ext($potential_libs, $verbose, $need_names);
  
    # Usually you can get away with:
    ExtUtils::Liblist->ext($potential_libs, $verbose, $need_names)
  
  =head1 DESCRIPTION
  
  This utility takes a list of libraries in the form C<-llib1 -llib2
  -llib3> and returns lines suitable for inclusion in an extension
  Makefile.  Extra library paths may be included with the form
  C<-L/another/path> this will affect the searches for all subsequent
  libraries.
  
  It returns an array of four or five scalar values: EXTRALIBS,
  BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to
  the array of the filenames of actual libraries.  Some of these don't
  mean anything unless on Unix.  See the details about those platform
  specifics below.  The list of the filenames is returned only if
  $need_names argument is true.
  
  Dependent libraries can be linked in one of three ways:
  
  =over 2
  
  =item * For static extensions
  
  by the ld command when the perl binary is linked with the extension
  library. See EXTRALIBS below.
  
  =item * For dynamic extensions at build/link time
  
  by the ld command when the shared object is built/linked. See
  LDLOADLIBS below.
  
  =item * For dynamic extensions at load time
  
  by the DynaLoader when the shared object is loaded. See BSLOADLIBS
  below.
  
  =back
  
  =head2 EXTRALIBS
  
  List of libraries that need to be linked with when linking a perl
  binary which includes this extension. Only those libraries that
  actually exist are included.  These are written to a file and used
  when linking perl.
  
  =head2 LDLOADLIBS and LD_RUN_PATH
  
  List of those libraries which can or must be linked into the shared
  library when created using ld. These may be static or dynamic
  libraries.  LD_RUN_PATH is a colon separated list of the directories
  in LDLOADLIBS. It is passed as an environment variable to the process
  that links the shared library.
  
  =head2 BSLOADLIBS
  
  List of those libraries that are needed but can be linked in
  dynamically at run time on this platform.  SunOS/Solaris does not need
  this because ld records the information (from LDLOADLIBS) into the
  object file.  This list is used to create a .bs (bootstrap) file.
  
  =head1 PORTABILITY
  
  This module deals with a lot of system dependencies and has quite a
  few architecture specific C<if>s in the code.
  
  =head2 VMS implementation
  
  The version of ext() which is executed under VMS differs from the
  Unix-OS/2 version in several respects:
  
  =over 2
  
  =item *
  
  Input library and path specifications are accepted with or without the
  C<-l> and C<-L> prefixes used by Unix linkers.  If neither prefix is
  present, a token is considered a directory to search if it is in fact
  a directory, and a library to search for otherwise.  Authors who wish
  their extensions to be portable to Unix or OS/2 should use the Unix
  prefixes, since the Unix-OS/2 version of ext() requires them.
  
  =item *
  
  Wherever possible, shareable images are preferred to object libraries,
  and object libraries to plain object files.  In accordance with VMS
  naming conventions, ext() looks for files named I<lib>shr and I<lib>rtl;
  it also looks for I<lib>lib and libI<lib> to accommodate Unix conventions
  used in some ported software.
  
  =item *
  
  For each library that is found, an appropriate directive for a linker options
  file is generated.  The return values are space-separated strings of
  these directives, rather than elements used on the linker command line.
  
  =item *
  
  LDLOADLIBS contains both the libraries found based on C<$potential_libs> and
  the CRTLs, if any, specified in Config.pm.  EXTRALIBS contains just those
  libraries found based on C<$potential_libs>.  BSLOADLIBS and LD_RUN_PATH
  are always empty.
  
  =back
  
  In addition, an attempt is made to recognize several common Unix library
  names, and filter them out or convert them to their VMS equivalents, as
  appropriate.
  
  In general, the VMS version of ext() should properly handle input from
  extensions originally designed for a Unix or VMS environment.  If you
  encounter problems, or discover cases where the search could be improved,
  please let us know.
  
  =head2 Win32 implementation
  
  The version of ext() which is executed under Win32 differs from the
  Unix-OS/2 version in several respects:
  
  =over 2
  
  =item *
  
  If C<$potential_libs> is empty, the return value will be empty.
  Otherwise, the libraries specified by C<$Config{perllibs}> (see Config.pm)
  will be appended to the list of C<$potential_libs>.  The libraries
  will be searched for in the directories specified in C<$potential_libs>,
  C<$Config{libpth}>, and in C<$Config{installarchlib}/CORE>.
  For each library that is found,  a space-separated list of fully qualified
  library pathnames is generated.
  
  =item *
  
  Input library and path specifications are accepted with or without the
  C<-l> and C<-L> prefixes used by Unix linkers.
  
  An entry of the form C<-La:\foo> specifies the C<a:\foo> directory to look
  for the libraries that follow.
  
  An entry of the form C<-lfoo> specifies the library C<foo>, which may be
  spelled differently depending on what kind of compiler you are using.  If
  you are using GCC, it gets translated to C<libfoo.a>, but for other win32
  compilers, it becomes C<foo.lib>.  If no files are found by those translated
  names, one more attempt is made to find them using either C<foo.a> or
  C<libfoo.lib>, depending on whether GCC or some other win32 compiler is
  being used, respectively.
  
  If neither the C<-L> or C<-l> prefix is present in an entry, the entry is
  considered a directory to search if it is in fact a directory, and a
  library to search for otherwise.  The C<$Config{lib_ext}> suffix will
  be appended to any entries that are not directories and don't already have
  the suffix.
  
  Note that the C<-L> and C<-l> prefixes are B<not required>, but authors
  who wish their extensions to be portable to Unix or OS/2 should use the
  prefixes, since the Unix-OS/2 version of ext() requires them.
  
  =item *
  
  Entries cannot be plain object files, as many Win32 compilers will
  not handle object files in the place of libraries.
  
  =item *
  
  Entries in C<$potential_libs> beginning with a colon and followed by
  alphanumeric characters are treated as flags.  Unknown flags will be ignored.
  
  An entry that matches C</:nodefault/i> disables the appending of default
  libraries found in C<$Config{perllibs}> (this should be only needed very rarely).
  
  An entry that matches C</:nosearch/i> disables all searching for
  the libraries specified after it.  Translation of C<-Lfoo> and
  C<-lfoo> still happens as appropriate (depending on compiler being used,
  as reflected by C<$Config{cc}>), but the entries are not verified to be
  valid files or directories.
  
  An entry that matches C</:search/i> reenables searching for
  the libraries specified after it.  You can put it at the end to
  enable searching for default libraries specified by C<$Config{perllibs}>.
  
  =item *
  
  The libraries specified may be a mixture of static libraries and
  import libraries (to link with DLLs).  Since both kinds are used
  pretty transparently on the Win32 platform, we do not attempt to
  distinguish between them.
  
  =item *
  
  LDLOADLIBS and EXTRALIBS are always identical under Win32, and BSLOADLIBS
  and LD_RUN_PATH are always empty (this may change in future).
  
  =item *
  
  You must make sure that any paths and path components are properly
  surrounded with double-quotes if they contain spaces. For example,
  C<$potential_libs> could be (literally):
  
  	"-Lc:\Program Files\vc\lib" msvcrt.lib "la test\foo bar.lib"
  
  Note how the first and last entries are protected by quotes in order
  to protect the spaces.
  
  =item *
  
  Since this module is most often used only indirectly from extension
  C<Makefile.PL> files, here is an example C<Makefile.PL> entry to add
  a library to the build process for an extension:
  
          LIBS => ['-lgl']
  
  When using GCC, that entry specifies that MakeMaker should first look
  for C<libgl.a> (followed by C<gl.a>) in all the locations specified by
  C<$Config{libpth}>.
  
  When using a compiler other than GCC, the above entry will search for
  C<gl.lib> (followed by C<libgl.lib>).
  
  If the library happens to be in a location not in C<$Config{libpth}>,
  you need:
  
          LIBS => ['-Lc:\gllibs -lgl']
  
  Here is a less often used example:
  
          LIBS => ['-lgl', ':nosearch -Ld:\mesalibs -lmesa -luser32']
  
  This specifies a search for library C<gl> as before.  If that search
  fails to find the library, it looks at the next item in the list. The
  C<:nosearch> flag will prevent searching for the libraries that follow,
  so it simply returns the value as C<-Ld:\mesalibs -lmesa -luser32>,
  since GCC can use that value as is with its linker.
  
  When using the Visual C compiler, the second item is returned as
  C<-libpath:d:\mesalibs mesa.lib user32.lib>.
  
  When using the Borland compiler, the second item is returned as
  C<-Ld:\mesalibs mesa.lib user32.lib>, and MakeMaker takes care of
  moving the C<-Ld:\mesalibs> to the correct place in the linker
  command line.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
EXTUTILS_LIBLIST

$fatpacked{"ExtUtils/Liblist/Kid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST_KID';
  package ExtUtils::Liblist::Kid;
  
  # XXX Splitting this out into its own .pm is a temporary solution.
  
  # This kid package is to be used by MakeMaker.  It will not work if
  # $self is not a Makemaker.
  
  use 5.006;
  
  # Broken out of MakeMaker from version 4.11
  
  use strict;
  use warnings;
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  use ExtUtils::MakeMaker::Config;
  use Cwd 'cwd';
  use File::Basename;
  use File::Spec;
  
  sub ext {
      if    ( $^O eq 'VMS' )     { return &_vms_ext; }
      elsif ( $^O eq 'MSWin32' ) { return &_win32_ext; }
      else                       { return &_unix_os2_ext; }
  }
  
  sub _unix_os2_ext {
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      if ( $^O =~ /os2|android/ and $Config{perllibs} ) {
  
          # Dynamic libraries are not transitive, so we may need including
          # the libraries linked against perl.dll/libperl.so again.
  
          $potential_libs .= " " if $potential_libs;
          $potential_libs .= $Config{perllibs};
      }
      return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
      warn "Potential libraries are '$potential_libs':\n" if $verbose;
  
      my ( $so ) = $Config{so};
      my ( $libs ) = defined $Config{perllibs} ? $Config{perllibs} : $Config{libs};
      my $Config_libext = $Config{lib_ext} || ".a";
      my $Config_dlext = $Config{dlext};
  
      # compute $extralibs, $bsloadlibs and $ldloadlibs from
      # $potential_libs
      # this is a rewrite of Andy Dougherty's extliblist in perl
  
      require Text::ParseWords;
  
      my ( @searchpath );    # from "-L/path" entries in $potential_libs
      my ( @libpath ) = Text::ParseWords::quotewords( '\s+', 0, $Config{'libpth'} || '' );
      my ( @ldloadlibs, @bsloadlibs, @extralibs, @ld_run_path, %ld_run_path_seen );
      my ( @libs,       %libs_seen );
      my ( $fullname,   @fullname );
      my ( $pwd )   = cwd();    # from Cwd.pm
      my ( $found ) = 0;
  
      if ( $^O eq 'darwin' or $^O eq 'next' )  {
          # 'escape' Mach-O ld -framework and -F flags, so they aren't dropped later on
          $potential_libs =~ s/(^|\s)(-(?:weak_|reexport_|lazy_)?framework)\s+(\S+)/$1-Wl,$2 -Wl,$3/g;
          $potential_libs =~ s/(^|\s)(-F)\s*(\S+)/$1-Wl,$2 -Wl,$3/g;
      }
  
      foreach my $thislib ( Text::ParseWords::quotewords( '\s+', 0, $potential_libs) ) {
          my ( $custom_name ) = '';
  
          # Handle possible linker path arguments.
          if ( $thislib =~ s/^(-[LR]|-Wl,-R|-Wl,-rpath,)// ) {    # save path flag type
              my ( $ptype ) = $1;
              unless ( -d $thislib ) {
                  warn "$ptype$thislib ignored, directory does not exist\n"
                    if $verbose;
                  next;
              }
              my ( $rtype ) = $ptype;
              if ( ( $ptype eq '-R' ) or ( $ptype =~ m!^-Wl,-[Rr]! ) ) {
                  if ( $Config{'lddlflags'} =~ /-Wl,-[Rr]/ ) {
                      $rtype = '-Wl,-R';
                  }
                  elsif ( $Config{'lddlflags'} =~ /-R/ ) {
                      $rtype = '-R';
                  }
              }
              unless ( File::Spec->file_name_is_absolute( $thislib ) ) {
                  warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";
                  $thislib = $self->catdir( $pwd, $thislib );
              }
              push( @searchpath, $thislib );
              $thislib = qq{"$thislib"} if $thislib =~ / /; # protect spaces if there
              push( @extralibs,  "$ptype$thislib" );
              push( @ldloadlibs, "$rtype$thislib" );
              next;
          }
  
          if ( $thislib =~ m!^-Wl,! ) {
              push( @extralibs,  $thislib );
              push( @ldloadlibs, $thislib );
              next;
          }
  
          # Handle possible library arguments.
          if ( $thislib =~ s/^-l(:)?// ) {
              # Handle -l:foo.so, which means that the library will
              # actually be called foo.so, not libfoo.so.  This
              # is used in Android by ExtUtils::Depends to allow one XS
              # module to link to another.
              $custom_name = $1 || '';
          }
          else {
              warn "Unrecognized argument in LIBS ignored: '$thislib'\n";
              next;
          }
  
          my ( $found_lib ) = 0;
          foreach my $thispth ( @searchpath, @libpath ) {
  
              # Try to find the full name of the library.  We need this to
              # determine whether it's a dynamically-loadable library or not.
              # This tends to be subject to various os-specific quirks.
              # For gcc-2.6.2 on linux (March 1995), DLD can not load
              # .sa libraries, with the exception of libm.sa, so we
              # deliberately skip them.
              if ((@fullname =
                   $self->lsdir($thispth, "^\Qlib$thislib.$so.\E[0-9]+")) ||
                  (@fullname =
                   $self->lsdir($thispth, "^\Qlib$thislib.\E[0-9]+\Q\.$so"))) {
                  # Take care that libfoo.so.10 wins against libfoo.so.9.
                  # Compare two libraries to find the most recent version
                  # number.  E.g.  if you have libfoo.so.9.0.7 and
                  # libfoo.so.10.1, first convert all digits into two
                  # decimal places.  Then we'll add ".00" to the shorter
                  # strings so that we're comparing strings of equal length
                  # Thus we'll compare libfoo.so.09.07.00 with
                  # libfoo.so.10.01.00.  Some libraries might have letters
                  # in the version.  We don't know what they mean, but will
                  # try to skip them gracefully -- we'll set any letter to
                  # '0'.  Finally, sort in reverse so we can take the
                  # first element.
  
                  #TODO: iterate through the directory instead of sorting
  
                  $fullname = "$thispth/" . (
                      sort {
                          my ( $ma ) = $a;
                          my ( $mb ) = $b;
                          $ma =~ tr/A-Za-z/0/s;
                          $ma =~ s/\b(\d)\b/0$1/g;
                          $mb =~ tr/A-Za-z/0/s;
                          $mb =~ s/\b(\d)\b/0$1/g;
                          while ( length( $ma ) < length( $mb ) ) { $ma .= ".00"; }
                          while ( length( $mb ) < length( $ma ) ) { $mb .= ".00"; }
  
                          # Comparison deliberately backwards
                          $mb cmp $ma;
                        } @fullname
                  )[0];
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib.$so" )
                  && ( ( $Config{'dlsrc'} ne "dl_dld.xs" ) || ( $thislib eq "m" ) ) )
              {
              }
              elsif (-f ( $fullname = "$thispth/lib${thislib}_s$Config_libext" )
                  && ( $Config{'archname'} !~ /RM\d\d\d-svr4/ )
                  && ( $thislib .= "_s" ) )
              {    # we must explicitly use _s version
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib$Config_libext" ) ) {
              }
              elsif ( defined( $Config_dlext )
                  && -f ( $fullname = "$thispth/lib$thislib.$Config_dlext" ) )
              {
              }
              elsif ( -f ( $fullname = "$thispth/$thislib$Config_libext" ) ) {
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib.dll$Config_libext" ) ) {
              }
              elsif ( $^O eq 'cygwin' && -f ( $fullname = "$thispth/$thislib.dll" ) ) {
              }
              elsif ( -f ( $fullname = "$thispth/Slib$thislib$Config_libext" ) ) {
              }
              elsif ($^O eq 'dgux'
                  && -l ( $fullname = "$thispth/lib$thislib$Config_libext" )
                  && readlink( $fullname ) =~ /^elink:/s )
              {
  
                  # Some of DG's libraries look like misconnected symbolic
                  # links, but development tools can follow them.  (They
                  # look like this:
                  #
                  #    libm.a -> elink:${SDE_PATH:-/usr}/sde/\
                  #    ${TARGET_BINARY_INTERFACE:-m88kdgux}/usr/lib/libm.a
                  #
                  # , the compilation tools expand the environment variables.)
              }
              elsif ( $custom_name && -f ( $fullname = "$thispth/$thislib" ) ) {
              }
              else {
                  warn "$thislib not found in $thispth\n" if $verbose;
                  next;
              }
              warn "'-l$thislib' found at $fullname\n" if $verbose;
              push @libs, $fullname unless $libs_seen{$fullname}++;
              $found++;
              $found_lib++;
  
              # Now update library lists
  
              # what do we know about this library...
              my $is_dyna = ( $fullname !~ /\Q$Config_libext\E\z/ );
              my $in_perl = ( $libs =~ /\B-l:?\Q${thislib}\E\b/s );
  
              # include the path to the lib once in the dynamic linker path
              # but only if it is a dynamic lib and not in Perl itself
              my ( $fullnamedir ) = dirname( $fullname );
              push @ld_run_path, $fullnamedir
                if $is_dyna
                    && !$in_perl
                    && !$ld_run_path_seen{$fullnamedir}++;
  
              # Do not add it into the list if it is already linked in
              # with the main perl executable.
              # We have to special-case the NeXT, because math and ndbm
              # are both in libsys_s
              unless (
                  $in_perl
                  || ( $Config{'osname'} eq 'next'
                      && ( $thislib eq 'm' || $thislib eq 'ndbm' ) )
                )
              {
                  push( @extralibs, "-l$custom_name$thislib" );
              }
  
              # We might be able to load this archive file dynamically
              if (   ( $Config{'dlsrc'} =~ /dl_next/ && $Config{'osvers'} lt '4_0' )
                  || ( $Config{'dlsrc'} =~ /dl_dld/ ) )
              {
  
                  # We push -l$thislib instead of $fullname because
                  # it avoids hardwiring a fixed path into the .bs file.
                  # Mkbootstrap will automatically add dl_findfile() to
                  # the .bs file if it sees a name in the -l format.
                  # USE THIS, when dl_findfile() is fixed:
                  # push(@bsloadlibs, "-l$thislib");
                  # OLD USE WAS while checking results against old_extliblist
                  push( @bsloadlibs, "$fullname" );
              }
              else {
                  if ( $is_dyna ) {
  
                      # For SunOS4, do not add in this shared library if
                      # it is already linked in the main perl executable
                      push( @ldloadlibs, "-l$custom_name$thislib" )
                        unless ( $in_perl and $^O eq 'sunos' );
                  }
                  else {
                      push( @ldloadlibs, "-l$custom_name$thislib" );
                  }
              }
              last;    # found one here so don't bother looking further
          }
          warn "Warning (mostly harmless): " . "No library found for -l$thislib\n"
            unless $found_lib > 0;
      }
  
      unless ( $found ) {
          return ( '', '', '', '', ( $give_libs ? \@libs : () ) );
      }
      else {
          return ( "@extralibs", "@bsloadlibs", "@ldloadlibs", join( ":", @ld_run_path ), ( $give_libs ? \@libs : () ) );
      }
  }
  
  sub _win32_ext {
  
      require Text::ParseWords;
  
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      # If user did not supply a list, we punt.
      # (caller should probably use the list in $Config{libs})
      return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
  
      # TODO: make this use MM_Win32.pm's compiler detection
      my %libs_seen;
      my @extralibs;
      my $cc = $Config{cc} || '';
      my $VC = $cc =~ /\bcl\b/i;
      my $GC = $cc =~ /\bgcc\b/i;
  
      my $libext     = _win32_lib_extensions();
      my @searchpath = ( '' );                                    # from "-L/path" entries in $potential_libs
      my @libpath    = _win32_default_search_paths( $VC, $GC );
      my $pwd        = cwd();                                     # from Cwd.pm
      my $search     = 1;
  
      # compute @extralibs from $potential_libs
      my @lib_search_list = _win32_make_lib_search_list( $potential_libs, $verbose );
      for ( @lib_search_list ) {
  
          my $thislib = $_;
  
          # see if entry is a flag
          if ( /^:\w+$/ ) {
              $search = 0 if lc eq ':nosearch';
              $search = 1 if lc eq ':search';
              _debug( "Ignoring unknown flag '$thislib'\n", $verbose ) if !/^:(no)?(search|default)$/i;
              next;
          }
  
          # if searching is disabled, do compiler-specific translations
          unless ( $search ) {
              s/^-l(.+)$/$1.lib/ unless $GC;
              s/^-L/-libpath:/ if $VC;
              push( @extralibs, $_ );
              next;
          }
  
          # handle possible linker path arguments
          if ( s/^-L// and not -d ) {
              _debug( "$thislib ignored, directory does not exist\n", $verbose );
              next;
          }
          elsif ( -d ) {
              unless ( File::Spec->file_name_is_absolute( $_ ) ) {
                  warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";
                  $_ = $self->catdir( $pwd, $_ );
              }
              push( @searchpath, $_ );
              next;
          }
  
          my @paths = ( @searchpath, @libpath );
          my ( $fullname, $path ) = _win32_search_file( $thislib, $libext, \@paths, $verbose, $GC );
  
          if ( !$fullname ) {
              warn "Warning (mostly harmless): No library found for $thislib\n";
              next;
          }
  
          _debug( "'$thislib' found as '$fullname'\n", $verbose );
          push( @extralibs, $fullname );
          $libs_seen{$fullname} = 1 if $path;    # why is this a special case?
      }
  
      my @libs = sort keys %libs_seen;
  
      return ( '', '', '', '', ( $give_libs ? \@libs : () ) ) unless @extralibs;
  
      # make sure paths with spaces are properly quoted
      @extralibs = map { qq["$_"] } @extralibs;
      @libs      = map { qq["$_"] } @libs;
  
      my $lib = join( ' ', @extralibs );
  
      # normalize back to backward slashes (to help braindead tools)
      # XXX this may break equally braindead GNU tools that don't understand
      # backslashes, either.  Seems like one can't win here.  Cursed be CP/M.
      $lib =~ s,/,\\,g;
  
      _debug( "Result: $lib\n", $verbose );
      wantarray ? ( $lib, '', $lib, '', ( $give_libs ? \@libs : () ) ) : $lib;
  }
  
  sub _win32_make_lib_search_list {
      my ( $potential_libs, $verbose ) = @_;
  
      # If Config.pm defines a set of default libs, we always
      # tack them on to the user-supplied list, unless the user
      # specified :nodefault
      my $libs = $Config{'perllibs'};
      $potential_libs = join( ' ', $potential_libs, $libs ) if $libs and $potential_libs !~ /:nodefault/i;
      _debug( "Potential libraries are '$potential_libs':\n", $verbose );
  
      $potential_libs =~ s,\\,/,g;    # normalize to forward slashes
  
      my @list = Text::ParseWords::quotewords( '\s+', 0, $potential_libs );
  
      return @list;
  }
  
  sub _win32_default_search_paths {
      my ( $VC, $GC ) = @_;
  
      my $libpth = $Config{'libpth'} || '';
      $libpth =~ s,\\,/,g;            # normalize to forward slashes
  
      my @libpath = Text::ParseWords::quotewords( '\s+', 0, $libpth );
      push @libpath, "$Config{installarchlib}/CORE";    # add "$Config{installarchlib}/CORE" to default search path
  
      push @libpath, split /;/, $ENV{LIB}          if $VC and $ENV{LIB};
      push @libpath, split /;/, $ENV{LIBRARY_PATH} if $GC and $ENV{LIBRARY_PATH};
  
      return @libpath;
  }
  
  sub _win32_search_file {
      my ( $thislib, $libext, $paths, $verbose, $GC ) = @_;
  
      my @file_list = _win32_build_file_list( $thislib, $GC, $libext );
  
      for my $lib_file ( @file_list ) {
          for my $path ( @{$paths} ) {
              my $fullname = $lib_file;
              $fullname = "$path\\$fullname" if $path;
  
              return ( $fullname, $path ) if -f $fullname;
  
              _debug( "'$thislib' not found as '$fullname'\n", $verbose );
          }
      }
  
      return;
  }
  
  sub _win32_build_file_list {
      my ( $lib, $GC, $extensions ) = @_;
  
      my @pre_fixed = _win32_build_prefixed_list( $lib, $GC );
      return map _win32_attach_extensions( $_, $extensions ), @pre_fixed;
  }
  
  sub _win32_build_prefixed_list {
      my ( $lib, $GC ) = @_;
  
      return $lib if $lib !~ s/^-l//;
      return $lib if $lib =~ /^lib/ and !$GC;
  
      ( my $no_prefix = $lib ) =~ s/^lib//i;
      $lib = "lib$lib" if $no_prefix eq $lib;
  
      return ( $lib, $no_prefix ) if $GC;
      return ( $no_prefix, $lib );
  }
  
  sub _win32_attach_extensions {
      my ( $lib, $extensions ) = @_;
      return map _win32_try_attach_extension( $lib, $_ ), @{$extensions};
  }
  
  sub _win32_try_attach_extension {
      my ( $lib, $extension ) = @_;
  
      return $lib if $lib =~ /\Q$extension\E$/i;
      return "$lib$extension";
  }
  
  sub _win32_lib_extensions {
      my @extensions;
      push @extensions, $Config{'lib_ext'} if $Config{'lib_ext'};
      push @extensions, '.dll.a' if grep { m!^\.a$! } @extensions;
      push @extensions, '.lib' unless grep { m!^\.lib$! } @extensions;
      return \@extensions;
  }
  
  sub _debug {
      my ( $message, $verbose ) = @_;
      return if !$verbose;
      warn $message;
      return;
  }
  
  sub _vms_ext {
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      my ( @crtls, $crtlstr );
      @crtls = ( ( $Config{'ldflags'} =~ m-/Debug-i ? $Config{'dbgprefix'} : '' ) . 'PerlShr/Share' );
      push( @crtls, grep { not /\(/ } split /\s+/, $Config{'perllibs'} );
      push( @crtls, grep { not /\(/ } split /\s+/, $Config{'libc'} );
  
      # In general, we pass through the basic libraries from %Config unchanged.
      # The one exception is that if we're building in the Perl source tree, and
      # a library spec could be resolved via a logical name, we go to some trouble
      # to insure that the copy in the local tree is used, rather than one to
      # which a system-wide logical may point.
      if ( $self->{PERL_SRC} ) {
          my ( $locspec, $type );
          foreach my $lib ( @crtls ) {
              if ( ( $locspec, $type ) = $lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i ) {
                  if    ( lc $type eq '/share' )   { $locspec .= $Config{'exe_ext'}; }
                  elsif ( lc $type eq '/library' ) { $locspec .= $Config{'lib_ext'}; }
                  else                             { $locspec .= $Config{'obj_ext'}; }
                  $locspec = $self->catfile( $self->{PERL_SRC}, $locspec );
                  $lib = "$locspec$type" if -e $locspec;
              }
          }
      }
      $crtlstr = @crtls ? join( ' ', @crtls ) : '';
  
      unless ( $potential_libs ) {
          warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if $verbose;
          return ( '', '', $crtlstr, '', ( $give_libs ? [] : () ) );
      }
  
      my ( %found, @fndlibs, $ldlib );
      my $cwd = cwd();
      my ( $so, $lib_ext, $obj_ext ) = @Config{ 'so', 'lib_ext', 'obj_ext' };
  
      # List of common Unix library names and their VMS equivalents
      # (VMS equivalent of '' indicates that the library is automatically
      # searched by the linker, and should be skipped here.)
      my ( @flibs, %libs_seen );
      my %libmap = (
          'm'      => '',
          'f77'    => '',
          'F77'    => '',
          'V77'    => '',
          'c'      => '',
          'malloc' => '',
          'crypt'  => '',
          'resolv' => '',
          'c_s'    => '',
          'socket' => '',
          'X11'    => 'DECW$XLIBSHR',
          'Xt'     => 'DECW$XTSHR',
          'Xm'     => 'DECW$XMLIBSHR',
          'Xmu'    => 'DECW$XMULIBSHR'
      );
  
      warn "Potential libraries are '$potential_libs'\n" if $verbose;
  
      # First, sort out directories and library names in the input
      my ( @dirs, @libs );
      foreach my $lib ( split ' ', $potential_libs ) {
          push( @dirs, $1 ),   next if $lib =~ /^-L(.*)/;
          push( @dirs, $lib ), next if $lib =~ /[:>\]]$/;
          push( @dirs, $lib ), next if -d $lib;
          push( @libs, $1 ),   next if $lib =~ /^-l(.*)/;
          push( @libs, $lib );
      }
      push( @dirs, split( ' ', $Config{'libpth'} ) );
  
      # Now make sure we've got VMS-syntax absolute directory specs
      # (We don't, however, check whether someone's hidden a relative
      # path in a logical name.)
      foreach my $dir ( @dirs ) {
          unless ( -d $dir ) {
              warn "Skipping nonexistent Directory $dir\n" if $verbose > 1;
              $dir = '';
              next;
          }
          warn "Resolving directory $dir\n" if $verbose;
          if ( File::Spec->file_name_is_absolute( $dir ) ) {
              $dir = VMS::Filespec::vmspath( $dir );
          }
          else {
              $dir = $self->catdir( $cwd, $dir );
          }
      }
      @dirs = grep { length( $_ ) } @dirs;
      unshift( @dirs, '' );    # Check each $lib without additions first
  
    LIB: foreach my $lib ( @libs ) {
          if ( exists $libmap{$lib} ) {
              next unless length $libmap{$lib};
              $lib = $libmap{$lib};
          }
  
          my ( @variants, $cand );
          my ( $ctype ) = '';
  
          # If we don't have a file type, consider it a possibly abbreviated name and
          # check for common variants.  We try these first to grab libraries before
          # a like-named executable image (e.g. -lperl resolves to perlshr.exe
          # before perl.exe).
          if ( $lib !~ /\.[^:>\]]*$/ ) {
              push( @variants, "${lib}shr", "${lib}rtl", "${lib}lib" );
              push( @variants, "lib$lib" ) if $lib !~ /[:>\]]/;
          }
          push( @variants, $lib );
          warn "Looking for $lib\n" if $verbose;
          foreach my $variant ( @variants ) {
              my ( $fullname, $name );
  
              foreach my $dir ( @dirs ) {
                  my ( $type );
  
                  $name = "$dir$variant";
                  warn "\tChecking $name\n" if $verbose > 2;
                  $fullname = VMS::Filespec::rmsexpand( $name );
                  if ( defined $fullname and -f $fullname ) {
  
                      # It's got its own suffix, so we'll have to figure out the type
                      if    ( $fullname =~ /(?:$so|exe)$/i )      { $type = 'SHR'; }
                      elsif ( $fullname =~ /(?:$lib_ext|olb)$/i ) { $type = 'OLB'; }
                      elsif ( $fullname =~ /(?:$obj_ext|obj)$/i ) {
                          warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                          $type = 'OBJ';
                      }
                      else {
                          warn "Warning (mostly harmless): " . "Unknown library type for $fullname; assuming shared\n";
                          $type = 'SHR';
                      }
                  }
                  elsif (-f ( $fullname = VMS::Filespec::rmsexpand( $name, $so ) )
                      or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.exe' ) ) )
                  {
                      $type = 'SHR';
                      $name = $fullname unless $fullname =~ /exe;?\d*$/i;
                  }
                  elsif (
                      not length( $ctype ) and    # If we've got a lib already,
                                                  # don't bother
                      ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $lib_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.olb' ) ) )
                    )
                  {
                      $type = 'OLB';
                      $name = $fullname unless $fullname =~ /olb;?\d*$/i;
                  }
                  elsif (
                      not length( $ctype ) and    # If we've got a lib already,
                                                  # don't bother
                      ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $obj_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.obj' ) ) )
                    )
                  {
                      warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                      $type = 'OBJ';
                      $name = $fullname unless $fullname =~ /obj;?\d*$/i;
                  }
                  if ( defined $type ) {
                      $ctype = $type;
                      $cand  = $name;
                      last if $ctype eq 'SHR';
                  }
              }
              if ( $ctype ) {
  
                  push @{ $found{$ctype} }, $cand;
                  warn "\tFound as $cand (really $fullname), type $ctype\n"
                    if $verbose > 1;
                  push @flibs, $name unless $libs_seen{$fullname}++;
                  next LIB;
              }
          }
          warn "Warning (mostly harmless): " . "No library found for $lib\n";
      }
  
      push @fndlibs, @{ $found{OBJ} } if exists $found{OBJ};
      push @fndlibs, map { "$_/Library" } @{ $found{OLB} } if exists $found{OLB};
      push @fndlibs, map { "$_/Share" } @{ $found{SHR} }   if exists $found{SHR};
      my $lib = join( ' ', @fndlibs );
  
      $ldlib = $crtlstr ? "$lib $crtlstr" : $lib;
      $ldlib =~ s/^\s+|\s+$//g;
      warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if $verbose;
      wantarray ? ( $lib, '', $ldlib, '', ( $give_libs ? \@flibs : () ) ) : $lib;
  }
  
  1;
EXTUTILS_LIBLIST_KID

$fatpacked{"ExtUtils/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM';
  package ExtUtils::MM;
  
  use strict;
  use ExtUtils::MakeMaker::Config;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::Liblist;
  require ExtUtils::MakeMaker;
  our @ISA = qw(ExtUtils::Liblist ExtUtils::MakeMaker);
  
  =head1 NAME
  
  ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass
  
  =head1 SYNOPSIS
  
    require ExtUtils::MM;
    my $mm = MM->new(...);
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically
  chooses the appropriate OS specific subclass for you
  (ie. ExtUils::MM_Unix, etc...).
  
  It also provides a convenient alias via the MM class (I didn't want
  MakeMaker modules outside of ExtUtils/).
  
  This class might turn out to be a temporary solution, but MM won't go
  away.
  
  =cut
  
  {
      # Convenient alias.
      package MM;
      our @ISA = qw(ExtUtils::MM);
      sub DESTROY {}
  }
  
  sub _is_win95 {
      # miniperl might not have the Win32 functions available and we need
      # to run in miniperl.
      my $have_win32 = eval { require Win32 };
      return $have_win32 && defined &Win32::IsWin95 ? Win32::IsWin95()
                                                    : ! defined $ENV{SYSTEMROOT};
  }
  
  my %Is = ();
  $Is{VMS}    = $^O eq 'VMS';
  $Is{OS2}    = $^O eq 'os2';
  $Is{MacOS}  = $^O eq 'MacOS';
  if( $^O eq 'MSWin32' ) {
      _is_win95() ? $Is{Win95} = 1 : $Is{Win32} = 1;
  }
  $Is{UWIN}   = $^O =~ /^uwin(-nt)?$/;
  $Is{Cygwin} = $^O eq 'cygwin';
  $Is{NW5}    = $Config{osname} eq 'NetWare';  # intentional
  $Is{BeOS}   = ($^O =~ /beos/i or $^O eq 'haiku');
  $Is{DOS}    = $^O eq 'dos';
  if( $Is{NW5} ) {
      $^O = 'NetWare';
      delete $Is{Win32};
  }
  $Is{VOS}    = $^O eq 'vos';
  $Is{QNX}    = $^O eq 'qnx';
  $Is{AIX}    = $^O eq 'aix';
  $Is{Darwin} = $^O eq 'darwin';
  
  $Is{Unix}   = !grep { $_ } values %Is;
  
  map { delete $Is{$_} unless $Is{$_} } keys %Is;
  _assert( keys %Is == 1 );
  my($OS) = keys %Is;
  
  
  my $class = "ExtUtils::MM_$OS";
  eval "require $class" unless $INC{"ExtUtils/MM_$OS.pm"}; ## no critic
  die $@ if $@;
  unshift @ISA, $class;
  
  
  sub _assert {
      my $sanity = shift;
      die sprintf "Assert failed at %s line %d\n", (caller)[1,2] unless $sanity;
      return;
  }
EXTUTILS_MM

$fatpacked{"ExtUtils/MM_AIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_AIX';
  package ExtUtils::MM_AIX;
  
  use strict;
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  use ExtUtils::MakeMaker::Config;
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  =head1 NAME
  
  ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  AIX.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 dlsyms
  
  Define DL_FUNCS and DL_VARS and write the *.exp files.
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
      return '' unless $self->needs_linking;
      join "\n", $self->xs_dlsyms_iterator(\%attribs);
  }
  
  =head3 xs_dlsyms_ext
  
  On AIX, is C<.exp>.
  
  =cut
  
  sub xs_dlsyms_ext {
      '.exp';
  }
  
  sub xs_dlsyms_arg {
      my($self, $file) = @_;
      my $arg = qq{-bE:${file}};
      $arg = '-Wl,'.$arg if $Config{lddlflags} =~ /-Wl,-bE:/;
      return $arg;
  }
  
  sub init_others {
      my $self = shift;
      $self->SUPER::init_others;
      # perl "hints" add -bE:$(BASEEXT).exp to LDDLFLAGS. strip that out
      # so right value can be added by xs_make_dynamic_lib to work for XSMULTI
      $self->{LDDLFLAGS} ||= $Config{lddlflags};
      $self->{LDDLFLAGS} =~ s#(\s*)\S*\Q$(BASEEXT)\E\S*(\s*)#$1$2#;
      return;
  }
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
EXTUTILS_MM_AIX

$fatpacked{"ExtUtils/MM_Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_ANY';
  package ExtUtils::MM_Any;
  
  use strict;
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  use Carp;
  use File::Spec;
  use File::Basename;
  BEGIN { our @ISA = qw(File::Spec); }
  
  # We need $Verbose
  use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);
  
  use ExtUtils::MakeMaker::Config;
  
  
  # So we don't have to keep calling the methods over and over again,
  # we have these globals to cache the values.  Faster and shrtr.
  my $Curdir  = __PACKAGE__->curdir;
  #my $Updir   = __PACKAGE__->updir;
  
  my $METASPEC_URL = 'https://metacpan.org/pod/CPAN::Meta::Spec';
  my $METASPEC_V = 2;
  
  =head1 NAME
  
  ExtUtils::MM_Any - Platform-agnostic MM methods
  
  =head1 SYNOPSIS
  
    FOR INTERNAL USE ONLY!
  
    package ExtUtils::MM_SomeOS;
  
    # Temporarily, you have to subclass both.  Put MM_Any first.
    require ExtUtils::MM_Any;
    require ExtUtils::MM_Unix;
    @ISA = qw(ExtUtils::MM_Any ExtUtils::Unix);
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY!>
  
  ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of
  modules.  It contains methods which are either inherently
  cross-platform or are written in a cross-platform manner.
  
  Subclass off of ExtUtils::MM_Any I<and> ExtUtils::MM_Unix.  This is a
  temporary solution.
  
  B<THIS MAY BE TEMPORARY!>
  
  
  =head1 METHODS
  
  Any methods marked I<Abstract> must be implemented by subclasses.
  
  
  =head2 Cross-platform helper methods
  
  These are methods which help writing cross-platform code.
  
  
  
  =head3 os_flavor  I<Abstract>
  
      my @os_flavor = $mm->os_flavor;
  
  @os_flavor is the style of operating system this is, usually
  corresponding to the MM_*.pm file we're using.
  
  The first element of @os_flavor is the major family (ie. Unix,
  Windows, VMS, OS/2, etc...) and the rest are sub families.
  
  Some examples:
  
      Cygwin98       ('Unix',  'Cygwin', 'Cygwin9x')
      Windows        ('Win32')
      Win98          ('Win32', 'Win9x')
      Linux          ('Unix',  'Linux')
      MacOS X        ('Unix',  'Darwin', 'MacOS', 'MacOS X')
      OS/2           ('OS/2')
  
  This is used to write code for styles of operating system.
  See os_flavor_is() for use.
  
  
  =head3 os_flavor_is
  
      my $is_this_flavor = $mm->os_flavor_is($this_flavor);
      my $is_this_flavor = $mm->os_flavor_is(@one_of_these_flavors);
  
  Checks to see if the current operating system is one of the given flavors.
  
  This is useful for code like:
  
      if( $mm->os_flavor_is('Unix') ) {
          $out = `foo 2>&1`;
      }
      else {
          $out = `foo`;
      }
  
  =cut
  
  sub os_flavor_is {
      my $self = shift;
      my %flavors = map { ($_ => 1) } $self->os_flavor;
      return (grep { $flavors{$_} } @_) ? 1 : 0;
  }
  
  
  =head3 can_load_xs
  
      my $can_load_xs = $self->can_load_xs;
  
  Returns true if we have the ability to load XS.
  
  This is important because miniperl, used to build XS modules in the
  core, can not load XS.
  
  =cut
  
  sub can_load_xs {
      return defined &DynaLoader::boot_DynaLoader ? 1 : 0;
  }
  
  
  =head3 can_run
  
    use ExtUtils::MM;
    my $runnable = MM->can_run($Config{make});
  
  If called in a scalar context it will return the full path to the binary
  you asked for if it was found, or C<undef> if it was not.
  
  If called in a list context, it will return a list of the full paths to instances
  of the binary where found in C<PATH>, or an empty list if it was not found.
  
  Copied from L<IPC::Cmd|IPC::Cmd/"$path = can_run( PROGRAM );">, but modified into
  a method (and removed C<$INSTANCES> capability).
  
  =cut
  
  sub can_run {
      my ($self, $command) = @_;
  
      # a lot of VMS executables have a symbol defined
      # check those first
      if ( $^O eq 'VMS' ) {
          require VMS::DCLsym;
          my $syms = VMS::DCLsym->new;
          return $command if scalar $syms->getsym( uc $command );
      }
  
      my @possibles;
  
      if( File::Spec->file_name_is_absolute($command) ) {
          return $self->maybe_command($command);
  
      } else {
          for my $dir (
              File::Spec->path,
              File::Spec->curdir
          ) {
              next if ! $dir || ! -d $dir;
              my $abs = File::Spec->catfile($self->os_flavor_is('Win32') ? Win32::GetShortPathName( $dir ) : $dir, $command);
              push @possibles, $abs if $abs = $self->maybe_command($abs);
          }
      }
      return @possibles if wantarray;
      return shift @possibles;
  }
  
  
  =head3 can_redirect_error
  
    $useredirect = MM->can_redirect_error;
  
  True if on an OS where qx operator (or backticks) can redirect C<STDERR>
  onto C<STDOUT>.
  
  =cut
  
  sub can_redirect_error {
    my $self = shift;
    $self->os_flavor_is('Unix')
        or ($self->os_flavor_is('Win32') and !$self->os_flavor_is('Win9x'))
        or $self->os_flavor_is('OS/2')
  }
  
  
  =head3 is_make_type
  
      my $is_dmake = $self->is_make_type('dmake');
  
  Returns true if C<< $self->make >> is the given type; possibilities are:
  
    gmake    GNU make
    dmake
    nmake
    bsdmake  BSD pmake-derived
  
  =cut
  
  my %maketype2true;
  # undocumented - so t/cd.t can still do its thing
  sub _clear_maketype_cache { %maketype2true = () }
  
  sub is_make_type {
      my($self, $type) = @_;
      return $maketype2true{$type} if defined $maketype2true{$type};
      (undef, undef, my $make_basename) = $self->splitpath($self->make);
      return $maketype2true{$type} = 1
          if $make_basename =~ /\b$type\b/i; # executable's filename
      return $maketype2true{$type} = 0
          if $make_basename =~ /\b[gdn]make\b/i; # Never fall through for dmake/nmake/gmake
      # now have to run with "-v" and guess
      my $redirect = $self->can_redirect_error ? '2>&1' : '';
      my $make = $self->make || $self->{MAKE};
      my $minus_v = `"$make" -v $redirect`;
      return $maketype2true{$type} = 1
          if $type eq 'gmake' and $minus_v =~ /GNU make/i;
      return $maketype2true{$type} = 1
          if $type eq 'bsdmake'
        and $minus_v =~ /^usage: make \[-BeikNnqrstWwX\]/im;
      $maketype2true{$type} = 0; # it wasn't whatever you asked
  }
  
  
  =head3 can_dep_space
  
      my $can_dep_space = $self->can_dep_space;
  
  Returns true if C<make> can handle (probably by quoting)
  dependencies that contain a space. Currently known true for GNU make,
  false for BSD pmake derivative.
  
  =cut
  
  my $cached_dep_space;
  sub can_dep_space {
      my $self = shift;
      return $cached_dep_space if defined $cached_dep_space;
      return $cached_dep_space = 1 if $self->is_make_type('gmake');
      return $cached_dep_space = 0 if $self->is_make_type('dmake'); # only on W32
      return $cached_dep_space = 0 if $self->is_make_type('bsdmake');
      return $cached_dep_space = 0; # assume no
  }
  
  
  =head3 quote_dep
  
    $text = $mm->quote_dep($text);
  
  Method that protects Makefile single-value constants (mainly filenames),
  so that make will still treat them as single values even if they
  inconveniently have spaces in. If the make program being used cannot
  achieve such protection and the given text would need it, throws an
  exception.
  
  =cut
  
  sub quote_dep {
      my ($self, $arg) = @_;
      die <<EOF if $arg =~ / / and not $self->can_dep_space;
  Tried to use make dependency with space for make that can't:
    '$arg'
  EOF
      $arg =~ s/( )/\\$1/g; # how GNU make does it
      return $arg;
  }
  
  
  =head3 split_command
  
      my @cmds = $MM->split_command($cmd, @args);
  
  Most OS have a maximum command length they can execute at once.  Large
  modules can easily generate commands well past that limit.  Its
  necessary to split long commands up into a series of shorter commands.
  
  C<split_command> will return a series of @cmds each processing part of
  the args.  Collectively they will process all the arguments.  Each
  individual line in @cmds will not be longer than the
  $self->max_exec_len being careful to take into account macro expansion.
  
  $cmd should include any switches and repeated initial arguments.
  
  If no @args are given, no @cmds will be returned.
  
  Pairs of arguments will always be preserved in a single command, this
  is a heuristic for things like pm_to_blib and pod2man which work on
  pairs of arguments.  This makes things like this safe:
  
      $self->split_command($cmd, %pod2man);
  
  
  =cut
  
  sub split_command {
      my($self, $cmd, @args) = @_;
  
      my @cmds = ();
      return(@cmds) unless @args;
  
      # If the command was given as a here-doc, there's probably a trailing
      # newline.
      chomp $cmd;
  
      # set aside 30% for macro expansion.
      my $len_left = int($self->max_exec_len * 0.70);
      $len_left -= length $self->_expand_macros($cmd);
  
      do {
          my $arg_str = '';
          my @next_args;
          while( @next_args = splice(@args, 0, 2) ) {
              # Two at a time to preserve pairs.
              my $next_arg_str = "\t  ". join ' ', @next_args, "\n";
  
              if( !length $arg_str ) {
                  $arg_str .= $next_arg_str
              }
              elsif( length($arg_str) + length($next_arg_str) > $len_left ) {
                  unshift @args, @next_args;
                  last;
              }
              else {
                  $arg_str .= $next_arg_str;
              }
          }
          chop $arg_str;
  
          push @cmds, $self->escape_newlines("$cmd \n$arg_str");
      } while @args;
  
      return @cmds;
  }
  
  
  sub _expand_macros {
      my($self, $cmd) = @_;
  
      $cmd =~ s{\$\((\w+)\)}{
          defined $self->{$1} ? $self->{$1} : "\$($1)"
      }e;
      return $cmd;
  }
  
  
  =head3 make_type
  
  Returns a suitable string describing the type of makefile being written.
  
  =cut
  
  # override if this isn't suitable!
  sub make_type { return 'Unix-style'; }
  
  
  =head3 stashmeta
  
      my @recipelines = $MM->stashmeta($text, $file);
  
  Generates a set of C<@recipelines> which will result in the literal
  C<$text> ending up in literal C<$file> when the recipe is executed. Call
  it once, with all the text you want in C<$file>. Make macros will not
  be expanded, so the locations will be fixed at configure-time, not
  at build-time.
  
  =cut
  
  sub stashmeta {
      my($self, $text, $file) = @_;
      $self->echo($text, $file, { allow_variables => 0, append => 0 });
  }
  
  
  =head3 echo
  
      my @commands = $MM->echo($text);
      my @commands = $MM->echo($text, $file);
      my @commands = $MM->echo($text, $file, \%opts);
  
  Generates a set of @commands which print the $text to a $file.
  
  If $file is not given, output goes to STDOUT.
  
  If $opts{append} is true the $file will be appended to rather than
  overwritten.  Default is to overwrite.
  
  If $opts{allow_variables} is true, make variables of the form
  C<$(...)> will not be escaped.  Other C<$> will.  Default is to escape
  all C<$>.
  
  Example of use:
  
      my $make = join '', map "\t$_\n", $MM->echo($text, $file);
  
  =cut
  
  sub echo {
      my($self, $text, $file, $opts) = @_;
  
      # Compatibility with old options
      if( !ref $opts ) {
          my $append = $opts;
          $opts = { append => $append || 0 };
      }
      $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};
  
      my $ql_opts = { allow_variables => $opts->{allow_variables} };
      my @cmds = map { '$(NOECHO) $(ECHO) '.$self->quote_literal($_, $ql_opts) }
                 split /\n/, $text;
      if( $file ) {
          my $redirect = $opts->{append} ? '>>' : '>';
          $cmds[0] .= " $redirect $file";
          $_ .= " >> $file" foreach @cmds[1..$#cmds];
      }
  
      return @cmds;
  }
  
  
  =head3 wraplist
  
    my $args = $mm->wraplist(@list);
  
  Takes an array of items and turns them into a well-formatted list of
  arguments.  In most cases this is simply something like:
  
      FOO \
      BAR \
      BAZ
  
  =cut
  
  sub wraplist {
      my $self = shift;
      return join " \\\n\t", @_;
  }
  
  
  =head3 maketext_filter
  
      my $filter_make_text = $mm->maketext_filter($make_text);
  
  The text of the Makefile is run through this method before writing to
  disk.  It allows systems a chance to make portability fixes to the
  Makefile.
  
  By default it does nothing.
  
  This method is protected and not intended to be called outside of
  MakeMaker.
  
  =cut
  
  sub maketext_filter { return $_[1] }
  
  
  =head3 cd  I<Abstract>
  
    my $subdir_cmd = $MM->cd($subdir, @cmds);
  
  This will generate a make fragment which runs the @cmds in the given
  $dir.  The rough equivalent to this, except cross platform.
  
    cd $subdir && $cmd
  
  Currently $dir can only go down one level.  "foo" is fine.  "foo/bar" is
  not.  "../foo" is right out.
  
  The resulting $subdir_cmd has no leading tab nor trailing newline.  This
  makes it easier to embed in a make string.  For example.
  
        my $make = sprintf <<'CODE', $subdir_cmd;
    foo :
        $(ECHO) what
        %s
        $(ECHO) mouche
    CODE
  
  
  =head3 oneliner  I<Abstract>
  
    my $oneliner = $MM->oneliner($perl_code);
    my $oneliner = $MM->oneliner($perl_code, \@switches);
  
  This will generate a perl one-liner safe for the particular platform
  you're on based on the given $perl_code and @switches (a -e is
  assumed) suitable for using in a make target.  It will use the proper
  shell quoting and escapes.
  
  $(PERLRUN) will be used as perl.
  
  Any newlines in $perl_code will be escaped.  Leading and trailing
  newlines will be stripped.  Makes this idiom much easier:
  
      my $code = $MM->oneliner(<<'CODE', [...switches...]);
  some code here
  another line here
  CODE
  
  Usage might be something like:
  
      # an echo emulation
      $oneliner = $MM->oneliner('print "Foo\n"');
      $make = '$oneliner > somefile';
  
  Dollar signs in the $perl_code will be protected from make using the
  C<quote_literal> method, unless they are recognised as being a make
  variable, C<$(varname)>, in which case they will be left for make
  to expand. Remember to quote make macros else it might be used as a
  bareword. For example:
  
      # Assign the value of the $(VERSION_FROM) make macro to $vf.
      $oneliner = $MM->oneliner('$vf = "$(VERSION_FROM)"');
  
  Its currently very simple and may be expanded sometime in the figure
  to include more flexible code and switches.
  
  
  =head3 quote_literal  I<Abstract>
  
      my $safe_text = $MM->quote_literal($text);
      my $safe_text = $MM->quote_literal($text, \%options);
  
  This will quote $text so it is interpreted literally in the shell.
  
  For example, on Unix this would escape any single-quotes in $text and
  put single-quotes around the whole thing.
  
  If $options{allow_variables} is true it will leave C<'$(FOO)'> make
  variables untouched.  If false they will be escaped like any other
  C<$>.  Defaults to true.
  
  =head3 escape_dollarsigns
  
      my $escaped_text = $MM->escape_dollarsigns($text);
  
  Escapes stray C<$> so they are not interpreted as make variables.
  
  It lets by C<$(...)>.
  
  =cut
  
  sub escape_dollarsigns {
      my($self, $text) = @_;
  
      # Escape dollar signs which are not starting a variable
      $text =~ s{\$ (?!\() }{\$\$}gx;
  
      return $text;
  }
  
  
  =head3 escape_all_dollarsigns
  
      my $escaped_text = $MM->escape_all_dollarsigns($text);
  
  Escapes all C<$> so they are not interpreted as make variables.
  
  =cut
  
  sub escape_all_dollarsigns {
      my($self, $text) = @_;
  
      # Escape dollar signs
      $text =~ s{\$}{\$\$}gx;
  
      return $text;
  }
  
  
  =head3 escape_newlines  I<Abstract>
  
      my $escaped_text = $MM->escape_newlines($text);
  
  Shell escapes newlines in $text.
  
  
  =head3 max_exec_len  I<Abstract>
  
      my $max_exec_len = $MM->max_exec_len;
  
  Calculates the maximum command size the OS can exec.  Effectively,
  this is the max size of a shell command line.
  
  =for _private
  $self->{_MAX_EXEC_LEN} is set by this method, but only for testing purposes.
  
  
  =head3 make
  
      my $make = $MM->make;
  
  Returns the make variant we're generating the Makefile for.  This attempts
  to do some normalization on the information from %Config or the user.
  
  =cut
  
  sub make {
      my $self = shift;
  
      my $make = lc $self->{MAKE};
  
      # Truncate anything like foomake6 to just foomake.
      $make =~ s/^(\w+make).*/$1/;
  
      # Turn gnumake into gmake.
      $make =~ s/^gnu/g/;
  
      return $make;
  }
  
  
  =head2 Targets
  
  These are methods which produce make targets.
  
  
  =head3 all_target
  
  Generate the default target 'all'.
  
  =cut
  
  sub all_target {
      my $self = shift;
  
      return <<'MAKE_EXT';
  all :: pure_all
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  
  }
  
  
  =head3 blibdirs_target
  
      my $make_frag = $mm->blibdirs_target;
  
  Creates the blibdirs target which creates all the directories we use
  in blib/.
  
  The blibdirs.ts target is deprecated.  Depend on blibdirs instead.
  
  
  =cut
  
  sub _xs_list_basenames {
      my ($self) = @_;
      map { (my $b = $_) =~ s/\.xs$//; $b } sort keys %{ $self->{XS} };
  }
  
  sub blibdirs_target {
      my $self = shift;
  
      my @dirs = map { uc "\$(INST_$_)" } qw(libdir archlib
                                             autodir archautodir
                                             bin script
                                             man1dir man3dir
                                            );
      if ($self->{XSMULTI}) {
          for my $ext ($self->_xs_list_basenames) {
              my ($v, $d, $f) = File::Spec->splitpath($ext);
              my @d = File::Spec->splitdir($d);
              shift @d if $d[0] eq 'lib';
              push @dirs, $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);
  	}
      }
  
      my @exists = map { $_.'$(DFSEP).exists' } @dirs;
  
      my $make = sprintf <<'MAKE', join(' ', @exists);
  blibdirs : %s
  	$(NOECHO) $(NOOP)
  
  # Backwards compat with 6.18 through 6.25
  blibdirs.ts : blibdirs
  	$(NOECHO) $(NOOP)
  
  MAKE
  
      $make .= $self->dir_target(@dirs);
  
      return $make;
  }
  
  
  =head3 clean (o)
  
  Defines the clean target.
  
  =cut
  
  sub clean {
  # --- Cleanup and Distribution Sections ---
  
      my($self, %attribs) = @_;
      my @m;
      push(@m, '
  # Delete temporary files but do not touch installed files. We don\'t delete
  # the Makefile here so a later make realclean still has a makefile to use.
  
  clean :: clean_subdirs
  ');
  
      my @files = sort values %{$self->{XS}}; # .c files from *.xs files
      push @files, map {
  	my $file = $_;
  	map { $file.$_ } $self->{OBJ_EXT}, qw(.def _def.old .bs .bso .exp .base);
      } $self->_xs_list_basenames;
      my @dirs  = qw(blib);
  
      # Normally these are all under blib but they might have been
      # redefined.
      # XXX normally this would be a good idea, but the Perl core sets
      # INST_LIB = ../../lib rather than actually installing the files.
      # So a "make clean" in an ext/ directory would blow away lib.
      # Until the core is adjusted let's leave this out.
  #     push @dirs, qw($(INST_ARCHLIB) $(INST_LIB)
  #                    $(INST_BIN) $(INST_SCRIPT)
  #                    $(INST_MAN1DIR) $(INST_MAN3DIR)
  #                    $(INST_LIBDIR) $(INST_ARCHLIBDIR) $(INST_AUTODIR)
  #                    $(INST_STATIC) $(INST_DYNAMIC)
  #                 );
  
  
      if( $attribs{FILES} ) {
          # Use @dirs because we don't know what's in here.
          push @dirs, ref $attribs{FILES}                ?
                          @{$attribs{FILES}}             :
                          split /\s+/, $attribs{FILES}   ;
      }
  
      push(@files, qw[$(MAKE_APERL_FILE)
                      MYMETA.json MYMETA.yml perlmain.c tmon.out mon.out so_locations
                      blibdirs.ts pm_to_blib pm_to_blib.ts
                      *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT)
                      $(BOOTSTRAP) $(BASEEXT).bso
                      $(BASEEXT).def lib$(BASEEXT).def
                      $(BASEEXT).exp $(BASEEXT).x
                     ]);
  
      push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
      push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));
  
      # core files
      if ($^O eq 'vos') {
          push(@files, qw[perl*.kp]);
      }
      else {
          push(@files, qw[core core.*perl.*.? *perl.core]);
      }
  
      push(@files, map { "core." . "[0-9]"x$_ } (1..5));
  
      # OS specific things to clean up.  Use @dirs since we don't know
      # what might be in here.
      push @dirs, $self->extra_clean_files;
  
      # Occasionally files are repeated several times from different sources
      { my(%f) = map { ($_ => 1) } @files; @files = sort keys %f; }
      { my(%d) = map { ($_ => 1) } @dirs;  @dirs  = sort keys %d; }
  
      push @m, map "\t$_\n", $self->split_command('- $(RM_F)',  @files);
      push @m, map "\t$_\n", $self->split_command('- $(RM_RF)', @dirs);
  
      # Leave Makefile.old around for realclean
      push @m, <<'MAKE';
  	  $(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)
  MAKE
  
      push(@m, "\t$attribs{POSTOP}\n")   if $attribs{POSTOP};
  
      join("", @m);
  }
  
  
  =head3 clean_subdirs_target
  
    my $make_frag = $MM->clean_subdirs_target;
  
  Returns the clean_subdirs target.  This is used by the clean target to
  call clean on any subdirectories which contain Makefiles.
  
  =cut
  
  sub clean_subdirs_target {
      my($self) = shift;
  
      # No subdirectories, no cleaning.
      return <<'NOOP_FRAG' unless @{$self->{DIR}};
  clean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  
  
      my $clean = "clean_subdirs :\n";
  
      for my $dir (@{$self->{DIR}}) {
          my $subclean = $self->oneliner(sprintf <<'CODE', $dir);
  exit 0 unless chdir '%s';  system '$(MAKE) clean' if -f '$(FIRST_MAKEFILE)';
  CODE
  
          $clean .= "\t$subclean\n";
      }
  
      return $clean;
  }
  
  
  =head3 dir_target
  
      my $make_frag = $mm->dir_target(@directories);
  
  Generates targets to create the specified directories and set its
  permission to PERM_DIR.
  
  Because depending on a directory to just ensure it exists doesn't work
  too well (the modified time changes too often) dir_target() creates a
  .exists file in the created directory.  It is this you should depend on.
  For portability purposes you should use the $(DIRFILESEP) macro rather
  than a '/' to separate the directory from the file.
  
      yourdirectory$(DIRFILESEP).exists
  
  =cut
  
  sub dir_target {
      my($self, @dirs) = @_;
  
      my $make = '';
      foreach my $dir (@dirs) {
          $make .= sprintf <<'MAKE', ($dir) x 4;
  %s$(DFSEP).exists :: Makefile.PL
  	$(NOECHO) $(MKPATH) %s
  	$(NOECHO) $(CHMOD) $(PERM_DIR) %s
  	$(NOECHO) $(TOUCH) %s$(DFSEP).exists
  
  MAKE
  
      }
  
      return $make;
  }
  
  
  =head3 distdir
  
  Defines the scratch directory target that will hold the distribution
  before tar-ing (or shar-ing).
  
  =cut
  
  # For backwards compatibility.
  *dist_dir = *distdir;
  
  sub distdir {
      my($self) = shift;
  
      my $meta_target = $self->{NO_META} ? '' : 'distmeta';
      my $sign_target = !$self->{SIGN}   ? '' : 'distsignature';
  
      return sprintf <<'MAKE_FRAG', $meta_target, $sign_target;
  create_distdir :
  	$(RM_RF) $(DISTVNAME)
  	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
  		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
  
  distdir : create_distdir %s %s
  	$(NOECHO) $(NOOP)
  
  MAKE_FRAG
  
  }
  
  
  =head3 dist_test
  
  Defines a target that produces the distribution in the
  scratch directory, and runs 'perl Makefile.PL; make ;make test' in that
  subdirectory.
  
  =cut
  
  sub dist_test {
      my($self) = shift;
  
      my $mpl_args = join " ", map qq["$_"], @ARGV;
  
      my $test = $self->cd('$(DISTVNAME)',
                           '$(ABSPERLRUN) Makefile.PL '.$mpl_args,
                           '$(MAKE) $(PASTHRU)',
                           '$(MAKE) test $(PASTHRU)'
                          );
  
      return sprintf <<'MAKE_FRAG', $test;
  disttest : distdir
  	%s
  
  MAKE_FRAG
  
  
  }
  
  
  =head3 xs_dlsyms_arg
  
  Returns command-line arg(s) to linker for file listing dlsyms to export.
  Defaults to returning empty string, can be overridden by e.g. AIX.
  
  =cut
  
  sub xs_dlsyms_arg {
      return '';
  }
  
  =head3 xs_dlsyms_ext
  
  Returns file-extension for C<xs_make_dlsyms> method's output file,
  including any "." character.
  
  =cut
  
  sub xs_dlsyms_ext {
      die "Pure virtual method";
  }
  
  =head3 xs_dlsyms_extra
  
  Returns any extra text to be prepended to the C<$extra> argument of
  C<xs_make_dlsyms>.
  
  =cut
  
  sub xs_dlsyms_extra {
      '';
  }
  
  =head3 xs_dlsyms_iterator
  
  Iterates over necessary shared objects, calling C<xs_make_dlsyms> method
  for each with appropriate arguments.
  
  =cut
  
  sub xs_dlsyms_iterator {
      my ($self, $attribs) = @_;
      if ($self->{XSMULTI}) {
          my @m;
          for my $ext ($self->_xs_list_basenames) {
              my @parts = File::Spec->splitdir($ext);
              shift @parts if $parts[0] eq 'lib';
              my $name = join '::', @parts;
              push @m, $self->xs_make_dlsyms(
                  $attribs,
                  $ext . $self->xs_dlsyms_ext,
                  "$ext.xs",
                  $name,
                  $parts[-1],
                  {}, [], {}, [],
                  $self->xs_dlsyms_extra . q!, 'FILE' => ! . neatvalue($ext),
              );
          }
          return join "\n", @m;
      } else {
          return $self->xs_make_dlsyms(
              $attribs,
              $self->{BASEEXT} . $self->xs_dlsyms_ext,
              'Makefile.PL',
              $self->{NAME},
              $self->{DLBASE},
              $attribs->{DL_FUNCS} || $self->{DL_FUNCS} || {},
              $attribs->{FUNCLIST} || $self->{FUNCLIST} || [],
              $attribs->{IMPORTS} || $self->{IMPORTS} || {},
              $attribs->{DL_VARS} || $self->{DL_VARS} || [],
              $self->xs_dlsyms_extra,
          );
      }
  }
  
  =head3 xs_make_dlsyms
  
      $self->xs_make_dlsyms(
          \%attribs, # hashref from %attribs in caller
          "$self->{BASEEXT}.def", # output file for Makefile target
          'Makefile.PL', # dependency
          $self->{NAME}, # shared object's "name"
          $self->{DLBASE}, # last ::-separated part of name
          $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {}, # various params
          $attribs{FUNCLIST} || $self->{FUNCLIST} || [],
          $attribs{IMPORTS} || $self->{IMPORTS} || {},
          $attribs{DL_VARS} || $self->{DL_VARS} || [],
          # optional extra param that will be added as param to Mksymlists
      );
  
  Utility method that returns Makefile snippet to call C<Mksymlists>.
  
  =cut
  
  sub xs_make_dlsyms {
      my ($self, $attribs, $target, $dep, $name, $dlbase, $funcs, $funclist, $imports, $vars, $extra) = @_;
      my @m = (
       "\n$target: $dep\n",
       q!	$(PERLRUN) -MExtUtils::Mksymlists \\
       -e "Mksymlists('NAME'=>\"!, $name,
       q!\", 'DLBASE' => '!,$dlbase,
       # The above two lines quoted differently to work around
       # a bug in the 4DOS/4NT command line interpreter.  The visible
       # result of the bug was files named q('extension_name',) *with the
       # single quotes and the comma* in the extension build directories.
       q!', 'DL_FUNCS' => !,neatvalue($funcs),
       q!, 'FUNCLIST' => !,neatvalue($funclist),
       q!, 'IMPORTS' => !,neatvalue($imports),
       q!, 'DL_VARS' => !, neatvalue($vars)
      );
      push @m, $extra if defined $extra;
      push @m, qq!);"\n!;
      join '', @m;
  }
  
  =head3 dynamic (o)
  
  Defines the dynamic target.
  
  =cut
  
  sub dynamic {
  # --- Dynamic Loading Sections ---
  
      my($self) = shift;
      '
  dynamic :: $(FIRST_MAKEFILE) config $(INST_BOOT) $(INST_DYNAMIC)
  	$(NOECHO) $(NOOP)
  ';
  }
  
  
  =head3 makemakerdflt_target
  
    my $make_frag = $mm->makemakerdflt_target
  
  Returns a make fragment with the makemakerdeflt_target specified.
  This target is the first target in the Makefile, is the default target
  and simply points off to 'all' just in case any make variant gets
  confused or something gets snuck in before the real 'all' target.
  
  =cut
  
  sub makemakerdflt_target {
      return <<'MAKE_FRAG';
  makemakerdflt : all
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  
  }
  
  
  =head3 manifypods_target
  
    my $manifypods_target = $self->manifypods_target;
  
  Generates the manifypods target.  This target generates man pages from
  all POD files in MAN1PODS and MAN3PODS.
  
  =cut
  
  sub manifypods_target {
      my($self) = shift;
  
      my $man1pods      = '';
      my $man3pods      = '';
      my $dependencies  = '';
  
      # populate manXpods & dependencies:
      foreach my $name (sort keys %{$self->{MAN1PODS}}, sort keys %{$self->{MAN3PODS}}) {
          $dependencies .= " \\\n\t$name";
      }
  
      my $manify = <<END;
  manifypods : pure_all config $dependencies
  END
  
      my @man_cmds;
      foreach my $num (qw(1 3)) {
          my $pods = $self->{"MAN${num}PODS"};
          my $p2m = sprintf <<'CMD', "\$(MAN${num}SECTION)", "$]" > 5.008 ? " -u" : "";
  	$(NOECHO) $(POD2MAN) --section=%s --perm_rw=$(PERM_RW)%s
  CMD
          push @man_cmds, $self->split_command($p2m, map {($_,$pods->{$_})} sort keys %$pods);
      }
  
      $manify .= "\t\$(NOECHO) \$(NOOP)\n" unless @man_cmds;
      $manify .= join '', map { "$_\n" } @man_cmds;
  
      return $manify;
  }
  
  {
      my $has_cpan_meta;
      sub _has_cpan_meta {
          return $has_cpan_meta if defined $has_cpan_meta;
          return $has_cpan_meta = !!eval {
              require CPAN::Meta;
              CPAN::Meta->VERSION(2.112150);
              1;
          };
      }
  }
  
  =head3 metafile_target
  
      my $target = $mm->metafile_target;
  
  Generate the metafile target.
  
  Writes the file META.yml (YAML encoded meta-data) and META.json
  (JSON encoded meta-data) about the module in the distdir.
  The format follows Module::Build's as closely as possible.
  
  =cut
  
  sub metafile_target {
      my $self = shift;
      return <<'MAKE_FRAG' if $self->{NO_META} or ! _has_cpan_meta();
  metafile :
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  
      my $metadata   = $self->metafile_data(
          $self->{META_ADD}   || {},
          $self->{META_MERGE} || {},
      );
  
      my $meta = $self->_fix_metadata_before_conversion( $metadata );
  
      my @write_metayml = $self->stashmeta(
        $meta->as_string({version => "1.4"}), 'META_new.yml'
      );
      my @write_metajson = $self->stashmeta(
        $meta->as_string({version => "2.0"}), 'META_new.json'
      );
  
      my $metayml = join("\n\t", @write_metayml);
      my $metajson = join("\n\t", @write_metajson);
      return sprintf <<'MAKE_FRAG', $metayml, $metajson;
  metafile : create_distdir
  	$(NOECHO) $(ECHO) Generating META.yml
  	%s
  	-$(NOECHO) $(MV) META_new.yml $(DISTVNAME)/META.yml
  	$(NOECHO) $(ECHO) Generating META.json
  	%s
  	-$(NOECHO) $(MV) META_new.json $(DISTVNAME)/META.json
  MAKE_FRAG
  
  }
  
  =begin private
  
  =head3 _fix_metadata_before_conversion
  
      $mm->_fix_metadata_before_conversion( \%metadata );
  
  Fixes errors in the metadata before it's handed off to CPAN::Meta for
  conversion. This hopefully results in something that can be used further
  on, no guarantee is made though.
  
  =end private
  
  =cut
  
  sub _fix_metadata_before_conversion {
      my ( $self, $metadata ) = @_;
  
      # we should never be called unless this already passed but
      # prefer to be defensive in case somebody else calls this
  
      return unless _has_cpan_meta;
  
      my $bad_version = $metadata->{version} &&
                        !CPAN::Meta::Validator->new->version( 'version', $metadata->{version} );
      # just delete all invalid versions
      if( $bad_version ) {
          warn "Can't parse version '$metadata->{version}'\n";
          $metadata->{version} = '';
      }
  
      my $validator2 = CPAN::Meta::Validator->new( $metadata );
      my @errors;
      push @errors, $validator2->errors if !$validator2->is_valid;
      my $validator14 = CPAN::Meta::Validator->new(
          {
              %$metadata,
              'meta-spec' => { version => 1.4 },
          }
      );
      push @errors, $validator14->errors if !$validator14->is_valid;
      # fix non-camelcase custom resource keys (only other trick we know)
      for my $error ( @errors ) {
          my ( $key ) = ( $error =~ /Custom resource '(.*)' must be in CamelCase./ );
          next if !$key;
  
          # first try to remove all non-alphabetic chars
          ( my $new_key = $key ) =~ s/[^_a-zA-Z]//g;
  
          # if that doesn't work, uppercase first one
          $new_key = ucfirst $new_key if !$validator14->custom_1( $new_key );
  
          # copy to new key if that worked
          $metadata->{resources}{$new_key} = $metadata->{resources}{$key}
            if $validator14->custom_1( $new_key );
  
          # and delete old one in any case
          delete $metadata->{resources}{$key};
      }
  
      # paper over validation issues, but still complain, necessary because
      # there's no guarantee that the above will fix ALL errors
      my $meta = eval { CPAN::Meta->create( $metadata, { lazy_validation => 1 } ) };
      warn $@ if $@ and
                 $@ !~ /encountered CODE.*, but JSON can only represent references to arrays or hashes/;
  
      # use the original metadata straight if the conversion failed
      # or if it can't be stringified.
      if( !$meta                                                  ||
          !eval { $meta->as_string( { version => $METASPEC_V } ) }      ||
          !eval { $meta->as_string }
      ) {
          $meta = bless $metadata, 'CPAN::Meta';
      }
  
      my $now_license = $meta->as_struct({ version => 2 })->{license};
      if ($self->{LICENSE} and $self->{LICENSE} ne 'unknown' and
          @{$now_license} == 1 and $now_license->[0] eq 'unknown'
      ) {
          warn "Invalid LICENSE value '$self->{LICENSE}' ignored\n";
      }
  
      $meta;
  }
  
  
  =begin private
  
  =head3 _sort_pairs
  
      my @pairs = _sort_pairs($sort_sub, \%hash);
  
  Sorts the pairs of a hash based on keys ordered according
  to C<$sort_sub>.
  
  =end private
  
  =cut
  
  sub _sort_pairs {
      my $sort  = shift;
      my $pairs = shift;
      return map  { $_ => $pairs->{$_} }
             sort $sort
             keys %$pairs;
  }
  
  
  # Taken from Module::Build::Base
  sub _hash_merge {
      my ($self, $h, $k, $v) = @_;
      if (ref $h->{$k} eq 'ARRAY') {
          push @{$h->{$k}}, ref $v ? @$v : $v;
      } elsif (ref $h->{$k} eq 'HASH') {
          $self->_hash_merge($h->{$k}, $_, $v->{$_}) foreach keys %$v;
      } else {
          $h->{$k} = $v;
      }
  }
  
  
  =head3 metafile_data
  
      my $metadata_hashref = $mm->metafile_data(\%meta_add, \%meta_merge);
  
  Returns the data which MakeMaker turns into the META.yml file 
  and the META.json file. It is always in version 2.0 of the format.
  
  Values of %meta_add will overwrite any existing metadata in those
  keys.  %meta_merge will be merged with them.
  
  =cut
  
  sub metafile_data {
      my $self = shift;
      my($meta_add, $meta_merge) = @_;
  
      $meta_add ||= {};
      $meta_merge ||= {};
  
      my $version = _normalize_version($self->{VERSION});
      my $release_status = ($version =~ /_/) ? 'unstable' : 'stable';
      my %meta = (
          # required
          abstract     => $self->{ABSTRACT} || 'unknown',
          author       => defined($self->{AUTHOR}) ? $self->{AUTHOR} : ['unknown'],
          dynamic_config => 1,
          generated_by => "ExtUtils::MakeMaker version $ExtUtils::MakeMaker::VERSION",
          license      => [ $self->{LICENSE} || 'unknown' ],
          'meta-spec'  => {
              url         => $METASPEC_URL,
              version     => $METASPEC_V,
          },
          name         => $self->{DISTNAME},
          release_status => $release_status,
          version      => $version,
  
          # optional
          no_index     => { directory => [qw(t inc)] },
      );
      $self->_add_requirements_to_meta(\%meta);
  
      if (!eval { require JSON::PP; require CPAN::Meta::Converter; CPAN::Meta::Converter->VERSION(2.141170) }) {
        return \%meta;
      }
  
      # needs to be based on the original version
      my $v1_add = _metaspec_version($meta_add) !~ /^2/;
  
      my ($add_v, $merge_v) = map _metaspec_version($_), $meta_add, $meta_merge;
      for my $frag ($meta_add, $meta_merge) {
          my $def_v = $frag == $meta_add ? $merge_v : $add_v;
          $frag = CPAN::Meta::Converter->new($frag, default_version => $def_v)->upgrade_fragment;
      }
  
      # if we upgraded a 1.x _ADD fragment, we gave it a prereqs key that
      # will override all prereqs, which is more than the user asked for;
      # instead, we'll go inside the prereqs and override all those
      while( my($key, $val) = each %$meta_add ) {
          if ($v1_add and $key eq 'prereqs') {
              $meta{$key}{$_} = $val->{$_} for keys %$val;
          } elsif ($key ne 'meta-spec') {
              $meta{$key} = $val;
          }
      }
  
      while( my($key, $val) = each %$meta_merge ) {
          next if $key eq 'meta-spec';
          $self->_hash_merge(\%meta, $key, $val);
      }
  
      return \%meta;
  }
  
  
  =begin private
  
  =cut
  
  sub _add_requirements_to_meta {
      my ( $self, $meta ) = @_;
      # Check the original args so we can tell between the user setting it
      # to an empty hash and it just being initialized.
      $meta->{prereqs}{configure}{requires} = $self->{ARGS}{CONFIGURE_REQUIRES}
          ? $self->{CONFIGURE_REQUIRES}
          : { 'ExtUtils::MakeMaker' => 0, };
      $meta->{prereqs}{build}{requires} = $self->{ARGS}{BUILD_REQUIRES}
          ? $self->{BUILD_REQUIRES}
          : { 'ExtUtils::MakeMaker' => 0, };
      $meta->{prereqs}{test}{requires} = $self->{TEST_REQUIRES}
          if $self->{ARGS}{TEST_REQUIRES};
      $meta->{prereqs}{runtime}{requires} = $self->{PREREQ_PM}
          if $self->{ARGS}{PREREQ_PM};
      $meta->{prereqs}{runtime}{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})
          if $self->{MIN_PERL_VERSION};
  }
  
  # spec version of given fragment - if not given, assume 1.4
  sub _metaspec_version {
    my ( $meta ) = @_;
    return $meta->{'meta-spec'}->{version}
      if defined $meta->{'meta-spec'}
         and defined $meta->{'meta-spec'}->{version};
    return '1.4';
  }
  
  sub _add_requirements_to_meta_v1_4 {
      my ( $self, $meta ) = @_;
      # Check the original args so we can tell between the user setting it
      # to an empty hash and it just being initialized.
      if( $self->{ARGS}{CONFIGURE_REQUIRES} ) {
          $meta->{configure_requires} = $self->{CONFIGURE_REQUIRES};
      } else {
          $meta->{configure_requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
      if( $self->{ARGS}{BUILD_REQUIRES} ) {
          $meta->{build_requires} = $self->{BUILD_REQUIRES};
      } else {
          $meta->{build_requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
      if( $self->{ARGS}{TEST_REQUIRES} ) {
          $meta->{build_requires} = {
            %{ $meta->{build_requires} },
            %{ $self->{TEST_REQUIRES} },
          };
      }
      $meta->{requires} = $self->{PREREQ_PM}
          if defined $self->{PREREQ_PM};
      $meta->{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})
          if $self->{MIN_PERL_VERSION};
  }
  
  # Adapted from Module::Build::Base
  sub _normalize_version {
    my ($version) = @_;
    $version = 0 unless defined $version;
  
    if ( ref $version eq 'version' ) { # version objects
      $version = $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  }
  
  =head3 _dump_hash
  
      $yaml = _dump_hash(\%options, %hash);
  
  Implements a fake YAML dumper for a hash given
  as a list of pairs. No quoting/escaping is done. Keys
  are supposed to be strings. Values are undef, strings,
  hash refs or array refs of strings.
  
  Supported options are:
  
      delta => STR - indentation delta
      use_header => BOOL - whether to include a YAML header
      indent => STR - a string of spaces
            default: ''
  
      max_key_length => INT - maximum key length used to align
          keys and values of the same hash
          default: 20
      key_sort => CODE - a sort sub
              It may be undef, which means no sorting by keys
          default: sub { lc $a cmp lc $b }
  
      customs => HASH - special options for certain keys
             (whose values are hashes themselves)
          may contain: max_key_length, key_sort, customs
  
  =end private
  
  =cut
  
  sub _dump_hash {
      croak "first argument should be a hash ref" unless ref $_[0] eq 'HASH';
      my $options = shift;
      my %hash = @_;
  
      # Use a list to preserve order.
      my @pairs;
  
      my $k_sort
          = exists $options->{key_sort} ? $options->{key_sort}
                                        : sub { lc $a cmp lc $b };
      if ($k_sort) {
          croak "'key_sort' should be a coderef" unless ref $k_sort eq 'CODE';
          @pairs = _sort_pairs($k_sort, \%hash);
      } else { # list of pairs, no sorting
          @pairs = @_;
      }
  
      my $yaml     = $options->{use_header} ? "--- #YAML:1.0\n" : '';
      my $indent   = $options->{indent} || '';
      my $k_length = min(
          ($options->{max_key_length} || 20),
          max(map { length($_) + 1 } grep { !ref $hash{$_} } keys %hash)
      );
      my $customs  = $options->{customs} || {};
  
      # printf format for key
      my $k_format = "%-${k_length}s";
  
      while( @pairs ) {
          my($key, $val) = splice @pairs, 0, 2;
          $val = '~' unless defined $val;
          if(ref $val eq 'HASH') {
              if ( keys %$val ) {
                  my %k_options = ( # options for recursive call
                      delta => $options->{delta},
                      use_header => 0,
                      indent => $indent . $options->{delta},
                  );
                  if (exists $customs->{$key}) {
                      my %k_custom = %{$customs->{$key}};
                      foreach my $k (qw(key_sort max_key_length customs)) {
                          $k_options{$k} = $k_custom{$k} if exists $k_custom{$k};
                      }
                  }
                  $yaml .= $indent . "$key:\n"
                    . _dump_hash(\%k_options, %$val);
              }
              else {
                  $yaml .= $indent . "$key:  {}\n";
              }
          }
          elsif (ref $val eq 'ARRAY') {
              if( @$val ) {
                  $yaml .= $indent . "$key:\n";
  
                  for (@$val) {
                      croak "only nested arrays of non-refs are supported" if ref $_;
                      $yaml .= $indent . $options->{delta} . "- $_\n";
                  }
              }
              else {
                  $yaml .= $indent . "$key:  []\n";
              }
          }
          elsif( ref $val and !blessed($val) ) {
              croak "only nested hashes, arrays and objects are supported";
          }
          else {  # if it's an object, just stringify it
              $yaml .= $indent . sprintf "$k_format  %s\n", "$key:", $val;
          }
      };
  
      return $yaml;
  
  }
  
  sub blessed {
      return eval { $_[0]->isa("UNIVERSAL"); };
  }
  
  sub max {
      return (sort { $b <=> $a } @_)[0];
  }
  
  sub min {
      return (sort { $a <=> $b } @_)[0];
  }
  
  =head3 metafile_file
  
      my $meta_yml = $mm->metafile_file(@metadata_pairs);
  
  Turns the @metadata_pairs into YAML.
  
  This method does not implement a complete YAML dumper, being limited
  to dump a hash with values which are strings, undef's or nested hashes
  and arrays of strings. No quoting/escaping is done.
  
  =cut
  
  sub metafile_file {
      my $self = shift;
  
      my %dump_options = (
          use_header => 1,
          delta      => ' ' x 4,
          key_sort   => undef,
      );
      return _dump_hash(\%dump_options, @_);
  
  }
  
  
  =head3 distmeta_target
  
      my $make_frag = $mm->distmeta_target;
  
  Generates the distmeta target to add META.yml and META.json to the MANIFEST
  in the distdir.
  
  =cut
  
  sub distmeta_target {
      my $self = shift;
  
      my @add_meta = (
        $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']),
  exit unless -e q{META.yml};
  eval { maniadd({q{META.yml} => q{Module YAML meta-data (added by MakeMaker)}}) }
      or die "Could not add META.yml to MANIFEST: ${'@'}"
  CODE
        $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd'])
  exit unless -f q{META.json};
  eval { maniadd({q{META.json} => q{Module JSON meta-data (added by MakeMaker)}}) }
      or die "Could not add META.json to MANIFEST: ${'@'}"
  CODE
      );
  
      my @add_meta_to_distdir = map { $self->cd('$(DISTVNAME)', $_) } @add_meta;
  
      return sprintf <<'MAKE', @add_meta_to_distdir;
  distmeta : create_distdir metafile
  	$(NOECHO) %s
  	$(NOECHO) %s
  
  MAKE
  
  }
  
  
  =head3 mymeta
  
      my $mymeta = $mm->mymeta;
  
  Generate MYMETA information as a hash either from an existing CPAN Meta file
  (META.json or META.yml) or from internal data.
  
  =cut
  
  sub mymeta {
      my $self = shift;
      my $file = shift || ''; # for testing
  
      my $mymeta = $self->_mymeta_from_meta($file);
      my $v2 = 1;
  
      unless ( $mymeta ) {
          $mymeta = $self->metafile_data(
              $self->{META_ADD}   || {},
              $self->{META_MERGE} || {},
          );
          $v2 = 0;
      }
  
      # Overwrite the non-configure dependency hashes
      $self->_add_requirements_to_meta($mymeta);
  
      $mymeta->{dynamic_config} = 0;
  
      return $mymeta;
  }
  
  
  sub _mymeta_from_meta {
      my $self = shift;
      my $metafile = shift || ''; # for testing
  
      return unless _has_cpan_meta();
  
      my $meta;
      for my $file ( $metafile, "META.json", "META.yml" ) {
        next unless -e $file;
        eval {
            $meta = CPAN::Meta->load_file($file)->as_struct( { version => 2 } );
        };
        last if $meta;
      }
      return unless $meta;
  
      # META.yml before 6.25_01 cannot be trusted.  META.yml lived in the source directory.
      # There was a good chance the author accidentally uploaded a stale META.yml if they
      # rolled their own tarball rather than using "make dist".
      if ($meta->{generated_by} &&
          $meta->{generated_by} =~ /ExtUtils::MakeMaker version ([\d\._]+)/) {
          my $eummv = do { local $^W = 0; $1+0; };
          if ($eummv < 6.2501) {
              return;
          }
      }
  
      return $meta;
  }
  
  =head3 write_mymeta
  
      $self->write_mymeta( $mymeta );
  
  Write MYMETA information to MYMETA.json and MYMETA.yml.
  
  =cut
  
  sub write_mymeta {
      my $self = shift;
      my $mymeta = shift;
  
      return unless _has_cpan_meta();
  
      my $meta_obj = $self->_fix_metadata_before_conversion( $mymeta );
  
      $meta_obj->save( 'MYMETA.json', { version => "2.0" } );
      $meta_obj->save( 'MYMETA.yml', { version => "1.4" } );
      return 1;
  }
  
  =head3 realclean (o)
  
  Defines the realclean target.
  
  =cut
  
  sub realclean {
      my($self, %attribs) = @_;
  
      my @dirs  = qw($(DISTVNAME));
      my @files = qw($(FIRST_MAKEFILE) $(MAKEFILE_OLD));
  
      # Special exception for the perl core where INST_* is not in blib.
      # This cleans up the files built from the ext/ directory (all XS).
      if( $self->{PERL_CORE} ) {
          push @dirs, qw($(INST_AUTODIR) $(INST_ARCHAUTODIR));
          push @files, values %{$self->{PM}};
      }
  
      if( $self->has_link_code ){
          push @files, qw($(OBJECT));
      }
  
      if( $attribs{FILES} ) {
          if( ref $attribs{FILES} ) {
              push @dirs, @{ $attribs{FILES} };
          }
          else {
              push @dirs, split /\s+/, $attribs{FILES};
          }
      }
  
      # Occasionally files are repeated several times from different sources
      { my(%f) = map { ($_ => 1) } @files;  @files = sort keys %f; }
      { my(%d) = map { ($_ => 1) } @dirs;   @dirs  = sort keys %d; }
  
      my $rm_cmd  = join "\n\t", map { "$_" }
                      $self->split_command('- $(RM_F)',  @files);
      my $rmf_cmd = join "\n\t", map { "$_" }
                      $self->split_command('- $(RM_RF)', @dirs);
  
      my $m = sprintf <<'MAKE', $rm_cmd, $rmf_cmd;
  # Delete temporary files (via clean) and also delete dist files
  realclean purge :: realclean_subdirs
  	%s
  	%s
  MAKE
  
      $m .= "\t$attribs{POSTOP}\n" if $attribs{POSTOP};
  
      return $m;
  }
  
  
  =head3 realclean_subdirs_target
  
    my $make_frag = $MM->realclean_subdirs_target;
  
  Returns the realclean_subdirs target.  This is used by the realclean
  target to call realclean on any subdirectories which contain Makefiles.
  
  =cut
  
  sub realclean_subdirs_target {
      my $self = shift;
      my @m = <<'EOF';
  # so clean is forced to complete before realclean_subdirs runs
  realclean_subdirs : clean
  EOF
      return join '', @m, "\t\$(NOECHO) \$(NOOP)\n" unless @{$self->{DIR}};
      foreach my $dir (@{$self->{DIR}}) {
          foreach my $makefile ('$(MAKEFILE_OLD)', '$(FIRST_MAKEFILE)' ) {
              my $subrclean .= $self->oneliner(_sprintf562 <<'CODE', $dir, $makefile);
  chdir '%1$s';  system '$(MAKE) $(USEMAKEFILE) %2$s realclean' if -f '%2$s';
  CODE
              push @m, "\t- $subrclean\n";
          }
      }
      return join '', @m;
  }
  
  
  =head3 signature_target
  
      my $target = $mm->signature_target;
  
  Generate the signature target.
  
  Writes the file SIGNATURE with "cpansign -s".
  
  =cut
  
  sub signature_target {
      my $self = shift;
  
      return <<'MAKE_FRAG';
  signature :
  	cpansign -s
  MAKE_FRAG
  
  }
  
  
  =head3 distsignature_target
  
      my $make_frag = $mm->distsignature_target;
  
  Generates the distsignature target to add SIGNATURE to the MANIFEST in the
  distdir.
  
  =cut
  
  sub distsignature_target {
      my $self = shift;
  
      my $add_sign = $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']);
  eval { maniadd({q{SIGNATURE} => q{Public-key signature (added by MakeMaker)}}) }
      or die "Could not add SIGNATURE to MANIFEST: ${'@'}"
  CODE
  
      my $sign_dist        = $self->cd('$(DISTVNAME)' => 'cpansign -s');
  
      # cpansign -s complains if SIGNATURE is in the MANIFEST yet does not
      # exist
      my $touch_sig        = $self->cd('$(DISTVNAME)' => '$(TOUCH) SIGNATURE');
      my $add_sign_to_dist = $self->cd('$(DISTVNAME)' => $add_sign );
  
      return sprintf <<'MAKE', $add_sign_to_dist, $touch_sig, $sign_dist
  distsignature : distmeta
  	$(NOECHO) %s
  	$(NOECHO) %s
  	%s
  
  MAKE
  
  }
  
  
  =head3 special_targets
  
    my $make_frag = $mm->special_targets
  
  Returns a make fragment containing any targets which have special
  meaning to make.  For example, .SUFFIXES and .PHONY.
  
  =cut
  
  sub special_targets {
      my $make_frag = <<'MAKE_FRAG';
  .SUFFIXES : .xs .c .C .cpp .i .s .cxx .cc $(OBJ_EXT)
  
  .PHONY: all config static dynamic test linkext manifest blibdirs clean realclean disttest distdir pure_all subdirs clean_subdirs makemakerdflt manifypods realclean_subdirs subdirs_dynamic subdirs_pure_nolink subdirs_static subdirs-test_dynamic subdirs-test_static test_dynamic test_static
  
  MAKE_FRAG
  
      $make_frag .= <<'MAKE_FRAG' if $ENV{CLEARCASE_ROOT};
  .NO_CONFIG_REC: Makefile
  
  MAKE_FRAG
  
      return $make_frag;
  }
  
  
  
  
  =head2 Init methods
  
  Methods which help initialize the MakeMaker object and macros.
  
  
  =head3 init_ABSTRACT
  
      $mm->init_ABSTRACT
  
  =cut
  
  sub init_ABSTRACT {
      my $self = shift;
  
      if( $self->{ABSTRACT_FROM} and $self->{ABSTRACT} ) {
          warn "Both ABSTRACT_FROM and ABSTRACT are set.  ".
               "Ignoring ABSTRACT_FROM.\n";
          return;
      }
  
      if ($self->{ABSTRACT_FROM}){
          $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or
              carp "WARNING: Setting ABSTRACT via file ".
                   "'$self->{ABSTRACT_FROM}' failed\n";
      }
  
      if ($self->{ABSTRACT} && $self->{ABSTRACT} =~ m![[:cntrl:]]+!) {
              warn "WARNING: ABSTRACT contains control character(s),".
                   " they will be removed\n";
              $self->{ABSTRACT} =~ s![[:cntrl:]]+!!g;
              return;
      }
  }
  
  =head3 init_INST
  
      $mm->init_INST;
  
  Called by init_main.  Sets up all INST_* variables except those related
  to XS code.  Those are handled in init_xs.
  
  =cut
  
  sub init_INST {
      my($self) = shift;
  
      $self->{INST_ARCHLIB} ||= $self->catdir($Curdir,"blib","arch");
      $self->{INST_BIN}     ||= $self->catdir($Curdir,'blib','bin');
  
      # INST_LIB typically pre-set if building an extension after
      # perl has been built and installed. Setting INST_LIB allows
      # you to build directly into, say $Config{privlibexp}.
      unless ($self->{INST_LIB}){
          if ($self->{PERL_CORE}) {
              $self->{INST_LIB} = $self->{INST_ARCHLIB} = $self->{PERL_LIB};
          } else {
              $self->{INST_LIB} = $self->catdir($Curdir,"blib","lib");
          }
      }
  
      my @parentdir = split(/::/, $self->{PARENT_NAME});
      $self->{INST_LIBDIR}      = $self->catdir('$(INST_LIB)',     @parentdir);
      $self->{INST_ARCHLIBDIR}  = $self->catdir('$(INST_ARCHLIB)', @parentdir);
      $self->{INST_AUTODIR}     = $self->catdir('$(INST_LIB)', 'auto',
                                                '$(FULLEXT)');
      $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)', 'auto',
                                                '$(FULLEXT)');
  
      $self->{INST_SCRIPT}  ||= $self->catdir($Curdir,'blib','script');
  
      $self->{INST_MAN1DIR} ||= $self->catdir($Curdir,'blib','man1');
      $self->{INST_MAN3DIR} ||= $self->catdir($Curdir,'blib','man3');
  
      return 1;
  }
  
  
  =head3 init_INSTALL
  
      $mm->init_INSTALL;
  
  Called by init_main.  Sets up all INSTALL_* variables (except
  INSTALLDIRS) and *PREFIX.
  
  =cut
  
  sub init_INSTALL {
      my($self) = shift;
  
      if( $self->{ARGS}{INSTALL_BASE} and $self->{ARGS}{PREFIX} ) {
          die "Only one of PREFIX or INSTALL_BASE can be given.  Not both.\n";
      }
  
      if( $self->{ARGS}{INSTALL_BASE} ) {
          $self->init_INSTALL_from_INSTALL_BASE;
      }
      else {
          $self->init_INSTALL_from_PREFIX;
      }
  }
  
  
  =head3 init_INSTALL_from_PREFIX
  
    $mm->init_INSTALL_from_PREFIX;
  
  =cut
  
  sub init_INSTALL_from_PREFIX {
      my $self = shift;
  
      $self->init_lib2arch;
  
      # There are often no Config.pm defaults for these new man variables so
      # we fall back to the old behavior which is to use installman*dir
      foreach my $num (1, 3) {
          my $k = 'installsiteman'.$num.'dir';
  
          $self->{uc $k} ||= uc "\$(installman${num}dir)"
            unless $Config{$k};
      }
  
      foreach my $num (1, 3) {
          my $k = 'installvendorman'.$num.'dir';
  
          unless( $Config{$k} ) {
              $self->{uc $k}  ||= $Config{usevendorprefix}
                                ? uc "\$(installman${num}dir)"
                                : '';
          }
      }
  
      $self->{INSTALLSITEBIN} ||= '$(INSTALLBIN)'
        unless $Config{installsitebin};
      $self->{INSTALLSITESCRIPT} ||= '$(INSTALLSCRIPT)'
        unless $Config{installsitescript};
  
      unless( $Config{installvendorbin} ) {
          $self->{INSTALLVENDORBIN} ||= $Config{usevendorprefix}
                                      ? $Config{installbin}
                                      : '';
      }
      unless( $Config{installvendorscript} ) {
          $self->{INSTALLVENDORSCRIPT} ||= $Config{usevendorprefix}
                                         ? $Config{installscript}
                                         : '';
      }
  
  
      my $iprefix = $Config{installprefixexp} || $Config{installprefix} ||
                    $Config{prefixexp}        || $Config{prefix} || '';
      my $vprefix = $Config{usevendorprefix}  ? $Config{vendorprefixexp} : '';
      my $sprefix = $Config{siteprefixexp}    || '';
  
      # 5.005_03 doesn't have a siteprefix.
      $sprefix = $iprefix unless $sprefix;
  
  
      $self->{PREFIX}       ||= '';
  
      if( $self->{PREFIX} ) {
          @{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)} =
            ('$(PREFIX)') x 3;
      }
      else {
          $self->{PERLPREFIX}   ||= $iprefix;
          $self->{SITEPREFIX}   ||= $sprefix;
          $self->{VENDORPREFIX} ||= $vprefix;
  
          # Lots of MM extension authors like to use $(PREFIX) so we
          # put something sensible in there no matter what.
          $self->{PREFIX} = '$('.uc $self->{INSTALLDIRS}.'PREFIX)';
      }
  
      my $arch    = $Config{archname};
      my $version = $Config{version};
  
      # default style
      my $libstyle = $Config{installstyle} || 'lib/perl5';
      my $manstyle = '';
  
      if( $self->{LIBSTYLE} ) {
          $libstyle = $self->{LIBSTYLE};
          $manstyle = $self->{LIBSTYLE} eq 'lib/perl5' ? 'lib/perl5' : '';
      }
  
      # Some systems, like VOS, set installman*dir to '' if they can't
      # read man pages.
      for my $num (1, 3) {
          $self->{'INSTALLMAN'.$num.'DIR'} ||= 'none'
            unless $Config{'installman'.$num.'dir'};
      }
  
      my %bin_layouts =
      (
          bin         => { s => $iprefix,
                           t => 'perl',
                           d => 'bin' },
          vendorbin   => { s => $vprefix,
                           t => 'vendor',
                           d => 'bin' },
          sitebin     => { s => $sprefix,
                           t => 'site',
                           d => 'bin' },
          script      => { s => $iprefix,
                           t => 'perl',
                           d => 'bin' },
          vendorscript=> { s => $vprefix,
                           t => 'vendor',
                           d => 'bin' },
          sitescript  => { s => $sprefix,
                           t => 'site',
                           d => 'bin' },
      );
  
      my %man_layouts =
      (
          man1dir         => { s => $iprefix,
                               t => 'perl',
                               d => 'man/man1',
                               style => $manstyle, },
          siteman1dir     => { s => $sprefix,
                               t => 'site',
                               d => 'man/man1',
                               style => $manstyle, },
          vendorman1dir   => { s => $vprefix,
                               t => 'vendor',
                               d => 'man/man1',
                               style => $manstyle, },
  
          man3dir         => { s => $iprefix,
                               t => 'perl',
                               d => 'man/man3',
                               style => $manstyle, },
          siteman3dir     => { s => $sprefix,
                               t => 'site',
                               d => 'man/man3',
                               style => $manstyle, },
          vendorman3dir   => { s => $vprefix,
                               t => 'vendor',
                               d => 'man/man3',
                               style => $manstyle, },
      );
  
      my %lib_layouts =
      (
          privlib     => { s => $iprefix,
                           t => 'perl',
                           d => '',
                           style => $libstyle, },
          vendorlib   => { s => $vprefix,
                           t => 'vendor',
                           d => '',
                           style => $libstyle, },
          sitelib     => { s => $sprefix,
                           t => 'site',
                           d => 'site_perl',
                           style => $libstyle, },
  
          archlib     => { s => $iprefix,
                           t => 'perl',
                           d => "$version/$arch",
                           style => $libstyle },
          vendorarch  => { s => $vprefix,
                           t => 'vendor',
                           d => "$version/$arch",
                           style => $libstyle },
          sitearch    => { s => $sprefix,
                           t => 'site',
                           d => "site_perl/$version/$arch",
                           style => $libstyle },
      );
  
  
      # Special case for LIB.
      if( $self->{LIB} ) {
          foreach my $var (keys %lib_layouts) {
              my $Installvar = uc "install$var";
  
              if( $var =~ /arch/ ) {
                  $self->{$Installvar} ||=
                    $self->catdir($self->{LIB}, $Config{archname});
              }
              else {
                  $self->{$Installvar} ||= $self->{LIB};
              }
          }
      }
  
      my %type2prefix = ( perl    => 'PERLPREFIX',
                          site    => 'SITEPREFIX',
                          vendor  => 'VENDORPREFIX'
                        );
  
      my %layouts = (%bin_layouts, %man_layouts, %lib_layouts);
      while( my($var, $layout) = each(%layouts) ) {
          my($s, $t, $d, $style) = @{$layout}{qw(s t d style)};
          my $r = '$('.$type2prefix{$t}.')';
  
          warn "Prefixing $var\n" if $Verbose >= 2;
  
          my $installvar = "install$var";
          my $Installvar = uc $installvar;
          next if $self->{$Installvar};
  
          $d = "$style/$d" if $style;
          $self->prefixify($installvar, $s, $r, $d);
  
          warn "  $Installvar == $self->{$Installvar}\n"
            if $Verbose >= 2;
      }
  
      # Generate these if they weren't figured out.
      $self->{VENDORARCHEXP} ||= $self->{INSTALLVENDORARCH};
      $self->{VENDORLIBEXP}  ||= $self->{INSTALLVENDORLIB};
  
      return 1;
  }
  
  
  =head3 init_from_INSTALL_BASE
  
      $mm->init_from_INSTALL_BASE
  
  =cut
  
  my %map = (
             lib      => [qw(lib perl5)],
             arch     => [('lib', 'perl5', $Config{archname})],
             bin      => [qw(bin)],
             man1dir  => [qw(man man1)],
             man3dir  => [qw(man man3)]
            );
  $map{script} = $map{bin};
  
  sub init_INSTALL_from_INSTALL_BASE {
      my $self = shift;
  
      @{$self}{qw(PREFIX VENDORPREFIX SITEPREFIX PERLPREFIX)} =
                                                           '$(INSTALL_BASE)';
  
      my %install;
      foreach my $thing (keys %map) {
          foreach my $dir (('', 'SITE', 'VENDOR')) {
              my $uc_thing = uc $thing;
              my $key = "INSTALL".$dir.$uc_thing;
  
              $install{$key} ||=
                  ($thing =~ /^man.dir$/ and not $Config{lc $key})
                  ? 'none'
                  : $self->catdir('$(INSTALL_BASE)', @{$map{$thing}});
          }
      }
  
      # Adjust for variable quirks.
      $install{INSTALLARCHLIB} ||= delete $install{INSTALLARCH};
      $install{INSTALLPRIVLIB} ||= delete $install{INSTALLLIB};
  
      foreach my $key (keys %install) {
          $self->{$key} ||= $install{$key};
      }
  
      return 1;
  }
  
  
  =head3 init_VERSION  I<Abstract>
  
      $mm->init_VERSION
  
  Initialize macros representing versions of MakeMaker and other tools
  
  MAKEMAKER: path to the MakeMaker module.
  
  MM_VERSION: ExtUtils::MakeMaker Version
  
  MM_REVISION: ExtUtils::MakeMaker version control revision (for backwards
               compat)
  
  VERSION: version of your module
  
  VERSION_MACRO: which macro represents the version (usually 'VERSION')
  
  VERSION_SYM: like version but safe for use as an RCS revision number
  
  DEFINE_VERSION: -D line to set the module version when compiling
  
  XS_VERSION: version in your .xs file.  Defaults to $(VERSION)
  
  XS_VERSION_MACRO: which macro represents the XS version.
  
  XS_DEFINE_VERSION: -D line to set the xs version when compiling.
  
  Called by init_main.
  
  =cut
  
  sub init_VERSION {
      my($self) = shift;
  
      $self->{MAKEMAKER}  = $ExtUtils::MakeMaker::Filename;
      $self->{MM_VERSION} = $ExtUtils::MakeMaker::VERSION;
      $self->{MM_REVISION}= $ExtUtils::MakeMaker::Revision;
      $self->{VERSION_FROM} ||= '';
  
      if ($self->{VERSION_FROM}){
          $self->{VERSION} = $self->parse_version($self->{VERSION_FROM});
          if( $self->{VERSION} eq 'undef' ) {
              carp("WARNING: Setting VERSION via file ".
                   "'$self->{VERSION_FROM}' failed\n");
          }
      }
  
      if (defined $self->{VERSION}) {
          if ( $self->{VERSION} !~ /^\s*v?[\d_\.]+\s*$/ ) {
            require version;
            my $normal = eval { version->new( $self->{VERSION} ) };
            $self->{VERSION} = $normal if defined $normal;
          }
          $self->{VERSION} =~ s/^\s+//;
          $self->{VERSION} =~ s/\s+$//;
      }
      else {
          $self->{VERSION} = '';
      }
  
  
      $self->{VERSION_MACRO}  = 'VERSION';
      ($self->{VERSION_SYM} = $self->{VERSION}) =~ s/\W/_/g;
      $self->{DEFINE_VERSION} = '-D$(VERSION_MACRO)=\"$(VERSION)\"';
  
  
      # Graham Barr and Paul Marquess had some ideas how to ensure
      # version compatibility between the *.pm file and the
      # corresponding *.xs file. The bottom line was, that we need an
      # XS_VERSION macro that defaults to VERSION:
      $self->{XS_VERSION} ||= $self->{VERSION};
  
      $self->{XS_VERSION_MACRO}  = 'XS_VERSION';
      $self->{XS_DEFINE_VERSION} = '-D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"';
  
  }
  
  
  =head3 init_tools
  
      $MM->init_tools();
  
  Initializes the simple macro definitions used by tools_other() and
  places them in the $MM object.  These use conservative cross platform
  versions and should be overridden with platform specific versions for
  performance.
  
  Defines at least these macros.
  
    Macro             Description
  
    NOOP              Do nothing
    NOECHO            Tell make not to display the command itself
  
    SHELL             Program used to run shell commands
  
    ECHO              Print text adding a newline on the end
    RM_F              Remove a file
    RM_RF             Remove a directory
    TOUCH             Update a file's timestamp
    TEST_F            Test for a file's existence
    TEST_S            Test the size of a file
    CP                Copy a file
    CP_NONEMPTY       Copy a file if it is not empty
    MV                Move a file
    CHMOD             Change permissions on a file
    FALSE             Exit with non-zero
    TRUE              Exit with zero
  
    UMASK_NULL        Nullify umask
    DEV_NULL          Suppress all command output
  
  =cut
  
  sub init_tools {
      my $self = shift;
  
      $self->{ECHO}     ||= $self->oneliner('binmode STDOUT, qq{:raw}; print qq{@ARGV}', ['-l']);
      $self->{ECHO_N}   ||= $self->oneliner('print qq{@ARGV}');
  
      $self->{TOUCH}    ||= $self->oneliner('touch', ["-MExtUtils::Command"]);
      $self->{CHMOD}    ||= $self->oneliner('chmod', ["-MExtUtils::Command"]);
      $self->{RM_F}     ||= $self->oneliner('rm_f',  ["-MExtUtils::Command"]);
      $self->{RM_RF}    ||= $self->oneliner('rm_rf', ["-MExtUtils::Command"]);
      $self->{TEST_F}   ||= $self->oneliner('test_f', ["-MExtUtils::Command"]);
      $self->{TEST_S}   ||= $self->oneliner('test_s', ["-MExtUtils::Command::MM"]);
      $self->{CP_NONEMPTY} ||= $self->oneliner('cp_nonempty', ["-MExtUtils::Command::MM"]);
      $self->{FALSE}    ||= $self->oneliner('exit 1');
      $self->{TRUE}     ||= $self->oneliner('exit 0');
  
      $self->{MKPATH}   ||= $self->oneliner('mkpath', ["-MExtUtils::Command"]);
  
      $self->{CP}       ||= $self->oneliner('cp', ["-MExtUtils::Command"]);
      $self->{MV}       ||= $self->oneliner('mv', ["-MExtUtils::Command"]);
  
      $self->{MOD_INSTALL} ||=
        $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
  install([ from_to => {@ARGV}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
      $self->{DOC_INSTALL} ||= $self->oneliner('perllocal_install', ["-MExtUtils::Command::MM"]);
      $self->{UNINSTALL}   ||= $self->oneliner('uninstall', ["-MExtUtils::Command::MM"]);
      $self->{WARN_IF_OLD_PACKLIST} ||=
        $self->oneliner('warn_if_old_packlist', ["-MExtUtils::Command::MM"]);
      $self->{FIXIN}       ||= $self->oneliner('MY->fixin(shift)', ["-MExtUtils::MY"]);
      $self->{EQUALIZE_TIMESTAMP} ||= $self->oneliner('eqtime', ["-MExtUtils::Command"]);
  
      $self->{UNINST}     ||= 0;
      $self->{VERBINST}   ||= 0;
  
      $self->{SHELL}              ||= $Config{sh};
  
      # UMASK_NULL is not used by MakeMaker but some CPAN modules
      # make use of it.
      $self->{UMASK_NULL}         ||= "umask 0";
  
      # Not the greatest default, but its something.
      $self->{DEV_NULL}           ||= "> /dev/null 2>&1";
  
      $self->{NOOP}               ||= '$(TRUE)';
      $self->{NOECHO}             = '@' unless defined $self->{NOECHO};
  
      $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE} || 'Makefile';
      $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE};
      $self->{MAKEFILE_OLD}       ||= $self->{MAKEFILE}.'.old';
      $self->{MAKE_APERL_FILE}    ||= $self->{MAKEFILE}.'.aperl';
  
      # Not everybody uses -f to indicate "use this Makefile instead"
      $self->{USEMAKEFILE}        ||= '-f';
  
      # Some makes require a wrapper around macros passed in on the command
      # line.
      $self->{MACROSTART}         ||= '';
      $self->{MACROEND}           ||= '';
  
      return;
  }
  
  
  =head3 init_others
  
      $MM->init_others();
  
  Initializes the macro definitions having to do with compiling and
  linking used by tools_other() and places them in the $MM object.
  
  If there is no description, its the same as the parameter to
  WriteMakefile() documented in ExtUtils::MakeMaker.
  
  =cut
  
  sub init_others {
      my $self = shift;
  
      $self->{LD_RUN_PATH} = "";
  
      $self->{LIBS} = $self->_fix_libs($self->{LIBS});
  
      # Compute EXTRALIBS, BSLOADLIBS and LDLOADLIBS from $self->{LIBS}
      foreach my $libs ( @{$self->{LIBS}} ){
          $libs =~ s/^\s*(.*\S)\s*$/$1/; # remove leading and trailing whitespace
          my(@libs) = $self->extliblist($libs);
          if ($libs[0] or $libs[1] or $libs[2]){
              # LD_RUN_PATH now computed by ExtUtils::Liblist
              ($self->{EXTRALIBS},  $self->{BSLOADLIBS},
               $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @libs;
              last;
          }
      }
  
      if ( $self->{OBJECT} ) {
          $self->{OBJECT} = join(" ", @{$self->{OBJECT}}) if ref $self->{OBJECT};
          $self->{OBJECT} =~ s!\.o(bj)?\b!\$(OBJ_EXT)!g;
      } elsif ( ($self->{MAGICXS} || $self->{XSMULTI}) && @{$self->{O_FILES}||[]} ) {
          $self->{OBJECT} = join(" ", @{$self->{O_FILES}});
          $self->{OBJECT} =~ s!\.o(bj)?\b!\$(OBJ_EXT)!g;
      } else {
          # init_dirscan should have found out, if we have C files
          $self->{OBJECT} = "";
          $self->{OBJECT} = '$(BASEEXT)$(OBJ_EXT)' if @{$self->{C}||[]};
      }
      $self->{OBJECT} =~ s/\n+/ \\\n\t/g;
  
      $self->{BOOTDEP}  = (-f "$self->{BASEEXT}_BS") ? "$self->{BASEEXT}_BS" : "";
      $self->{PERLMAINCC} ||= '$(CC)';
      $self->{LDFROM} = '$(OBJECT)' unless $self->{LDFROM};
  
      # Sanity check: don't define LINKTYPE = dynamic if we're skipping
      # the 'dynamic' section of MM.  We don't have this problem with
      # 'static', since we either must use it (%Config says we can't
      # use dynamic loading) or the caller asked for it explicitly.
      if (!$self->{LINKTYPE}) {
         $self->{LINKTYPE} = $self->{SKIPHASH}{'dynamic'}
                          ? 'static'
                          : ($Config{usedl} ? 'dynamic' : 'static');
      }
  
      return;
  }
  
  
  # Lets look at $self->{LIBS} carefully: It may be an anon array, a string or
  # undefined. In any case we turn it into an anon array
  sub _fix_libs {
      my($self, $libs) = @_;
  
      return !defined $libs       ? ['']          :
             !ref $libs           ? [$libs]       :
             !defined $libs->[0]  ? ['']          :
                                    $libs         ;
  }
  
  
  =head3 tools_other
  
      my $make_frag = $MM->tools_other;
  
  Returns a make fragment containing definitions for the macros init_others()
  initializes.
  
  =cut
  
  sub tools_other {
      my($self) = shift;
      my @m;
  
      # We set PM_FILTER as late as possible so it can see all the earlier
      # on macro-order sensitive makes such as nmake.
      for my $tool (qw{ SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH
                        UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP
                        FALSE TRUE
                        ECHO ECHO_N
                        UNINST VERBINST
                        MOD_INSTALL DOC_INSTALL UNINSTALL
                        WARN_IF_OLD_PACKLIST
                        MACROSTART MACROEND
                        USEMAKEFILE
                        PM_FILTER
                        FIXIN
                        CP_NONEMPTY
                      } )
      {
          next unless defined $self->{$tool};
          push @m, "$tool = $self->{$tool}\n";
      }
  
      return join "", @m;
  }
  
  
  =head3 init_DIRFILESEP  I<Abstract>
  
    $MM->init_DIRFILESEP;
    my $dirfilesep = $MM->{DIRFILESEP};
  
  Initializes the DIRFILESEP macro which is the separator between the
  directory and filename in a filepath.  ie. / on Unix, \ on Win32 and
  nothing on VMS.
  
  For example:
  
      # instead of $(INST_ARCHAUTODIR)/extralibs.ld
      $(INST_ARCHAUTODIR)$(DIRFILESEP)extralibs.ld
  
  Something of a hack but it prevents a lot of code duplication between
  MM_* variants.
  
  Do not use this as a separator between directories.  Some operating
  systems use different separators between subdirectories as between
  directories and filenames (for example:  VOLUME:[dir1.dir2]file on VMS).
  
  =head3 init_linker  I<Abstract>
  
      $mm->init_linker;
  
  Initialize macros which have to do with linking.
  
  PERL_ARCHIVE: path to libperl.a equivalent to be linked to dynamic
  extensions.
  
  PERL_ARCHIVE_AFTER: path to a library which should be put on the
  linker command line I<after> the external libraries to be linked to
  dynamic extensions.  This may be needed if the linker is one-pass, and
  Perl includes some overrides for C RTL functions, such as malloc().
  
  EXPORT_LIST: name of a file that is passed to linker to define symbols
  to be exported.
  
  Some OSes do not need these in which case leave it blank.
  
  
  =head3 init_platform
  
      $mm->init_platform
  
  Initialize any macros which are for platform specific use only.
  
  A typical one is the version number of your OS specific module.
  (ie. MM_Unix_VERSION or MM_VMS_VERSION).
  
  =cut
  
  sub init_platform {
      return '';
  }
  
  
  =head3 init_MAKE
  
      $mm->init_MAKE
  
  Initialize MAKE from either a MAKE environment variable or $Config{make}.
  
  =cut
  
  sub init_MAKE {
      my $self = shift;
  
      $self->{MAKE} ||= $ENV{MAKE} || $Config{make};
  }
  
  
  =head2 Tools
  
  A grab bag of methods to generate specific macros and commands.
  
  
  
  =head3 manifypods
  
  Defines targets and routines to translate the pods into manpages and
  put them into the INST_* directories.
  
  =cut
  
  sub manifypods {
      my $self          = shift;
  
      my $POD2MAN_macro = $self->POD2MAN_macro();
      my $manifypods_target = $self->manifypods_target();
  
      return <<END_OF_TARGET;
  
  $POD2MAN_macro
  
  $manifypods_target
  
  END_OF_TARGET
  
  }
  
  
  =head3 POD2MAN_macro
  
    my $pod2man_macro = $self->POD2MAN_macro
  
  Returns a definition for the POD2MAN macro.  This is a program
  which emulates the pod2man utility.  You can add more switches to the
  command by simply appending them on the macro.
  
  Typical usage:
  
      $(POD2MAN) --section=3 --perm_rw=$(PERM_RW) podfile1 man_page1 ...
  
  =cut
  
  sub POD2MAN_macro {
      my $self = shift;
  
  # Need the trailing '--' so perl stops gobbling arguments and - happens
  # to be an alternative end of line separator on VMS so we quote it
      return <<'END_OF_DEF';
  POD2MAN_EXE = $(PERLRUN) "-MExtUtils::Command::MM" -e pod2man "--"
  POD2MAN = $(POD2MAN_EXE)
  END_OF_DEF
  }
  
  
  =head3 test_via_harness
  
    my $command = $mm->test_via_harness($perl, $tests);
  
  Returns a $command line which runs the given set of $tests with
  Test::Harness and the given $perl.
  
  Used on the t/*.t files.
  
  =cut
  
  sub test_via_harness {
      my($self, $perl, $tests) = @_;
  
      return qq{\t$perl "-MExtUtils::Command::MM" "-MTest::Harness" }.
             qq{"-e" "undef *Test::Harness::Switches; test_harness(\$(TEST_VERBOSE), '\$(INST_LIB)', '\$(INST_ARCHLIB)')" $tests\n};
  }
  
  =head3 test_via_script
  
    my $command = $mm->test_via_script($perl, $script);
  
  Returns a $command line which just runs a single test without
  Test::Harness.  No checks are done on the results, they're just
  printed.
  
  Used for test.pl, since they don't always follow Test::Harness
  formatting.
  
  =cut
  
  sub test_via_script {
      my($self, $perl, $script) = @_;
      return qq{\t$perl "-I\$(INST_LIB)" "-I\$(INST_ARCHLIB)" $script\n};
  }
  
  
  =head3 tool_autosplit
  
  Defines a simple perl call that runs autosplit. May be deprecated by
  pm_to_blib soon.
  
  =cut
  
  sub tool_autosplit {
      my($self, %attribs) = @_;
  
      my $maxlen = $attribs{MAXLEN} ? '$$AutoSplit::Maxlen=$attribs{MAXLEN};'
                                    : '';
  
      my $asplit = $self->oneliner(sprintf <<'PERL_CODE', $maxlen);
  use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1)
  PERL_CODE
  
      return sprintf <<'MAKE_FRAG', $asplit;
  # Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
  AUTOSPLITFILE = %s
  
  MAKE_FRAG
  
  }
  
  
  =head3 arch_check
  
      my $arch_ok = $mm->arch_check(
          $INC{"Config.pm"},
          File::Spec->catfile($Config{archlibexp}, "Config.pm")
      );
  
  A sanity check that what Perl thinks the architecture is and what
  Config thinks the architecture is are the same.  If they're not it
  will return false and show a diagnostic message.
  
  When building Perl it will always return true, as nothing is installed
  yet.
  
  The interface is a bit odd because this is the result of a
  quick refactoring.  Don't rely on it.
  
  =cut
  
  sub arch_check {
      my $self = shift;
      my($pconfig, $cconfig) = @_;
  
      return 1 if $self->{PERL_SRC};
  
      my($pvol, $pthinks) = $self->splitpath($pconfig);
      my($cvol, $cthinks) = $self->splitpath($cconfig);
  
      $pthinks = $self->canonpath($pthinks);
      $cthinks = $self->canonpath($cthinks);
  
      my $ret = 1;
      if ($pthinks ne $cthinks) {
          print "Have $pthinks\n";
          print "Want $cthinks\n";
  
          $ret = 0;
  
          my $arch = (grep length, $self->splitdir($pthinks))[-1];
  
          print <<END unless $self->{UNINSTALLED_PERL};
  Your perl and your Config.pm seem to have different ideas about the
  architecture they are running on.
  Perl thinks: [$arch]
  Config says: [$Config{archname}]
  This may or may not cause problems. Please check your installation of perl
  if you have problems building this extension.
  END
      }
  
      return $ret;
  }
  
  
  
  =head2 File::Spec wrappers
  
  ExtUtils::MM_Any is a subclass of File::Spec.  The methods noted here
  override File::Spec.
  
  
  
  =head3 catfile
  
  File::Spec <= 0.83 has a bug where the file part of catfile is not
  canonicalized.  This override fixes that bug.
  
  =cut
  
  sub catfile {
      my $self = shift;
      return $self->canonpath($self->SUPER::catfile(@_));
  }
  
  
  
  =head2 Misc
  
  Methods I can't really figure out where they should go yet.
  
  
  =head3 find_tests
  
    my $test = $mm->find_tests;
  
  Returns a string suitable for feeding to the shell to return all
  tests in t/*.t.
  
  =cut
  
  sub find_tests {
      my($self) = shift;
      return -d 't' ? 't/*.t' : '';
  }
  
  =head3 find_tests_recursive
  
    my $tests = $mm->find_tests_recursive;
  
  Returns a string suitable for feeding to the shell to return all
  tests in t/ but recursively. Equivalent to
  
    my $tests = $mm->find_tests_recursive_in('t');
  
  =cut
  
  sub find_tests_recursive {
      my $self = shift;
      return $self->find_tests_recursive_in('t');
  }
  
  =head3 find_tests_recursive_in
  
    my $tests = $mm->find_tests_recursive_in($dir);
  
  Returns a string suitable for feeding to the shell to return all
  tests in $dir recursively.
  
  =cut
  
  sub find_tests_recursive_in {
      my($self, $dir) = @_;
      return '' unless -d $dir;
  
      require File::Find;
  
      my $base_depth = grep { $_ ne '' } File::Spec->splitdir( (File::Spec->splitpath($dir))[1] );
      my %depths;
  
      my $wanted = sub {
          return unless m!\.t$!;
          my ($volume,$directories,$file) =
              File::Spec->splitpath( $File::Find::name  );
          my $depth = grep { $_ ne '' } File::Spec->splitdir( $directories );
          $depth -= $base_depth;
          $depths{ $depth } = 1;
      };
  
      File::Find::find( $wanted, $dir );
  
      return join ' ',
          map { $dir . '/*' x $_ . '.t' }
          sort { $a <=> $b }
          keys %depths;
  }
  
  =head3 extra_clean_files
  
      my @files_to_clean = $MM->extra_clean_files;
  
  Returns a list of OS specific files to be removed in the clean target in
  addition to the usual set.
  
  =cut
  
  # An empty method here tickled a perl 5.8.1 bug and would return its object.
  sub extra_clean_files {
      return;
  }
  
  
  =head3 installvars
  
      my @installvars = $mm->installvars;
  
  A list of all the INSTALL* variables without the INSTALL prefix.  Useful
  for iteration or building related variable sets.
  
  =cut
  
  sub installvars {
      return qw(PRIVLIB SITELIB  VENDORLIB
                ARCHLIB SITEARCH VENDORARCH
                BIN     SITEBIN  VENDORBIN
                SCRIPT  SITESCRIPT  VENDORSCRIPT
                MAN1DIR SITEMAN1DIR VENDORMAN1DIR
                MAN3DIR SITEMAN3DIR VENDORMAN3DIR
               );
  }
  
  
  =head3 libscan
  
    my $wanted = $self->libscan($path);
  
  Takes a path to a file or dir and returns an empty string if we don't
  want to include this file in the library.  Otherwise it returns the
  the $path unchanged.
  
  Mainly used to exclude version control administrative directories
  and base-level F<README.pod> from installation.
  
  =cut
  
  sub libscan {
      my($self,$path) = @_;
  
      if ($path =~ m<^README\.pod$>i) {
          warn "WARNING: Older versions of ExtUtils::MakeMaker may errantly install $path as part of this distribution. It is recommended to avoid using this path in CPAN modules.\n"
            unless $ENV{PERL_CORE};
          return '';
      }
  
      my($dirs,$file) = ($self->splitpath($path))[1,2];
      return '' if grep /^(?:RCS|CVS|SCCS|\.svn|_darcs)$/,
                       $self->splitdir($dirs), $file;
  
      return $path;
  }
  
  
  =head3 platform_constants
  
      my $make_frag = $mm->platform_constants
  
  Returns a make fragment defining all the macros initialized in
  init_platform() rather than put them in constants().
  
  =cut
  
  sub platform_constants {
      return '';
  }
  
  =head3 post_constants (o)
  
  Returns an empty string per default. Dedicated to overrides from
  within Makefile.PL after all constants have been defined.
  
  =cut
  
  sub post_constants {
      "";
  }
  
  =head3 post_initialize (o)
  
  Returns an empty string per default. Used in Makefile.PLs to add some
  chunk of text to the Makefile after the object is initialized.
  
  =cut
  
  sub post_initialize {
      "";
  }
  
  =head3 postamble (o)
  
  Returns an empty string. Can be used in Makefile.PLs to write some
  text to the Makefile at the end.
  
  =cut
  
  sub postamble {
      "";
  }
  
  =begin private
  
  =head3 _PREREQ_PRINT
  
      $self->_PREREQ_PRINT;
  
  Implements PREREQ_PRINT.
  
  Refactored out of MakeMaker->new().
  
  =end private
  
  =cut
  
  sub _PREREQ_PRINT {
      my $self = shift;
  
      require Data::Dumper;
      my @what = ('PREREQ_PM');
      push @what, 'MIN_PERL_VERSION' if $self->{MIN_PERL_VERSION};
      push @what, 'BUILD_REQUIRES'   if $self->{BUILD_REQUIRES};
      print Data::Dumper->Dump([@{$self}{@what}], \@what);
      exit 0;
  }
  
  
  =begin private
  
  =head3 _PRINT_PREREQ
  
    $mm->_PRINT_PREREQ;
  
  Implements PRINT_PREREQ, a slightly different version of PREREQ_PRINT
  added by Redhat to, I think, support generating RPMs from Perl modules.
  
  Should not include BUILD_REQUIRES as RPMs do not include them.
  
  Refactored out of MakeMaker->new().
  
  =end private
  
  =cut
  
  sub _PRINT_PREREQ {
      my $self = shift;
  
      my $prereqs= $self->{PREREQ_PM};
      my @prereq = map { [$_, $prereqs->{$_}] } keys %$prereqs;
  
      if ( $self->{MIN_PERL_VERSION} ) {
          push @prereq, ['perl' => $self->{MIN_PERL_VERSION}];
      }
  
      print join(" ", map { "perl($_->[0])>=$_->[1] " }
                   sort { $a->[0] cmp $b->[0] } @prereq), "\n";
      exit 0;
  }
  
  
  =begin private
  
  =head3 _perl_header_files
  
    my $perl_header_files= $self->_perl_header_files;
  
  returns a sorted list of header files as found in PERL_SRC or $archlibexp/CORE.
  
  Used by perldepend() in MM_Unix and MM_VMS via _perl_header_files_fragment()
  
  =end private
  
  =cut
  
  sub _perl_header_files {
      my $self = shift;
  
      my $header_dir = $self->{PERL_SRC} || $ENV{PERL_SRC} || $self->catdir($Config{archlibexp}, 'CORE');
      opendir my $dh, $header_dir
          or die "Failed to opendir '$header_dir' to find header files: $!";
  
      # we need to use a temporary here as the sort in scalar context would have undefined results.
      my @perl_headers= sort grep { /\.h\z/ } readdir($dh);
  
      closedir $dh;
  
      return @perl_headers;
  }
  
  =begin private
  
  =head3 _perl_header_files_fragment ($o, $separator)
  
    my $perl_header_files_fragment= $self->_perl_header_files_fragment("/");
  
  return a Makefile fragment which holds the list of perl header files which
  XS code depends on $(PERL_INC), and sets up the dependency for the $(OBJECT) file.
  
  The $separator argument defaults to "". MM_VMS will set it to "" and MM_UNIX to "/"
  in perldepend(). This reason child subclasses need to control this is that in
  VMS the $(PERL_INC) directory will already have delimiters in it, but in
  UNIX $(PERL_INC) will need a slash between it an the filename. Hypothetically
  win32 could use "\\" (but it doesn't need to).
  
  =end private
  
  =cut
  
  sub _perl_header_files_fragment {
      my ($self, $separator)= @_;
      $separator ||= "";
      return join("\\\n",
                  "PERL_HDRS = ",
                  map {
                      sprintf( "        \$(PERL_INCDEP)%s%s            ", $separator, $_ )
                  } $self->_perl_header_files()
             ) . "\n\n"
             . "\$(OBJECT) : \$(PERL_HDRS)\n";
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> and the denizens of
  makemaker@perl.org with code from ExtUtils::MM_Unix and
  ExtUtils::MM_Win32.
  
  
  =cut
  
  1;
EXTUTILS_MM_ANY

$fatpacked{"ExtUtils/MM_BeOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_BEOS';
  package ExtUtils::MM_BeOS;
  
  use strict;
  
  =head1 NAME
  
  ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_BeOS;	# Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =cut
  
  use ExtUtils::MakeMaker::Config;
  use File::Spec;
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  
  =item os_flavor
  
  BeOS is BeOS.
  
  =cut
  
  sub os_flavor {
      return('BeOS');
  }
  
  =item init_linker
  
  libperl.a equivalent to be linked to dynamic extensions.
  
  =cut
  
  sub init_linker {
      my($self) = shift;
  
      $self->{PERL_ARCHIVE} ||=
        File::Spec->catdir('$(PERL_INC)',$Config{libperl});
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  =back
  
  =cut
  
  1;
  __END__
  
EXTUTILS_MM_BEOS

$fatpacked{"ExtUtils/MM_Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_CYGWIN';
  package ExtUtils::MM_Cygwin;
  
  use strict;
  
  use ExtUtils::MakeMaker::Config;
  use File::Spec;
  
  require ExtUtils::MM_Unix;
  require ExtUtils::MM_Win32;
  our @ISA = qw( ExtUtils::MM_Unix );
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  
  =head1 NAME
  
  ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_Cygwin; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided there.
  
  =over 4
  
  =item os_flavor
  
  We're Unix and Cygwin.
  
  =cut
  
  sub os_flavor {
      return('Unix', 'Cygwin');
  }
  
  =item cflags
  
  if configured for dynamic loading, triggers #define EXT in EXTERN.h
  
  =cut
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my $base = $self->SUPER::cflags($libperl);
      foreach (split /\n/, $base) {
          /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
      };
      $self->{CCFLAGS} .= " -DUSEIMPORTLIB" if ($Config{useshrplib} eq 'true');
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  
  }
  
  
  =item replace_manpage_separator
  
  replaces strings '::' with '.' in MAN*POD man page names
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
      $man =~ s{/+}{.}g;
      return $man;
  }
  
  =item init_linker
  
  points to libperl.a
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      if ($Config{useshrplib} eq 'true') {
          my $libperl = '$(PERL_INC)' .'/'. "$Config{libperl}";
          if( "$]" >= 5.006002 ) {
              $libperl =~ s/(dll\.)?a$/dll.a/;
          }
          $self->{PERL_ARCHIVE} = $libperl;
      } else {
          $self->{PERL_ARCHIVE} =
            '$(PERL_INC)' .'/'. ("$Config{libperl}" or "libperl.a");
      }
  
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  =item maybe_command
  
  Determine whether a file is native to Cygwin by checking whether it
  resides inside the Cygwin installation (using Windows paths). If so,
  use C<ExtUtils::MM_Unix> to determine if it may be a command.
  Otherwise use the tests from C<ExtUtils::MM_Win32>.
  
  =cut
  
  sub maybe_command {
      my ($self, $file) = @_;
  
      my $cygpath = Cygwin::posix_to_win_path('/', 1);
      my $filepath = Cygwin::posix_to_win_path($file, 1);
  
      return (substr($filepath,0,length($cygpath)) eq $cygpath)
      ? $self->SUPER::maybe_command($file) # Unix
      : ExtUtils::MM_Win32->maybe_command($file); # Win32
  }
  
  =item dynamic_lib
  
  Use the default to produce the *.dll's.
  But for new archdir dll's use the same rebase address if the old exists.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      my $s = ExtUtils::MM_Unix::dynamic_lib($self, %attribs);
      return '' unless $s;
      return $s unless %{$self->{XS}};
  
      # do an ephemeral rebase so the new DLL fits to the current rebase map
      $s .= "\t/bin/find \$\(INST_ARCHLIB\)/auto -xdev -name \\*.$self->{DLEXT} | /bin/rebase -sOT -" if (( $Config{myarchname} eq 'i686-cygwin' ) and not ( exists $ENV{CYGPORT_PACKAGE_VERSION} ));
      $s;
  }
  
  =item install
  
  Rebase dll's with the global rebase database after installation.
  
  =cut
  
  sub install {
      my($self, %attribs) = @_;
      my $s = ExtUtils::MM_Unix::install($self, %attribs);
      return '' unless $s;
      return $s unless %{$self->{XS}};
  
      my $INSTALLDIRS = $self->{INSTALLDIRS};
      my $INSTALLLIB = $self->{"INSTALL". ($INSTALLDIRS eq 'perl' ? 'ARCHLIB' : uc($INSTALLDIRS)."ARCH")};
      my $dop = "\$\(DESTDIR\)$INSTALLLIB/auto/";
      my $dll = "$dop/$self->{FULLEXT}/$self->{BASEEXT}.$self->{DLEXT}";
      $s =~ s|^(pure_install :: pure_\$\(INSTALLDIRS\)_install\n\t)\$\(NOECHO\) \$\(NOOP\)\n|$1\$(CHMOD) \$(PERM_RWX) $dll\n\t/bin/find $dop -xdev -name \\*.$self->{DLEXT} \| /bin/rebase -sOT -\n|m if (( $Config{myarchname} eq 'i686-cygwin') and not ( exists $ENV{CYGPORT_PACKAGE_VERSION} ));
      $s;
  }
  
  =item all_target
  
  Build man pages, too
  
  =cut
  
  sub all_target {
      ExtUtils::MM_Unix::all_target(shift);
  }
  
  =back
  
  =cut
  
  1;
EXTUTILS_MM_CYGWIN

$fatpacked{"ExtUtils/MM_DOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DOS';
  package ExtUtils::MM_DOS;
  
  use strict;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  
  
  =head1 NAME
  
  ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality
  for DOS.
  
  Unless otherwise stated, it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =over 4
  
  =item os_flavor
  
  =cut
  
  sub os_flavor {
      return('DOS');
  }
  
  =item B<replace_manpage_separator>
  
  Generates Foo__Bar.3 style man page names
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
  
      $man =~ s,/+,__,g;
      return $man;
  }
  
  =item xs_static_lib_is_xs
  
  =cut
  
  sub xs_static_lib_is_xs {
      return 1;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MM_Unix>, L<ExtUtils::MakeMaker>
  
  =cut
  
  1;
EXTUTILS_MM_DOS

$fatpacked{"ExtUtils/MM_Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DARWIN';
  package ExtUtils::MM_Darwin;
  
  use strict;
  
  BEGIN {
      require ExtUtils::MM_Unix;
      our @ISA = qw( ExtUtils::MM_Unix );
  }
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  
  =head1 NAME
  
  ExtUtils::MM_Darwin - special behaviors for OS X
  
  =head1 SYNOPSIS
  
      For internal MakeMaker use only
  
  =head1 DESCRIPTION
  
  See L<ExtUtils::MM_Unix> for L<ExtUtils::MM_Any> for documentation on the
  methods overridden here.
  
  =head2 Overridden Methods
  
  =head3 init_dist
  
  Turn off Apple tar's tendency to copy resource forks as "._foo" files.
  
  =cut
  
  sub init_dist {
      my $self = shift;
  
      # Thank you, Apple, for breaking tar and then breaking the work around.
      # 10.4 wants COPY_EXTENDED_ATTRIBUTES_DISABLE while 10.5 wants
      # COPYFILE_DISABLE.  I'm not going to push my luck and instead just
      # set both.
      $self->{TAR} ||=
          'COPY_EXTENDED_ATTRIBUTES_DISABLE=1 COPYFILE_DISABLE=1 tar';
  
      $self->SUPER::init_dist(@_);
  }
  
  1;
EXTUTILS_MM_DARWIN

$fatpacked{"ExtUtils/MM_MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_MACOS';
  package ExtUtils::MM_MacOS;
  
  use strict;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  sub new {
      die 'MacOS Classic (MacPerl) is no longer supported by MakeMaker';
  }
  
  =head1 NAME
  
  ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic
  
  =head1 SYNOPSIS
  
    # MM_MacOS no longer contains any code.  This is just a stub.
  
  =head1 DESCRIPTION
  
  Once upon a time, MakeMaker could produce an approximation of a correct
  Makefile on MacOS Classic (MacPerl).  Due to a lack of maintainers, this
  fell out of sync with the rest of MakeMaker and hadn't worked in years.
  Since there's little chance of it being repaired, MacOS Classic is fading
  away, and the code was icky to begin with, the code has been deleted to
  make maintenance easier.
  
  Anyone interested in resurrecting this file should pull the old version
  from the MakeMaker CVS repository and contact makemaker@perl.org.
  
  =cut
  
  1;
EXTUTILS_MM_MACOS

$fatpacked{"ExtUtils/MM_NW5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_NW5';
  package ExtUtils::MM_NW5;
  
  =head1 NAME
  
  ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_NW5; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over
  
  =cut
  
  use strict;
  use ExtUtils::MakeMaker::Config;
  use File::Basename;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Win32;
  our @ISA = qw(ExtUtils::MM_Win32);
  
  use ExtUtils::MakeMaker qw(&neatvalue &_sprintf562);
  
  $ENV{EMXSHELL} = 'sh'; # to run `commands`
  
  my $BORLAND  = $Config{'cc'} =~ /\bbcc/i;
  my $GCC      = $Config{'cc'} =~ /\bgcc/i;
  
  
  =item os_flavor
  
  We're Netware in addition to being Windows.
  
  =cut
  
  sub os_flavor {
      my $self = shift;
      return ($self->SUPER::os_flavor, 'Netware');
  }
  
  =item init_platform
  
  Add Netware macros.
  
  LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL,
  NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION
  
  
  =item platform_constants
  
  Add Netware macros initialized above to the Makefile.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      # To get Win32's setup.
      $self->SUPER::init_platform;
  
      # incpath is copied to makefile var INCLUDE in constants sub, here just
      # make it empty
      my $libpth = $Config{'libpth'};
      $libpth =~ s( )(;);
      $self->{'LIBPTH'} = $libpth;
  
      $self->{'BASE_IMPORT'} = $Config{'base_import'};
  
      # Additional import file specified from Makefile.pl
      if($self->{'base_import'}) {
          $self->{'BASE_IMPORT'} .= ', ' . $self->{'base_import'};
      }
  
      $self->{'NLM_VERSION'} = $Config{'nlm_version'};
      $self->{'MPKTOOL'}	= $Config{'mpktool'};
      $self->{'TOOLPATH'}	= $Config{'toolpath'};
  
      (my $boot = $self->{'NAME'}) =~ s/:/_/g;
      $self->{'BOOT_SYMBOL'}=$boot;
  
      # If the final binary name is greater than 8 chars,
      # truncate it here.
      if(length($self->{'BASEEXT'}) > 8) {
          $self->{'NLM_SHORT_NAME'} = substr($self->{'BASEEXT'},0,8);
      }
  
      # Get the include path and replace the spaces with ;
      # Copy this to makefile as INCLUDE = d:\...;d:\;
      ($self->{INCLUDE} = $Config{'incpath'}) =~ s/([ ]*)-I/;/g;
  
      # Set the path to CodeWarrior binaries which might not have been set in
      # any other place
      $self->{PATH} = '$(PATH);$(TOOLPATH)';
  
      $self->{MM_NW5_VERSION} = $VERSION;
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      # Setup Win32's constants.
      $make_frag .= $self->SUPER::platform_constants;
  
      foreach my $macro (qw(LIBPTH BASE_IMPORT NLM_VERSION MPKTOOL
                            TOOLPATH BOOT_SYMBOL NLM_SHORT_NAME INCLUDE PATH
                            MM_NW5_VERSION
                        ))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  =item static_lib_pure_cmd
  
  Defines how to run the archive utility
  
  =cut
  
  sub static_lib_pure_cmd {
      my ($self, $src) = @_;
      $src =~ s/(\$\(\w+)(\))/$1:^"+"$2/g if $BORLAND;
      sprintf qq{\t\$(AR) %s\n}, ($BORLAND ? '$@ ' . $src
                            : ($GCC ? '-ru $@ ' . $src
                                    : '-type library -o $@ ' . $src));
  }
  
  =item xs_static_lib_is_xs
  
  =cut
  
  sub xs_static_lib_is_xs {
      return 1;
  }
  
  =item dynamic_lib
  
  Override of utility methods for OS-specific work.
  
  =cut
  
  sub xs_make_dynamic_lib {
      my ($self, $attribs, $from, $to, $todir, $ldfrom, $exportlist) = @_;
      my @m;
      # Taking care of long names like FileHandle, ByteLoader, SDBM_File etc
      if ($to =~ /^\$/) {
          if ($self->{NLM_SHORT_NAME}) {
              # deal with shortnames
              my $newto = q{$(INST_AUTODIR)\\$(NLM_SHORT_NAME).$(DLEXT)};
              push @m, "$to: $newto\n\n";
              $to = $newto;
          }
      } else {
          my ($v, $d, $f) = File::Spec->splitpath($to);
          # relies on $f having a literal "." in it, unlike for $(OBJ_EXT)
          if ($f =~ /[^\.]{9}\./) {
              # 9+ chars before '.', need to shorten
              $f = substr $f, 0, 8;
          }
          my $newto = File::Spec->catpath($v, $d, $f);
          push @m, "$to: $newto\n\n";
          $to = $newto;
      }
      # bits below should be in dlsyms, not here
      #                                   1    2      3       4
      push @m, _sprintf562 <<'MAKE_FRAG', $to, $from, $todir, $exportlist;
  # Create xdc data for an MT safe NLM in case of mpk build
  %1$s: %2$s $(MYEXTLIB) $(BOOTSTRAP) %3$s$(DFSEP).exists
  	$(NOECHO) $(ECHO) Export boot_$(BOOT_SYMBOL) > %4$s
  	$(NOECHO) $(ECHO) $(BASE_IMPORT) >> %4$s
  	$(NOECHO) $(ECHO) Import @$(PERL_INC)\perl.imp >> %4$s
  MAKE_FRAG
      if ( $self->{CCFLAGS} =~ m/ -DMPK_ON /) {
          (my $xdc = $exportlist) =~ s#def\z#xdc#;
          $xdc = '$(BASEEXT).xdc';
          push @m, sprintf <<'MAKE_FRAG', $xdc, $exportlist;
  	$(MPKTOOL) $(XDCFLAGS) %s
  	$(NOECHO) $(ECHO) xdcdata $(BASEEXT).xdc >> %s
  MAKE_FRAG
      }
      # Reconstruct the X.Y.Z version.
      my $version = join '.', map { sprintf "%d", $_ }
                                "$]" =~ /(\d)\.(\d{3})(\d{2})/;
      push @m, sprintf <<'EOF', $from, $version, $to, $exportlist;
  	$(LD) $(LDFLAGS) %s -desc "Perl %s Extension ($(BASEEXT))  XS_VERSION: $(XS_VERSION)" -nlmversion $(NLM_VERSION) -o %s $(MYEXTLIB) $(PERL_INC)\Main.lib -commandfile %s
  	$(CHMOD) 755 $@
  EOF
      join '', @m;
  }
  
  1;
  __END__
  
  =back
  
  =cut
EXTUTILS_MM_NW5

$fatpacked{"ExtUtils/MM_OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_OS2';
  package ExtUtils::MM_OS2;
  
  use strict;
  
  use ExtUtils::MakeMaker qw(neatvalue);
  use File::Spec;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Any ExtUtils::MM_Unix);
  
  =pod
  
  =head1 NAME
  
  ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_OS2; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =head1 METHODS
  
  =over 4
  
  =item init_dist
  
  Define TO_UNIX to convert OS2 linefeeds to Unix style.
  
  =cut
  
  sub init_dist {
      my($self) = @_;
  
      $self->{TO_UNIX} ||= <<'MAKE_TEXT';
  $(NOECHO) $(TEST_F) tmp.zip && $(RM_F) tmp.zip; $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM_F) tmp.zip
  MAKE_TEXT
  
      $self->SUPER::init_dist;
  }
  
  sub dlsyms {
      my($self,%attribs) = @_;
      if ($self->{IMPORTS} && %{$self->{IMPORTS}}) {
  	# Make import files (needed for static build)
  	-d 'tmp_imp' or mkdir 'tmp_imp', 0777 or die "Can't mkdir tmp_imp";
  	open my $imp, '>', 'tmpimp.imp' or die "Can't open tmpimp.imp";
  	foreach my $name (sort keys %{$self->{IMPORTS}}) {
  	    my $exp = $self->{IMPORTS}->{$name};
  	    my ($lib, $id) = ($exp =~ /(.*)\.(.*)/) or die "Malformed IMPORT `$exp'";
  	    print $imp "$name $lib $id ?\n";
  	}
  	close $imp or die "Can't close tmpimp.imp";
  	# print "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp\n";
  	system "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp"
  	    and die "Cannot make import library: $!, \$?=$?";
  	# May be running under miniperl, so have no glob...
  	eval { unlink <tmp_imp/*>; 1 } or system "rm tmp_imp/*";
  	system "cd tmp_imp; $Config::Config{ar} x ../tmpimp$Config::Config{lib_ext}"
  	    and die "Cannot extract import objects: $!, \$?=$?";
      }
      return '' if $self->{SKIPHASH}{'dynamic'};
      $self->xs_dlsyms_iterator(\%attribs);
  }
  
  sub xs_dlsyms_ext {
      '.def';
  }
  
  sub xs_dlsyms_extra {
      join '', map { qq{, "$_" => "\$($_)"} } qw(VERSION DISTNAME INSTALLDIRS);
  }
  
  sub static_lib_pure_cmd {
      my($self) = @_;
      my $old = $self->SUPER::static_lib_pure_cmd;
      return $old unless $self->{IMPORTS} && %{$self->{IMPORTS}};
      $old . <<'EOC';
  	$(AR) $(AR_STATIC_ARGS) "$@" tmp_imp/*
  	$(RANLIB) "$@"
  EOC
  }
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man =~ s,/+,.,g;
      $man;
  }
  
  sub maybe_command {
      my($self,$file) = @_;
      $file =~ s,[/\\]+,/,g;
      return $file if -x $file && ! -d _;
      return "$file.exe" if -x "$file.exe" && ! -d _;
      return "$file.cmd" if -x "$file.cmd" && ! -d _;
      return;
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      $self->{PERL_ARCHIVE} = "\$(PERL_INC)/libperl\$(LIB_EXT)";
  
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} = $OS2::is_aout
        ? ''
        : '$(PERL_INC)/libperl_override$(LIB_EXT)';
      $self->{EXPORT_LIST} = '$(BASEEXT).def';
  }
  
  =item os_flavor
  
  OS/2 is OS/2
  
  =cut
  
  sub os_flavor {
      return('OS/2');
  }
  
  =item xs_static_lib_is_xs
  
  =cut
  
  sub xs_static_lib_is_xs {
      return 1;
  }
  
  =back
  
  =cut
  
  1;
EXTUTILS_MM_OS2

$fatpacked{"ExtUtils/MM_QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_QNX';
  package ExtUtils::MM_QNX;
  
  use strict;
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  QNX.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 extra_clean_files
  
  Add .err files corresponding to each .c file.
  
  =cut
  
  sub extra_clean_files {
      my $self = shift;
  
      my @errfiles = @{$self->{C}};
      for ( @errfiles ) {
  	s/.c$/.err/;
      }
  
      return( @errfiles, 'perlmain.err' );
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
EXTUTILS_MM_QNX

$fatpacked{"ExtUtils/MM_UWIN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UWIN';
  package ExtUtils::MM_UWIN;
  
  use strict;
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  the AT&T U/WIN UNIX on Windows environment.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =over 4
  
  =item os_flavor
  
  In addition to being Unix, we're U/WIN.
  
  =cut
  
  sub os_flavor {
      return('Unix', 'U/WIN');
  }
  
  
  =item B<replace_manpage_separator>
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
  
      $man =~ s,/+,.,g;
      return $man;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MM_Win32>, L<ExtUtils::MakeMaker>
  
  =cut
  
  1;
EXTUTILS_MM_UWIN

$fatpacked{"ExtUtils/MM_Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UNIX';
  package ExtUtils::MM_Unix;
  
  require 5.006;
  
  use strict;
  
  use Carp;
  use ExtUtils::MakeMaker::Config;
  use File::Basename qw(basename dirname);
  
  our %Config_Override;
  
  use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);
  
  # If we make $VERSION an our variable parse_version() breaks
  use vars qw($VERSION);
  $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Any;
  our @ISA = qw(ExtUtils::MM_Any);
  
  my %Is;
  BEGIN {
      $Is{OS2}     = $^O eq 'os2';
      $Is{Win32}   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
      $Is{Dos}     = $^O eq 'dos';
      $Is{VMS}     = $^O eq 'VMS';
      $Is{OSF}     = $^O eq 'dec_osf';
      $Is{IRIX}    = $^O eq 'irix';
      $Is{NetBSD}  = $^O eq 'netbsd';
      $Is{Interix} = $^O eq 'interix';
      $Is{SunOS4}  = $^O eq 'sunos';
      $Is{Solaris} = $^O eq 'solaris';
      $Is{SunOS}   = $Is{SunOS4} || $Is{Solaris};
      $Is{BSD}     = ($^O =~ /^(?:free|net|open)bsd$/ or
                     grep( $^O eq $_, qw(bsdos interix dragonfly) )
                    );
      $Is{Android} = $^O =~ /android/;
      if ( $^O eq 'darwin' && $^X eq '/usr/bin/perl' ) {
        my @osvers = split /\./, $Config{osvers};
        $Is{ApplCor} = ( $osvers[0] >= 18 );
      }
  }
  
  BEGIN {
      if( $Is{VMS} ) {
          # For things like vmsify()
          require VMS::Filespec;
          VMS::Filespec->import;
      }
  }
  
  
  =head1 NAME
  
  ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
    require ExtUtils::MM_Unix;
  
  =head1 DESCRIPTION
  
  The methods provided by this package are designed to be used in
  conjunction with ExtUtils::MakeMaker. When MakeMaker writes a
  Makefile, it creates one or more objects that inherit their methods
  from a package C<MM>. MM itself doesn't provide any methods, but it
  ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating
  specific packages take the responsibility for all the methods provided
  by MM_Unix. We are trying to reduce the number of the necessary
  overrides by defining rather primitive operations within
  ExtUtils::MM_Unix.
  
  If you are going to write a platform specific MM package, please try
  to limit the necessary overrides to primitive methods, and if it is not
  possible to do so, let's work out how to achieve that gain.
  
  If you are overriding any of these methods in your Makefile.PL (in the
  MY class), please report that to the makemaker mailing list. We are
  trying to minimize the necessary method overrides and switch to data
  driven Makefile.PLs wherever possible. In the long run less methods
  will be overridable via the MY class.
  
  =head1 METHODS
  
  The following description of methods is still under
  development. Please refer to the code for not suitably documented
  sections and complain loudly to the makemaker@perl.org mailing list.
  Better yet, provide a patch.
  
  Not all of the methods below are overridable in a
  Makefile.PL. Overridable methods are marked as (o). All methods are
  overridable by a platform specific MM_*.pm file.
  
  Cross-platform methods are being moved into MM_Any.  If you can't find
  something that used to be in here, look in MM_Any.
  
  =cut
  
  # So we don't have to keep calling the methods over and over again,
  # we have these globals to cache the values.  Faster and shrtr.
  my $Curdir  = __PACKAGE__->curdir;
  my $Updir   = __PACKAGE__->updir;
  
  
  =head2 Methods
  
  =over 4
  
  =item os_flavor
  
  Simply says that we're Unix.
  
  =cut
  
  sub os_flavor {
      return('Unix');
  }
  
  
  =item c_o (o)
  
  Defines the suffix rules to compile different flavors of C files to
  object files.
  
  =cut
  
  sub c_o {
  # --- Translation Sections ---
  
      my($self) = shift;
      return '' unless $self->needs_linking();
      my(@m);
  
      my $command = '$(CCCMD)';
      my $flags   = '$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';
  
      if ( $Is{ApplCor} ) {
          $flags =~ s/"-I(\$\(PERL_INC\))"/-iwithsysroot "$1"/;
      }
  
      if (my $cpp = $Config{cpprun}) {
          my $cpp_cmd = $self->const_cccmd;
          $cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;
          push @m, qq{
  .c.i:
  	$cpp_cmd $flags \$*.c > \$*.i
  };
      }
  
      my $m_o = $self->{XSMULTI} ? $self->xs_obj_opt('$*.s') : '';
      push @m, sprintf <<'EOF', $command, $flags, $m_o;
  
  .c.s :
  	%s -S %s $*.c %s
  EOF
  
      my @exts = qw(c cpp cxx cc);
      push @exts, 'C' if !$Is{OS2} and !$Is{Win32} and !$Is{Dos}; #Case-specific
      $m_o = $self->{XSMULTI} ? $self->xs_obj_opt('$*$(OBJ_EXT)') : '';
      my $dbgout = $self->dbgoutflag;
      for my $ext (@exts) {
  	push @m, "\n.$ext\$(OBJ_EXT) :\n\t$command $flags "
              .($dbgout?"$dbgout ":'')
              ."\$*.$ext" . ( $m_o ? " $m_o" : '' ) . "\n";
      }
      return join "", @m;
  }
  
  
  =item xs_obj_opt
  
  Takes the object file as an argument, and returns the portion of compile
  command-line that will output to the specified object file.
  
  =cut
  
  sub xs_obj_opt {
      my ($self, $output_file) = @_;
      "-o $output_file";
  }
  
  =item dbgoutflag
  
  Returns a CC flag that tells the CC to emit a separate debugging symbol file
  when compiling an object file.
  
  =cut
  
  sub dbgoutflag {
      '';
  }
  
  =item cflags (o)
  
  Does very much the same as the cflags script in the perl
  distribution. It doesn't return the whole compiler command line, but
  initializes all of its parts. The const_cccmd method then actually
  returns the definition of the CCCMD macro which uses these parts.
  
  =cut
  
  #'
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my($prog, $uc, $perltype, %cflags);
      $libperl ||= $self->{LIBPERL_A} || "libperl$self->{LIB_EXT}" ;
      $libperl =~ s/\.\$\(A\)$/$self->{LIB_EXT}/;
  
      @cflags{qw(cc ccflags optimize shellflags)}
  	= @Config{qw(cc ccflags optimize shellflags)};
  
      # Perl 5.21.4 adds the (gcc) warning (-Wall ...) and std (-std=c89)
      # flags to the %Config, and the modules in the core should be built
      # with the warning flags, but NOT the -std=c89 flags (the latter
      # would break using any system header files that are strict C99).
      my @ccextraflags = qw(ccwarnflags);
      if ($ENV{PERL_CORE}) {
        for my $x (@ccextraflags) {
          if (exists $Config{$x}) {
            $cflags{$x} = $Config{$x};
          }
        }
      }
  
      my($optdebug) = "";
  
      $cflags{shellflags} ||= '';
  
      my(%map) =  (
  		D =>   '-DDEBUGGING',
  		E =>   '-DEMBED',
  		DE =>  '-DDEBUGGING -DEMBED',
  		M =>   '-DEMBED -DMULTIPLICITY',
  		DM =>  '-DDEBUGGING -DEMBED -DMULTIPLICITY',
  		);
  
      if ($libperl =~ /libperl(\w*)\Q$self->{LIB_EXT}/){
  	$uc = uc($1);
      } else {
  	$uc = ""; # avoid warning
      }
      $perltype = $map{$uc} ? $map{$uc} : "";
  
      if ($uc =~ /^D/) {
  	$optdebug = "-g";
      }
  
  
      my($name);
      ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
      if ($prog = $Config{$name}) {
  	# Expand hints for this extension via the shell
  	print "Processing $name hint:\n" if $Verbose;
  	my(@o)=`cc=\"$cflags{cc}\"
  	  ccflags=\"$cflags{ccflags}\"
  	  optimize=\"$cflags{optimize}\"
  	  perltype=\"$cflags{perltype}\"
  	  optdebug=\"$cflags{optdebug}\"
  	  eval '$prog'
  	  echo cc=\$cc
  	  echo ccflags=\$ccflags
  	  echo optimize=\$optimize
  	  echo perltype=\$perltype
  	  echo optdebug=\$optdebug
  	  `;
  	foreach my $line (@o){
  	    chomp $line;
  	    if ($line =~ /(.*?)=\s*(.*)\s*$/){
  		$cflags{$1} = $2;
  		print "	$1 = $2\n" if $Verbose;
  	    } else {
  		print "Unrecognised result from hint: '$line'\n";
  	    }
  	}
      }
  
      if ($optdebug) {
  	$cflags{optimize} = $optdebug;
      }
  
      for (qw(ccflags optimize perltype)) {
          $cflags{$_} ||= '';
  	$cflags{$_} =~ s/^\s+//;
  	$cflags{$_} =~ s/\s+/ /g;
  	$cflags{$_} =~ s/\s+$//;
  	$self->{uc $_} ||= $cflags{$_};
      }
  
      if ($self->{POLLUTE}) {
  	$self->{CCFLAGS} .= ' -DPERL_POLLUTE ';
      }
  
      for my $x (@ccextraflags) {
        next unless exists $cflags{$x};
        $self->{CCFLAGS} .= $cflags{$x} =~ m!^\s! ? $cflags{$x} : ' ' . $cflags{$x};
      }
  
      my $pollute = '';
      if ($Config{usemymalloc} and not $Config{bincompat5005}
  	and not $Config{ccflags} =~ /-DPERL_POLLUTE_MALLOC\b/
  	and $self->{PERL_MALLOC_OK}) {
  	$pollute = '$(PERL_MALLOC_DEF)';
      }
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  MPOLLUTE = $pollute
  };
  
  }
  
  
  =item const_cccmd (o)
  
  Returns the full compiler call for C programs and stores the
  definition in CONST_CCCMD.
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl)=@_;
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      return $self->{CONST_CCCMD} =
  	q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
  	$(CCFLAGS) $(OPTIMIZE) \\
  	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
  	$(XS_DEFINE_VERSION)};
  }
  
  =item const_config (o)
  
  Sets SHELL if needed, then defines a couple of constants in the Makefile
  that are imported from %Config.
  
  =cut
  
  sub const_config {
  # --- Constants Sections ---
  
      my($self) = shift;
      my @m = $self->specify_shell(); # Usually returns empty string
      push @m, <<"END";
  
  # These definitions are from config.sh (via $INC{'Config.pm'}).
  # They may have been overridden via Makefile.PL or on the command line.
  END
  
      my(%once_only);
      foreach my $key (@{$self->{CONFIG}}){
          # SITE*EXP macros are defined in &constants; avoid duplicates here
          next if $once_only{$key};
          push @m, uc($key) , ' = ' , $self->{uc $key}, "\n";
          $once_only{$key} = 1;
      }
      join('', @m);
  }
  
  =item const_loadlibs (o)
  
  Defines EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH. See
  L<ExtUtils::Liblist> for details.
  
  =cut
  
  sub const_loadlibs {
      my($self) = shift;
      return "" unless $self->needs_linking;
      my @m;
      push @m, qq{
  # $self->{NAME} might depend on some other libraries:
  # See ExtUtils::Liblist for details
  #
  };
      for my $tmp (qw/
           EXTRALIBS LDLOADLIBS BSLOADLIBS
           /) {
          next unless defined $self->{$tmp};
          push @m, "$tmp = $self->{$tmp}\n";
      }
      # don't set LD_RUN_PATH if empty
      for my $tmp (qw/
           LD_RUN_PATH
           /) {
          next unless $self->{$tmp};
          push @m, "$tmp = $self->{$tmp}\n";
      }
      return join "", @m;
  }
  
  =item constants (o)
  
    my $make_frag = $mm->constants;
  
  Prints out macros for lots of constants.
  
  =cut
  
  sub constants {
      my($self) = @_;
      my @m = ();
  
      $self->{DFSEP} = '$(DIRFILESEP)';  # alias for internal use
  
      for my $macro (qw(
  
                AR_STATIC_ARGS DIRFILESEP DFSEP
                NAME NAME_SYM
                VERSION    VERSION_MACRO    VERSION_SYM DEFINE_VERSION
                XS_VERSION XS_VERSION_MACRO             XS_DEFINE_VERSION
                INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB
                INST_MAN1DIR INST_MAN3DIR
                MAN1EXT      MAN3EXT
                MAN1SECTION  MAN3SECTION
                INSTALLDIRS INSTALL_BASE DESTDIR PREFIX
                PERLPREFIX      SITEPREFIX      VENDORPREFIX
                     ),
                     (map { ("INSTALL".$_,
                            "DESTINSTALL".$_)
                          } $self->installvars),
                     qw(
                PERL_LIB
                PERL_ARCHLIB PERL_ARCHLIBDEP
                LIBPERL_A MYEXTLIB
                FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE
                PERLMAINCC PERL_SRC PERL_INC PERL_INCDEP
                PERL            FULLPERL          ABSPERL
                PERLRUN         FULLPERLRUN       ABSPERLRUN
                PERLRUNINST     FULLPERLRUNINST   ABSPERLRUNINST
                PERL_CORE
                PERM_DIR PERM_RW PERM_RWX
  
  	      ) )
      {
  	next unless defined $self->{$macro};
  
          # pathnames can have sharp signs in them; escape them so
          # make doesn't think it is a comment-start character.
          $self->{$macro} =~ s/#/\\#/g;
  	$self->{$macro} = $self->quote_dep($self->{$macro})
  	  if $ExtUtils::MakeMaker::macro_dep{$macro};
  	push @m, "$macro = $self->{$macro}\n";
      }
  
      push @m, qq{
  MAKEMAKER   = $self->{MAKEMAKER}
  MM_VERSION  = $self->{MM_VERSION}
  MM_REVISION = $self->{MM_REVISION}
  };
  
      push @m, q{
  # FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
  # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
  # PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
  # DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
  };
  
      for my $macro (qw/
                MAKE
  	      FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT
  	      LDFROM LINKTYPE BOOTDEP
  	      /	)
      {
  	next unless defined $self->{$macro};
  	push @m, "$macro = $self->{$macro}\n";
      }
  
      push @m, "
  # Handy lists of source code files:
  XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
  C_FILES  = ".$self->wraplist(sort @{$self->{C}})."
  O_FILES  = ".$self->wraplist(sort @{$self->{O_FILES}})."
  H_FILES  = ".$self->wraplist(sort @{$self->{H}})."
  MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
  MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
  ";
  
      push @m, q{
  SDKROOT := $(shell xcrun --show-sdk-path)
  PERL_SYSROOT = $(SDKROOT)
  } if $Is{ApplCor} && $self->{'PERL_INC'} =~ m!^/System/Library/Perl/!;
  
      push @m, q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_SYSROOT)$(PERL_INCDEP)$(DFSEP)config.h
  } if $Is{ApplCor};
  
      push @m, q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_INCDEP)$(DFSEP)config.h
  } if -e $self->catfile( $self->{PERL_INC}, 'config.h' ) && !$Is{ApplCor};
  
      push @m, qq{
  # Where to build things
  INST_LIBDIR      = $self->{INST_LIBDIR}
  INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
  
  INST_AUTODIR     = $self->{INST_AUTODIR}
  INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
  
  INST_STATIC      = $self->{INST_STATIC}
  INST_DYNAMIC     = $self->{INST_DYNAMIC}
  INST_BOOT        = $self->{INST_BOOT}
  };
  
      push @m, qq{
  # Extra linker info
  EXPORT_LIST        = $self->{EXPORT_LIST}
  PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
  PERL_ARCHIVEDEP    = $self->{PERL_ARCHIVEDEP}
  PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
  };
  
      push @m, "
  
  TO_INST_PM = ".$self->wraplist(map $self->quote_dep($_), sort keys %{$self->{PM}})."\n";
  
      join('',@m);
  }
  
  
  =item depend (o)
  
  Same as macro for the depend attribute.
  
  =cut
  
  sub depend {
      my($self,%attribs) = @_;
      my(@m,$key,$val);
      for my $key (sort keys %attribs){
  	my $val = $attribs{$key};
  	next unless defined $key and defined $val;
  	push @m, "$key : $val\n";
      }
      join "", @m;
  }
  
  
  =item init_DEST
  
    $mm->init_DEST
  
  Defines the DESTDIR and DEST* variables paralleling the INSTALL*.
  
  =cut
  
  sub init_DEST {
      my $self = shift;
  
      # Initialize DESTDIR
      $self->{DESTDIR} ||= '';
  
      # Make DEST variables.
      foreach my $var ($self->installvars) {
          my $destvar = 'DESTINSTALL'.$var;
          $self->{$destvar} ||= '$(DESTDIR)$(INSTALL'.$var.')';
      }
  }
  
  
  =item init_dist
  
    $mm->init_dist;
  
  Defines a lot of macros for distribution support.
  
    macro         description                     default
  
    TAR           tar command to use              tar
    TARFLAGS      flags to pass to TAR            cvf
  
    ZIP           zip command to use              zip
    ZIPFLAGS      flags to pass to ZIP            -r
  
    COMPRESS      compression command to          gzip --best
                  use for tarfiles
    SUFFIX        suffix to put on                .gz
                  compressed files
  
    SHAR          shar command to use             shar
  
    PREOP         extra commands to run before
                  making the archive
    POSTOP        extra commands to run after
                  making the archive
  
    TO_UNIX       a command to convert linefeeds
                  to Unix style in your archive
  
    CI            command to checkin your         ci -u
                  sources to version control
    RCS_LABEL     command to label your sources   rcs -Nv$(VERSION_SYM): -q
                  just after CI is run
  
    DIST_CP       $how argument to manicopy()     best
                  when the distdir is created
  
    DIST_DEFAULT  default target to use to        tardist
                  create a distribution
  
    DISTVNAME     name of the resulting archive   $(DISTNAME)-$(VERSION)
                  (minus suffixes)
  
  =cut
  
  sub init_dist {
      my $self = shift;
  
      $self->{TAR}      ||= 'tar';
      $self->{TARFLAGS} ||= 'cvf';
      $self->{ZIP}      ||= 'zip';
      $self->{ZIPFLAGS} ||= '-r';
      $self->{COMPRESS} ||= 'gzip --best';
      $self->{SUFFIX}   ||= '.gz';
      $self->{SHAR}     ||= 'shar';
      $self->{PREOP}    ||= '$(NOECHO) $(NOOP)'; # eg update MANIFEST
      $self->{POSTOP}   ||= '$(NOECHO) $(NOOP)'; # eg remove the distdir
      $self->{TO_UNIX}  ||= '$(NOECHO) $(NOOP)';
  
      $self->{CI}       ||= 'ci -u';
      $self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';
      $self->{DIST_CP}  ||= 'best';
      $self->{DIST_DEFAULT} ||= 'tardist';
  
      ($self->{DISTNAME} = $self->{NAME}) =~ s{::}{-}g unless $self->{DISTNAME};
      $self->{DISTVNAME} ||= $self->{DISTNAME}.'-'.$self->{VERSION};
  }
  
  =item dist (o)
  
    my $dist_macros = $mm->dist(%overrides);
  
  Generates a make fragment defining all the macros initialized in
  init_dist.
  
  %overrides can be used to override any of the above.
  
  =cut
  
  sub dist {
      my($self, %attribs) = @_;
  
      my $make = '';
      if ( $attribs{SUFFIX} && $attribs{SUFFIX} !~ m!^\.! ) {
        $attribs{SUFFIX} = '.' . $attribs{SUFFIX};
      }
      foreach my $key (qw(
              TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR
              PREOP POSTOP TO_UNIX
              CI RCS_LABEL DIST_CP DIST_DEFAULT
              DISTNAME DISTVNAME
             ))
      {
          my $value = $attribs{$key} || $self->{$key};
          $make .= "$key = $value\n";
      }
  
      return $make;
  }
  
  =item dist_basics (o)
  
  Defines the targets distclean, distcheck, skipcheck, manifest, veryclean.
  
  =cut
  
  sub dist_basics {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  distclean :: realclean distcheck
  	$(NOECHO) $(NOOP)
  
  distcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
  
  skipcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
  
  manifest :
  	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
  
  veryclean : realclean
  	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old
  
  MAKE_FRAG
  
  }
  
  =item dist_ci (o)
  
  Defines a check in target for RCS.
  
  =cut
  
  sub dist_ci {
      my($self) = shift;
      return sprintf "ci :\n\t%s\n", $self->oneliner(<<'EOF', [qw(-MExtUtils::Manifest=maniread)]);
  @all = sort keys %{ maniread() };
  print(qq{Executing $(CI) @all\n});
  system(qq{$(CI) @all}) == 0 or die $!;
  print(qq{Executing $(RCS_LABEL) ...\n});
  system(qq{$(RCS_LABEL) @all}) == 0 or die $!;
  EOF
  }
  
  =item dist_core (o)
  
    my $dist_make_fragment = $MM->dist_core;
  
  Puts the targets necessary for 'make dist' together into one make
  fragment.
  
  =cut
  
  sub dist_core {
      my($self) = shift;
  
      my $make_frag = '';
      foreach my $target (qw(dist tardist uutardist tarfile zipdist zipfile
                             shdist))
      {
          my $method = $target.'_target';
          $make_frag .= "\n";
          $make_frag .= $self->$method();
      }
  
      return $make_frag;
  }
  
  
  =item B<dist_target>
  
    my $make_frag = $MM->dist_target;
  
  Returns the 'dist' target to make an archive for distribution.  This
  target simply checks to make sure the Makefile is up-to-date and
  depends on $(DIST_DEFAULT).
  
  =cut
  
  sub dist_target {
      my($self) = shift;
  
      my $date_check = $self->oneliner(<<'CODE', ['-l']);
  print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
      if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
  CODE
  
      return sprintf <<'MAKE_FRAG', $date_check;
  dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
  	$(NOECHO) %s
  MAKE_FRAG
  }
  
  =item B<tardist_target>
  
    my $make_frag = $MM->tardist_target;
  
  Returns the 'tardist' target which is simply so 'make tardist' works.
  The real work is done by the dynamically named tardistfile_target()
  method, tardist should have that as a dependency.
  
  =cut
  
  sub tardist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  tardist : $(DISTVNAME).tar$(SUFFIX)
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  }
  
  =item B<zipdist_target>
  
    my $make_frag = $MM->zipdist_target;
  
  Returns the 'zipdist' target which is simply so 'make zipdist' works.
  The real work is done by the dynamically named zipdistfile_target()
  method, zipdist should have that as a dependency.
  
  =cut
  
  sub zipdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  zipdist : $(DISTVNAME).zip
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  }
  
  =item B<tarfile_target>
  
    my $make_frag = $MM->tarfile_target;
  
  The name of this target is the name of the tarball generated by
  tardist.  This target does the actual work of turning the distdir into
  a tarball.
  
  =cut
  
  sub tarfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  =item zipfile_target
  
    my $make_frag = $MM->zipfile_target;
  
  The name of this target is the name of the zip file generated by
  zipdist.  This target does the actual work of turning the distdir into
  a zip file.
  
  =cut
  
  sub zipfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).zip'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  =item uutardist_target
  
    my $make_frag = $MM->uutardist_target;
  
  Converts the tarfile into a uuencoded file
  
  =cut
  
  sub uutardist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  uutardist : $(DISTVNAME).tar$(SUFFIX)
  	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)_uu'
  MAKE_FRAG
  }
  
  
  =item shdist_target
  
    my $make_frag = $MM->shdist_target;
  
  Converts the distdir into a shell archive.
  
  =cut
  
  sub shdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  shdist : distdir
  	$(PREOP)
  	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).shar'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  
  =item dlsyms (o)
  
  Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.
  
  Normally just returns an empty string.
  
  =cut
  
  sub dlsyms {
      return '';
  }
  
  
  =item dynamic_bs (o)
  
  Defines targets for bootstrap files.
  
  =cut
  
  sub dynamic_bs {
      my($self, %attribs) = @_;
      return "\nBOOTSTRAP =\n" unless $self->has_link_code();
      my @exts;
      if ($self->{XSMULTI}) {
  	@exts = $self->_xs_list_basenames;
      } else {
  	@exts = '$(BASEEXT)';
      }
      return join "\n",
          "BOOTSTRAP = @{[map { qq{$_.bs} } @exts]}\n",
          map { $self->_xs_make_bs($_) } @exts;
  }
  
  sub _xs_make_bs {
      my ($self, $basename) = @_;
      my ($v, $d, $f) = File::Spec->splitpath($basename);
      my @d = File::Spec->splitdir($d);
      shift @d if $self->{XSMULTI} and $d[0] eq 'lib';
      my $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);
      $instdir = '$(INST_ARCHAUTODIR)' if $basename eq '$(BASEEXT)';
      my $instfile = $self->catfile($instdir, "$f.bs");
      my $exists = "$instdir\$(DFSEP).exists"; # match blibdirs_target
      #                                 1          2          3
      return _sprintf562 <<'MAKE_FRAG', $basename, $instfile, $exists;
  # As Mkbootstrap might not write a file (if none is required)
  # we use touch to prevent make continually trying to remake it.
  # The DynaLoader only reads a non-empty file.
  %1$s.bs : $(FIRST_MAKEFILE) $(BOOTDEP)
  	$(NOECHO) $(ECHO) "Running Mkbootstrap for %1$s ($(BSLOADLIBS))"
  	$(NOECHO) $(PERLRUN) \
  		"-MExtUtils::Mkbootstrap" \
  		-e "Mkbootstrap('%1$s','$(BSLOADLIBS)');"
  	$(NOECHO) $(TOUCH) "%1$s.bs"
  	$(CHMOD) $(PERM_RW) "%1$s.bs"
  
  %2$s : %1$s.bs %3$s
  	$(NOECHO) $(RM_RF) %2$s
  	- $(CP_NONEMPTY) %1$s.bs %2$s $(PERM_RW)
  MAKE_FRAG
  }
  
  =item dynamic_lib (o)
  
  Defines how to produce the *.so (or equivalent) files.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
      return '' unless $self->has_link_code;
      my @m = $self->xs_dynamic_lib_macros(\%attribs);
      my @libs;
      my $dlsyms_ext = eval { $self->xs_dlsyms_ext };
      if ($self->{XSMULTI}) {
          my @exts = $self->_xs_list_basenames;
          for my $ext (@exts) {
              my ($v, $d, $f) = File::Spec->splitpath($ext);
              my @d = File::Spec->splitdir($d);
              shift @d if $d[0] eq 'lib';
              pop @d if $d[$#d] eq '';
              my $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);
  
              # Dynamic library names may need special handling.
              eval { require DynaLoader };
              if (defined &DynaLoader::mod2fname) {
                  $f = &DynaLoader::mod2fname([@d, $f]);
              }
  
              my $instfile = $self->catfile($instdir, "$f.\$(DLEXT)");
              my $objfile = $self->_xsbuild_value('xs', $ext, 'OBJECT');
              $objfile = "$ext\$(OBJ_EXT)" unless defined $objfile;
              my $ldfrom = $self->_xsbuild_value('xs', $ext, 'LDFROM');
              $ldfrom = $objfile unless defined $ldfrom;
              my $exportlist = "$ext.def";
              my @libchunk = ($objfile, $instfile, $instdir, $ldfrom, $exportlist);
              push @libchunk, $dlsyms_ext ? $ext.$dlsyms_ext : undef;
              push @libs, \@libchunk;
          }
      } else {
          my @libchunk = qw($(OBJECT) $(INST_DYNAMIC) $(INST_ARCHAUTODIR) $(LDFROM) $(EXPORT_LIST));
          push @libchunk, $dlsyms_ext ? '$(BASEEXT)'.$dlsyms_ext : undef;
          @libs = (\@libchunk);
      }
      push @m, map { $self->xs_make_dynamic_lib(\%attribs, @$_); } @libs;
  
      return join("\n",@m);
  }
  
  =item xs_dynamic_lib_macros
  
  Defines the macros for the C<dynamic_lib> section.
  
  =cut
  
  sub xs_dynamic_lib_macros {
      my ($self, $attribs) = @_;
      my $otherldflags = $attribs->{OTHERLDFLAGS} || "";
      my $inst_dynamic_dep = $attribs->{INST_DYNAMIC_DEP} || "";
      my $armaybe = $self->_xs_armaybe($attribs);
      my $ld_opt = $Is{OS2} ? '$(OPTIMIZE) ' : ''; # Useful on other systems too?
      my $ld_fix = $Is{OS2} ? '|| ( $(RM_F) $@ && sh -c false )' : '';
      sprintf <<'EOF', $armaybe, $ld_opt.$otherldflags, $inst_dynamic_dep, $ld_fix;
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  ARMAYBE = %s
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  INST_DYNAMIC_FIX = %s
  EOF
  }
  
  sub _xs_armaybe {
      my ($self, $attribs) = @_;
      my $armaybe = $attribs->{ARMAYBE} || $self->{ARMAYBE} || ":";
      $armaybe = 'ar' if ($Is{OSF} and $armaybe eq ':');
      $armaybe;
  }
  
  =item xs_make_dynamic_lib
  
  Defines the recipes for the C<dynamic_lib> section.
  
  =cut
  
  sub xs_make_dynamic_lib {
      my ($self, $attribs, $object, $to, $todir, $ldfrom, $exportlist, $dlsyms) = @_;
      $exportlist = '' if $exportlist ne '$(EXPORT_LIST)';
      my $armaybe = $self->_xs_armaybe($attribs);
      my @m = sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP) %s'."\n", $to, $object, $todir, $exportlist, ($dlsyms || '');
      my $dlsyms_arg = $self->xs_dlsyms_arg($dlsyms);
      if ($armaybe ne ':'){
          $ldfrom = 'tmp$(LIB_EXT)';
          push(@m,"	\$(ARMAYBE) cr $ldfrom $object\n");
          push(@m,"	\$(RANLIB) $ldfrom\n");
      }
      $ldfrom = "-all $ldfrom -none" if $Is{OSF};
  
      # The IRIX linker doesn't use LD_RUN_PATH
      my $ldrun = $Is{IRIX} && $self->{LD_RUN_PATH} ?
                         qq{-rpath "$self->{LD_RUN_PATH}"} : '';
  
      # For example in AIX the shared objects/libraries from previous builds
      # linger quite a while in the shared dynalinker cache even when nobody
      # is using them.  This is painful if one for instance tries to restart
      # a failed build because the link command will fail unnecessarily 'cos
      # the shared object/library is 'busy'.
      push(@m,"	\$(RM_F) \$\@\n");
  
      my $libs = '$(LDLOADLIBS)';
      if (($Is{NetBSD} || $Is{Interix} || $Is{Android}) && $Config{'useshrplib'} eq 'true') {
          # Use nothing on static perl platforms, and to the flags needed
          # to link against the shared libperl library on shared perl
          # platforms.  We peek at lddlflags to see if we need -Wl,-R
          # or -R to add paths to the run-time library search path.
          if ($Config{'lddlflags'} =~ /-Wl,-R/) {
              $libs .= ' "-L$(PERL_INC)" "-Wl,-R$(INSTALLARCHLIB)/CORE" "-Wl,-R$(PERL_ARCHLIB)/CORE" -lperl';
          } elsif ($Config{'lddlflags'} =~ /-R/) {
              $libs .= ' "-L$(PERL_INC)" "-R$(INSTALLARCHLIB)/CORE" "-R$(PERL_ARCHLIB)/CORE" -lperl';
          } elsif ( $Is{Android} ) {
              # The Android linker will not recognize symbols from
              # libperl unless the module explicitly depends on it.
              $libs .= ' "-L$(PERL_INC)" -lperl';
          }
      }
  
      my $ld_run_path_shell = "";
      if ($self->{LD_RUN_PATH} ne "") {
          $ld_run_path_shell = 'LD_RUN_PATH="$(LD_RUN_PATH)" ';
      }
  
      push @m, sprintf <<'MAKE', $ld_run_path_shell, $ldrun, $dlsyms_arg, $ldfrom, $self->xs_obj_opt('$@'), $libs, $exportlist;
  	%s$(LD) %s $(LDDLFLAGS) %s %s $(OTHERLDFLAGS) %s $(MYEXTLIB) \
  	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) %s \
  	  $(INST_DYNAMIC_FIX)
  	$(CHMOD) $(PERM_RWX) $@
  MAKE
      join '', @m;
  }
  
  =item exescan
  
  Deprecated method. Use libscan instead.
  
  =cut
  
  sub exescan {
      my($self,$path) = @_;
      $path;
  }
  
  =item extliblist
  
  Called by init_others, and calls ext ExtUtils::Liblist. See
  L<ExtUtils::Liblist> for details.
  
  =cut
  
  sub extliblist {
      my($self,$libs) = @_;
      require ExtUtils::Liblist;
      $self->ext($libs, $Verbose);
  }
  
  =item find_perl
  
  Finds the executables PERL and FULLPERL
  
  =cut
  
  sub find_perl {
      my($self, $ver, $names, $dirs, $trace) = @_;
      if ($trace >= 2){
          print "Looking for perl $ver by these names:
  @$names
  in these dirs:
  @$dirs
  ";
      }
  
      my $stderr_duped = 0;
      local *STDERR_COPY;
  
      unless ($Is{BSD}) {
          # >& and lexical filehandles together give 5.6.2 indigestion
          if( open(STDERR_COPY, '>&STDERR') ) {  ## no critic
              $stderr_duped = 1;
          }
          else {
              warn <<WARNING;
  find_perl() can't dup STDERR: $!
  You might see some garbage while we search for Perl
  WARNING
          }
      }
  
      foreach my $name (@$names){
          my ($abs, $use_dir);
          if ($self->file_name_is_absolute($name)) {     # /foo/bar
              $abs = $name;
          } elsif ($self->canonpath($name) eq
                   $self->canonpath(basename($name))) {  # foo
              $use_dir = 1;
          } else {                                            # foo/bar
              $abs = $self->catfile($Curdir, $name);
          }
          foreach my $dir ($use_dir ? @$dirs : 1){
              next unless defined $dir; # $self->{PERL_SRC} may be undefined
  
              $abs = $self->catfile($dir, $name)
                  if $use_dir;
  
              print "Checking $abs\n" if ($trace >= 2);
              next unless $self->maybe_command($abs);
              print "Executing $abs\n" if ($trace >= 2);
  
              my $val;
              my $version_check = qq{"$abs" -le "require $ver; print qq{VER_OK}"};
  
              # To avoid using the unportable 2>&1 to suppress STDERR,
              # we close it before running the command.
              # However, thanks to a thread library bug in many BSDs
              # ( http://www.freebsd.org/cgi/query-pr.cgi?pr=51535 )
              # we cannot use the fancier more portable way in here
              # but instead need to use the traditional 2>&1 construct.
              if ($Is{BSD}) {
                  $val = `$version_check 2>&1`;
              } else {
                  close STDERR if $stderr_duped;
                  $val = `$version_check`;
  
                  # 5.6.2's 3-arg open doesn't work with >&
                  open STDERR, ">&STDERR_COPY"  ## no critic
                          if $stderr_duped;
              }
  
              if ($val =~ /^VER_OK/m) {
                  print "Using PERL=$abs\n" if $trace;
                  return $abs;
              } elsif ($trace >= 2) {
                  print "Result: '$val' ".($? >> 8)."\n";
              }
          }
      }
      print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";
      0; # false and not empty
  }
  
  
  =item fixin
  
    $mm->fixin(@files);
  
  Inserts the sharpbang or equivalent magic number to a set of @files.
  
  =cut
  
  sub fixin {    # stolen from the pink Camel book, more or less
      my ( $self, @files ) = @_;
  
      for my $file (@files) {
          my $file_new = "$file.new";
          my $file_bak = "$file.bak";
  
          open( my $fixin, '<', $file ) or croak "Can't process '$file': $!";
          local $/ = "\n";
          chomp( my $line = <$fixin> );
          next unless $line =~ s/^\s*\#!\s*//;    # Not a shebang file.
  
          my $shb = $self->_fixin_replace_shebang( $file, $line );
          next unless defined $shb;
  
          open( my $fixout, ">", "$file_new" ) or do {
              warn "Can't create new $file: $!\n";
              next;
          };
  
          # Print out the new #! line (or equivalent).
          local $\;
          local $/;
          print $fixout $shb, <$fixin>;
          close $fixin;
          close $fixout;
  
          chmod 0666, $file_bak;
          unlink $file_bak;
          unless ( _rename( $file, $file_bak ) ) {
              warn "Can't rename $file to $file_bak: $!";
              next;
          }
          unless ( _rename( $file_new, $file ) ) {
              warn "Can't rename $file_new to $file: $!";
              unless ( _rename( $file_bak, $file ) ) {
                  warn "Can't rename $file_bak back to $file either: $!";
                  warn "Leaving $file renamed as $file_bak\n";
              }
              next;
          }
          unlink $file_bak;
      }
      continue {
          system("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
      }
  }
  
  
  sub _rename {
      my($old, $new) = @_;
  
      foreach my $file ($old, $new) {
          if( $Is{VMS} and basename($file) !~ /\./ ) {
              # rename() in 5.8.0 on VMS will not rename a file if it
              # does not contain a dot yet it returns success.
              $file = "$file.";
          }
      }
  
      return rename($old, $new);
  }
  
  sub _fixin_replace_shebang {
      my ( $self, $file, $line ) = @_;
  
      # Now figure out the interpreter name.
      my ( $origcmd, $arg ) = split ' ', $line, 2;
      (my $cmd = $origcmd) =~ s!^.*/!!;
  
      # Now look (in reverse) for interpreter in absolute PATH (unless perl).
      my $interpreter;
      if ( defined $ENV{PERL_MM_SHEBANG} && $ENV{PERL_MM_SHEBANG} eq "relocatable" ) {
          $interpreter = "/usr/bin/env perl";
      }
      elsif ( $cmd =~ m{^perl(?:\z|[^a-z])} ) {
          if ( $Config{startperl} =~ m,^\#!.*/perl, ) {
              $interpreter = $Config{startperl};
              $interpreter =~ s,^\#!,,;
          }
          else {
              $interpreter = $Config{perlpath};
          }
      }
      else {
          my (@absdirs)
              = reverse grep { $self->file_name_is_absolute($_) } $self->path;
          $interpreter = '';
  
          foreach my $dir (@absdirs) {
              my $maybefile = $self->catfile($dir,$cmd);
              if ( $self->maybe_command($maybefile) ) {
                  warn "Ignoring $interpreter in $file\n"
                      if $Verbose && $interpreter;
                  $interpreter = $maybefile;
              }
          }
  
          # If the shebang is absolute and exists in PATH, but was not
          # the first one found, leave it alone if it's actually the
          # same file as first one.  This avoids packages built on
          # merged-/usr systems with /usr/bin before /bin in the path
          # breaking when installed on systems without merged /usr
          if ($origcmd ne $interpreter and $self->file_name_is_absolute($origcmd)) {
              my $origdir = dirname($origcmd);
              if ($self->maybe_command($origcmd) && grep { $_ eq $origdir } @absdirs) {
                  my ($odev, $oino) = stat $origcmd;
                  my ($idev, $iino) = stat $interpreter;
                  if ($odev == $idev && $oino == $iino) {
                      warn "$origcmd is the same as $interpreter, leaving alone"
                          if $Verbose;
                      $interpreter = $origcmd;
                  }
              }
          }
      }
  
      # Figure out how to invoke interpreter on this machine.
  
      my ($does_shbang) = $Config{'sharpbang'} =~ /^\s*\#\!/;
      my ($shb) = "";
      if ($interpreter) {
          print "Changing sharpbang in $file to $interpreter"
              if $Verbose;
           # this is probably value-free on DOSISH platforms
          if ($does_shbang) {
              $shb .= "$Config{'sharpbang'}$interpreter";
              $shb .= ' ' . $arg if defined $arg;
              $shb .= "\n";
          }
      }
      else {
          warn "Can't find $cmd in PATH, $file unchanged"
              if $Verbose;
          return;
      }
      return $shb
  }
  
  =item force (o)
  
  Writes an empty FORCE: target.
  
  =cut
  
  sub force {
      my($self) = shift;
      '# Phony target to force checking subdirectories.
  FORCE :
  	$(NOECHO) $(NOOP)
  ';
  }
  
  =item guess_name
  
  Guess the name of this package by examining the working directory's
  name. MakeMaker calls this only if the developer has not supplied a
  NAME attribute.
  
  =cut
  
  # ';
  
  sub guess_name {
      my($self) = @_;
      use Cwd 'cwd';
      my $name = basename(cwd());
      $name =~ s|[\-_][\d\.\-]+\z||;  # this is new with MM 5.00, we
                                      # strip minus or underline
                                      # followed by a float or some such
      print "Warning: Guessing NAME [$name] from current directory name.\n";
      $name;
  }
  
  =item has_link_code
  
  Returns true if C, XS, MYEXTLIB or similar objects exist within this
  object that need a compiler. Does not descend into subdirectories as
  needs_linking() does.
  
  =cut
  
  sub has_link_code {
      my($self) = shift;
      return $self->{HAS_LINK_CODE} if defined $self->{HAS_LINK_CODE};
      if ($self->{OBJECT} or @{$self->{C} || []} or $self->{MYEXTLIB}){
  	$self->{HAS_LINK_CODE} = 1;
  	return 1;
      }
      return $self->{HAS_LINK_CODE} = 0;
  }
  
  
  =item init_dirscan
  
  Scans the directory structure and initializes DIR, XS, XS_FILES,
  C, C_FILES, O_FILES, H, H_FILES, PL_FILES, EXE_FILES.
  
  Called by init_main.
  
  =cut
  
  sub init_dirscan {	# --- File and Directory Lists (.xs .pm .pod etc)
      my($self) = @_;
      my(%dir, %xs, %c, %o, %h, %pl_files, %pm);
  
      my %ignore = map {( $_ => 1 )} qw(Makefile.PL Build.PL test.pl t);
  
      # ignore the distdir
      $Is{VMS} ? $ignore{"$self->{DISTVNAME}.dir"} = 1
              : $ignore{$self->{DISTVNAME}} = 1;
  
      my $distprefix = $Is{VMS} ? qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+\.dir$/i
                                : qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+$/;
  
      @ignore{map lc, keys %ignore} = values %ignore if $Is{VMS};
  
      if ( defined $self->{XS} and !defined $self->{C} ) {
  	my @c_files = grep { m/\.c(pp|xx)?\z/i } values %{$self->{XS}};
  	my @o_files = grep { m/(?:.(?:o(?:bj)?)|\$\(OBJ_EXT\))\z/i } values %{$self->{XS}};
  	%c = map { $_ => 1 } @c_files;
  	%o = map { $_ => 1 } @o_files;
      }
  
      foreach my $name ($self->lsdir($Curdir)){
  	next if $name =~ /\#/;
  	next if $name =~ $distprefix && -d $name;
  	$name = lc($name) if $Is{VMS};
  	next if $name eq $Curdir or $name eq $Updir or $ignore{$name};
  	next unless $self->libscan($name);
  	if (-d $name){
  	    next if -l $name; # We do not support symlinks at all
              next if $self->{NORECURS};
  	    $dir{$name} = $name if (-f $self->catfile($name,"Makefile.PL"));
  	} elsif ($name =~ /\.xs\z/){
  	    my($c); ($c = $name) =~ s/\.xs\z/.c/;
  	    $xs{$name} = $c;
  	    $c{$c} = 1;
  	} elsif ($name =~ /\.c(pp|xx|c)?\z/i){  # .c .C .cpp .cxx .cc
  	    $c{$name} = 1
  		unless $name =~ m/perlmain\.c/; # See MAP_TARGET
  	} elsif ($name =~ /\.h\z/i){
  	    $h{$name} = 1;
  	} elsif ($name =~ /\.PL\z/) {
  	    ($pl_files{$name} = $name) =~ s/\.PL\z// ;
  	} elsif (($Is{VMS} || $Is{Dos}) && $name =~ /[._]pl$/i) {
  	    # case-insensitive filesystem, one dot per name, so foo.h.PL
  	    # under Unix appears as foo.h_pl under VMS or fooh.pl on Dos
  	    local($/); open(my $pl, '<', $name); my $txt = <$pl>; close $pl;
  	    if ($txt =~ /Extracting \S+ \(with variable substitutions/) {
  		($pl_files{$name} = $name) =~ s/[._]pl\z//i ;
  	    }
  	    else {
                  $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
              }
  	} elsif ($name =~ /\.(p[ml]|pod)\z/){
  	    $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
  	}
      }
  
      $self->{PL_FILES}   ||= \%pl_files;
      $self->{DIR}        ||= [sort keys %dir];
      $self->{XS}         ||= \%xs;
      $self->{C}          ||= [sort keys %c];
      $self->{H}          ||= [sort keys %h];
      $self->{PM}         ||= \%pm;
  
      my @o_files = @{$self->{C}};
      %o = (%o, map { $_ => 1 } grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @o_files);
      $self->{O_FILES} = [sort keys %o];
  }
  
  
  =item init_MANPODS
  
  Determines if man pages should be generated and initializes MAN1PODS
  and MAN3PODS as appropriate.
  
  =cut
  
  sub init_MANPODS {
      my $self = shift;
  
      # Set up names of manual pages to generate from pods
      foreach my $man (qw(MAN1 MAN3)) {
          if ( $self->{"${man}PODS"}
               or $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/
          ) {
              $self->{"${man}PODS"} ||= {};
          }
          else {
              my $init_method = "init_${man}PODS";
              $self->$init_method();
          }
      }
  
      # logic similar to picking man${num}ext in perl's Configure script
      foreach my $num (1,3) {
          my $installdirs = uc $self->{INSTALLDIRS};
          $installdirs = '' if $installdirs eq 'PERL';
          my $mandir = $self->_expand_macros(
              $self->{ "INSTALL${installdirs}MAN${num}DIR" } );
          my $section = $num;
  
          foreach ($num, "${num}p", "${num}pm", qw< l n o C L >, "L$num") {
              if ( $mandir =~ /\b(?:man|cat)$_$/ ) {
                  $section = $_;
                  last;
              }
          }
  
          $self->{"MAN${num}SECTION"} = $section;
      }
  }
  
  
  sub _has_pod {
      my($self, $file) = @_;
  
      my($ispod)=0;
      if (open( my $fh, '<', $file )) {
          while (<$fh>) {
              if (/^=(?:head\d+|item|pod)\b/) {
                  $ispod=1;
                  last;
              }
          }
          close $fh;
      } else {
          # If it doesn't exist yet, we assume, it has pods in it
          $ispod = 1;
      }
  
      return $ispod;
  }
  
  
  =item init_MAN1PODS
  
  Initializes MAN1PODS from the list of EXE_FILES.
  
  =cut
  
  sub init_MAN1PODS {
      my($self) = @_;
  
      if ( exists $self->{EXE_FILES} ) {
  	foreach my $name (@{$self->{EXE_FILES}}) {
  	    next unless $self->_has_pod($name);
  
  	    $self->{MAN1PODS}->{$name} =
  		$self->catfile("\$(INST_MAN1DIR)",
  			       basename($name).".\$(MAN1EXT)");
  	}
      }
  }
  
  
  =item init_MAN3PODS
  
  Initializes MAN3PODS from the list of PM files.
  
  =cut
  
  sub init_MAN3PODS {
      my $self = shift;
  
      my %manifypods = (); # we collect the keys first, i.e. the files
                           # we have to convert to pod
  
      foreach my $name (keys %{$self->{PM}}) {
  	if ($name =~ /\.pod\z/ ) {
  	    $manifypods{$name} = $self->{PM}{$name};
  	} elsif ($name =~ /\.p[ml]\z/ ) {
  	    if( $self->_has_pod($name) ) {
  		$manifypods{$name} = $self->{PM}{$name};
  	    }
  	}
      }
  
      my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};
  
      # Remove "Configure.pm" and similar, if it's not the only pod listed
      # To force inclusion, just name it "Configure.pod", or override
      # MAN3PODS
      foreach my $name (keys %manifypods) {
  	if (
              ($self->{PERL_CORE} and $name =~ /(config|setup).*\.pm/is) or
              ( $name =~ m/^README\.pod$/i ) # don't manify top-level README.pod
          ) {
  	    delete $manifypods{$name};
  	    next;
  	}
  	my($manpagename) = $name;
  	$manpagename =~ s/\.p(od|m|l)\z//;
  	# everything below lib is ok
  	unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s) {
  	    $manpagename = $self->catfile(
  	        split(/::/,$self->{PARENT_NAME}),$manpagename
  	    );
  	}
  	$manpagename = $self->replace_manpage_separator($manpagename);
  	$self->{MAN3PODS}->{$name} =
  	    $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
      }
  }
  
  
  =item init_PM
  
  Initializes PMLIBDIRS and PM from PMLIBDIRS.
  
  =cut
  
  sub init_PM {
      my $self = shift;
  
      # Some larger extensions often wish to install a number of *.pm/pl
      # files into the library in various locations.
  
      # The attribute PMLIBDIRS holds an array reference which lists
      # subdirectories which we should search for library files to
      # install. PMLIBDIRS defaults to [ 'lib', $self->{BASEEXT} ].  We
      # recursively search through the named directories (skipping any
      # which don't exist or contain Makefile.PL files).
  
      # For each *.pm or *.pl file found $self->libscan() is called with
      # the default installation path in $_[1]. The return value of
      # libscan defines the actual installation location.  The default
      # libscan function simply returns the path.  The file is skipped
      # if libscan returns false.
  
      # The default installation location passed to libscan in $_[1] is:
      #
      #  ./*.pm		=> $(INST_LIBDIR)/*.pm
      #  ./xyz/...	=> $(INST_LIBDIR)/xyz/...
      #  ./lib/...	=> $(INST_LIB)/...
      #
      # In this way the 'lib' directory is seen as the root of the actual
      # perl library whereas the others are relative to INST_LIBDIR
      # (which includes PARENT_NAME). This is a subtle distinction but one
      # that's important for nested modules.
  
      unless( $self->{PMLIBDIRS} ) {
          if( $Is{VMS} ) {
              # Avoid logical name vs directory collisions
              $self->{PMLIBDIRS} = ['./lib', "./$self->{BASEEXT}"];
          }
          else {
              $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}];
          }
      }
  
      #only existing directories that aren't in $dir are allowed
  
      # Avoid $_ wherever possible:
      # @{$self->{PMLIBDIRS}} = grep -d && !$dir{$_}, @{$self->{PMLIBDIRS}};
      my (@pmlibdirs) = @{$self->{PMLIBDIRS}};
      @{$self->{PMLIBDIRS}} = ();
      my %dir = map { ($_ => $_) } @{$self->{DIR}};
      foreach my $pmlibdir (@pmlibdirs) {
  	-d $pmlibdir && !$dir{$pmlibdir} && push @{$self->{PMLIBDIRS}}, $pmlibdir;
      }
  
      unless( $self->{PMLIBPARENTDIRS} ) {
  	@{$self->{PMLIBPARENTDIRS}} = ('lib');
      }
  
      return if $self->{PM} and $self->{ARGS}{PM};
  
      if (@{$self->{PMLIBDIRS}}){
  	print "Searching PMLIBDIRS: @{$self->{PMLIBDIRS}}\n"
  	    if ($Verbose >= 2);
  	require File::Find;
          File::Find::find(sub {
              if (-d $_){
                  unless ($self->libscan($_)){
                      $File::Find::prune = 1;
                  }
                  return;
              }
              return if /\#/;
              return if /~$/;             # emacs temp files
              return if /,v$/;            # RCS files
              return if m{\.swp$};        # vim swap files
  
  	    my $path   = $File::Find::name;
              my $prefix = $self->{INST_LIBDIR};
              my $striplibpath;
  
  	    my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};
  	    $prefix =  $self->{INST_LIB}
                  if ($striplibpath = $path) =~ s{^(\W*)($parentlibs_re)\W}
  	                                       {$1}i;
  
  	    my($inst) = $self->catfile($prefix,$striplibpath);
  	    local($_) = $inst; # for backwards compatibility
  	    $inst = $self->libscan($inst);
  	    print "libscan($path) => '$inst'\n" if ($Verbose >= 2);
  	    return unless $inst;
  	    if ($self->{XSMULTI} and $inst =~ /\.xs\z/) {
  		my($base); ($base = $path) =~ s/\.xs\z//;
  		$self->{XS}{$path} = "$base.c";
  		push @{$self->{C}}, "$base.c";
  		push @{$self->{O_FILES}}, "$base$self->{OBJ_EXT}";
  	    } else {
  		$self->{PM}{$path} = $inst;
  	    }
  	}, @{$self->{PMLIBDIRS}});
      }
  }
  
  
  =item init_DIRFILESEP
  
  Using / for Unix.  Called by init_main.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      $self->{DIRFILESEP} = '/';
  }
  
  
  =item init_main
  
  Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE,
  EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*,
  INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,
  OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB,
  PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION,
  VERSION_SYM, XS_VERSION.
  
  =cut
  
  sub init_main {
      my($self) = @_;
  
      # --- Initialize Module Name and Paths
  
      # NAME    = Foo::Bar::Oracle
      # FULLEXT = Foo/Bar/Oracle
      # BASEEXT = Oracle
      # PARENT_NAME = Foo::Bar
  ### Only UNIX:
  ###    ($self->{FULLEXT} =
  ###     $self->{NAME}) =~ s!::!/!g ; #eg. BSD/Foo/Socket
      $self->{FULLEXT} = $self->catdir(split /::/, $self->{NAME});
  
  
      # Copied from DynaLoader:
  
      my(@modparts) = split(/::/,$self->{NAME});
      my($modfname) = $modparts[-1];
  
      # Some systems have restrictions on files names for DLL's etc.
      # mod2fname returns appropriate file base name (typically truncated)
      # It may also edit @modparts if required.
      # We require DynaLoader to make sure that mod2fname is loaded
      eval { require DynaLoader };
      if (defined &DynaLoader::mod2fname) {
          $modfname = &DynaLoader::mod2fname(\@modparts);
      }
  
      ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\w:]+)::)?(\w+)\z! ;
      $self->{PARENT_NAME} ||= '';
  
      if (defined &DynaLoader::mod2fname) {
  	# As of 5.001m, dl_os2 appends '_'
  	$self->{DLBASE} = $modfname;
      } else {
  	$self->{DLBASE} = '$(BASEEXT)';
      }
  
  
      # --- Initialize PERL_LIB, PERL_SRC
  
      # *Real* information: where did we get these two from? ...
      my $inc_config_dir = dirname($INC{'Config.pm'});
      my $inc_carp_dir   = dirname($INC{'Carp.pm'});
  
      unless ($self->{PERL_SRC}){
          foreach my $dir_count (1..8) { # 8 is the VMS limit for nesting
              my $dir = $self->catdir(($Updir) x $dir_count);
  
              if (-f $self->catfile($dir,"config_h.SH")   &&
                  -f $self->catfile($dir,"perl.h")        &&
                  -f $self->catfile($dir,"lib","strict.pm")
              ) {
                  $self->{PERL_SRC}=$dir ;
                  last;
              }
          }
      }
  
      warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if
        $self->{PERL_CORE} and !$self->{PERL_SRC};
  
      if ($self->{PERL_SRC}){
  	$self->{PERL_LIB}     ||= $self->catdir("$self->{PERL_SRC}","lib");
  
          $self->{PERL_ARCHLIB} = $self->{PERL_LIB};
          $self->{PERL_INC}     = ($Is{Win32}) ?
              $self->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
  
  	# catch a situation that has occurred a few times in the past:
  	unless (
  		-s $self->catfile($self->{PERL_SRC},'cflags')
  		or
  		$Is{VMS}
  		&&
  		-s $self->catfile($self->{PERL_SRC},'vmsish.h')
  		or
  		$Is{Win32}
  	       ){
  	    warn qq{
  You cannot build extensions below the perl source tree after executing
  a 'make clean' in the perl source tree.
  
  To rebuild extensions distributed with the perl source you should
  simply Configure (to include those extensions) and then build perl as
  normal. After installing perl the source tree can be deleted. It is
  not needed for building extensions by running 'perl Makefile.PL'
  usually without extra arguments.
  
  It is recommended that you unpack and build additional extensions away
  from the perl source tree.
  };
  	}
      } else {
  	# we should also consider $ENV{PERL5LIB} here
          my $old = $self->{PERL_LIB} || $self->{PERL_ARCHLIB} || $self->{PERL_INC};
  	$self->{PERL_LIB}     ||= $Config{privlibexp};
  	$self->{PERL_ARCHLIB} ||= $Config{archlibexp};
  	$self->{PERL_INC}     = $self->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
  	my $perl_h;
  
  	if (not -f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))
  	    and not $old){
  	    # Maybe somebody tries to build an extension with an
  	    # uninstalled Perl outside of Perl build tree
  	    my $lib;
  	    for my $dir (@INC) {
  	      $lib = $dir, last if -e $self->catfile($dir, "Config.pm");
  	    }
  	    if ($lib) {
                # Win32 puts its header files in /perl/src/lib/CORE.
                # Unix leaves them in /perl/src.
  	      my $inc = $Is{Win32} ? $self->catdir($lib, "CORE" )
                                    : dirname $lib;
  	      if (-e $self->catfile($inc, "perl.h")) {
  		$self->{PERL_LIB}	   = $lib;
  		$self->{PERL_ARCHLIB}	   = $lib;
  		$self->{PERL_INC}	   = $inc;
  		$self->{UNINSTALLED_PERL}  = 1;
  		print <<EOP;
  ... Detected uninstalled Perl.  Trying to continue.
  EOP
  	      }
  	    }
  	}
      }
  
      if ($Is{Android}) {
      	# Android fun times!
      	# ../../perl -I../../lib -MFile::Glob -e1 works
      	# ../../../perl -I../../../lib -MFile::Glob -e1 fails to find
      	# the .so for File::Glob.
      	# This always affects core perl, but may also affect an installed
      	# perl built with -Duserelocatableinc.
      	$self->{PERL_LIB} = File::Spec->rel2abs($self->{PERL_LIB});
      	$self->{PERL_ARCHLIB} = File::Spec->rel2abs($self->{PERL_ARCHLIB});
      }
      $self->{PERL_INCDEP} = $self->{PERL_INC};
      $self->{PERL_ARCHLIBDEP} = $self->{PERL_ARCHLIB};
  
      # We get SITELIBEXP and SITEARCHEXP directly via
      # Get_from_Config. When we are running standard modules, these
      # won't matter, we will set INSTALLDIRS to "perl". Otherwise we
      # set it to "site". I prefer that INSTALLDIRS be set from outside
      # MakeMaker.
      $self->{INSTALLDIRS} ||= "site";
  
      $self->{MAN1EXT} ||= $Config{man1ext};
      $self->{MAN3EXT} ||= $Config{man3ext};
  
      # Get some stuff out of %Config if we haven't yet done so
      print "CONFIG must be an array ref\n"
          if ($self->{CONFIG} and ref $self->{CONFIG} ne 'ARRAY');
      $self->{CONFIG} = [] unless (ref $self->{CONFIG});
      push(@{$self->{CONFIG}}, @ExtUtils::MakeMaker::Get_from_Config);
      push(@{$self->{CONFIG}}, 'shellflags') if $Config{shellflags};
      my(%once_only);
      foreach my $m (@{$self->{CONFIG}}){
          next if $once_only{$m};
          print "CONFIG key '$m' does not exist in Config.pm\n"
                  unless exists $Config{$m};
          $self->{uc $m} ||= $Config{$m};
          $once_only{$m} = 1;
      }
  
  # This is too dangerous:
  #    if ($^O eq "next") {
  #	$self->{AR} = "libtool";
  #	$self->{AR_STATIC_ARGS} = "-o";
  #    }
  # But I leave it as a placeholder
  
      $self->{AR_STATIC_ARGS} ||= "cr";
  
      # These should never be needed
      $self->{OBJ_EXT} ||= '.o';
      $self->{LIB_EXT} ||= '.a';
  
      $self->{MAP_TARGET} ||= "perl";
  
      $self->{LIBPERL_A} ||= "libperl$self->{LIB_EXT}";
  
      # make a simple check if we find strict
      warn "Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory
          (strict.pm not found)"
          unless -f $self->catfile("$self->{PERL_LIB}","strict.pm") ||
                 $self->{NAME} eq "ExtUtils::MakeMaker";
  }
  
  =item init_tools
  
  Initializes tools to use their common (and faster) Unix commands.
  
  =cut
  
  sub init_tools {
      my $self = shift;
  
      $self->{ECHO}       ||= 'echo';
      $self->{ECHO_N}     ||= 'echo -n';
      $self->{RM_F}       ||= "rm -f";
      $self->{RM_RF}      ||= "rm -rf";
      $self->{TOUCH}      ||= "touch";
      $self->{TEST_F}     ||= "test -f";
      $self->{TEST_S}     ||= "test -s";
      $self->{CP}         ||= "cp";
      $self->{MV}         ||= "mv";
      $self->{CHMOD}      ||= "chmod";
      $self->{FALSE}      ||= 'false';
      $self->{TRUE}       ||= 'true';
  
      $self->{LD}         ||= 'ld';
  
      return $self->SUPER::init_tools(@_);
  
      # After SUPER::init_tools so $Config{shell} has a
      # chance to get set.
      $self->{SHELL}      ||= '/bin/sh';
  
      return;
  }
  
  
  =item init_linker
  
  Unix has no need of special linker flags.
  
  =cut
  
  sub init_linker {
      my($self) = shift;
      $self->{PERL_ARCHIVE} ||= '';
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  
  =begin _protected
  
  =item init_lib2arch
  
      $mm->init_lib2arch
  
  =end _protected
  
  =cut
  
  sub init_lib2arch {
      my($self) = shift;
  
      # The user who requests an installation directory explicitly
      # should not have to tell us an architecture installation directory
      # as well. We look if a directory exists that is named after the
      # architecture. If not we take it as a sign that it should be the
      # same as the requested installation directory. Otherwise we take
      # the found one.
      for my $libpair ({l=>"privlib",   a=>"archlib"},
                       {l=>"sitelib",   a=>"sitearch"},
                       {l=>"vendorlib", a=>"vendorarch"},
                      )
      {
          my $lib = "install$libpair->{l}";
          my $Lib = uc $lib;
          my $Arch = uc "install$libpair->{a}";
          if( $self->{$Lib} && ! $self->{$Arch} ){
              my($ilib) = $Config{$lib};
  
              $self->prefixify($Arch,$ilib,$self->{$Lib});
  
              unless (-d $self->{$Arch}) {
                  print "Directory $self->{$Arch} not found\n"
                    if $Verbose;
                  $self->{$Arch} = $self->{$Lib};
              }
              print "Defaulting $Arch to $self->{$Arch}\n" if $Verbose;
          }
      }
  }
  
  
  =item init_PERL
  
      $mm->init_PERL;
  
  Called by init_main.  Sets up ABSPERL, PERL, FULLPERL and all the
  *PERLRUN* permutations.
  
      PERL is allowed to be miniperl
      FULLPERL must be a complete perl
  
      ABSPERL is PERL converted to an absolute path
  
      *PERLRUN contains everything necessary to run perl, find it's
           libraries, etc...
  
      *PERLRUNINST is *PERLRUN + everything necessary to find the
           modules being built.
  
  =cut
  
  sub init_PERL {
      my($self) = shift;
  
      my @defpath = ();
      foreach my $component ($self->{PERL_SRC}, $self->path(),
                             $Config{binexp})
      {
  	push @defpath, $component if defined $component;
      }
  
      # Build up a set of file names (not command names).
      my $thisperl = $self->canonpath($^X);
      $thisperl .= $Config{exe_ext} unless
                  # VMS might have a file version # at the end
        $Is{VMS} ? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i
                : $thisperl =~ m/$Config{exe_ext}$/i;
  
      # We need a relative path to perl when in the core.
      $thisperl = $self->abs2rel($thisperl) if $self->{PERL_CORE};
  
      my @perls = ($thisperl);
      push @perls, map { "$_$Config{exe_ext}" }
                       ("perl$Config{version}", 'perl5', 'perl');
  
      # miniperl has priority over all but the canonical perl when in the
      # core.  Otherwise its a last resort.
      my $miniperl = "miniperl$Config{exe_ext}";
      if( $self->{PERL_CORE} ) {
          splice @perls, 1, 0, $miniperl;
      }
      else {
          push @perls, $miniperl;
      }
  
      $self->{PERL} ||=
          $self->find_perl(5.0, \@perls, \@defpath, $Verbose );
  
      my $perl = $self->{PERL};
      $perl =~ s/^"//;
      my $has_mcr = $perl =~ s/^MCR\s*//;
      my $perlflags = '';
      my $stripped_perl;
      while ($perl) {
  	($stripped_perl = $perl) =~ s/"$//;
  	last if -x $stripped_perl;
  	last unless $perl =~ s/(\s+\S+)$//;
  	$perlflags = $1.$perlflags;
      }
      $self->{PERL} = $stripped_perl;
      $self->{PERL} = 'MCR '.$self->{PERL} if $has_mcr || $Is{VMS};
  
      # When built for debugging, VMS doesn't create perl.exe but ndbgperl.exe.
      my $perl_name = 'perl';
      $perl_name = 'ndbgperl' if $Is{VMS} &&
        defined $Config{usevmsdebug} && $Config{usevmsdebug} eq 'define';
  
      # XXX This logic is flawed.  If "miniperl" is anywhere in the path
      # it will get confused.  It should be fixed to work only on the filename.
      # Define 'FULLPERL' to be a non-miniperl (used in test: target)
      unless ($self->{FULLPERL}) {
        ($self->{FULLPERL} = $self->{PERL}) =~ s/\Q$miniperl\E$/$perl_name$Config{exe_ext}/i;
        $self->{FULLPERL} = qq{"$self->{FULLPERL}"}.$perlflags;
      }
      # Can't have an image name with quotes, and findperl will have
      # already escaped spaces.
      $self->{FULLPERL} =~ tr/"//d if $Is{VMS};
  
      # `dmake` can fail for image (aka, executable) names which start with double-quotes
      # * push quote inward by at least one character (or the drive prefix, if present)
      # * including any initial directory separator preserves the `file_name_is_absolute` property
      $self->{FULLPERL} =~ s/^"(\S(:\\|:)?)/$1"/ if $self->is_make_type('dmake');
  
      # Little hack to get around VMS's find_perl putting "MCR" in front
      # sometimes.
      $self->{ABSPERL} = $self->{PERL};
      $has_mcr = $self->{ABSPERL} =~ s/^MCR\s*//;
      if( $self->file_name_is_absolute($self->{ABSPERL}) ) {
          $self->{ABSPERL} = '$(PERL)';
      }
      else {
          $self->{ABSPERL} = $self->rel2abs($self->{ABSPERL});
  
          # Quote the perl command if it contains whitespace
          $self->{ABSPERL} = $self->quote_literal($self->{ABSPERL})
            if $self->{ABSPERL} =~ /\s/;
  
          $self->{ABSPERL} = 'MCR '.$self->{ABSPERL} if $has_mcr;
      }
      $self->{PERL} = qq{"$self->{PERL}"}.$perlflags;
  
      # Can't have an image name with quotes, and findperl will have
      # already escaped spaces.
      $self->{PERL} =~ tr/"//d if $Is{VMS};
  
      # `dmake` can fail for image (aka, executable) names which start with double-quotes
      # * push quote inward by at least one character (or the drive prefix, if present)
      # * including any initial directory separator preserves the `file_name_is_absolute` property
      $self->{PERL} =~ s/^"(\S(:\\|:)?)/$1"/ if $self->is_make_type('dmake');
  
      # Are we building the core?
      $self->{PERL_CORE} = $ENV{PERL_CORE} unless exists $self->{PERL_CORE};
      $self->{PERL_CORE} = 0               unless defined $self->{PERL_CORE};
  
      # Make sure perl can find itself before it's installed.
      my $lib_paths = $self->{UNINSTALLED_PERL} || $self->{PERL_CORE}
          ? ( $self->{PERL_ARCHLIB} && $self->{PERL_LIB} && $self->{PERL_ARCHLIB} ne $self->{PERL_LIB} ) ?
              q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} : q{ "-I$(PERL_LIB)"}
          : undef;
      my $inst_lib_paths = $self->{INST_ARCHLIB} ne $self->{INST_LIB}
          ? 'RUN)'.$perlflags.' "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"'
          : 'RUN)'.$perlflags.' "-I$(INST_LIB)"';
      # How do we run perl?
      foreach my $perl (qw(PERL FULLPERL ABSPERL)) {
          my $run  = $perl.'RUN';
  
          $self->{$run}  = qq{\$($perl)};
          $self->{$run} .= $lib_paths if $lib_paths;
  
          $self->{$perl.'RUNINST'} = '$('.$perl.$inst_lib_paths;
      }
  
      return 1;
  }
  
  
  =item init_platform
  
  =item platform_constants
  
  Add MM_Unix_VERSION.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_Unix_VERSION} = $VERSION;
      $self->{PERL_MALLOC_DEF} = '-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.
                                 '-Dfree=Perl_mfree -Drealloc=Perl_realloc '.
                                 '-Dcalloc=Perl_calloc';
  
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item init_PERM
  
    $mm->init_PERM
  
  Called by init_main.  Initializes PERL_*
  
  =cut
  
  sub init_PERM {
      my($self) = shift;
  
      $self->{PERM_DIR} = 755  unless defined $self->{PERM_DIR};
      $self->{PERM_RW}  = 644  unless defined $self->{PERM_RW};
      $self->{PERM_RWX} = 755  unless defined $self->{PERM_RWX};
  
      return 1;
  }
  
  
  =item init_xs
  
      $mm->init_xs
  
  Sets up macros having to do with XS code.  Currently just INST_STATIC,
  INST_DYNAMIC and INST_BOOT.
  
  =cut
  
  sub init_xs {
      my $self = shift;
  
      if ($self->has_link_code()) {
          $self->{INST_STATIC}  =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT)$(LIB_EXT)');
          $self->{INST_DYNAMIC} =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(DLBASE).$(DLEXT)');
          $self->{INST_BOOT}    =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT).bs');
  	if ($self->{XSMULTI}) {
  	    my @exts = $self->_xs_list_basenames;
  	    my (@statics, @dynamics, @boots);
  	    for my $ext (@exts) {
  		my ($v, $d, $f) = File::Spec->splitpath($ext);
  		my @d = File::Spec->splitdir($d);
  		shift @d if defined $d[0] and $d[0] eq 'lib';
  		pop @d if $d[$#d] eq '';
  		my $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);
  		my $instfile = $self->catfile($instdir, $f);
  		push @statics, "$instfile\$(LIB_EXT)";
  
                  # Dynamic library names may need special handling.
                  my $dynfile = $instfile;
                  eval { require DynaLoader };
                  if (defined &DynaLoader::mod2fname) {
                      $dynfile = $self->catfile($instdir, &DynaLoader::mod2fname([@d, $f]));
                  }
  
  		push @dynamics, "$dynfile.\$(DLEXT)";
  		push @boots, "$instfile.bs";
  	    }
  	    $self->{INST_STATIC} = join ' ', @statics;
  	    $self->{INST_DYNAMIC} = join ' ', @dynamics;
  	    $self->{INST_BOOT} = join ' ', @boots;
  	}
      } else {
          $self->{INST_STATIC}  = '';
          $self->{INST_DYNAMIC} = '';
          $self->{INST_BOOT}    = '';
      }
  }
  
  =item install (o)
  
  Defines the install target.
  
  =cut
  
  sub install {
      my($self, %attribs) = @_;
      my(@m);
  
      push @m, q{
  install :: pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  pure_perl_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
  
      push @m,
  q{		read "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		"$(INST_LIB)" "$(DESTINSTALLPRIVLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLARCHLIB)" \
  		"$(INST_BIN)" "$(DESTINSTALLBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{"
  
  
  pure_site_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
      push @m,
  q{		read "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		"$(INST_LIB)" "$(DESTINSTALLSITELIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLSITEARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLSITEBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSITESCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLSITEMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLSITEMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{"
  
  pure_vendor_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
      push @m,
  q{		read "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		"$(INST_LIB)" "$(DESTINSTALLVENDORLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLVENDORARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLVENDORBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLVENDORSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLVENDORMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLVENDORMAN3DIR)"
  
  };
  
      push @m, q{
  doc_perl_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_site_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install :: all
  	$(NOECHO) $(NOOP)
  
  } if $self->{NO_PERLLOCAL};
  
      push @m, q{
  doc_perl_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLPRIVLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_site_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLSITELIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_vendor_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLVENDORLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  } unless $self->{NO_PERLLOCAL};
  
      push @m, q{
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  };
  
      join("",@m);
  }
  
  =item installbin (o)
  
  Defines targets to make and to install EXE_FILES.
  
  =cut
  
  sub installbin {
      my($self) = shift;
  
      return "" unless $self->{EXE_FILES} && ref $self->{EXE_FILES} eq "ARRAY";
      my @exefiles = sort @{$self->{EXE_FILES}};
      return "" unless @exefiles;
  
      @exefiles = map vmsify($_), @exefiles if $Is{VMS};
  
      my %fromto;
      for my $from (@exefiles) {
  	my($path)= $self->catfile('$(INST_SCRIPT)', basename($from));
  
  	local($_) = $path; # for backwards compatibility
  	my $to = $self->libscan($path);
  	print "libscan($from) => '$to'\n" if ($Verbose >=2);
  
          $to = vmsify($to) if $Is{VMS};
  	$fromto{$from} = $to;
      }
      my @to   = sort values %fromto;
  
      my @m;
      push(@m, qq{
  EXE_FILES = @exefiles
  
  pure_all :: @to
  	\$(NOECHO) \$(NOOP)
  
  realclean ::
  });
  
      # realclean can get rather large.
      push @m, map "\t$_\n", $self->split_command('$(RM_F)', @to);
      push @m, "\n";
  
      # A target for each exe file.
      my @froms = sort keys %fromto;
      for my $from (@froms) {
          #                              1      2
          push @m, _sprintf562 <<'MAKE', $from, $fromto{$from};
  %2$s : %1$s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
  	$(NOECHO) $(RM_F) %2$s
  	$(CP) %1$s %2$s
  	$(FIXIN) %2$s
  	-$(NOECHO) $(CHMOD) $(PERM_RWX) %2$s
  
  MAKE
  
      }
  
      join "", @m;
  }
  
  =item linkext (o)
  
  Defines the linkext target which in turn defines the LINKTYPE.
  
  =cut
  
  # LINKTYPE => static or dynamic or ''
  sub linkext {
      my($self, %attribs) = @_;
      my $linktype = $attribs{LINKTYPE};
      $linktype = $self->{LINKTYPE} unless defined $linktype;
      if (defined $linktype and $linktype eq '') {
          warn "Warning: LINKTYPE set to '', no longer necessary\n";
      }
      $linktype = '$(LINKTYPE)' unless defined $linktype;
      "
  linkext :: $linktype
  	\$(NOECHO) \$(NOOP)
  ";
  }
  
  =item lsdir
  
  Takes as arguments a directory name and a regular expression. Returns
  all entries in the directory that match the regular expression.
  
  =cut
  
  sub lsdir {
      #  $self
      my(undef, $dir, $regex) = @_;
      opendir(my $dh, defined($dir) ? $dir : ".")
          or return;
      my @ls = readdir $dh;
      closedir $dh;
      @ls = grep(/$regex/, @ls) if defined $regex;
      @ls;
  }
  
  =item macro (o)
  
  Simple subroutine to insert the macros defined by the macro attribute
  into the Makefile.
  
  =cut
  
  sub macro {
      my($self,%attribs) = @_;
      my @m;
      foreach my $key (sort keys %attribs) {
  	my $val = $attribs{$key};
  	push @m, "$key = $val\n";
      }
      join "", @m;
  }
  
  =item makeaperl (o)
  
  Called by staticmake. Defines how to write the Makefile to produce a
  static new perl.
  
  By default the Makefile produced includes all the static extensions in
  the perl library. (Purified versions of library files, e.g.,
  DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)
  
  =cut
  
  sub makeaperl {
      my($self, %attribs) = @_;
      my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmp, $libperl) =
  	@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
      s/^(.*)/"-I$1"/ for @{$perlinc || []};
      my(@m);
      push @m, "
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  FULLPERL      = $self->{FULLPERL}
  MAP_PERLINC   = @{$perlinc || []}
  ";
      return join '', @m if $self->{PARENT};
  
      my($dir) = join ":", @{$self->{DIR}};
  
      unless ($self->{MAKEAPERL}) {
  	push @m, q{
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@
  
  $(MAKE_APERL_FILE) : static $(FIRST_MAKEFILE) pm_to_blib
  	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR="}, $dir, q{" \
  		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};
  
  	foreach (@ARGV){
  		my $arg = $_; # avoid lvalue aliasing
  		if ( $arg =~ /(^.*?=)(.*['\s].*)/ ) {
  			$arg = $1 . $self->quote_literal($2);
  		}
  		push @m, " \\\n\t\t$arg";
  	}
  	push @m, "\n";
  
  	return join '', @m;
      }
  
      my $cccmd = $self->const_cccmd($libperl);
      $cccmd =~ s/^CCCMD\s*=\s*//;
      $cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;
      $cccmd .= " $Config{cccdlflags}"
  	if ($Config{useshrplib} eq 'true');
      $cccmd =~ s/\(CC\)/\(PERLMAINCC\)/;
  
      # The front matter of the linkcommand...
      my $linkcmd = join ' ', "\$(CC)",
  	    grep($_, @Config{qw(ldflags ccdlflags)});
      $linkcmd =~ s/\s+/ /g;
      $linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;
  
      # Which *.a files could we make use of...
      my $staticlib21 = $self->_find_static_libs($searchdirs);
      # We trust that what has been handed in as argument, will be buildable
      $static = [] unless $static;
      @$staticlib21{@{$static}} = (1) x @{$static};
  
      $extra = [] unless $extra && ref $extra eq 'ARRAY';
      for (sort keys %$staticlib21) {
  	next unless /\Q$self->{LIB_EXT}\E\z/;
  	$_ = dirname($_) . "/extralibs.ld";
  	push @$extra, $_;
      }
  
      s/^(.*)/"-I$1"/ for @{$perlinc || []};
  
      $target ||= "perl";
      $tmp    ||= ".";
  
  # MAP_STATIC doesn't look into subdirs yet. Once "all" is made and we
  # regenerate the Makefiles, MAP_STATIC and the dependencies for
  # extralibs.all are computed correctly
      my @map_static = reverse sort keys %$staticlib21;
      push @m, "
  MAP_LINKCMD   = $linkcmd
  MAP_STATIC    = ", join(" \\\n\t", map { qq{"$_"} } @map_static), "
  MAP_STATICDEP = ", join(' ', map { $self->quote_dep($_) } @map_static), "
  
  MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
  ";
  
      my $lperl;
      if (defined $libperl) {
  	($lperl = $libperl) =~ s/\$\(A\)/$self->{LIB_EXT}/;
      }
      unless ($libperl && -f $lperl) { # Ilya's code...
  	my $dir = $self->{PERL_SRC} || "$self->{PERL_ARCHLIB}/CORE";
  	$dir = "$self->{PERL_ARCHLIB}/.." if $self->{UNINSTALLED_PERL};
  	$libperl ||= "libperl$self->{LIB_EXT}";
  	$libperl   = "$dir/$libperl";
  	$lperl   ||= "libperl$self->{LIB_EXT}";
  	$lperl     = "$dir/$lperl";
  
          if (! -f $libperl and ! -f $lperl) {
            # We did not find a static libperl. Maybe there is a shared one?
            if ($Is{SunOS}) {
              $lperl  = $libperl = "$dir/$Config{libperl}";
              # SUNOS ld does not take the full path to a shared library
              $libperl = '' if $Is{SunOS4};
            }
          }
  
  	print <<EOF unless -f $lperl || defined($self->{PERL_SRC});
  Warning: $libperl not found
  If you're going to build a static perl binary, make sure perl is installed
  otherwise ignore this warning
  EOF
      }
  
      # SUNOS ld does not take the full path to a shared library
      my $llibperl = $libperl ? '$(MAP_LIBPERL)' : '-lperl';
      my $libperl_dep = $self->quote_dep($libperl);
  
      push @m, "
  MAP_LIBPERL = $libperl
  MAP_LIBPERLDEP = $libperl_dep
  LLIBPERL    = $llibperl
  ";
  
      push @m, '
  $(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t", @$extra).'
  	$(NOECHO) $(RM_F)  $@
  	$(NOECHO) $(TOUCH) $@
  ';
  
      foreach my $catfile (@$extra){
  	push @m, "\tcat $catfile >> \$\@\n";
      }
  
      my $ldfrom = $self->{XSMULTI} ? '' : '$(LDFROM)';
      #                             1     2                        3        4
      push @m, _sprintf562 <<'EOF', $tmp, $ldfrom, $self->xs_obj_opt('$@'), $makefilename;
  $(MAP_TARGET) :: %1$s/perlmain$(OBJ_EXT) $(MAP_LIBPERLDEP) $(MAP_STATICDEP) $(INST_ARCHAUTODIR)/extralibs.all
  	$(MAP_LINKCMD) %2$s $(OPTIMIZE) %1$s/perlmain$(OBJ_EXT) %3$s $(MAP_STATIC) "$(LLIBPERL)" `cat $(INST_ARCHAUTODIR)/extralibs.all` $(MAP_PRELIBS)
  	$(NOECHO) $(ECHO) "To install the new '$(MAP_TARGET)' binary, call"
  	$(NOECHO) $(ECHO) "    $(MAKE) $(USEMAKEFILE) %4$s inst_perl MAP_TARGET=$(MAP_TARGET)"
  	$(NOECHO) $(ECHO) "    $(MAKE) $(USEMAKEFILE) %4$s map_clean"
  
  %1$s/perlmain\$(OBJ_EXT): %1$s/perlmain.c
  EOF
      push @m, "\t".$self->cd($tmp, qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";
  
      my $maybe_DynaLoader = $Config{usedl} ? 'q(DynaLoader)' : '';
      push @m, _sprintf562 <<'EOF', $tmp, $makefilename, $maybe_DynaLoader;
  
  %1$s/perlmain.c: %2$s
  	$(NOECHO) $(ECHO) Writing $@
  	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \
  		-e "writemain(grep(s#.*/auto/##s, @ARGV), %3$s)" $(MAP_STATIC) > $@t
  	$(MV) $@t $@
  
  EOF
      push @m, "\t", q{$(NOECHO) $(PERL) "$(INSTALLSCRIPT)/fixpmain"
  } if (defined (&Dos::UseLFN) && Dos::UseLFN()==0);
  
  
      push @m, q{
  doc_inst_perl :
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Perl binary" "$(MAP_TARGET)" \
  		MAP_STATIC "$(MAP_STATIC)" \
  		MAP_EXTRA "`cat $(INST_ARCHAUTODIR)/extralibs.all`" \
  		MAP_LIBPERL "$(MAP_LIBPERL)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  };
  
      push @m, q{
  inst_perl : pure_inst_perl doc_inst_perl
  
  pure_inst_perl : $(MAP_TARGET)
  	}.$self->{CP}.q{ $(MAP_TARGET) "}.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{"
  
  clean :: map_clean
  
  map_clean :
  	}.$self->{RM_F}.qq{ $tmp/perlmain\$(OBJ_EXT) $tmp/perlmain.c \$(MAP_TARGET) $makefilename \$(INST_ARCHAUTODIR)/extralibs.all
  };
  
      join '', @m;
  }
  
  # utility method
  sub _find_static_libs {
      my ($self, $searchdirs) = @_;
      # don't use File::Spec here because on Win32 F::F still uses "/"
      my $installed_version = join('/',
  	'auto', $self->{FULLEXT}, "$self->{BASEEXT}$self->{LIB_EXT}"
      );
      my %staticlib21;
      require File::Find;
      File::Find::find(sub {
  	if ($File::Find::name =~ m{/auto/share\z}) {
  	    # in a subdir of auto/share, prune because e.g.
  	    # Alien::pkgconfig uses File::ShareDir to put .a files
  	    # there. do not want
  	    $File::Find::prune = 1;
  	    return;
  	}
  
  	return unless m/\Q$self->{LIB_EXT}\E$/;
  
  	return unless -f 'extralibs.ld'; # this checks is a "proper" XS installation
  
          # Skip perl's libraries.
          return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;
  
  	# Skip purified versions of libraries
          # (e.g., DynaLoader_pure_p1_c0_032.a)
  	return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";
  
  	if( exists $self->{INCLUDE_EXT} ){
  		my $found = 0;
  
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything not explicitly marked for inclusion.
  		# DynaLoader is implied.
  		foreach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){
  			if( $xx eq $incl ){
  				$found++;
  				last;
  			}
  		}
  		return unless $found;
  	}
  	elsif( exists $self->{EXCLUDE_EXT} ){
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything explicitly marked for exclusion
  		foreach my $excl (@{$self->{EXCLUDE_EXT}}){
  			return if( $xx eq $excl );
  		}
  	}
  
  	# don't include the installed version of this extension. I
  	# leave this line here, although it is not necessary anymore:
  	# I patched minimod.PL instead, so that Miniperl.pm won't
  	# include duplicates
  
  	# Once the patch to minimod.PL is in the distribution, I can
  	# drop it
  	return if $File::Find::name =~ m:\Q$installed_version\E\z:;
  	return if !$self->xs_static_lib_is_xs($_);
  	use Cwd 'cwd';
  	$staticlib21{cwd() . "/" . $_}++;
      }, grep( -d $_, map { $self->catdir($_, 'auto') } @{$searchdirs || []}) );
      return \%staticlib21;
  }
  
  =item xs_static_lib_is_xs (o)
  
  Called by a utility method of makeaperl. Checks whether a given file
  is an XS library by seeing whether it defines any symbols starting
  with C<boot_> (with an optional leading underscore - needed on MacOS).
  
  =cut
  
  sub xs_static_lib_is_xs {
      my ($self, $libfile) = @_;
      my $devnull = File::Spec->devnull;
      return `nm $libfile 2>$devnull` =~ /\b_?boot_/;
  }
  
  =item makefile (o)
  
  Defines how to rewrite the Makefile.
  
  =cut
  
  sub makefile {
      my($self) = shift;
      my $m;
      # We do not know what target was originally specified so we
      # must force a manual rerun to be sure. But as it should only
      # happen very rarely it is not a significant problem.
      $m = '
  $(OBJECT) : $(FIRST_MAKEFILE)
  
  ' if $self->{OBJECT};
  
      my $newer_than_target = $Is{VMS} ? '$(MMS$SOURCE_LIST)' : '$?';
      my $mpl_args = join " ", map qq["$_"], @ARGV;
      my $cross = '';
      if (defined $::Cross::platform) {
          # Inherited from win32/buildext.pl
          $cross = "-MCross=$::Cross::platform ";
      }
      $m .= sprintf <<'MAKE_FRAG', $newer_than_target, $cross, $mpl_args;
  # We take a very conservative approach here, but it's worth it.
  # We move Makefile to Makefile.old here to avoid gnu make looping.
  $(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
  	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
  	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
  	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
  	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
  	$(PERLRUN) %sMakefile.PL %s
  	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
  	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
  	$(FALSE)
  
  MAKE_FRAG
  
      return $m;
  }
  
  
  =item maybe_command
  
  Returns true, if the argument is likely to be a command.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d $file;
      return;
  }
  
  
  =item needs_linking (o)
  
  Does this module need linking? Looks into subdirectory objects (see
  also has_link_code())
  
  =cut
  
  sub needs_linking {
      my($self) = shift;
  
      my $caller = (caller(0))[3];
      confess("needs_linking called too early") if
        $caller =~ /^ExtUtils::MakeMaker::/;
      return $self->{NEEDS_LINKING} if defined $self->{NEEDS_LINKING};
      if ($self->has_link_code or $self->{MAKEAPERL}){
  	$self->{NEEDS_LINKING} = 1;
  	return 1;
      }
      foreach my $child (keys %{$self->{CHILDREN}}) {
  	if ($self->{CHILDREN}->{$child}->needs_linking) {
  	    $self->{NEEDS_LINKING} = 1;
  	    return 1;
  	}
      }
      return $self->{NEEDS_LINKING} = 0;
  }
  
  
  =item parse_abstract
  
  parse a file and return what you think is the ABSTRACT
  
  =cut
  
  sub parse_abstract {
      my($self,$parsefile) = @_;
      my $result;
  
      local $/ = "\n";
      open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
      binmode $fh;
      my $inpod = 0;
      my $pod_encoding;
      my $package = $self->{DISTNAME};
      $package =~ s/-/::/g;
      while (<$fh>) {
          $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
          next if !$inpod;
          s#\r*\n\z##; # handle CRLF input
  
          if ( /^=encoding\s*(.*)$/i ) {
              $pod_encoding = $1;
          }
  
          if ( /^($package(?:\.pm)? \s+ -+ \s+)(.*)/x ) {
            $result = $2;
            next;
          }
          next unless $result;
  
          if ( $result && ( /^\s*$/ || /^\=/ ) ) {
            last;
          }
          $result = join ' ', $result, $_;
      }
      close $fh;
  
      if ( $pod_encoding and !( "$]" < 5.008 or !$Config{useperlio} ) ) {
          # Have to wrap in an eval{} for when running under PERL_CORE
          # Encode isn't available during build phase and parsing
          # ABSTRACT isn't important there
          eval {
            require Encode;
            $result = Encode::decode($pod_encoding, $result);
          }
      }
  
      return $result;
  }
  
  =item parse_version
  
      my $version = MM->parse_version($file);
  
  Parse a $file and return what $VERSION is set to by the first assignment.
  It will return the string "undef" if it can't figure out what $VERSION
  is. $VERSION should be for all to see, so C<our $VERSION> or plain $VERSION
  are okay, but C<my $VERSION> is not.
  
  C<package Foo VERSION> is also checked for.  The first version
  declaration found is used, but this may change as it differs from how
  Perl does it.
  
  parse_version() will try to C<use version> before checking for
  C<$VERSION> so the following will work.
  
      $VERSION = qv(1.2.3);
  
  =cut
  
  sub parse_version {
      my($self,$parsefile) = @_;
      my $result;
  
      local $/ = "\n";
      local $_;
      open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
      my $inpod = 0;
      while (<$fh>) {
          $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
          next if $inpod || /^\s*#/;
          chop;
          next if /^\s*(if|unless|elsif)/;
          if ( m{^ \s* package \s+ \w[\w\:\']* \s+ (v?[0-9._]+) \s* (;|\{)  }x ) {
              local $^W = 0;
              $result = $1;
          }
          elsif ( m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* (?<![<>=!])\=[^=]}x ) {
  			$result = $self->get_version($parsefile, $1, $2);
          }
          else {
            next;
          }
          last if defined $result;
      }
      close $fh;
  
      if ( defined $result && $result !~ /^v?[\d_\.]+$/ ) {
        require version;
        my $normal = eval { version->new( $result ) };
        $result = $normal if defined $normal;
      }
      $result = "undef" unless defined $result;
      return $result;
  }
  
  sub get_version {
      my ($self, $parsefile, $sigil, $name) = @_;
      my $line = $_; # from the while() loop in parse_version
      {
          package ExtUtils::MakeMaker::_version;
          undef *version; # in case of unexpected version() sub
          eval {
              require version;
              version::->import;
          };
          no strict;
          local *{$name};
          local $^W = 0;
          $line = $1 if $line =~ m{^(.+)}s;
          eval($line); ## no critic
          return ${$name};
      }
  }
  
  =item pasthru (o)
  
  Defines the string that is passed to recursive make calls in
  subdirectories. The variables like C<PASTHRU_DEFINE> are used in each
  level, and passed downwards on the command-line with e.g. the value of
  that level's DEFINE. Example:
  
      # Level 0 has DEFINE = -Dfunky
      # This code will define level 0's PASTHRU=PASTHRU_DEFINE="$(DEFINE)
      #     $(PASTHRU_DEFINE)"
      # Level 0's $(CCCMD) will include macros $(DEFINE) and $(PASTHRU_DEFINE)
      # So will level 1's, so when level 1 compiles, it will get right values
      # And so ad infinitum
  
  =cut
  
  sub pasthru {
      my($self) = shift;
      my(@m);
  
      my(@pasthru);
      my($sep) = $Is{VMS} ? ',' : '';
      $sep .= "\\\n\t";
  
      foreach my $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE
                       PREFIX INSTALL_BASE)
                   )
      {
          next unless defined $self->{$key};
  	push @pasthru, "$key=\"\$($key)\"";
      }
  
      foreach my $key (qw(DEFINE INC)) {
          # default to the make var
          my $val = qq{\$($key)};
          # expand within perl if given since need to use quote_literal
          # since INC might include space-protecting ""!
          chomp($val = $self->{$key}) if defined $self->{$key};
          $val .= " \$(PASTHRU_$key)";
          my $quoted = $self->quote_literal($val);
          push @pasthru, qq{PASTHRU_$key=$quoted};
      }
  
      push @m, "\nPASTHRU = ", join ($sep, @pasthru), "\n";
      join "", @m;
  }
  
  =item perl_script
  
  Takes one argument, a file name, and returns the file name, if the
  argument is likely to be a perl script. On MM_Unix this is true for
  any ordinary, readable file.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && -f _;
      return;
  }
  
  =item perldepend (o)
  
  Defines the dependency from all *.h files that come with the perl
  distribution.
  
  =cut
  
  sub perldepend {
      my($self) = shift;
      my(@m);
  
      my $make_config = $self->cd('$(PERL_SRC)', '$(MAKE) lib/Config.pm');
  
      push @m, sprintf <<'MAKE_FRAG', $make_config if $self->{PERL_SRC};
  # Check for unpropogated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INCDEP)/config.h: $(PERL_SRC)/config.sh
  	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)
  
  $(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh
  	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
  	%s
  MAKE_FRAG
  
      return join "", @m unless $self->needs_linking;
  
      if ($self->{OBJECT}) {
          # Need to add an object file dependency on the perl headers.
          # this is very important for XS modules in perl.git development.
          push @m, $self->_perl_header_files_fragment("/"); # Directory separator between $(PERL_INC)/header.h
      }
  
      push @m, join(" ", sort values %{$self->{XS}})." : \$(XSUBPPDEPS)\n"  if %{$self->{XS}};
  
      return join "\n", @m;
  }
  
  
  =item pm_to_blib
  
  Defines target that copies all files in the hash PM to their
  destination and autosplits them. See L<ExtUtils::Install/DESCRIPTION>
  
  =cut
  
  sub pm_to_blib {
      my $self = shift;
      my($autodir) = $self->catdir('$(INST_LIB)','auto');
      my $r = q{
  pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
  };
  
      # VMS will swallow '' and PM_FILTER is often empty.  So use q[]
      my $pm_to_blib = $self->oneliner(<<CODE, ['-MExtUtils::Install']);
  pm_to_blib({\@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
  CODE
  
      my @cmds = $self->split_command($pm_to_blib,
                    map { ($self->quote_literal($_) => $self->quote_literal($self->{PM}->{$_})) } sort keys %{$self->{PM}});
  
      $r .= join '', map { "\t\$(NOECHO) $_\n" } @cmds;
      $r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};
  
      return $r;
  }
  
  # transform dot-separated version string into comma-separated quadruple
  # examples:  '1.2.3.4.5' => '1,2,3,4'
  #            '1.2.3'     => '1,2,3,0'
  sub _ppd_version {
      my ($self, $string) = @_;
      return join ',', ((split /\./, $string), (0) x 4)[0..3];
  }
  
  =item ppd
  
  Defines target that creates a PPD (Perl Package Description) file
  for a binary distribution.
  
  =cut
  
  sub ppd {
      my($self) = @_;
  
      my $abstract = $self->{ABSTRACT} || '';
      $abstract =~ s/\n/\\n/sg;
      $abstract =~ s/</&lt;/g;
      $abstract =~ s/>/&gt;/g;
  
      my $author = join(', ',@{ ref $self->{AUTHOR} eq 'ARRAY' ? $self->{AUTHOR} : [ $self->{AUTHOR} || '']});
      $author =~ s/</&lt;/g;
      $author =~ s/>/&gt;/g;
  
      my $ppd_file = "$self->{DISTNAME}.ppd";
  
      my @ppd_chunks = qq(<SOFTPKG NAME="$self->{DISTNAME}" VERSION="$self->{VERSION}">\n);
  
      push @ppd_chunks, sprintf <<'PPD_HTML', $abstract, $author;
      <ABSTRACT>%s</ABSTRACT>
      <AUTHOR>%s</AUTHOR>
  PPD_HTML
  
      push @ppd_chunks, "    <IMPLEMENTATION>\n";
      if ( $self->{MIN_PERL_VERSION} ) {
          my $min_perl_version = $self->_ppd_version($self->{MIN_PERL_VERSION});
          push @ppd_chunks, sprintf <<'PPD_PERLVERS', $min_perl_version;
          <PERLCORE VERSION="%s" />
  PPD_PERLVERS
  
      }
  
      # Don't add "perl" to requires.  perl dependencies are
      # handles by ARCHITECTURE.
      my %prereqs = %{$self->{PREREQ_PM}};
      delete $prereqs{perl};
  
      # Build up REQUIRE
      foreach my $prereq (sort keys %prereqs) {
          my $name = $prereq;
          $name .= '::' unless $name =~ /::/;
          my $version = $prereqs{$prereq};
  
          my %attrs = ( NAME => $name );
          $attrs{VERSION} = $version if $version;
          my $attrs = join " ", map { qq[$_="$attrs{$_}"] } sort keys %attrs;
          push @ppd_chunks, qq(        <REQUIRE $attrs />\n);
      }
  
      my $archname = $Config{archname};
      if ("$]" >= 5.008) {
          # archname did not change from 5.6 to 5.8, but those versions may
          # not be not binary compatible so now we append the part of the
          # version that changes when binary compatibility may change
          $archname .= "-$Config{PERL_REVISION}.$Config{PERL_VERSION}";
      }
      push @ppd_chunks, sprintf <<'PPD_OUT', $archname;
          <ARCHITECTURE NAME="%s" />
  PPD_OUT
  
      if ($self->{PPM_INSTALL_SCRIPT}) {
          if ($self->{PPM_INSTALL_EXEC}) {
              push @ppd_chunks, sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},
                    $self->{PPM_INSTALL_EXEC}, $self->{PPM_INSTALL_SCRIPT};
          }
          else {
              push @ppd_chunks, sprintf qq{        <INSTALL>%s</INSTALL>\n},
                    $self->{PPM_INSTALL_SCRIPT};
          }
      }
  
      if ($self->{PPM_UNINSTALL_SCRIPT}) {
          if ($self->{PPM_UNINSTALL_EXEC}) {
              push @ppd_chunks, sprintf qq{        <UNINSTALL EXEC="%s">%s</UNINSTALL>\n},
                    $self->{PPM_UNINSTALL_EXEC}, $self->{PPM_UNINSTALL_SCRIPT};
          }
          else {
              push @ppd_chunks, sprintf qq{        <UNINSTALL>%s</UNINSTALL>\n},
                    $self->{PPM_UNINSTALL_SCRIPT};
          }
      }
  
      my ($bin_location) = $self->{BINARY_LOCATION} || '';
      $bin_location =~ s/\\/\\\\/g;
  
      push @ppd_chunks, sprintf <<'PPD_XML', $bin_location;
          <CODEBASE HREF="%s" />
      </IMPLEMENTATION>
  </SOFTPKG>
  PPD_XML
  
      my @ppd_cmds = $self->stashmeta(join('', @ppd_chunks), $ppd_file);
  
      return sprintf <<'PPD_OUT', join "\n\t", @ppd_cmds;
  # Creates a PPD (Perl Package Description) for a binary distribution.
  ppd :
  	%s
  PPD_OUT
  
  }
  
  =item prefixify
  
    $MM->prefixify($var, $prefix, $new_prefix, $default);
  
  Using either $MM->{uc $var} || $Config{lc $var}, it will attempt to
  replace it's $prefix with a $new_prefix.
  
  Should the $prefix fail to match I<AND> a PREFIX was given as an
  argument to WriteMakefile() it will set it to the $new_prefix +
  $default.  This is for systems whose file layouts don't neatly fit into
  our ideas of prefixes.
  
  This is for heuristics which attempt to create directory structures
  that mirror those of the installed perl.
  
  For example:
  
      $MM->prefixify('installman1dir', '/usr', '/home/foo', 'man/man1');
  
  this will attempt to remove '/usr' from the front of the
  $MM->{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir}
  if necessary) and replace it with '/home/foo'.  If this fails it will
  simply use '/home/foo/man/man1'.
  
  =cut
  
  sub prefixify {
      my($self,$var,$sprefix,$rprefix,$default) = @_;
  
      my $path = $self->{uc $var} ||
                 $Config_Override{lc $var} || $Config{lc $var} || '';
  
      $rprefix .= '/' if $sprefix =~ m|/$|;
  
      warn "  prefixify $var => $path\n" if $Verbose >= 2;
      warn "    from $sprefix to $rprefix\n" if $Verbose >= 2;
  
      if( $self->{ARGS}{PREFIX} &&
          $path !~ s{^\Q$sprefix\E\b}{$rprefix}s )
      {
  
          warn "    cannot prefix, using default.\n" if $Verbose >= 2;
          warn "    no default!\n" if !$default && $Verbose >= 2;
  
          $path = $self->catdir($rprefix, $default) if $default;
      }
  
      print "    now $path\n" if $Verbose >= 2;
      return $self->{uc $var} = $path;
  }
  
  
  =item processPL (o)
  
  Defines targets to run *.PL files.
  
  =cut
  
  sub processPL {
      my $self = shift;
      my $pl_files = $self->{PL_FILES};
  
      return "" unless $pl_files;
  
      my $m = '';
      foreach my $plfile (sort keys %$pl_files) {
          my $targets = $pl_files->{$plfile};
          my $list =
              ref($targets) eq 'HASH'  ? [ sort keys %$targets ] :
              ref($targets) eq 'ARRAY' ? $pl_files->{$plfile}   :
              [$pl_files->{$plfile}];
  
          foreach my $target (@$list) {
              if( $Is{VMS} ) {
                  $plfile = vmsify($self->eliminate_macros($plfile));
                  $target = vmsify($self->eliminate_macros($target));
              }
  
              # Normally a .PL file runs AFTER pm_to_blib so it can have
              # blib in its @INC and load the just built modules.  BUT if
              # the generated module is something in $(TO_INST_PM) which
              # pm_to_blib depends on then it can't depend on pm_to_blib
              # else we have a dependency loop.
              my $pm_dep;
              my $perlrun;
              if( defined $self->{PM}{$target} ) {
                  $pm_dep  = '';
                  $perlrun = 'PERLRUN';
              }
              else {
                  $pm_dep  = 'pm_to_blib';
                  $perlrun = 'PERLRUNINST';
              }
  
              my $extra_inputs = '';
              if( ref($targets) eq 'HASH' ) {
                  my $inputs = ref($targets->{$target})
                      ? $targets->{$target}
                      : [$targets->{$target}];
  
                  for my $input (@$inputs) {
                      if( $Is{VMS} ) {
                          $input = vmsify($self->eliminate_macros($input));
                      }
                      $extra_inputs .= ' '.$input;
                  }
              }
  
              $m .= <<MAKE_FRAG;
  
  pure_all :: $target
  	\$(NOECHO) \$(NOOP)
  
  $target :: $plfile $pm_dep $extra_inputs
  	\$($perlrun) $plfile $target $extra_inputs
  MAKE_FRAG
  
          }
      }
  
      return $m;
  }
  
  =item specify_shell
  
  Specify SHELL if needed - not done on Unix.
  
  =cut
  
  sub specify_shell {
    return '';
  }
  
  =item quote_paren
  
  Backslashes parentheses C<()> in command line arguments.
  Doesn't handle recursive Makefile C<$(...)> constructs,
  but handles simple ones.
  
  =cut
  
  sub quote_paren {
      my $arg = shift;
      $arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;	# protect $(...)
      $arg =~ s{(?<!\\)([()])}{\\$1}g;		# quote unprotected
      $arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;	# unprotect $(...)
      return $arg;
  }
  
  =item replace_manpage_separator
  
    my $man_name = $MM->replace_manpage_separator($file_path);
  
  Takes the name of a package, which may be a nested package, in the
  form 'Foo/Bar.pm' and replaces the slash with C<::> or something else
  safe for a man page file name.  Returns the replacement.
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
  
      $man =~ s,/+,::,g;
      return $man;
  }
  
  
  =item cd
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      # No leading tab and no trailing newline makes for easier embedding
      my $make_frag = join "\n\t", map { "cd $dir && $_" } @cmds;
  
      return $make_frag;
  }
  
  =item oneliner
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      my @cmds = split /\n/, $cmd;
      $cmd = join " \n\t  -e ", map $self->quote_literal($_), @cmds;
      $cmd = $self->escape_newlines($cmd);
  
      $switches = join ' ', @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd --};
  }
  
  
  =item quote_literal
  
  Quotes macro literal value suitable for being used on a command line so
  that when expanded by make, will be received by command as given to
  this method:
  
    my $quoted = $mm->quote_literal(q{it isn't});
    # returns:
    #   'it isn'\''t'
    print MAKEFILE "target:\n\techo $quoted\n";
    # when run "make target", will output:
    #   it isn't
  
  =cut
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # Quote single quotes
      $text =~ s{'}{'\\''}g;
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return "'$text'";
  }
  
  
  =item escape_newlines
  
  =cut
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      $text =~ s{\n}{\\\n}g;
  
      return $text;
  }
  
  
  =item max_exec_len
  
  Using POSIX::ARG_MAX.  Otherwise falling back to 4096.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      if (!defined $self->{_MAX_EXEC_LEN}) {
          if (my $arg_max = eval { require POSIX;  &POSIX::ARG_MAX }) {
              $self->{_MAX_EXEC_LEN} = $arg_max;
          }
          else {      # POSIX minimum exec size
              $self->{_MAX_EXEC_LEN} = 4096;
          }
      }
  
      return $self->{_MAX_EXEC_LEN};
  }
  
  
  =item static (o)
  
  Defines the static target.
  
  =cut
  
  sub static {
  # --- Static Loading Sections ---
  
      my($self) = shift;
      '
  ## $(INST_PM) has been moved to the all: target.
  ## It remains here for awhile to allow for old usage: "make static"
  static :: $(FIRST_MAKEFILE) $(INST_STATIC)
  	$(NOECHO) $(NOOP)
  ';
  }
  
  sub static_lib {
      my($self) = @_;
      return '' unless $self->has_link_code;
      my(@m);
      my @libs;
      if ($self->{XSMULTI}) {
  	for my $ext ($self->_xs_list_basenames) {
  	    my ($v, $d, $f) = File::Spec->splitpath($ext);
  	    my @d = File::Spec->splitdir($d);
  	    shift @d if $d[0] eq 'lib';
  	    my $instdir = $self->catdir('$(INST_ARCHLIB)', 'auto', @d, $f);
  	    my $instfile = $self->catfile($instdir, "$f\$(LIB_EXT)");
  	    my $objfile = "$ext\$(OBJ_EXT)";
  	    push @libs, [ $objfile, $instfile, $instdir ];
  	}
      } else {
  	@libs = ([ qw($(OBJECT) $(INST_STATIC) $(INST_ARCHAUTODIR)) ]);
      }
      push @m, map { $self->xs_make_static_lib(@$_); } @libs;
      join "\n", @m;
  }
  
  =item xs_make_static_lib
  
  Defines the recipes for the C<static_lib> section.
  
  =cut
  
  sub xs_make_static_lib {
      my ($self, $from, $to, $todir) = @_;
      my @m = sprintf '%s: %s $(MYEXTLIB) %s$(DFSEP).exists'."\n", $to, $from, $todir;
      push @m, "\t\$(RM_F) \"\$\@\"\n";
      push @m, $self->static_lib_fixtures;
      push @m, $self->static_lib_pure_cmd($from);
      push @m, "\t\$(CHMOD) \$(PERM_RWX) \$\@\n";
      push @m, $self->static_lib_closures($todir);
      join '', @m;
  }
  
  =item static_lib_closures
  
  Records C<$(EXTRALIBS)> in F<extralibs.ld> and F<$(PERL_SRC)/ext.libs>.
  
  =cut
  
  sub static_lib_closures {
      my ($self, $todir) = @_;
      my @m = sprintf <<'MAKE_FRAG', $todir;
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > %s$(DFSEP)extralibs.ld
  MAKE_FRAG
      # Old mechanism - still available:
      push @m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)$(DFSEP)ext.libs
  MAKE_FRAG
      @m;
  }
  
  =item static_lib_fixtures
  
  Handles copying C<$(MYEXTLIB)> as starter for final static library that
  then gets added to.
  
  =cut
  
  sub static_lib_fixtures {
      my ($self) = @_;
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      return unless $self->{MYEXTLIB};
      "\t\$(CP) \$(MYEXTLIB) \"\$\@\"\n";
  }
  
  =item static_lib_pure_cmd
  
  Defines how to run the archive utility.
  
  =cut
  
  sub static_lib_pure_cmd {
      my ($self, $from) = @_;
      my $ar;
      if (exists $self->{FULL_AR} && -x $self->{FULL_AR}) {
          # Prefer the absolute pathed ar if available so that PATH
          # doesn't confuse us.  Perl itself is built with the full_ar.
          $ar = 'FULL_AR';
      } else {
          $ar = 'AR';
      }
      sprintf <<'MAKE_FRAG', $ar, $from;
  	$(%s) $(AR_STATIC_ARGS) "$@" %s
  	$(RANLIB) "$@"
  MAKE_FRAG
  }
  
  =item staticmake (o)
  
  Calls makeaperl.
  
  =cut
  
  sub staticmake {
      my($self, %attribs) = @_;
      my(@static);
  
      my(@searchdirs)=($self->{PERL_ARCHLIB}, $self->{SITEARCHEXP},  $self->{INST_ARCHLIB});
  
      # And as it's not yet built, we add the current extension
      # but only if it has some C code (or XS code, which implies C code)
      if (@{$self->{C}}) {
  	@static = $self->catfile($self->{INST_ARCHLIB},
  				 "auto",
  				 $self->{FULLEXT},
  				 "$self->{BASEEXT}$self->{LIB_EXT}"
  				);
      }
  
      # Either we determine now, which libraries we will produce in the
      # subdirectories or we do it at runtime of the make.
  
      # We could ask all subdir objects, but I cannot imagine, why it
      # would be necessary.
  
      # Instead we determine all libraries for the new perl at
      # runtime.
      my(@perlinc) = ($self->{INST_ARCHLIB}, $self->{INST_LIB}, $self->{PERL_ARCHLIB}, $self->{PERL_LIB});
  
      $self->makeaperl(MAKE	=> $self->{MAKEFILE},
  		     DIRS	=> \@searchdirs,
  		     STAT	=> \@static,
  		     INCL	=> \@perlinc,
  		     TARGET	=> $self->{MAP_TARGET},
  		     TMP	=> "",
  		     LIBPERL	=> $self->{LIBPERL_A}
  		    );
  }
  
  =item subdir_x (o)
  
  Helper subroutine for subdirs
  
  =cut
  
  sub subdir_x {
      my($self, $subdir) = @_;
  
      my $subdir_cmd = $self->cd($subdir,
        '$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)'
      );
      return sprintf <<'EOT', $subdir_cmd;
  
  subdirs ::
  	$(NOECHO) %s
  EOT
  
  }
  
  =item subdirs (o)
  
  Defines targets to process subdirectories.
  
  =cut
  
  sub subdirs {
  # --- Sub-directory Sections ---
      my($self) = shift;
      my(@m);
      # This method provides a mechanism to automatically deal with
      # subdirectories containing further Makefile.PL scripts.
      # It calls the subdir_x() method for each subdirectory.
      foreach my $dir (@{$self->{DIR}}){
  	push @m, $self->subdir_x($dir);
  ####	print "Including $dir subdirectory\n";
      }
      if (@m){
  	unshift @m, <<'EOF';
  
  # The default clean, realclean and test targets in this Makefile
  # have automatically been given entries for each subdir.
  
  EOF
      } else {
  	push(@m, "\n# none")
      }
      join('',@m);
  }
  
  =item test (o)
  
  Defines the test targets.
  
  =cut
  
  sub test {
      my($self, %attribs) = @_;
      my $tests = $attribs{TESTS} || '';
      if (!$tests && -d 't' && defined $attribs{RECURSIVE_TEST_FILES}) {
          $tests = $self->find_tests_recursive;
      }
      elsif (!$tests && -d 't') {
          $tests = $self->find_tests;
      }
      # have to do this because nmake is broken
      $tests =~ s!/!\\!g if $self->is_make_type('nmake');
      # note: 'test.pl' name is also hardcoded in init_dirscan()
      my @m;
      my $default_testtype = $Config{usedl} ? 'dynamic' : 'static';
      push @m, <<EOF;
  TEST_VERBOSE=0
  TEST_TYPE=test_\$(LINKTYPE)
  TEST_FILE = test.pl
  TEST_FILES = $tests
  TESTDB_SW = -d
  
  testdb :: testdb_\$(LINKTYPE)
  	\$(NOECHO) \$(NOOP)
  
  test :: \$(TEST_TYPE)
  	\$(NOECHO) \$(NOOP)
  
  # Occasionally we may face this degenerate target:
  test_ : test_$default_testtype
  	\$(NOECHO) \$(NOOP)
  
  EOF
  
      for my $linktype (qw(dynamic static)) {
          my $directdeps = join ' ', grep !$self->{SKIPHASH}{$_}, $linktype, "pure_all"; # no depend on a linktype if SKIPped
          push @m, "subdirs-test_$linktype :: $directdeps\n";
          foreach my $dir (@{ $self->{DIR} }) {
              my $test = $self->cd($dir, "\$(MAKE) test_$linktype \$(PASTHRU)");
              push @m, "\t\$(NOECHO) $test\n";
          }
          push @m, "\n";
          if ($tests or -f "test.pl") {
              for my $testspec ([ '', '' ], [ 'db', ' $(TESTDB_SW)' ]) {
                  my ($db, $switch) = @$testspec;
                  my ($command, $deps);
                  # if testdb, build all but don't test all
                  $deps = $db eq 'db' ? $directdeps : "subdirs-test_$linktype";
                  if ($linktype eq 'static' and $self->needs_linking) {
                      my $target = File::Spec->rel2abs('$(MAP_TARGET)');
                      $command = qq{"$target" \$(MAP_PERLINC)};
                      $deps .= ' $(MAP_TARGET)';
                  } else {
                      $command = '$(FULLPERLRUN)' . $switch;
                  }
                  push @m, "test${db}_$linktype :: $deps\n";
                  if ($db eq 'db') {
                      push @m, $self->test_via_script($command, '$(TEST_FILE)')
                  } else {
                      push @m, $self->test_via_script($command, '$(TEST_FILE)')
                          if -f "test.pl";
                      push @m, $self->test_via_harness($command, '$(TEST_FILES)')
                          if $tests;
                  }
                  push @m, "\n";
              }
          } else {
              push @m, _sprintf562 <<'EOF', $linktype;
  testdb_%1$s test_%1$s :: subdirs-test_%1$s
  	$(NOECHO) $(ECHO) 'No tests defined for $(NAME) extension.'
  
  EOF
          }
      }
  
      join "", @m;
  }
  
  =item test_via_harness (override)
  
  For some reason which I forget, Unix machines like to have
  PERL_DL_NONLAZY set for tests.
  
  =cut
  
  sub test_via_harness {
      my($self, $perl, $tests) = @_;
      return $self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl", $tests);
  }
  
  =item test_via_script (override)
  
  Again, the PERL_DL_NONLAZY thing.
  
  =cut
  
  sub test_via_script {
      my($self, $perl, $script) = @_;
      return $self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl", $script);
  }
  
  
  =item tool_xsubpp (o)
  
  Determines typemaps, xsubpp version, prototype behaviour.
  
  =cut
  
  sub tool_xsubpp {
      my($self) = shift;
      return "" unless $self->needs_linking;
  
      my $xsdir;
      my @xsubpp_dirs = @INC;
  
      # Make sure we pick up the new xsubpp if we're building perl.
      unshift @xsubpp_dirs, $self->{PERL_LIB} if $self->{PERL_CORE};
  
      my $foundxsubpp = 0;
      foreach my $dir (@xsubpp_dirs) {
          $xsdir = $self->catdir($dir, 'ExtUtils');
          if( -r $self->catfile($xsdir, "xsubpp") ) {
              $foundxsubpp = 1;
              last;
          }
      }
      die "ExtUtils::MM_Unix::tool_xsubpp : Can't find xsubpp" if !$foundxsubpp;
  
      my $tmdir   = $self->catdir($self->{PERL_LIB},"ExtUtils");
      my(@tmdeps) = $self->catfile($tmdir,'typemap');
      if( $self->{TYPEMAPS} ){
          foreach my $typemap (@{$self->{TYPEMAPS}}){
              if( ! -f  $typemap ) {
                  warn "Typemap $typemap not found.\n";
              }
              else {
                  $typemap = vmsify($typemap) if $Is{VMS};
                  push(@tmdeps, $typemap);
              }
          }
      }
      push(@tmdeps, "typemap") if -f "typemap";
      # absolutised because with deep-located typemaps, eg "lib/XS/typemap",
      # if xsubpp is called from top level with
      #     $(XSUBPP) ... -typemap "lib/XS/typemap" "lib/XS/Test.xs"
      # it says:
      #     Can't find lib/XS/type map in (fulldir)/lib/XS
      # because ExtUtils::ParseXS::process_file chdir's to .xs file's
      # location. This is the only way to get all specified typemaps used,
      # wherever located.
      my @tmargs = map { '-typemap '.$self->quote_literal(File::Spec->rel2abs($_)) } @tmdeps;
      $_ = $self->quote_dep($_) for @tmdeps;
      if( exists $self->{XSOPT} ){
          unshift( @tmargs, $self->{XSOPT} );
      }
  
      if ($Is{VMS}                          &&
          $Config{'ldflags'}               &&
          $Config{'ldflags'} =~ m!/Debug!i &&
          (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)
         )
      {
          unshift(@tmargs,'-nolinenumbers');
      }
  
  
      $self->{XSPROTOARG} = "" unless defined $self->{XSPROTOARG};
      my $xsdirdep = $self->quote_dep($xsdir);
      # -dep for use when dependency not command
  
      return qq{
  XSUBPPDIR = $xsdir
  XSUBPP = "\$(XSUBPPDIR)\$(DFSEP)xsubpp"
  XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
  XSPROTOARG = $self->{XSPROTOARG}
  XSUBPPDEPS = @tmdeps $xsdirdep\$(DFSEP)xsubpp
  XSUBPPARGS = @tmargs
  XSUBPP_EXTRA_ARGS =
  };
  }
  
  
  =item all_target
  
  Build man pages, too
  
  =cut
  
  sub all_target {
      my $self = shift;
  
      return <<'MAKE_EXT';
  all :: pure_all manifypods
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  }
  
  =item top_targets (o)
  
  Defines the targets all, subdirs, config, and O_FILES
  
  =cut
  
  sub top_targets {
  # --- Target Sections ---
  
      my($self) = shift;
      my(@m);
  
      push @m, $self->all_target, "\n" unless $self->{SKIPHASH}{'all'};
  
      push @m, sprintf <<'EOF';
  pure_all :: config pm_to_blib subdirs linkext
  	$(NOECHO) $(NOOP)
  
  	$(NOECHO) $(NOOP)
  
  subdirs :: $(MYEXTLIB)
  	$(NOECHO) $(NOOP)
  
  config :: $(FIRST_MAKEFILE) blibdirs
  	$(NOECHO) $(NOOP)
  EOF
  
      push @m, '
  $(O_FILES) : $(H_FILES)
  ' if @{$self->{O_FILES} || []} && @{$self->{H} || []};
  
      push @m, q{
  help :
  	perldoc ExtUtils::MakeMaker
  };
  
      join('',@m);
  }
  
  =item writedoc
  
  Obsolete, deprecated method. Not used since Version 5.21.
  
  =cut
  
  sub writedoc {
  # --- perllocal.pod section ---
      my($self,$what,$name,@attribs)=@_;
      my $time = gmtime($ENV{SOURCE_DATE_EPOCH} || time);
      print "=head2 $time: $what C<$name>\n\n=over 4\n\n=item *\n\n";
      print join "\n\n=item *\n\n", map("C<$_>",@attribs);
      print "\n\n=back\n\n";
  }
  
  =item xs_c (o)
  
  Defines the suffix rules to compile XS files to C.
  
  =cut
  
  sub xs_c {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  ';
  }
  
  =item xs_cpp (o)
  
  Defines the suffix rules to compile XS files to C++.
  
  =cut
  
  sub xs_cpp {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.cpp
  ';
  }
  
  =item xs_o (o)
  
  Defines suffix rules to go from XS to object files directly. This was
  originally only intended for broken make implementations, but is now
  necessary for per-XS file under C<XSMULTI>, since each XS file might
  have an individual C<$(VERSION)>.
  
  =cut
  
  sub xs_o {
      my ($self) = @_;
      return '' unless $self->needs_linking();
      my $m_o = $self->{XSMULTI} ? $self->xs_obj_opt('$*$(OBJ_EXT)') : '';
      my $dbgout = $self->dbgoutflag;
      $dbgout = $dbgout ? "$dbgout " : '';
      my $frag = '';
      # dmake makes noise about ambiguous rule
      $frag .= sprintf <<'EOF', $dbgout, $m_o unless $self->is_make_type('dmake');
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) %s$*.c %s
  EOF
      if ($self->{XSMULTI}) {
  	for my $ext ($self->_xs_list_basenames) {
  	    my $pmfile = "$ext.pm";
  	    croak "$ext.xs has no matching $pmfile: $!" unless -f $pmfile;
  	    my $version = $self->parse_version($pmfile);
  	    my $cccmd = $self->{CONST_CCCMD};
  	    $cccmd =~ s/^\s*CCCMD\s*=\s*//;
  	    $cccmd =~ s/\$\(DEFINE_VERSION\)/-DVERSION=\\"$version\\"/;
  	    $cccmd =~ s/\$\(XS_DEFINE_VERSION\)/-DXS_VERSION=\\"$version\\"/;
              $self->_xsbuild_replace_macro($cccmd, 'xs', $ext, 'INC');
              my $define = '$(DEFINE)';
              $self->_xsbuild_replace_macro($define, 'xs', $ext, 'DEFINE');
              #                             1     2       3     4        5
              $frag .= _sprintf562 <<'EOF', $ext, $cccmd, $m_o, $define, $dbgout;
  
  %1$s$(OBJ_EXT): %1$s.xs
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  	%2$s $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) %4$s %5$s$*.c %3$s
  EOF
  	}
      }
      $frag =~ s/"-I(\$\(PERL_INC\))"/-iwithsysroot "$1"/sg if $Is{ApplCor};
      $frag;
  }
  
  # param gets modified
  sub _xsbuild_replace_macro {
      my ($self, undef, $xstype, $ext, $varname) = @_;
      my $value = $self->_xsbuild_value($xstype, $ext, $varname);
      return unless defined $value;
      $_[1] =~ s/\$\($varname\)/$value/;
  }
  
  sub _xsbuild_value {
      my ($self, $xstype, $ext, $varname) = @_;
      return $self->{XSBUILD}{$xstype}{$ext}{$varname}
          if $self->{XSBUILD}{$xstype}{$ext}{$varname};
      return $self->{XSBUILD}{$xstype}{all}{$varname}
          if $self->{XSBUILD}{$xstype}{all}{$varname};
      ();
  }
  
  1;
  
  =back
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  __END__
EXTUTILS_MM_UNIX

$fatpacked{"ExtUtils/MM_VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VMS';
  package ExtUtils::MM_VMS;
  
  use strict;
  
  use ExtUtils::MakeMaker::Config;
  require Exporter;
  
  BEGIN {
      # so we can compile the thing on non-VMS platforms.
      if( $^O eq 'VMS' ) {
          require VMS::Filespec;
          VMS::Filespec->import;
      }
  }
  
  use File::Basename;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  
  use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);
  our $Revision = $ExtUtils::MakeMaker::Revision;
  
  
  =head1 NAME
  
  ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
    Do not use this directly.
    Instead, use ExtUtils::MM and it will figure out which MM_*
    class to use for you.
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =head2 Methods always loaded
  
  =over 4
  
  =item wraplist
  
  Converts a list into a string wrapped at approximately 80 columns.
  
  =cut
  
  sub wraplist {
      my($self) = shift;
      my($line,$hlen) = ('',0);
  
      foreach my $word (@_) {
        # Perl bug -- seems to occasionally insert extra elements when
        # traversing array (scalar(@array) doesn't show them, but
        # foreach(@array) does) (5.00307)
        next unless $word =~ /\w/;
        $line .= ' ' if length($line);
        if ($hlen > 80) { $line .= "\\\n\t"; $hlen = 0; }
        $line .= $word;
        $hlen += length($word) + 2;
      }
      $line;
  }
  
  
  # This isn't really an override.  It's just here because ExtUtils::MM_VMS
  # appears in @MM::ISA before ExtUtils::Liblist::Kid, so if there isn't an ext()
  # in MM_VMS, then AUTOLOAD is called, and bad things happen.  So, we just
  # mimic inheritance here and hand off to ExtUtils::Liblist::Kid.
  # XXX This hackery will die soon. --Schwern
  sub ext {
      require ExtUtils::Liblist::Kid;
      goto &ExtUtils::Liblist::Kid::ext;
  }
  
  =back
  
  =head2 Methods
  
  Those methods which override default MM_Unix methods are marked
  "(override)", while methods unique to MM_VMS are marked "(specific)".
  For overridden methods, documentation is limited to an explanation
  of why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix
  documentation for more details.
  
  =over 4
  
  =item guess_name (override)
  
  Try to determine name of extension being built.  We begin with the name
  of the current directory.  Since VMS filenames are case-insensitive,
  however, we look for a F<.pm> file whose name matches that of the current
  directory (presumably the 'main' F<.pm> file for this extension), and try
  to find a C<package> statement from which to obtain the Mixed::Case
  package name.
  
  =cut
  
  sub guess_name {
      my($self) = @_;
      my($defname,$defpm,@pm,%xs);
      local *PM;
  
      $defname = basename(fileify($ENV{'DEFAULT'}));
      $defname =~ s![\d\-_]*\.dir.*$!!;  # Clip off .dir;1 suffix, and package version
      $defpm = $defname;
      # Fallback in case for some reason a user has copied the files for an
      # extension into a working directory whose name doesn't reflect the
      # extension's name.  We'll use the name of a unique .pm file, or the
      # first .pm file with a matching .xs file.
      if (not -e "${defpm}.pm") {
        @pm = glob('*.pm');
        s/.pm$// for @pm;
        if (@pm == 1) { ($defpm = $pm[0]) =~ s/.pm$//; }
        elsif (@pm) {
          %xs = map { s/.xs$//; ($_,1) } glob('*.xs');  ## no critic
          if (keys %xs) {
              foreach my $pm (@pm) {
                  $defpm = $pm, last if exists $xs{$pm};
              }
          }
        }
      }
      if (open(my $pm, '<', "${defpm}.pm")){
          while (<$pm>) {
              if (/^\s*package\s+([^;]+)/i) {
                  $defname = $1;
                  last;
              }
          }
          print "Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\n\t",
                       "defaulting package name to $defname\n"
              if eof($pm);
          close $pm;
      }
      else {
          print "Warning (non-fatal): Couldn't find ${defpm}.pm;\n\t",
                       "defaulting package name to $defname\n";
      }
      $defname =~ s#[\d.\-_]+$##;
      $defname;
  }
  
  =item find_perl (override)
  
  Use VMS file specification syntax and CLI commands to find and
  invoke Perl images.
  
  =cut
  
  sub find_perl {
      my($self, $ver, $names, $dirs, $trace) = @_;
      my($vmsfile,@sdirs,@snames,@cand);
      my($rslt);
      my($inabs) = 0;
      local *TCF;
  
      if( $self->{PERL_CORE} ) {
          # Check in relative directories first, so we pick up the current
          # version of Perl if we're running MakeMaker as part of the main build.
          @sdirs = sort { my($absa) = $self->file_name_is_absolute($a);
                          my($absb) = $self->file_name_is_absolute($b);
                          if ($absa && $absb) { return $a cmp $b }
                          else { return $absa ? 1 : ($absb ? -1 : ($a cmp $b)); }
                        } @$dirs;
          # Check miniperl before perl, and check names likely to contain
          # version numbers before "generic" names, so we pick up an
          # executable that's less likely to be from an old installation.
          @snames = sort { my($ba) = $a =~ m!([^:>\]/]+)$!;  # basename
                           my($bb) = $b =~ m!([^:>\]/]+)$!;
                           my($ahasdir) = (length($a) - length($ba) > 0);
                           my($bhasdir) = (length($b) - length($bb) > 0);
                           if    ($ahasdir and not $bhasdir) { return 1; }
                           elsif ($bhasdir and not $ahasdir) { return -1; }
                           else { $bb =~ /\d/ <=> $ba =~ /\d/
                                    or substr($ba,0,1) cmp substr($bb,0,1)
                                    or length($bb) <=> length($ba) } } @$names;
      }
      else {
          @sdirs  = @$dirs;
          @snames = @$names;
      }
  
      # Image names containing Perl version use '_' instead of '.' under VMS
      s/\.(\d+)$/_$1/ for @snames;
      if ($trace >= 2){
          print "Looking for perl $ver by these names:\n";
          print "\t@snames,\n";
          print "in these dirs:\n";
          print "\t@sdirs\n";
      }
      foreach my $dir (@sdirs){
          next unless defined $dir; # $self->{PERL_SRC} may be undefined
          $inabs++ if $self->file_name_is_absolute($dir);
          if ($inabs == 1) {
              # We've covered relative dirs; everything else is an absolute
              # dir (probably an installed location).  First, we'll try
              # potential command names, to see whether we can avoid a long
              # MCR expression.
              foreach my $name (@snames) {
                  push(@cand,$name) if $name =~ /^[\w\-\$]+$/;
              }
              $inabs++; # Should happen above in next $dir, but just in case...
          }
          foreach my $name (@snames){
              push @cand, ($name !~ m![/:>\]]!) ? $self->catfile($dir,$name)
                                                : $self->fixpath($name,0);
          }
      }
      foreach my $name (@cand) {
          print "Checking $name\n" if $trace >= 2;
          # If it looks like a potential command, try it without the MCR
          if ($name =~ /^[\w\-\$]+$/) {
              open(my $tcf, ">", "temp_mmvms.com")
                  or die('unable to open temp file');
              print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
              print $tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";
              close $tcf;
              $rslt = `\@temp_mmvms.com` ;
              unlink('temp_mmvms.com');
              if ($rslt =~ /VER_OK/) {
                  print "Using PERL=$name\n" if $trace;
                  return $name;
              }
          }
          next unless $vmsfile = $self->maybe_command($name);
          $vmsfile =~ s/;[\d\-]*$//;  # Clip off version number; we can use a newer version as well
          print "Executing $vmsfile\n" if ($trace >= 2);
          open(my $tcf, '>', "temp_mmvms.com")
                  or die('unable to open temp file');
          print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
          print $tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";
          close $tcf;
          $rslt = `\@temp_mmvms.com`;
          unlink('temp_mmvms.com');
          if ($rslt =~ /VER_OK/) {
              print "Using PERL=MCR $vmsfile\n" if $trace;
              return "MCR $vmsfile";
          }
      }
      print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";
      0; # false and not empty
  }
  
  =item _fixin_replace_shebang (override)
  
  Helper routine for MM->fixin(), overridden because there's no such thing as an
  actual shebang line that will be interpreted by the shell, so we just prepend
  $Config{startperl} and preserve the shebang line argument for any switches it
  may contain.
  
  =cut
  
  sub _fixin_replace_shebang {
      my ( $self, $file, $line ) = @_;
  
      my ( undef, $arg ) = split ' ', $line, 2;
  
      return $Config{startperl} . "\n" . $Config{sharpbang} . "perl $arg\n";
  }
  
  =item maybe_command (override)
  
  Follows VMS naming conventions for executable files.
  If the name passed in doesn't exactly match an executable file,
  appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
  to check for DCL procedure.  If this fails, checks directories in DCL$PATH
  and finally F<Sys$System:> for an executable file having the name specified,
  with or without the F<.Exe>-equivalent suffix.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d _;
      my(@dirs) = ('');
      my(@exts) = ('',$Config{'exe_ext'},'.exe','.com');
  
      if ($file !~ m![/:>\]]!) {
          for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
              my $dir = $ENV{"DCL\$PATH;$i"};
              $dir .= ':' unless $dir =~ m%[\]:]$%;
              push(@dirs,$dir);
          }
          push(@dirs,'Sys$System:');
          foreach my $dir (@dirs) {
              my $sysfile = "$dir$file";
              foreach my $ext (@exts) {
                  return $file if -x "$sysfile$ext" && ! -d _;
              }
          }
      }
      return 0;
  }
  
  
  =item pasthru (override)
  
  The list of macro definitions to be passed through must be specified using
  the /MACRO qualifier and must not add another /DEFINE qualifier.  We prepend
  our own comma here to the contents of $(PASTHRU_DEFINE) because it is often
  empty and a comma always present in CCFLAGS would generate a missing
  qualifier value error.
  
  =cut
  
  sub pasthru {
      my($self) = shift;
      my $pasthru = $self->SUPER::pasthru;
      $pasthru =~ s|(PASTHRU\s*=\s*)|$1/MACRO=(|;
      $pasthru =~ s|\n\z|)\n|m;
      $pasthru =~ s|/defi?n?e?=\(?([^\),]+)\)?|,$1|ig;
  
      return $pasthru;
  }
  
  
  =item pm_to_blib (override)
  
  VMS wants a dot in every file so we can't have one called 'pm_to_blib',
  it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when
  you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.
  
  So in VMS its pm_to_blib.ts.
  
  =cut
  
  sub pm_to_blib {
      my $self = shift;
  
      my $make = $self->SUPER::pm_to_blib;
  
      $make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;
      $make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};
  
      $make = <<'MAKE' . $make;
  # Dummy target to match Unix target name; we use pm_to_blib.ts as
  # timestamp file to avoid repeated invocations under VMS
  pm_to_blib : pm_to_blib.ts
  	$(NOECHO) $(NOOP)
  
  MAKE
  
      return $make;
  }
  
  
  =item perl_script (override)
  
  If name passed in doesn't specify a readable file, appends F<.com> or
  F<.pl> and tries again, since it's customary to have file types on all files
  under VMS.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && ! -d _;
      return "$file.com" if -r "$file.com";
      return "$file.pl" if -r "$file.pl";
      return '';
  }
  
  
  =item replace_manpage_separator
  
  Use as separator a character which is legal in a VMS-syntax file name.
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man = unixify($man);
      $man =~ s#/+#__#g;
      $man;
  }
  
  =item init_DEST
  
  (override) Because of the difficulty concatenating VMS filepaths we
  must pre-expand the DEST* variables.
  
  =cut
  
  sub init_DEST {
      my $self = shift;
  
      $self->SUPER::init_DEST;
  
      # Expand DEST variables.
      foreach my $var ($self->installvars) {
          my $destvar = 'DESTINSTALL'.$var;
          $self->{$destvar} = $self->eliminate_macros($self->{$destvar});
      }
  }
  
  
  =item init_DIRFILESEP
  
  No separator between a directory path and a filename on VMS.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      $self->{DIRFILESEP} = '';
      return 1;
  }
  
  
  =item init_main (override)
  
  
  =cut
  
  sub init_main {
      my($self) = shift;
  
      $self->SUPER::init_main;
  
      $self->{DEFINE} ||= '';
      if ($self->{DEFINE} ne '') {
          my(@terms) = split(/\s+/,$self->{DEFINE});
          my(@defs,@udefs);
          foreach my $def (@terms) {
              next unless $def;
              my $targ = \@defs;
              if ($def =~ s/^-([DU])//) {    # If it was a Unix-style definition
                  $targ = \@udefs if $1 eq 'U';
                  $def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''
                  $def =~ s/^'(.*)'$/$1/;   # from entire term or argument
              }
              if ($def =~ /=/) {
                  $def =~ s/"/""/g;  # Protect existing " from DCL
                  $def = qq["$def"]; # and quote to prevent parsing of =
              }
              push @$targ, $def;
          }
  
          $self->{DEFINE} = '';
          if (@defs)  {
              $self->{DEFINE}  = '/Define=(' . join(',',@defs)  . ')';
          }
          if (@udefs) {
              $self->{DEFINE} .= '/Undef=('  . join(',',@udefs) . ')';
          }
      }
  }
  
  =item init_tools (override)
  
  Provide VMS-specific forms of various utility commands.
  
  Sets DEV_NULL to nothing because I don't know how to do it on VMS.
  
  Changes EQUALIZE_TIMESTAMP to set revision date of target file to
  one second later than source file, since MMK interprets precisely
  equal revision dates for a source and target file as a sign that the
  target needs to be updated.
  
  =cut
  
  sub init_tools {
      my($self) = @_;
  
      $self->{NOOP}               = 'Continue';
      $self->{NOECHO}             ||= '@ ';
  
      $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';
      $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};
      $self->{MAKE_APERL_FILE}    ||= 'Makeaperl.MMS';
      $self->{MAKEFILE_OLD}       ||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');
  #
  #   If an extension is not specified, then MMS/MMK assumes an
  #   an extension of .MMS.  If there really is no extension,
  #   then a trailing "." needs to be appended to specify a
  #   a null extension.
  #
      $self->{MAKEFILE} .= '.' unless $self->{MAKEFILE} =~ m/\./;
      $self->{FIRST_MAKEFILE} .= '.' unless $self->{FIRST_MAKEFILE} =~ m/\./;
      $self->{MAKE_APERL_FILE} .= '.' unless $self->{MAKE_APERL_FILE} =~ m/\./;
      $self->{MAKEFILE_OLD} .= '.' unless $self->{MAKEFILE_OLD} =~ m/\./;
  
      $self->{MACROSTART}         ||= '/Macro=(';
      $self->{MACROEND}           ||= ')';
      $self->{USEMAKEFILE}        ||= '/Descrip=';
  
      $self->{EQUALIZE_TIMESTAMP} ||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';
  
      $self->{MOD_INSTALL} ||=
        $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
  install([ from_to => {split('\|', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  
      $self->{UMASK_NULL} = '! ';
  
      $self->SUPER::init_tools;
  
      # Use the default shell
      $self->{SHELL}    ||= 'Posix';
  
      # Redirection on VMS goes before the command, not after as on Unix.
      # $(DEV_NULL) is used once and its not worth going nuts over making
      # it work.  However, Unix's DEV_NULL is quite wrong for VMS.
      $self->{DEV_NULL}   = '';
  
      return;
  }
  
  =item init_platform (override)
  
  Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.
  
  MM_VMS_REVISION is for backwards compatibility before MM_VMS had a
  $VERSION.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_VMS_REVISION} = $Revision;
      $self->{MM_VMS_VERSION}  = $VERSION;
      $self->{PERL_VMS} = $self->catdir($self->{PERL_SRC}, 'VMS')
        if $self->{PERL_SRC};
  }
  
  
  =item platform_constants
  
  =cut
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item init_VERSION (override)
  
  Override the *DEFINE_VERSION macros with VMS semantics.  Translate the
  MAKEMAKER filepath to VMS style.
  
  =cut
  
  sub init_VERSION {
      my $self = shift;
  
      $self->SUPER::init_VERSION;
  
      $self->{DEFINE_VERSION}    = '"$(VERSION_MACRO)=""$(VERSION)"""';
      $self->{XS_DEFINE_VERSION} = '"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';
      $self->{MAKEMAKER} = vmsify($INC{'ExtUtils/MakeMaker.pm'});
  }
  
  
  =item constants (override)
  
  Fixes up numerous file and directory macros to insure VMS syntax
  regardless of input syntax.  Also makes lists of files
  comma-separated.
  
  =cut
  
  sub constants {
      my($self) = @_;
  
      # Be kind about case for pollution
      for (@ARGV) { $_ = uc($_) if /POLLUTE/i; }
  
      # Cleanup paths for directories in MMS macros.
      foreach my $macro ( qw [
              INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB
              PERL_LIB PERL_ARCHLIB PERL_ARCHLIBDEP
              PERL_INC PERL_SRC ],
                          (map { 'INSTALL'.$_ } $self->installvars),
                          (map { 'DESTINSTALL'.$_ } $self->installvars)
                        )
      {
          next unless defined $self->{$macro};
          next if $macro =~ /MAN/ && $self->{$macro} eq 'none';
          $self->{$macro} = $self->fixpath($self->{$macro},1);
      }
  
      # Cleanup paths for files in MMS macros.
      foreach my $macro ( qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD
                             MAKE_APERL_FILE MYEXTLIB] )
      {
          next unless defined $self->{$macro};
          $self->{$macro} = $self->fixpath($self->{$macro},0);
      }
  
      # Fixup files for MMS macros
      # XXX is this list complete?
      for my $macro (qw/
                     FULLEXT VERSION_FROM
  	      /	) {
          next unless defined $self->{$macro};
          $self->{$macro} = $self->fixpath($self->{$macro},0);
      }
  
  
      for my $macro (qw/
                     OBJECT LDFROM
  	      /	) {
          next unless defined $self->{$macro};
  
          # Must expand macros before splitting on unescaped whitespace.
          $self->{$macro} = $self->eliminate_macros($self->{$macro});
          if ($self->{$macro} =~ /(?<!\^)\s/) {
              $self->{$macro} =~ s/(\\)?\n+\s+/ /g;
              $self->{$macro} = $self->wraplist(
                  map $self->fixpath($_,0), split /,?(?<!\^)\s+/, $self->{$macro}
              );
          }
          else {
              $self->{$macro} = $self->fixpath($self->{$macro},0);
          }
      }
  
      for my $macro (qw/ XS MAN1PODS MAN3PODS PM /) {
          # Where is the space coming from? --jhi
          next unless $self ne " " && defined $self->{$macro};
          my %tmp = ();
          for my $key (keys %{$self->{$macro}}) {
              $tmp{$self->fixpath($key,0)} =
                                       $self->fixpath($self->{$macro}{$key},0);
          }
          $self->{$macro} = \%tmp;
      }
  
      for my $macro (qw/ C O_FILES H /) {
          next unless defined $self->{$macro};
          my @tmp = ();
          for my $val (@{$self->{$macro}}) {
              push(@tmp,$self->fixpath($val,0));
          }
          $self->{$macro} = \@tmp;
      }
  
      # mms/k does not define a $(MAKE) macro.
      $self->{MAKE} = '$(MMS)$(MMSQUALIFIERS)';
  
      return $self->SUPER::constants;
  }
  
  
  =item special_targets
  
  Clear the default .SUFFIXES and put in our own list.
  
  =cut
  
  sub special_targets {
      my $self = shift;
  
      my $make_frag .= <<'MAKE_FRAG';
  .SUFFIXES :
  .SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs
  
  MAKE_FRAG
  
      return $make_frag;
  }
  
  =item cflags (override)
  
  Bypass shell script and produce qualifiers for CC directly (but warn
  user if a shell script for this extension exists).  Fold multiple
  /Defines into one, since some C compilers pay attention to only one
  instance of this qualifier on the command line.
  
  =cut
  
  sub cflags {
      my($self,$libperl) = @_;
      my($quals) = $self->{CCFLAGS} || $Config{'ccflags'};
      my($definestr,$undefstr,$flagoptstr) = ('','','');
      my($incstr) = '/Include=($(PERL_INC)';
      my($name,$sys,@m);
  
      ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
      print "Unix shell script ".$Config{"$self->{'BASEEXT'}_cflags"}.
           " required to modify CC command for $self->{'BASEEXT'}\n"
      if ($Config{$name});
  
      if ($quals =~ / -[DIUOg]/) {
  	while ($quals =~ / -([Og])(\d*)\b/) {
  	    my($type,$lvl) = ($1,$2);
  	    $quals =~ s/ -$type$lvl\b\s*//;
  	    if ($type eq 'g') { $flagoptstr = '/NoOptimize'; }
  	    else { $flagoptstr = '/Optimize' . (defined($lvl) ? "=$lvl" : ''); }
  	}
  	while ($quals =~ / -([DIU])(\S+)/) {
  	    my($type,$def) = ($1,$2);
  	    $quals =~ s/ -$type$def\s*//;
  	    $def =~ s/"/""/g;
  	    if    ($type eq 'D') { $definestr .= qq["$def",]; }
  	    elsif ($type eq 'I') { $incstr .= ',' . $self->fixpath($def,1); }
  	    else                 { $undefstr  .= qq["$def",]; }
  	}
      }
      if (length $quals and $quals !~ m!/!) {
  	warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";
  	$quals = '';
      }
      $definestr .= q["PERL_POLLUTE",] if $self->{POLLUTE};
      if (length $definestr) { chop($definestr); $quals .= "/Define=($definestr)"; }
      if (length $undefstr)  { chop($undefstr);  $quals .= "/Undef=($undefstr)";   }
      # Deal with $self->{DEFINE} here since some C compilers pay attention
      # to only one /Define clause on command line, so we have to
      # conflate the ones from $Config{'ccflags'} and $self->{DEFINE}
      # ($self->{DEFINE} has already been VMSified in constants() above)
      if ($self->{DEFINE}) { $quals .= $self->{DEFINE}; }
      for my $type (qw(Def Undef)) {
  	my(@terms);
  	while ($quals =~ m:/${type}i?n?e?=([^/]+):ig) {
  		my $term = $1;
  		$term =~ s:^\((.+)\)$:$1:;
  		push @terms, $term;
  	}
  	if ($type eq 'Def') {
  	    push @terms, qw[ $(DEFINE_VERSION) $(XS_DEFINE_VERSION) ];
  	}
  	if (@terms) {
  	    $quals =~ s:/${type}i?n?e?=[^/]+::ig;
              # PASTHRU_DEFINE will have its own comma
  	    $quals .= "/${type}ine=(" . join(',',@terms) . ($type eq 'Def' ? '$(PASTHRU_DEFINE)' : '') . ')';
  	}
      }
  
      $libperl or $libperl = $self->{LIBPERL_A} || "libperl.olb";
  
      # Likewise with $self->{INC} and /Include
      if ($self->{'INC'}) {
  	my(@includes) = split(/\s+/,$self->{INC});
  	foreach (@includes) {
  	    s/^-I//;
  	    $incstr .= ','.$self->fixpath($_,1);
  	}
      }
      $quals .= "$incstr)";
  #    $quals =~ s/,,/,/g; $quals =~ s/\(,/(/g;
      $self->{CCFLAGS} = $quals;
  
      $self->{PERLTYPE} ||= '';
  
      $self->{OPTIMIZE} ||= $flagoptstr || $Config{'optimize'};
      if ($self->{OPTIMIZE} !~ m!/!) {
  	if    ($self->{OPTIMIZE} =~ m!-g!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }
  	elsif ($self->{OPTIMIZE} =~ /-O(\d*)/) {
  	    $self->{OPTIMIZE} = '/Optimize' . (defined($1) ? "=$1" : '');
  	}
  	else {
  	    warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length $self->{OPTIMIZE};
  	    $self->{OPTIMIZE} = '/Optimize';
  	}
      }
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  }
  
  =item const_cccmd (override)
  
  Adds directives to point C preprocessor to the right place when
  handling #include E<lt>sys/foo.hE<gt> directives.  Also constructs CC
  command line a bit differently than MM_Unix method.
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl) = @_;
      my(@m);
  
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      if ($Config{'vms_cc_type'} eq 'gcc') {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" Then Define/NoLog SYS GNU_CC_Include:[VMS]';
      }
      elsif ($Config{'vms_cc_type'} eq 'vaxc') {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").eqs."" Then Define/NoLog SYS Sys$Library
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").nes."" Then Define/NoLog SYS VAXC$Include';
      }
      else {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").eqs."" Then Define/NoLog SYS ',
  		($Config{'archname'} eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").nes."" Then Define/NoLog SYS DECC$System_Include';
      }
  
      push(@m, "\n\nCCCMD = $Config{'cc'} \$(CCFLAGS)\$(OPTIMIZE)\n");
  
      $self->{CONST_CCCMD} = join('',@m);
  }
  
  
  =item tools_other (override)
  
  Throw in some dubious extra macros for Makefile args.
  
  Also keep around the old $(SAY) macro in case somebody's using it.
  
  =cut
  
  sub tools_other {
      my($self) = @_;
  
      # XXX Are these necessary?  Does anyone override them?  They're longer
      # than just typing the literal string.
      my $extra_tools = <<'EXTRA_TOOLS';
  
  # Just in case anyone is using the old macro.
  USEMACROS = $(MACROSTART)
  SAY = $(ECHO)
  
  EXTRA_TOOLS
  
      return $self->SUPER::tools_other . $extra_tools;
  }
  
  =item init_dist (override)
  
  VMSish defaults for some values.
  
    macro         description                     default
  
    ZIPFLAGS      flags to pass to ZIP            -Vu
  
    COMPRESS      compression command to          gzip
                  use for tarfiles
    SUFFIX        suffix to put on                -gz
                  compressed files
  
    SHAR          shar command to use             vms_share
  
    DIST_DEFAULT  default target to use to        tardist
                  create a distribution
  
    DISTVNAME     Use VERSION_SYM instead of      $(DISTNAME)-$(VERSION_SYM)
                  VERSION for the name
  
  =cut
  
  sub init_dist {
      my($self) = @_;
      $self->{ZIPFLAGS}     ||= '-Vu';
      $self->{COMPRESS}     ||= 'gzip';
      $self->{SUFFIX}       ||= '-gz';
      $self->{SHAR}         ||= 'vms_share';
      $self->{DIST_DEFAULT} ||= 'zipdist';
  
      $self->SUPER::init_dist;
  
      $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION_SYM}"
        unless $self->{ARGS}{DISTVNAME};
  
      return;
  }
  
  =item c_o (override)
  
  Use VMS syntax on command line.  In particular, $(DEFINE) and
  $(PERL_INC) have been pulled into $(CCCMD).  Also use MM[SK] macros.
  
  =cut
  
  sub c_o {
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .c$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  .cpp$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  .cxx$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  ';
  }
  
  =item xs_c (override)
  
  Use MM[SK] macros.
  
  =cut
  
  sub xs_c {
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .xs.c :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  ';
  }
  
  =item xs_o (override)
  
  Use MM[SK] macros, and VMS command line for C compiler.
  
  =cut
  
  sub xs_o {
      my ($self) = @_;
      return '' unless $self->needs_linking();
      my $frag = '
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  ';
      if ($self->{XSMULTI}) {
  	for my $ext ($self->_xs_list_basenames) {
  	    my $version = $self->parse_version("$ext.pm");
  	    my $ccflags = $self->{CCFLAGS};
  	    $ccflags =~ s/\$\(DEFINE_VERSION\)/\"VERSION_MACRO=\\"\"$version\\"\"/;
  	    $ccflags =~ s/\$\(XS_DEFINE_VERSION\)/\"XS_VERSION_MACRO=\\"\"$version\\"\"/;
  	    $self->_xsbuild_replace_macro($ccflags, 'xs', $ext, 'INC');
  	    $self->_xsbuild_replace_macro($ccflags, 'xs', $ext, 'DEFINE');
  
  	    $frag .= _sprintf562 <<'EOF', $ext, $ccflags;
  
  %1$s$(OBJ_EXT) : %1$s.xs
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs > $(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  	$(CC)%2$s$(OPTIMIZE) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  EOF
  	}
      }
      $frag;
  }
  
  =item _xsbuild_replace_macro (override)
  
  There is no simple replacement possible since a qualifier and all its
  subqualifiers must be considered together, so we use our own utility
  routine for the replacement.
  
  =cut
  
  sub _xsbuild_replace_macro {
      my ($self, undef, $xstype, $ext, $varname) = @_;
      my $value = $self->_xsbuild_value($xstype, $ext, $varname);
      return unless defined $value;
      $_[1] = _vms_replace_qualifier($self, $_[1], $value, $varname);
  }
  
  =item _xsbuild_value (override)
  
  Convert the extension spec to Unix format, as that's what will
  match what's in the XSBUILD data structure.
  
  =cut
  
  sub _xsbuild_value {
      my ($self, $xstype, $ext, $varname) = @_;
      $ext = unixify($ext);
      return $self->SUPER::_xsbuild_value($xstype, $ext, $varname);
  }
  
  sub _vms_replace_qualifier {
      my ($self, $flags, $newflag, $macro) = @_;
      my $qual_type;
      my $type_suffix;
      my $quote_subquals = 0;
      my @subquals_new = split /\s+/, $newflag;
  
      if ($macro eq 'DEFINE') {
          $qual_type = 'Def';
          $type_suffix = 'ine';
          map { $_ =~ s/^-D// } @subquals_new;
          $quote_subquals = 1;
      }
      elsif ($macro eq 'INC') {
          $qual_type = 'Inc';
          $type_suffix = 'lude';
          map { $_ =~ s/^-I//; $_ = $self->fixpath($_) } @subquals_new;
      }
  
      my @subquals = ();
      while ($flags =~ m:/${qual_type}\S{0,4}=([^/]+):ig) {
          my $term = $1;
          $term =~ s/\"//g;
          $term =~ s:^\((.+)\)$:$1:;
          push @subquals, split /,/, $term;
      }
      for my $new (@subquals_new) {
          my ($sq_new, $sqval_new) = split /=/, $new;
          my $replaced_old = 0;
          for my $old (@subquals) {
              my ($sq, $sqval) = split /=/, $old;
              if ($sq_new eq $sq) {
                  $old = $sq_new;
                  $old .= '=' . $sqval_new if defined($sqval_new) and length($sqval_new);
                  $replaced_old = 1;
                  last;
              }
          }
          push @subquals, $new unless $replaced_old;
      }
  
      if (@subquals) {
          $flags =~ s:/${qual_type}\S{0,4}=[^/]+::ig;
          # add quotes if requested but not for unexpanded macros
          map { $_ = qq/"$_"/ if $_ !~ m/^\$\(/ } @subquals if $quote_subquals;
          $flags .= "/${qual_type}$type_suffix=(" . join(',',@subquals) . ')';
      }
  
      return $flags;
  }
  
  
  sub xs_dlsyms_ext {
      '.opt';
  }
  
  =item dlsyms (override)
  
  Create VMS linker options files specifying universal symbols for this
  extension's shareable image(s), and listing other shareable images or
  libraries to which it should be linked.
  
  =cut
  
  sub dlsyms {
      my ($self, %attribs) = @_;
      return '' unless $self->needs_linking;
      $self->xs_dlsyms_iterator;
  }
  
  sub xs_make_dlsyms {
      my ($self, $attribs, $target, $dep, $name, $dlbase, $funcs, $funclist, $imports, $vars, $extra) = @_;
      my @m;
      my $instloc;
      if ($self->{XSMULTI}) {
  	my ($v, $d, $f) = File::Spec->splitpath($target);
  	my @d = File::Spec->splitdir($d);
  	shift @d if $d[0] eq 'lib';
  	$instloc = $self->catfile('$(INST_ARCHLIB)', 'auto', @d, $f);
  	push @m,"\ndynamic :: $instloc\n\t\$(NOECHO) \$(NOOP)\n"
  	  unless $self->{SKIPHASH}{'dynamic'};
  	push @m,"\nstatic :: $instloc\n\t\$(NOECHO) \$(NOOP)\n"
  	  unless $self->{SKIPHASH}{'static'};
  	push @m, "\n", sprintf <<'EOF', $instloc, $target;
  %s : %s
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  EOF
      }
      else {
  	push @m,"\ndynamic :: \$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\n\t\$(NOECHO) \$(NOOP)\n"
  	  unless $self->{SKIPHASH}{'dynamic'};
  	push @m,"\nstatic :: \$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\n\t\$(NOECHO) \$(NOOP)\n"
  	  unless $self->{SKIPHASH}{'static'};
  	push @m, "\n", sprintf <<'EOF', $target;
  $(INST_ARCHAUTODIR)$(BASEEXT).opt : %s
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  EOF
      }
      push @m,
       "\n$target : $dep\n\t",
       q!$(PERLRUN) -MExtUtils::Mksymlists -e "Mksymlists('NAME'=>'!, $name,
       q!', 'DLBASE' => '!,$dlbase,
       q!', 'DL_FUNCS' => !,neatvalue($funcs),
       q!, 'FUNCLIST' => !,neatvalue($funclist),
       q!, 'IMPORTS' => !,neatvalue($imports),
       q!, 'DL_VARS' => !, neatvalue($vars);
      push @m, $extra if defined $extra;
      push @m, qq!);"\n\t!;
      # Can't use dlbase as it's been through mod2fname.
      my $olb_base = basename($target, '.opt');
      if ($self->{XSMULTI}) {
          # We've been passed everything but the kitchen sink -- and the location of the
          # static library we're using to build the dynamic library -- so concoct that
          # location from what we do have.
          my $olb_dir = $self->catdir(dirname($instloc), $olb_base);
          push @m, qq!\$(PERL) -e "print ""${olb_dir}${olb_base}\$(LIB_EXT)/Include=!;
          push @m, ($Config{d_vms_case_sensitive_symbols} ? uc($olb_base) : $olb_base);
          push @m, '\n' . $olb_dir . $olb_base . '$(LIB_EXT)/Library\n"";" >>$(MMS$TARGET)',"\n";
      }
      else {
          push @m, qq!\$(PERL) -e "print ""\$(INST_ARCHAUTODIR)${olb_base}\$(LIB_EXT)/Include=!;
          if ($self->{OBJECT} =~ /\bBASEEXT\b/ or
              $self->{OBJECT} =~ /\b$self->{BASEEXT}\b/i) {
              push @m, ($Config{d_vms_case_sensitive_symbols}
  	              ? uc($self->{BASEEXT}) :'$(BASEEXT)');
          }
          else {  # We don't have a "main" object file, so pull 'em all in
              # Upcase module names if linker is being case-sensitive
              my($upcase) = $Config{d_vms_case_sensitive_symbols};
              my(@omods) = split ' ', $self->eliminate_macros($self->{OBJECT});
              for (@omods) {
                  s/\.[^.]*$//;         # Trim off file type
                  s[\$\(\w+_EXT\)][];   # even as a macro
                  s/.*[:>\/\]]//;       # Trim off dir spec
                  $_ = uc if $upcase;
              };
              my(@lines);
              my $tmp = shift @omods;
              foreach my $elt (@omods) {
                  $tmp .= ",$elt";
                  if (length($tmp) > 80) { push @lines, $tmp;  $tmp = ''; }
              }
              push @lines, $tmp;
              push @m, '(', join( qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""], @lines),')';
          }
          push @m, '\n$(INST_ARCHAUTODIR)' . $olb_base . '$(LIB_EXT)/Library\n"";" >>$(MMS$TARGET)',"\n";
      }
      if (length $self->{LDLOADLIBS}) {
          my($line) = '';
          foreach my $lib (split ' ', $self->{LDLOADLIBS}) {
              $lib =~ s%\$%\\\$%g;  # Escape '$' in VMS filespecs
              if (length($line) + length($lib) > 160) {
                  push @m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";
                  $line = $lib . '\n';
              }
              else { $line .= $lib . '\n'; }
          }
          push @m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if $line;
      }
      join '', @m;
  }
  
  
  =item xs_obj_opt
  
  Override to fixup -o flags.
  
  =cut
  
  sub xs_obj_opt {
      my ($self, $output_file) = @_;
      "/OBJECT=$output_file";
  }
  
  =item dynamic_lib (override)
  
  Use VMS Link command.
  
  =cut
  
  sub xs_dynamic_lib_macros {
      my ($self, $attribs) = @_;
      my $otherldflags = $attribs->{OTHERLDFLAGS} || "";
      my $inst_dynamic_dep = $attribs->{INST_DYNAMIC_DEP} || "";
      sprintf <<'EOF', $otherldflags, $inst_dynamic_dep;
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  EOF
  }
  
  sub xs_make_dynamic_lib {
      my ($self, $attribs, $from, $to, $todir, $ldfrom, $exportlist) = @_;
      my $shr = $Config{'dbgprefix'} . 'PerlShr';
      $exportlist =~ s/.def$/.opt/;  # it's a linker options file
      #                    1    2       3            4     5
      _sprintf562 <<'EOF', $to, $todir, $exportlist, $shr, "$shr Sys\$Share:$shr.$Config{'dlext'}";
  %1$s : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt %2$s$(DFSEP).exists %3$s $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  	If F$TrnLNm("%4$s").eqs."" Then Define/NoLog/User %5$s
  	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) %3$s/Option,$(PERL_INC)perlshr_attr.opt/Option
  EOF
  }
  
  =item xs_make_static_lib (override)
  
  Use VMS commands to manipulate object library.
  
  =cut
  
  sub xs_make_static_lib {
      my ($self, $object, $to, $todir) = @_;
  
      my @objects;
      if ($self->{XSMULTI}) {
          # The extension name should be the main object file name minus file type.
          my $lib = $object;
          $lib =~ s/\$\(OBJ_EXT\)\z//;
          my $override = $self->_xsbuild_value('xs', $lib, 'OBJECT');
          $object = $override if defined $override;
          @objects = map { $self->fixpath($_,0) } split /(?<!\^)\s+/, $object;
      }
      else {
          push @objects, $object;
      }
  
      my @m;
      for my $obj (@objects) {
          push(@m, sprintf "\n%s : %s\$(DFSEP).exists", $obj, $todir);
      }
      push(@m, sprintf "\n\n%s : %s \$(MYEXTLIB)\n", $to, (join ' ', @objects));
  
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      push(@m, "\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n") if $self->{MYEXTLIB};
  
      push(@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");
  
      # if there was a library to copy, then we can't use MMS$SOURCE_LIST,
      # 'cause it's a library and you can't stick them in other libraries.
      # In that case, we use $OBJECT instead and hope for the best
      if ($self->{MYEXTLIB}) {
          for my $obj (@objects) {
              push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) ' . $obj,"\n");
          }
      }
      else {
        push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n");
      }
  
      push @m, "\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";
      foreach my $lib (split ' ', $self->{EXTRALIBS}) {
        push(@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n");
      }
      join('',@m);
  }
  
  
  =item static_lib_pure_cmd (override)
  
  Use VMS commands to manipulate object library.
  
  =cut
  
  sub static_lib_pure_cmd {
      my ($self, $from) = @_;
  
      sprintf <<'MAKE_FRAG', $from;
  	If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)
  	Library/Object/Replace $(MMS$TARGET) %s
  MAKE_FRAG
  }
  
  =item xs_static_lib_is_xs
  
  =cut
  
  sub xs_static_lib_is_xs {
      return 1;
  }
  
  =item extra_clean_files
  
  Clean up some OS specific files.  Plus the temp file used to shorten
  a lot of commands.  And the name mangler database.
  
  =cut
  
  sub extra_clean_files {
      return qw(
                *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso
                .MM_Tmp cxx_repository
               );
  }
  
  
  =item zipfile_target
  
  =item tarfile_target
  
  =item shdist_target
  
  Syntax for invoking shar, tar and zip differs from that for Unix.
  
  =cut
  
  sub zipfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  }
  
  sub tarfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(POSTOP)
  MAKE_FRAG
  }
  
  sub shdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  shdist : distdir
  	$(PREOP)
  	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  }
  
  
  # --- Test and Installation Sections ---
  
  =item install (override)
  
  Work around DCL's 255 character limit several times,and use
  VMS-style command line quoting in a few cases.
  
  =cut
  
  sub install {
      my($self, %attribs) = @_;
      my(@m);
  
      push @m, q[
  install :: all pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: all pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: all pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: all pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  # This hack brought to you by DCL's 255-character command line limit
  pure_perl_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLPRIVLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLARCHLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q["
  
  # Likewise
  pure_site_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLSITELIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLSITEARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLSITEBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLSITEMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLSITEMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q["
  
  pure_vendor_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLVENDORLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLVENDORARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLVENDORBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLVENDORMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLVENDORMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ];
  
      push @m, q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(NOOP)
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install ::
  	$(NOECHO) $(NOOP)
  
  ] if $self->{NO_PERLLOCAL};
  
      push @m, q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  doc_vendor_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ] unless $self->{NO_PERLLOCAL};
  
      push @m, q[
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{VENDORARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  ];
  
      join('',@m);
  }
  
  =item perldepend (override)
  
  Use VMS-style syntax for files; it's cheaper to just do it directly here
  than to have the MM_Unix method call C<catfile> repeatedly.  Also, if
  we have to rebuild Config.pm, use MM[SK] to do it.
  
  =cut
  
  sub perldepend {
      my($self) = @_;
      my(@m);
  
      if ($self->{OBJECT}) {
          # Need to add an object file dependency on the perl headers.
          # this is very important for XS modules in perl.git development.
  
          push @m, $self->_perl_header_files_fragment(""); # empty separator on VMS as its in the $(PERL_INC)
      }
  
      if ($self->{PERL_SRC}) {
  	my(@macros);
  	my($mmsquals) = '$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';
  	push(@macros,'__AXP__=1') if $Config{'archname'} eq 'VMS_AXP';
  	push(@macros,'DECC=1')    if $Config{'vms_cc_type'} eq 'decc';
  	push(@macros,'GNUC=1')    if $Config{'vms_cc_type'} eq 'gcc';
  	push(@macros,'SOCKET=1')  if $Config{'d_has_sockets'};
  	push(@macros,qq["CC=$Config{'cc'}"])  if $Config{'cc'} =~ m!/!;
  	$mmsquals .= '$(USEMACROS)' . join(',',@macros) . '$(MACROEND)' if @macros;
  	push(@m,q[
  # Check for unpropagated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)config.h : $(PERL_SRC)config.sh
  	$(NOOP)
  
  $(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
  	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
  	olddef = F$Environment("Default")
  	Set Default $(PERL_SRC)
  	$(MMS)],$mmsquals,);
  	if ($self->{PERL_ARCHLIB} =~ m|\[-| && $self->{PERL_SRC} =~ m|(\[-+)|) {
  	    my($prefix,$target) = ($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));
  	    $target =~ s/\Q$prefix/[/;
  	    push(@m," $target");
  	}
  	else { push(@m,' $(MMS$TARGET)'); }
  	push(@m,q[
  	Set Default 'olddef'
  ]);
      }
  
      push(@m, join(" ", map($self->fixpath($_,0),sort values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")
        if %{$self->{XS}};
  
      join('',@m);
  }
  
  
  =item makeaperl (override)
  
  Undertake to build a new set of Perl images using VMS commands.  Since
  VMS does dynamic loading, it's not necessary to statically link each
  extension into the Perl image, so this isn't the normal build path.
  Consequently, it hasn't really been tested, and may well be incomplete.
  
  =cut
  
  our %olbs;  # needs to be localized
  
  sub makeaperl {
      my($self, %attribs) = @_;
      my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmpdir, $libperl) =
        @attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
      my(@m);
      push @m, "
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  ";
      return join '', @m if $self->{PARENT};
  
      my($dir) = join ":", @{$self->{DIR}};
  
      unless ($self->{MAKEAPERL}) {
  	push @m, q{
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
  	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=}, $dir, q{ \
  		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 };
  
  	push @m, map(q[ \\\n\t\t"$_"], @ARGV),q{
  
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
  };
  	push @m, "\n";
  
  	return join '', @m;
      }
  
  
      my($linkcmd,@optlibs,@staticpkgs,$extralist,$targdir,$libperldir,%libseen);
      local($_);
  
      # The front matter of the linkcommand...
      $linkcmd = join ' ', $Config{'ld'},
  	    grep($_, @Config{qw(large split ldflags ccdlflags)});
      $linkcmd =~ s/\s+/ /g;
  
      # Which *.olb files could we make use of...
      local(%olbs);       # XXX can this be lexical?
      $olbs{$self->{INST_ARCHAUTODIR}} = "$self->{BASEEXT}\$(LIB_EXT)";
      require File::Find;
      File::Find::find(sub {
  	return unless m/\Q$self->{LIB_EXT}\E$/;
  	return if m/^libperl/;
  
  	if( exists $self->{INCLUDE_EXT} ){
  		my $found = 0;
  
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything not explicitly marked for inclusion.
  		# DynaLoader is implied.
  		foreach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){
  			if( $xx eq $incl ){
  				$found++;
  				last;
  			}
  		}
  		return unless $found;
  	}
  	elsif( exists $self->{EXCLUDE_EXT} ){
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything explicitly marked for exclusion
  		foreach my $excl (@{$self->{EXCLUDE_EXT}}){
  			return if( $xx eq $excl );
  		}
  	}
  
  	$olbs{$ENV{DEFAULT}} = $_;
      }, grep( -d $_, @{$searchdirs || []}));
  
      # We trust that what has been handed in as argument will be buildable
      $static = [] unless $static;
      @olbs{@{$static}} = (1) x @{$static};
  
      $extra = [] unless $extra && ref $extra eq 'ARRAY';
      # Sort the object libraries in inverse order of
      # filespec length to try to insure that dependent extensions
      # will appear before their parents, so the linker will
      # search the parent library to resolve references.
      # (e.g. Intuit::DWIM will precede Intuit, so unresolved
      # references from [.intuit.dwim]dwim.obj can be found
      # in [.intuit]intuit.olb).
      for (sort { length($a) <=> length($b) || $a cmp $b } keys %olbs) {
  	next unless $olbs{$_} =~ /\Q$self->{LIB_EXT}\E$/;
  	my($dir) = $self->fixpath($_,1);
  	my($extralibs) = $dir . "extralibs.ld";
  	my($extopt) = $dir . $olbs{$_};
  	$extopt =~ s/$self->{LIB_EXT}$/.opt/;
  	push @optlibs, "$dir$olbs{$_}";
  	# Get external libraries this extension will need
  	if (-f $extralibs ) {
  	    my %seenthis;
  	    open my $list, "<", $extralibs or warn $!,next;
  	    while (<$list>) {
  		chomp;
  		# Include a library in the link only once, unless it's mentioned
  		# multiple times within a single extension's options file, in which
  		# case we assume the builder needed to search it again later in the
  		# link.
  		my $skip = exists($libseen{$_}) && !exists($seenthis{$_});
  		$libseen{$_}++;  $seenthis{$_}++;
  		next if $skip;
  		push @$extra,$_;
  	    }
  	}
  	# Get full name of extension for ExtUtils::Miniperl
  	if (-f $extopt) {
  	    open my $opt, '<', $extopt or die $!;
  	    while (<$opt>) {
  		next unless /(?:UNIVERSAL|VECTOR)=boot_([\w_]+)/;
  		my $pkg = $1;
  		$pkg =~ s#__*#::#g;
  		push @staticpkgs,$pkg;
  	    }
  	}
      }
      # Place all of the external libraries after all of the Perl extension
      # libraries in the final link, in order to maximize the opportunity
      # for XS code from multiple extensions to resolve symbols against the
      # same external library while only including that library once.
      push @optlibs, @$extra;
  
      $target = "Perl$Config{'exe_ext'}" unless $target;
      my $shrtarget;
      ($shrtarget,$targdir) = fileparse($target);
      $shrtarget =~ s/^([^.]*)/$1Shr/;
      $shrtarget = $targdir . $shrtarget;
      $target = "Perlshr.$Config{'dlext'}" unless $target;
      $tmpdir = "[]" unless $tmpdir;
      $tmpdir = $self->fixpath($tmpdir,1);
      if (@optlibs) { $extralist = join(' ',@optlibs); }
      else          { $extralist = ''; }
      # Let ExtUtils::Liblist find the necessary libs for us (but skip PerlShr)
      # that's what we're building here).
      push @optlibs, grep { !/PerlShr/i } split ' ', +($self->ext())[2];
      if ($libperl) {
  	unless (-f $libperl || -f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',$libperl))) {
  	    print "Warning: $libperl not found\n";
  	    undef $libperl;
  	}
      }
      unless ($libperl) {
  	if (defined $self->{PERL_SRC}) {
  	    $libperl = $self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
  	} elsif (-f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
  	} else {
  	    print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n";
  	}
      }
      $libperldir = $self->fixpath((fileparse($libperl))[1],1);
  
      push @m, '
  # Fill in the target you want to produce if it\'s not perl
  MAP_TARGET    = ',$self->fixpath($target,0),'
  MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = ", $perlinc ? map('"$_" ',@{$perlinc}) : '',"
  MAP_EXTRA     = $extralist
  MAP_LIBPERL = ",$self->fixpath($libperl,0),'
  ';
  
  
      push @m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";
      foreach (@optlibs) {
  	push @m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n";
      }
      push @m,"\n${tmpdir}PerlShr.Opt :\n\t";
      push @m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";
  
      push @m,'
  $(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
  	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
  $(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
  	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
  	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
  	$(NOECHO) $(ECHO) "To remove the intermediate files, say
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
  ';
      push @m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";
      push @m, "# More from the 255-char line length limit\n";
      foreach (@staticpkgs) {
  	push @m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n];
      }
  
      push @m, sprintf <<'MAKE_FRAG', $tmpdir, $tmpdir;
  	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@F)" %sWritemain.tmp >$(MMS$TARGET)
  	$(NOECHO) $(RM_F) %sWritemain.tmp
  MAKE_FRAG
  
      push @m, q[
  # Still more from the 255-char line length limit
  doc_inst_perl :
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
  	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
  	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
  	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  ];
  
      push @m, "
  inst_perl : pure_inst_perl doc_inst_perl
  	\$(NOECHO) \$(NOOP)
  
  pure_inst_perl : \$(MAP_TARGET)
  	$self->{CP} \$(MAP_SHRTARGET) ",$self->fixpath($Config{'installbin'},1),"
  	$self->{CP} \$(MAP_TARGET) ",$self->fixpath($Config{'installbin'},1),"
  
  clean :: map_clean
  	\$(NOECHO) \$(NOOP)
  
  map_clean :
  	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
  	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
  ";
  
      join '', @m;
  }
  
  
  # --- Output postprocessing section ---
  
  =item maketext_filter (override)
  
  Ensure that colons marking targets are preceded by space, in order
  to distinguish the target delimiter from a colon appearing as
  part of a filespec.
  
  =cut
  
  sub maketext_filter {
      my($self, $text) = @_;
  
      $text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;
      return $text;
  }
  
  =item prefixify (override)
  
  prefixifying on VMS is simple.  Each should simply be:
  
      perl_root:[some.dir]
  
  which can just be converted to:
  
      volume:[your.prefix.some.dir]
  
  otherwise you get the default layout.
  
  In effect, your search prefix is ignored and $Config{vms_prefix} is
  used instead.
  
  =cut
  
  sub prefixify {
      my($self, $var, $sprefix, $rprefix, $default) = @_;
  
      # Translate $(PERLPREFIX) to a real path.
      $rprefix = $self->eliminate_macros($rprefix);
      $rprefix = vmspath($rprefix) if $rprefix;
      $sprefix = vmspath($sprefix) if $sprefix;
  
      $default = vmsify($default)
        unless $default =~ /\[.*\]/;
  
      (my $var_no_install = $var) =~ s/^install//;
      my $path = $self->{uc $var} ||
                 $ExtUtils::MM_Unix::Config_Override{lc $var} ||
                 $Config{lc $var} || $Config{lc $var_no_install};
  
      if( !$path ) {
          warn "  no Config found for $var.\n" if $Verbose >= 2;
          $path = $self->_prefixify_default($rprefix, $default);
      }
      elsif( !$self->{ARGS}{PREFIX} || !$self->file_name_is_absolute($path) ) {
          # do nothing if there's no prefix or if its relative
      }
      elsif( $sprefix eq $rprefix ) {
          warn "  no new prefix.\n" if $Verbose >= 2;
      }
      else {
  
          warn "  prefixify $var => $path\n"     if $Verbose >= 2;
          warn "    from $sprefix to $rprefix\n" if $Verbose >= 2;
  
          my($path_vol, $path_dirs) = $self->splitpath( $path );
          if( $path_vol eq $Config{vms_prefix}.':' ) {
              warn "  $Config{vms_prefix}: seen\n" if $Verbose >= 2;
  
              $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
              $path = $self->_catprefix($rprefix, $path_dirs);
          }
          else {
              $path = $self->_prefixify_default($rprefix, $default);
          }
      }
  
      print "    now $path\n" if $Verbose >= 2;
      return $self->{uc $var} = $path;
  }
  
  
  sub _prefixify_default {
      my($self, $rprefix, $default) = @_;
  
      warn "  cannot prefix, using default.\n" if $Verbose >= 2;
  
      if( !$default ) {
          warn "No default!\n" if $Verbose >= 1;
          return;
      }
      if( !$rprefix ) {
          warn "No replacement prefix!\n" if $Verbose >= 1;
          return '';
      }
  
      return $self->_catprefix($rprefix, $default);
  }
  
  sub _catprefix {
      my($self, $rprefix, $default) = @_;
  
      my($rvol, $rdirs) = $self->splitpath($rprefix);
      if( $rvol ) {
          return $self->catpath($rvol,
                                     $self->catdir($rdirs, $default),
                                     ''
                                    )
      }
      else {
          return $self->catdir($rdirs, $default);
      }
  }
  
  
  =item cd
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      $dir = vmspath($dir);
  
      my $cmd = join "\n\t", map "$_", @cmds;
  
      # No leading tab makes it look right when embedded
      my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;
  startdir = F$Environment("Default")
  	Set Default %s
  	%s
  	Set Default 'startdir'
  MAKE_FRAG
  
      # No trailing newline makes this easier to embed
      chomp $make_frag;
  
      return $make_frag;
  }
  
  
  =item oneliner
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      my @cmds = split /\n/, $cmd;
      $cmd = join " \n\t  -e ", map $self->quote_literal($_), @cmds;
      $cmd = $self->escape_newlines($cmd);
  
      # Switches must be quoted else they will be lowercased.
      $switches = join ' ', map { qq{"$_"} } @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd "--"};
  }
  
  
  =item B<echo>
  
  perl trips up on "<foo>" thinking it's an input redirect.  So we use the
  native Write command instead.  Besides, it's faster.
  
  =cut
  
  sub echo {
      my($self, $text, $file, $opts) = @_;
  
      # Compatibility with old options
      if( !ref $opts ) {
          my $append = $opts;
          $opts = { append => $append || 0 };
      }
      my $opencmd = $opts->{append} ? 'Open/Append' : 'Open/Write';
  
      $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};
  
      my $ql_opts = { allow_variables => $opts->{allow_variables} };
  
      my @cmds = ("\$(NOECHO) $opencmd MMECHOFILE $file ");
      push @cmds, map { '$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_, $ql_opts) }
                  split /\n/, $text;
      push @cmds, '$(NOECHO) Close MMECHOFILE';
      return @cmds;
  }
  
  
  =item quote_literal
  
  =cut
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # I believe this is all we should need.
      $text =~ s{"}{""}g;
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return qq{"$text"};
  }
  
  =item escape_dollarsigns
  
  Quote, don't escape.
  
  =cut
  
  sub escape_dollarsigns {
      my($self, $text) = @_;
  
      # Quote dollar signs which are not starting a variable
      $text =~ s{\$ (?!\() }{"\$"}gx;
  
      return $text;
  }
  
  
  =item escape_all_dollarsigns
  
  Quote, don't escape.
  
  =cut
  
  sub escape_all_dollarsigns {
      my($self, $text) = @_;
  
      # Quote dollar signs
      $text =~ s{\$}{"\$\"}gx;
  
      return $text;
  }
  
  =item escape_newlines
  
  =cut
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      $text =~ s{\n}{-\n}g;
  
      return $text;
  }
  
  =item max_exec_len
  
  256 characters.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 256;
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
      $self->{EXPORT_LIST} ||= '$(BASEEXT).opt';
  
      my $shr = $Config{dbgprefix} . 'PERLSHR';
      if ($self->{PERL_SRC}) {
          $self->{PERL_ARCHIVE} ||=
            $self->catfile($self->{PERL_SRC}, "$shr.$Config{'dlext'}");
      }
      else {
          $self->{PERL_ARCHIVE} ||=
            $ENV{$shr} ? $ENV{$shr} : "Sys\$Share:$shr.$Config{'dlext'}";
      }
  
      $self->{PERL_ARCHIVEDEP} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
  }
  
  
  =item catdir (override)
  
  =item catfile (override)
  
  Eliminate the macros in the output to the MMS/MMK file.
  
  (File::Spec::VMS used to do this for us, but it's being removed)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      # Process the macros on VMS MMS/MMK
      my @args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @_;
  
      my $dir = $self->SUPER::catdir(@args);
  
      # Fix up the directory and force it to VMS format.
      $dir = $self->fixpath($dir, 1);
  
      return $dir;
  }
  
  sub catfile {
      my $self = shift;
  
      # Process the macros on VMS MMS/MMK
      my @args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @_;
  
      my $file = $self->SUPER::catfile(@args);
  
      $file = vmsify($file);
  
      return $file
  }
  
  
  =item eliminate_macros
  
  Expands MM[KS]/Make macros in a text string, using the contents of
  identically named elements of C<%$self>, and returns the result
  as a file specification in Unix syntax.
  
  NOTE:  This is the canonical version of the method.  The version in
  File::Spec::VMS is deprecated.
  
  =cut
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless $path;
      $self = {} unless ref $self;
  
      my($npath) = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) {
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else {
                  $macro = $self->{$macro};
                  # Don't unixify if there is unescaped whitespace
                  $macro = unixify($macro) unless ($macro =~ /(?<!\^)\s/);
                  $macro =~ s#/\Z(?!\n)##;
              }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  =item fixpath
  
     my $path = $mm->fixpath($path);
     my $path = $mm->fixpath($path, $is_dir);
  
  Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  in any directory specification, in order to avoid juxtaposing two
  VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  are all macro, so that we can tell how long the expansion is, and avoid
  overrunning DCL's command buffer when MM[KS] is running.
  
  fixpath() checks to see whether the result matches the name of a
  directory in the current default directory and returns a directory or
  file specification accordingly.  C<$is_dir> can be set to true to
  force fixpath() to consider the path to be a directory or false to force
  it to be a file.
  
  NOTE:  This is the canonical version of the method.  The version in
  File::Spec::VMS is deprecated.
  
  =cut
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) {
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
  
      return $fixedpath;
  }
  
  
  =item os_flavor
  
  VMS is VMS.
  
  =cut
  
  sub os_flavor {
      return('VMS');
  }
  
  
  =item is_make_type (override)
  
  None of the make types being checked for is viable on VMS,
  plus our $self->{MAKE} is an unexpanded (and unexpandable)
  macro whose value is known only to the make utility itself.
  
  =cut
  
  sub is_make_type {
      my($self, $type) = @_;
      return 0;
  }
  
  
  =item make_type (override)
  
  Returns a suitable string describing the type of makefile being written.
  
  =cut
  
  sub make_type { "$Config{make}-style"; }
  
  
  =back
  
  
  =head1 AUTHOR
  
  Original author Charles Bailey F<bailey@newman.upenn.edu>
  
  Maintained by Michael G Schwern F<schwern@pobox.com>
  
  See L<ExtUtils::MakeMaker> for patching and contact information.
  
  
  =cut
  
  1;
  
EXTUTILS_MM_VMS

$fatpacked{"ExtUtils/MM_VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VOS';
  package ExtUtils::MM_VOS;
  
  use strict;
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  VOS.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 extra_clean_files
  
  Cleanup VOS core files
  
  =cut
  
  sub extra_clean_files {
      return qw(*.kp);
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
EXTUTILS_MM_VOS

$fatpacked{"ExtUtils/MM_Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN32';
  package ExtUtils::MM_Win32;
  
  use strict;
  
  
  =head1 NAME
  
  ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_Win32; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =cut
  
  use ExtUtils::MakeMaker::Config;
  use File::Basename;
  use File::Spec;
  use ExtUtils::MakeMaker qw(neatvalue _sprintf562);
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  $ENV{EMXSHELL} = 'sh'; # to run `commands`
  
  my ( $BORLAND, $GCC, $MSVC ) = _identify_compiler_environment( \%Config );
  
  sub _identify_compiler_environment {
  	my ( $config ) = @_;
  
  	my $BORLAND = $config->{cc} =~ /\bbcc/i ? 1 : 0;
  	my $GCC     = $config->{cc} =~ /\bgcc\b/i ? 1 : 0;
  	my $MSVC    = $config->{cc} =~ /\b(?:cl|icl)/i ? 1 : 0; # MSVC can come as clarm.exe, icl=Intel C
  
  	return ( $BORLAND, $GCC, $MSVC );
  }
  
  
  =head2 Overridden methods
  
  =over 4
  
  =item B<dlsyms>
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
      return '' if $self->{SKIPHASH}{'dynamic'};
      $self->xs_dlsyms_iterator(\%attribs);
  }
  
  =item xs_dlsyms_ext
  
  On Win32, is C<.def>.
  
  =cut
  
  sub xs_dlsyms_ext {
      '.def';
  }
  
  =item replace_manpage_separator
  
  Changes the path separator with .
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man =~ s,[/\\]+,.,g;
      $man;
  }
  
  
  =item B<maybe_command>
  
  Since Windows has nothing as simple as an executable bit, we check the
  file extension.
  
  The PATHEXT env variable will be used to get a list of extensions that
  might indicate a command, otherwise .com, .exe, .bat and .cmd will be
  used by default.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      my @e = exists($ENV{'PATHEXT'})
            ? split(/;/, $ENV{PATHEXT})
  	  : qw(.com .exe .bat .cmd);
      my $e = '';
      for (@e) { $e .= "\Q$_\E|" }
      chop $e;
      # see if file ends in one of the known extensions
      if ($file =~ /($e)$/i) {
  	return $file if -e $file;
      }
      else {
  	for (@e) {
  	    return "$file$_" if -e "$file$_";
  	}
      }
      return;
  }
  
  
  =item B<init_DIRFILESEP>
  
  Using \ for Windows, except for "gmake" where it is /.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      # The ^ makes sure its not interpreted as an escape in nmake
      $self->{DIRFILESEP} = $self->is_make_type('nmake') ? '^\\' :
                            $self->is_make_type('dmake') ? '\\\\' :
                            $self->is_make_type('gmake') ? '/'
                                                         : '\\';
  }
  
  =item init_tools
  
  Override some of the slower, portable commands with Windows specific ones.
  
  =cut
  
  sub init_tools {
      my ($self) = @_;
  
      $self->{NOOP}     ||= 'rem';
      $self->{DEV_NULL} ||= '> NUL';
  
      $self->{FIXIN}    ||= $self->{PERL_CORE} ?
        "\$(PERLRUN) -I$self->{PERL_SRC}\\cpan\\ExtUtils-PL2Bat\\lib $self->{PERL_SRC}\\win32\\bin\\pl2bat.pl" :
        'pl2bat.bat';
  
      $self->SUPER::init_tools;
  
      # Setting SHELL from $Config{sh} can break dmake.  Its ok without it.
      delete $self->{SHELL};
  
      return;
  }
  
  
  =item init_others
  
  Override the default link and compile tools.
  
  LDLOADLIBS's default is changed to $Config{libs}.
  
  Adjustments are made for Borland's quirks needing -L to come first.
  
  =cut
  
  sub init_others {
      my $self = shift;
  
      $self->{LD}     ||= 'link';
      $self->{AR}     ||= 'lib';
  
      $self->SUPER::init_others;
  
      $self->{LDLOADLIBS} ||= $Config{libs};
      # -Lfoo must come first for Borland, so we put it in LDDLFLAGS
      if ($BORLAND) {
          my $libs = $self->{LDLOADLIBS};
          my $libpath = '';
          while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /) {
              $libpath .= ' ' if length $libpath;
              $libpath .= $1;
          }
          $self->{LDLOADLIBS} = $libs;
          $self->{LDDLFLAGS} ||= $Config{lddlflags};
          $self->{LDDLFLAGS} .= " $libpath";
      }
  
      return;
  }
  
  
  =item init_platform
  
  Add MM_Win32_VERSION.
  
  =item platform_constants
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_Win32_VERSION} = $VERSION;
  
      return;
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(MM_Win32_VERSION))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  =item specify_shell
  
  Set SHELL to $ENV{COMSPEC} only if make is type 'gmake'.
  
  =cut
  
  sub specify_shell {
      my $self = shift;
      return '' unless $self->is_make_type('gmake');
      "\nSHELL = $ENV{COMSPEC}\n";
  }
  
  =item constants
  
  Add MAXLINELENGTH for dmake before all the constants are output.
  
  =cut
  
  sub constants {
      my $self = shift;
  
      my $make_text = $self->SUPER::constants;
      return $make_text unless $self->is_make_type('dmake');
  
      # dmake won't read any single "line" (even those with escaped newlines)
      # larger than a certain size which can be as small as 8k.  PM_TO_BLIB
      # on large modules like DateTime::TimeZone can create lines over 32k.
      # So we'll crank it up to a <ironic>WHOPPING</ironic> 64k.
      #
      # This has to come here before all the constants and not in
      # platform_constants which is after constants.
      my $size = $self->{MAXLINELENGTH} || 800000;
      my $prefix = qq{
  # Get dmake to read long commands like PM_TO_BLIB
  MAXLINELENGTH = $size
  
  };
  
      return $prefix . $make_text;
  }
  
  
  =item special_targets
  
  Add .USESHELL target for dmake.
  
  =cut
  
  sub special_targets {
      my($self) = @_;
  
      my $make_frag = $self->SUPER::special_targets;
  
      $make_frag .= <<'MAKE_FRAG' if $self->is_make_type('dmake');
  .USESHELL :
  MAKE_FRAG
  
      return $make_frag;
  }
  
  =item static_lib_pure_cmd
  
  Defines how to run the archive utility
  
  =cut
  
  sub static_lib_pure_cmd {
      my ($self, $from) = @_;
      $from =~ s/(\$\(\w+)(\))/$1:^"+"$2/g if $BORLAND;
      sprintf qq{\t\$(AR) %s\n}, ($BORLAND ? '$@ ' . $from
                            : ($GCC ? '-ru $@ ' . $from
                                    : '-out:$@ ' . $from));
  }
  
  =item dynamic_lib
  
  Methods are overridden here: not dynamic_lib itself, but the utility
  ones that do the OS-specific work.
  
  =cut
  
  sub xs_make_dynamic_lib {
      my ($self, $attribs, $from, $to, $todir, $ldfrom, $exportlist) = @_;
      my @m = sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(INST_DYNAMIC_DEP)'."\n", $to, $from, $todir, $exportlist;
      if ($GCC) {
        # per https://rt.cpan.org/Ticket/Display.html?id=78395 no longer
        # uses dlltool - relies on post 2002 MinGW
        #                             1            2
        push @m, _sprintf562 <<'EOF', $exportlist, $ldfrom;
  	$(LD) %1$s -o $@ $(LDDLFLAGS) %2$s $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) -Wl,--enable-auto-image-base
  EOF
      } elsif ($BORLAND) {
        my $ldargs = $self->is_make_type('dmake')
            ? q{"$(PERL_ARCHIVE:s,/,\,)" $(LDLOADLIBS:s,/,\,) $(MYEXTLIB:s,/,\,),}
            : q{"$(subst /,\,$(PERL_ARCHIVE))" $(subst /,\,$(LDLOADLIBS)) $(subst /,\,$(MYEXTLIB)),};
        my $subbed;
        if ($exportlist eq '$(EXPORT_LIST)') {
            $subbed = $self->is_make_type('dmake')
                ? q{$(EXPORT_LIST:s,/,\,)}
                : q{$(subst /,\,$(EXPORT_LIST))};
        } else {
              # in XSMULTI, exportlist is per-XS, so have to sub in perl not make
            ($subbed = $exportlist) =~ s#/#\\#g;
        }
        push @m, sprintf <<'EOF', $ldfrom, $ldargs . $subbed;
          $(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) %s,$@,,%s,$(RESFILES)
  EOF
      } else {	# VC
        push @m, sprintf <<'EOF', $ldfrom, $exportlist;
  	$(LD) -out:$@ $(LDDLFLAGS) %s $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) -def:%s
  EOF
        # Embed the manifest file if it exists
        push(@m, q{	if exist $@.manifest mt -nologo -manifest $@.manifest -outputresource:$@;2
  	if exist $@.manifest del $@.manifest});
      }
      push @m, "\n\t\$(CHMOD) \$(PERM_RWX) \$\@\n";
  
      join '', @m;
  }
  
  sub xs_dynamic_lib_macros {
      my ($self, $attribs) = @_;
      my $otherldflags = $attribs->{OTHERLDFLAGS} || ($BORLAND ? 'c0d32.obj': '');
      my $inst_dynamic_dep = $attribs->{INST_DYNAMIC_DEP} || "";
      sprintf <<'EOF', $otherldflags, $inst_dynamic_dep;
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  EOF
  }
  
  =item extra_clean_files
  
  Clean out some extra dll.{base,exp} files which might be generated by
  gcc.  Otherwise, take out all *.pdb files.
  
  =cut
  
  sub extra_clean_files {
      my $self = shift;
  
      return $GCC ? (qw(dll.base dll.exp)) : ('*.pdb');
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      $self->{PERL_ARCHIVE}       = "\$(PERL_INC)\\$Config{libperl}";
      $self->{PERL_ARCHIVEDEP}    = "\$(PERL_INCDEP)\\$Config{libperl}";
      $self->{PERL_ARCHIVE_AFTER} = '';
      $self->{EXPORT_LIST}        = '$(BASEEXT).def';
  }
  
  
  =item perl_script
  
  Checks for the perl program under several common perl extensions.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && -f _;
      return "$file.pl"  if -r "$file.pl" && -f _;
      return "$file.plx" if -r "$file.plx" && -f _;
      return "$file.bat" if -r "$file.bat" && -f _;
      return;
  }
  
  sub can_dep_space {
      my $self = shift;
      1; # with Win32::GetShortPathName
  }
  
  =item quote_dep
  
  =cut
  
  sub quote_dep {
      my ($self, $arg) = @_;
      if ($arg =~ / / and not $self->is_make_type('gmake')) {
          require Win32;
          $arg = Win32::GetShortPathName($arg);
          die <<EOF if not defined $arg or $arg =~ / /;
  Tried to use make dependency with space for non-GNU make:
    '$arg'
  Fallback to short pathname failed.
  EOF
          return $arg;
      }
      return $self->SUPER::quote_dep($arg);
  }
  
  
  =item xs_obj_opt
  
  Override to fixup -o flags for MSVC.
  
  =cut
  
  sub xs_obj_opt {
      my ($self, $output_file) = @_;
      ($MSVC ? "/Fo" : "-o ") . $output_file;
  }
  
  
  =item pasthru
  
  All we send is -nologo to nmake to prevent it from printing its damned
  banner.
  
  =cut
  
  sub pasthru {
      my($self) = shift;
      my $old = $self->SUPER::pasthru;
      return $old unless $self->is_make_type('nmake');
      $old =~ s/(PASTHRU\s*=\s*)/$1 -nologo /;
      $old;
  }
  
  
  =item arch_check (override)
  
  Normalize all arguments for consistency of comparison.
  
  =cut
  
  sub arch_check {
      my $self = shift;
  
      # Win32 is an XS module, minperl won't have it.
      # arch_check() is not critical, so just fake it.
      return 1 unless $self->can_load_xs;
      return $self->SUPER::arch_check( map { $self->_normalize_path_name($_) } @_);
  }
  
  sub _normalize_path_name {
      my $self = shift;
      my $file = shift;
  
      require Win32;
      my $short = Win32::GetShortPathName($file);
      return defined $short ? lc $short : lc $file;
  }
  
  
  =item oneliner
  
  These are based on what command.com does on Win98.  They may be wrong
  for other Windows shells, I don't know.
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      $cmd = $self->quote_literal($cmd);
      $cmd = $self->escape_newlines($cmd);
  
      $switches = join ' ', @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd --};
  }
  
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # See: http://www.autohotkey.net/~deleyd/parameters/parameters.htm#CPP
  
      # Apply the Microsoft C/C++ parsing rules
      $text =~ s{\\\\"}{\\\\\\\\\\"}g;  # \\" -> \\\\\"
      $text =~ s{(?<!\\)\\"}{\\\\\\"}g; # \"  -> \\\"
      $text =~ s{(?<!\\)"}{\\"}g;       # "   -> \"
      $text = qq{"$text"} if $text =~ /[ \t#]/; # hash because gmake 4.2.1
  
      # Apply the Command Prompt parsing rules (cmd.exe)
      my @text = split /("[^"]*")/, $text;
      # We should also escape parentheses, but it breaks one-liners containing
      # $(MACRO)s in makefiles.
      s{([<>|&^@!])}{^$1}g foreach grep { !/^"[^"]*"$/ } @text;
      $text = join('', @text);
  
      # dmake expands {{ to { and }} to }.
      if( $self->is_make_type('dmake') ) {
          $text =~ s/{/{{/g;
          $text =~ s/}/}}/g;
      }
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return $text;
  }
  
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      # Escape newlines
      $text =~ s{\n}{\\\n}g;
  
      return $text;
  }
  
  
  =item cd
  
  dmake can handle Unix style cd'ing but nmake (at least 1.5) cannot.  It
  wants:
  
      cd dir1\dir2
      command
      another_command
      cd ..\..
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      return $self->SUPER::cd($dir, @cmds) unless $self->is_make_type('nmake');
  
      my $cmd = join "\n\t", map "$_", @cmds;
  
      my $updirs = $self->catdir(map { $self->updir } $self->splitdir($dir));
  
      # No leading tab and no trailing newline makes for easier embedding.
      my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd, $updirs;
  cd %s
  	%s
  	cd %s
  MAKE_FRAG
  
      chomp $make_frag;
  
      return $make_frag;
  }
  
  
  =item max_exec_len
  
  nmake 1.50 limits command length to 2048 characters.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 2 * 1024;
  }
  
  
  =item os_flavor
  
  Windows is Win32.
  
  =cut
  
  sub os_flavor {
      return('Win32');
  }
  
  =item dbgoutflag
  
  Returns a CC flag that tells the CC to emit a separate debugging symbol file
  when compiling an object file.
  
  =cut
  
  sub dbgoutflag {
      $MSVC ? '-Fd$(*).pdb' : '';
  }
  
  =item cflags
  
  Defines the PERLDLL symbol if we are configured for static building since all
  code destined for the perl5xx.dll must be compiled with the PERLDLL symbol
  defined.
  
  =cut
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my $base = $self->SUPER::cflags($libperl);
      foreach (split /\n/, $base) {
          /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
      };
      $self->{CCFLAGS} .= " -DPERLDLL" if ($self->{LINKTYPE} eq 'static');
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  
  }
  
  =item make_type
  
  Returns a suitable string describing the type of makefile being written.
  
  =cut
  
  sub make_type {
      my ($self) = @_;
      my $make = $self->make;
      $make = +( File::Spec->splitpath( $make ) )[-1];
      $make =~ s!\.exe$!!i;
      if ( $make =~ m![^A-Z0-9]!i ) {
        ($make) = grep { m!make!i } split m![^A-Z0-9]!i, $make;
      }
      return "$make-style";
  }
  
  1;
  __END__
  
  =back
EXTUTILS_MM_WIN32

$fatpacked{"ExtUtils/MM_Win95.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN95';
  package ExtUtils::MM_Win95;
  
  use strict;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require ExtUtils::MM_Win32;
  our @ISA = qw(ExtUtils::MM_Win32);
  
  use ExtUtils::MakeMaker::Config;
  
  
  =head1 NAME
  
  ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X
  
  =head1 SYNOPSIS
  
    You should not be using this module directly.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Win32 containing changes necessary
  to get MakeMaker playing nice with command.com and other Win9Xisms.
  
  =head2 Overridden methods
  
  Most of these make up for limitations in the Win9x/nmake command shell.
  
  =over 4
  
  
  =item max_exec_len
  
  Win98 chokes on things like Encode if we set the max length to nmake's max
  of 2K.  So we go for a more conservative value of 1K.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 1024;
  }
  
  
  =item os_flavor
  
  Win95 and Win98 and WinME are collectively Win9x and Win32
  
  =cut
  
  sub os_flavor {
      my $self = shift;
      return ($self->SUPER::os_flavor, 'Win9x');
  }
  
  
  =back
  
  
  =head1 AUTHOR
  
  Code originally inside MM_Win32.  Original author unknown.
  
  Currently maintained by Michael G Schwern C<schwern@pobox.com>.
  
  Send patches and ideas to C<makemaker@perl.org>.
  
  See https://metacpan.org/release/ExtUtils-MakeMaker.
  
  =cut
  
  
  1;
EXTUTILS_MM_WIN95

$fatpacked{"ExtUtils/MY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MY';
  package ExtUtils::MY;
  
  use strict;
  require ExtUtils::MM;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  our @ISA = qw(ExtUtils::MM);
  
  {
      package MY;
      our @ISA = qw(ExtUtils::MY);
  }
  
  sub DESTROY {}
  
  
  =head1 NAME
  
  ExtUtils::MY - ExtUtils::MakeMaker subclass for customization
  
  =head1 SYNOPSIS
  
    # in your Makefile.PL
    sub MY::whatever {
        ...
    }
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  ExtUtils::MY is a subclass of ExtUtils::MM.  Its provided in your
  Makefile.PL for you to add and override MakeMaker functionality.
  
  It also provides a convenient alias via the MY class.
  
  ExtUtils::MY might turn out to be a temporary solution, but MY won't
  go away.
  
  =cut
EXTUTILS_MY

$fatpacked{"ExtUtils/MakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER';
  # $Id$
  package ExtUtils::MakeMaker;
  
  use strict;
  
  BEGIN {require 5.006;}
  
  require Exporter;
  use ExtUtils::MakeMaker::Config;
  use ExtUtils::MakeMaker::version; # ensure we always have our fake version.pm
  use Carp;
  use File::Path;
  my $CAN_DECODE = eval { require ExtUtils::MakeMaker::Locale; }; # 2 birds, 1 stone
  eval { ExtUtils::MakeMaker::Locale::reinit('UTF-8') }
    if $CAN_DECODE and Encode::find_encoding('locale')->name eq 'ascii';
  
  our $Verbose = 0;       # exported
  our @Parent;            # needs to be localized
  our @Get_from_Config;   # referenced by MM_Unix
  our @MM_Sections;
  our @Overridable;
  my @Prepend_parent;
  my %Recognized_Att_Keys;
  our %macro_fsentity; # whether a macro is a filesystem name
  our %macro_dep; # whether a macro is a dependency
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  # Emulate something resembling CVS $Revision$
  (our $Revision = $VERSION) =~ s{_}{};
  $Revision = int $Revision * 10000;
  
  our $Filename = __FILE__;   # referenced outside MakeMaker
  
  our @ISA = qw(Exporter);
  our @EXPORT    = qw(&WriteMakefile $Verbose &prompt &os_unsupported);
  our @EXPORT_OK = qw($VERSION &neatvalue &mkbootstrap &mksymlists
                      &WriteEmptyMakefile &open_for_writing &write_file_via_tmp
                      &_sprintf562);
  
  # These will go away once the last of the Win32 & VMS specific code is
  # purged.
  my $Is_VMS     = $^O eq 'VMS';
  my $Is_Win32   = $^O eq 'MSWin32';
  our $UNDER_CORE = $ENV{PERL_CORE}; # needs to be our
  
  full_setup();
  
  require ExtUtils::MM;  # Things like CPAN assume loading ExtUtils::MakeMaker
                         # will give them MM.
  
  require ExtUtils::MY;  # XXX pre-5.8 versions of ExtUtils::Embed expect
                         # loading ExtUtils::MakeMaker will give them MY.
                         # This will go when Embed is its own CPAN module.
  
  
  # 5.6.2 can't do sprintf "%1$s" - this can only do %s
  sub _sprintf562 {
      my ($format, @args) = @_;
      for (my $i = 1; $i <= @args; $i++) {
          $format =~ s#%$i\$s#$args[$i-1]#g;
      }
      $format;
  }
  
  sub WriteMakefile {
      croak "WriteMakefile: Need even number of args" if @_ % 2;
  
      require ExtUtils::MY;
      my %att = @_;
  
      _convert_compat_attrs(\%att);
  
      _verify_att(\%att);
  
      my $mm = MM->new(\%att);
      $mm->flush;
  
      return $mm;
  }
  
  
  # Basic signatures of the attributes WriteMakefile takes.  Each is the
  # reference type.  Empty value indicate it takes a non-reference
  # scalar.
  my %Att_Sigs;
  my %Special_Sigs = (
   AUTHOR             => 'ARRAY',
   C                  => 'ARRAY',
   CONFIG             => 'ARRAY',
   CONFIGURE          => 'CODE',
   DIR                => 'ARRAY',
   DL_FUNCS           => 'HASH',
   DL_VARS            => 'ARRAY',
   EXCLUDE_EXT        => 'ARRAY',
   EXE_FILES          => 'ARRAY',
   FUNCLIST           => 'ARRAY',
   H                  => 'ARRAY',
   IMPORTS            => 'HASH',
   INCLUDE_EXT        => 'ARRAY',
   LIBS               => ['ARRAY',''],
   MAN1PODS           => 'HASH',
   MAN3PODS           => 'HASH',
   META_ADD           => 'HASH',
   META_MERGE         => 'HASH',
   OBJECT             => ['ARRAY', ''],
   PL_FILES           => 'HASH',
   PM                 => 'HASH',
   PMLIBDIRS          => 'ARRAY',
   PMLIBPARENTDIRS    => 'ARRAY',
   PREREQ_PM          => 'HASH',
   BUILD_REQUIRES     => 'HASH',
   CONFIGURE_REQUIRES => 'HASH',
   TEST_REQUIRES      => 'HASH',
   SKIP               => 'ARRAY',
   TYPEMAPS           => 'ARRAY',
   XS                 => 'HASH',
   XSBUILD            => 'HASH',
   VERSION            => ['version',''],
   _KEEP_AFTER_FLUSH  => '',
  
   clean      => 'HASH',
   depend     => 'HASH',
   dist       => 'HASH',
   dynamic_lib=> 'HASH',
   linkext    => 'HASH',
   macro      => 'HASH',
   postamble  => 'HASH',
   realclean  => 'HASH',
   test       => 'HASH',
   tool_autosplit => 'HASH',
  );
  
  @Att_Sigs{keys %Recognized_Att_Keys} = ('') x keys %Recognized_Att_Keys;
  @Att_Sigs{keys %Special_Sigs} = values %Special_Sigs;
  
  sub _convert_compat_attrs { #result of running several times should be same
      my($att) = @_;
      if (exists $att->{AUTHOR}) {
          if ($att->{AUTHOR}) {
              if (!ref($att->{AUTHOR})) {
                  my $t = $att->{AUTHOR};
                  $att->{AUTHOR} = [$t];
              }
          } else {
                  $att->{AUTHOR} = [];
          }
      }
  }
  
  sub _verify_att {
      my($att) = @_;
  
      foreach my $key (sort keys %$att) {
          my $val = $att->{$key};
          my $sig = $Att_Sigs{$key};
          unless( defined $sig ) {
              warn "WARNING: $key is not a known parameter.\n";
              next;
          }
  
          my @sigs   = ref $sig ? @$sig : $sig;
          my $given  = ref $val;
          unless( grep { _is_of_type($val, $_) } @sigs ) {
              my $takes = join " or ", map { _format_att($_) } @sigs;
  
              my $has = _format_att($given);
              warn "WARNING: $key takes a $takes not a $has.\n".
                   "         Please inform the author.\n";
          }
      }
  }
  
  
  # Check if a given thing is a reference or instance of $type
  sub _is_of_type {
      my($thing, $type) = @_;
  
      return 1 if ref $thing eq $type;
  
      local $SIG{__DIE__};
      return 1 if eval{ $thing->isa($type) };
  
      return 0;
  }
  
  
  sub _format_att {
      my $given = shift;
  
      return $given eq ''        ? "string/number"
           : uc $given eq $given ? "$given reference"
           :                       "$given object"
           ;
  }
  
  
  sub prompt ($;$) {  ## no critic
      my($mess, $def) = @_;
      confess("prompt function called without an argument")
          unless defined $mess;
  
      my $isa_tty = -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;
  
      my $dispdef = defined $def ? "[$def] " : " ";
      $def = defined $def ? $def : "";
  
      local $|=1;
      local $\;
      print "$mess $dispdef";
  
      my $ans;
      if ($ENV{PERL_MM_USE_DEFAULT} || (!$isa_tty && eof STDIN)) {
          print "$def\n";
      }
      else {
          $ans = <STDIN>;
          if( defined $ans ) {
              $ans =~ s{\015?\012$}{};
          }
          else { # user hit ctrl-D
              print "\n";
          }
      }
  
      return (!defined $ans || $ans eq '') ? $def : $ans;
  }
  
  sub os_unsupported {
      die "OS unsupported\n";
  }
  
  sub eval_in_subdirs {
      my($self) = @_;
      use Cwd qw(cwd abs_path);
      my $pwd = cwd() || die "Can't figure out your cwd!";
  
      local @INC = map eval {abs_path($_) if -e} || $_, @INC;
      push @INC, '.';     # '.' has to always be at the end of @INC
  
      foreach my $dir (@{$self->{DIR}}){
          my($abs) = $self->catdir($pwd,$dir);
          eval { $self->eval_in_x($abs); };
          last if $@;
      }
      chdir $pwd;
      die $@ if $@;
  }
  
  sub eval_in_x {
      my($self,$dir) = @_;
      chdir $dir or carp("Couldn't change to directory $dir: $!");
  
      {
          package main;
          do './Makefile.PL';
      };
      if ($@) {
  #         if ($@ =~ /prerequisites/) {
  #             die "MakeMaker WARNING: $@";
  #         } else {
  #             warn "WARNING from evaluation of $dir/Makefile.PL: $@";
  #         }
          die "ERROR from evaluation of $dir/Makefile.PL: $@";
      }
  }
  
  
  # package name for the classes into which the first object will be blessed
  my $PACKNAME = 'PACK000';
  
  sub full_setup {
      $Verbose ||= 0;
  
      my @dep_macros = qw/
      PERL_INCDEP        PERL_ARCHLIBDEP     PERL_ARCHIVEDEP
      /;
  
      my @fs_macros = qw/
      FULLPERL XSUBPPDIR
  
      INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR
      INSTALLDIRS
      DESTDIR PREFIX INSTALL_BASE
      PERLPREFIX      SITEPREFIX      VENDORPREFIX
      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
      INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN
      INSTALLMAN1DIR          INSTALLMAN3DIR
      INSTALLSITEMAN1DIR      INSTALLSITEMAN3DIR
      INSTALLVENDORMAN1DIR    INSTALLVENDORMAN3DIR
      INSTALLSCRIPT   INSTALLSITESCRIPT  INSTALLVENDORSCRIPT
      PERL_LIB        PERL_ARCHLIB
      SITELIBEXP      SITEARCHEXP
  
      MAKE LIBPERL_A LIB PERL_SRC PERL_INC
      PPM_INSTALL_EXEC PPM_UNINSTALL_EXEC
      PPM_INSTALL_SCRIPT PPM_UNINSTALL_SCRIPT
      /;
  
      my @attrib_help = qw/
  
      AUTHOR ABSTRACT ABSTRACT_FROM BINARY_LOCATION
      C CAPI CCFLAGS CONFIG CONFIGURE DEFINE DIR DISTNAME DISTVNAME
      DL_FUNCS DL_VARS
      EXCLUDE_EXT EXE_FILES FIRST_MAKEFILE
      FULLPERLRUN FULLPERLRUNINST
      FUNCLIST H IMPORTS
  
      INC INCLUDE_EXT LDFROM LIBS LICENSE
      LINKTYPE MAKEAPERL MAKEFILE MAKEFILE_OLD MAN1PODS MAN3PODS MAP_TARGET
      META_ADD META_MERGE MIN_PERL_VERSION BUILD_REQUIRES CONFIGURE_REQUIRES
      MYEXTLIB NAME NEEDS_LINKING NOECHO NO_META NO_MYMETA NO_PACKLIST NO_PERLLOCAL
      NORECURS NO_VC OBJECT OPTIMIZE PERL_MALLOC_OK PERL PERLMAINCC PERLRUN
      PERLRUNINST PERL_CORE
      PERM_DIR PERM_RW PERM_RWX MAGICXS
      PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE
      PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ PUREPERL_ONLY
      SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST VERSION VERSION_FROM XS
      XSBUILD XSMULTI XSOPT XSPROTOARG XS_VERSION
      clean depend dist dynamic_lib linkext macro realclean tool_autosplit
  
      MAN1EXT MAN3EXT
  
      MACPERL_SRC MACPERL_LIB MACLIBS_68K MACLIBS_PPC MACLIBS_SC MACLIBS_MRC
      MACLIBS_ALL_68K MACLIBS_ALL_PPC MACLIBS_SHARED
          /;
      push @attrib_help, @fs_macros;
      @macro_fsentity{@fs_macros, @dep_macros} = (1) x (@fs_macros+@dep_macros);
      @macro_dep{@dep_macros} = (1) x @dep_macros;
  
      # IMPORTS is used under OS/2 and Win32
  
      # @Overridable is close to @MM_Sections but not identical.  The
      # order is important. Many subroutines declare macros. These
      # depend on each other. Let's try to collect the macros up front,
      # then pasthru, then the rules.
  
      # MM_Sections are the sections we have to call explicitly
      # in Overridable we have subroutines that are used indirectly
  
  
      @MM_Sections =
          qw(
  
   post_initialize const_config constants platform_constants
   tool_autosplit tool_xsubpp tools_other
  
   makemakerdflt
  
   dist macro depend cflags const_loadlibs const_cccmd
   post_constants
  
   pasthru
  
   special_targets
   c_o xs_c xs_o
   top_targets blibdirs linkext dlsyms dynamic_bs dynamic
   dynamic_lib static static_lib manifypods processPL
   installbin subdirs
   clean_subdirs clean realclean_subdirs realclean
   metafile signature
   dist_basics dist_core distdir dist_test dist_ci distmeta distsignature
   install force perldepend makefile staticmake test ppd
  
            ); # loses section ordering
  
      @Overridable = @MM_Sections;
      push @Overridable, qw[
  
   libscan makeaperl needs_linking
   subdir_x test_via_harness test_via_script
  
   init_VERSION init_dist init_INST init_INSTALL init_DEST init_dirscan
   init_PM init_MANPODS init_xs init_PERL init_DIRFILESEP init_linker
                           ];
  
      push @MM_Sections, qw[
  
   pm_to_blib selfdocument
  
                           ];
  
      # Postamble needs to be the last that was always the case
      push @MM_Sections, "postamble";
      push @Overridable, "postamble";
  
      # All sections are valid keys.
      @Recognized_Att_Keys{@MM_Sections} = (1) x @MM_Sections;
  
      # we will use all these variables in the Makefile
      @Get_from_Config =
          qw(
             ar cc cccdlflags ccdlflags dlext dlsrc exe_ext full_ar ld
             lddlflags ldflags libc lib_ext obj_ext osname osvers ranlib
             sitelibexp sitearchexp so
            );
  
      # 5.5.3 doesn't have any concept of vendor libs
      push @Get_from_Config, qw( vendorarchexp vendorlibexp ) if "$]" >= 5.006;
  
      foreach my $item (@attrib_help){
          $Recognized_Att_Keys{$item} = 1;
      }
      foreach my $item (@Get_from_Config) {
          $Recognized_Att_Keys{uc $item} = $Config{$item};
          print "Attribute '\U$item\E' => '$Config{$item}'\n"
              if ($Verbose >= 2);
      }
  
      #
      # When we eval a Makefile.PL in a subdirectory, that one will ask
      # us (the parent) for the values and will prepend "..", so that
      # all files to be installed end up below OUR ./blib
      #
      @Prepend_parent = qw(
             INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT
             MAP_TARGET INST_MAN1DIR INST_MAN3DIR PERL_SRC
             PERL FULLPERL
      );
  }
  
  sub _has_cpan_meta_requirements {
      return eval {
        require CPAN::Meta::Requirements;
        CPAN::Meta::Requirements->VERSION(2.130);
        require B; # CMR requires this, for core we have to too.
      };
  }
  
  sub new {
      my($class,$self) = @_;
      my($key);
  
      _convert_compat_attrs($self) if defined $self && $self;
  
      # Store the original args passed to WriteMakefile()
      foreach my $k (keys %$self) {
          $self->{ARGS}{$k} = $self->{$k};
      }
  
      $self = {} unless defined $self;
  
      # Temporarily bless it into MM so it can be used as an
      # object.  It will be blessed into a temp package later.
      bless $self, "MM";
  
      # Cleanup all the module requirement bits
      my %key2cmr;
      for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {
          $self->{$key}      ||= {};
          if (_has_cpan_meta_requirements) {
              my $cmr = CPAN::Meta::Requirements->from_string_hash(
                  $self->{$key},
                  {
                    bad_version_hook => sub {
                      #no warnings 'numeric'; # module doesn't use warnings
                      my $fallback;
                      if ( $_[0] =~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$! ) {
                        $fallback = sprintf "%f", $_[0];
                      } else {
                        ($fallback) = $_[0] ? ($_[0] =~ /^([0-9.]+)/) : 0;
                        $fallback += 0;
                        carp "Unparsable version '$_[0]' for prerequisite $_[1] treated as $fallback";
                      }
                      version->new($fallback);
                    },
                  },
              );
              $self->{$key} = $cmr->as_string_hash;
              $key2cmr{$key} = $cmr;
          } else {
              for my $module (sort keys %{ $self->{$key} }) {
                  my $version = $self->{$key}->{$module};
                  my $fallback = 0;
                  if (!defined($version) or !length($version)) {
                      carp "Undefined requirement for $module treated as '0' (CPAN::Meta::Requirements not available)";
                  }
                  elsif ($version =~ /^\d+(?:\.\d+(?:_\d+)*)?$/) {
                      next;
                  }
                  else {
                      if ( $version =~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$! ) {
                        $fallback = sprintf "%f", $version;
                      } else {
                        ($fallback) = $version ? ($version =~ /^([0-9.]+)/) : 0;
                        $fallback += 0;
                        carp "Unparsable version '$version' for prerequisite $module treated as $fallback (CPAN::Meta::Requirements not available)";
                      }
                  }
                  $self->{$key}->{$module} = $fallback;
              }
          }
      }
  
      if ("@ARGV" =~ /\bPREREQ_PRINT\b/) {
          $self->_PREREQ_PRINT;
      }
  
      # PRINT_PREREQ is RedHatism.
      if ("@ARGV" =~ /\bPRINT_PREREQ\b/) {
          $self->_PRINT_PREREQ;
     }
  
      print "MakeMaker (v$VERSION)\n" if $Verbose;
      if (-f "MANIFEST" && ! -f "Makefile" && ! $UNDER_CORE){
          check_manifest();
      }
  
      check_hints($self);
  
      if ( defined $self->{MIN_PERL_VERSION}
            && $self->{MIN_PERL_VERSION} !~ /^v?[\d_\.]+$/ ) {
        require version;
        my $normal = eval {
          local $SIG{__WARN__} = sub {
              # simulate "use warnings FATAL => 'all'" for vintage perls
              die @_;
          };
          version->new( $self->{MIN_PERL_VERSION} )
        };
        $self->{MIN_PERL_VERSION} = $normal if defined $normal && !$@;
      }
  
      # Translate X.Y.Z to X.00Y00Z
      if( defined $self->{MIN_PERL_VERSION} ) {
          $self->{MIN_PERL_VERSION} =~ s{ ^v? (\d+) \. (\d+) \. (\d+) $ }
                                        {sprintf "%d.%03d%03d", $1, $2, $3}ex;
      }
  
      my $perl_version_ok = eval {
          local $SIG{__WARN__} = sub {
              # simulate "use warnings FATAL => 'all'" for vintage perls
              die @_;
          };
          !$self->{MIN_PERL_VERSION} or $self->{MIN_PERL_VERSION} <= "$]"
      };
      if (!$perl_version_ok) {
          if (!defined $perl_version_ok) {
              die <<'END';
  Warning: MIN_PERL_VERSION is not in a recognized format.
  Recommended is a quoted numerical value like '5.005' or '5.008001'.
  END
          }
          elsif ($self->{PREREQ_FATAL}) {
              die sprintf <<"END", $self->{MIN_PERL_VERSION}, $];
  MakeMaker FATAL: perl version too low for this distribution.
  Required is %s. We run %s.
  END
          }
          else {
              warn sprintf
                  "Warning: Perl version %s or higher required. We run %s.\n",
                  $self->{MIN_PERL_VERSION}, $];
          }
      }
  
      my %configure_att;         # record &{$self->{CONFIGURE}} attributes
      my(%initial_att) = %$self; # record initial attributes
  
      my(%unsatisfied) = ();
      my %prereq2version;
      my $cmr;
      if (_has_cpan_meta_requirements) {
          $cmr = CPAN::Meta::Requirements->new;
          for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {
              $cmr->add_requirements($key2cmr{$key}) if $key2cmr{$key};
          }
          foreach my $prereq ($cmr->required_modules) {
              $prereq2version{$prereq} = $cmr->requirements_for_module($prereq);
          }
      } else {
          for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {
              next unless my $module2version = $self->{$key};
              $prereq2version{$_} = $module2version->{$_} for keys %$module2version;
          }
      }
      foreach my $prereq (sort keys %prereq2version) {
          my $required_version = $prereq2version{$prereq};
  
          my $pr_version = 0;
          my $installed_file;
  
          if ( $prereq eq 'perl' ) {
            if ( defined $required_version && $required_version =~ /^v?[\d_\.]+$/
                 || $required_version !~ /^v?[\d_\.]+$/ ) {
              require version;
              my $normal = eval { version->new( $required_version ) };
              $required_version = $normal if defined $normal;
            }
            $installed_file = $prereq;
            $pr_version = $];
          }
          else {
            $installed_file = MM->_installed_file_for_module($prereq);
            $pr_version = MM->parse_version($installed_file) if $installed_file;
            $pr_version = 0 if $pr_version eq 'undef';
            if ( !eval { version->new( $pr_version ); 1 } ) {
              #no warnings 'numeric'; # module doesn't use warnings
              my $fallback;
              if ( $pr_version =~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$! ) {
                $fallback = sprintf '%f', $pr_version;
              } else {
                ($fallback) = $pr_version ? ($pr_version =~ /^([0-9.]+)/) : 0;
                $fallback += 0;
                carp "Unparsable version '$pr_version' for installed prerequisite $prereq treated as $fallback";
              }
              $pr_version = $fallback;
            }
          }
  
          # convert X.Y_Z alpha version #s to X.YZ for easier comparisons
          $pr_version =~ s/(\d+)\.(\d+)_(\d+)/$1.$2$3/;
  
          if (!$installed_file) {
              warn sprintf "Warning: prerequisite %s %s not found.\n",
                $prereq, $required_version
                     unless $self->{PREREQ_FATAL}
                         or $UNDER_CORE;
  
              $unsatisfied{$prereq} = 'not installed';
          }
          elsif (
              $cmr
                  ? !$cmr->accepts_module($prereq, $pr_version)
                  : $required_version > $pr_version
          ) {
              warn sprintf "Warning: prerequisite %s %s not found. We have %s.\n",
                $prereq, $required_version, ($pr_version || 'unknown version')
                    unless $self->{PREREQ_FATAL}
                         or $UNDER_CORE;
  
              $unsatisfied{$prereq} = $required_version || 'unknown version' ;
          }
      }
  
      if (%unsatisfied && $self->{PREREQ_FATAL}){
          my $failedprereqs = join "\n", map {"    $_ $unsatisfied{$_}"}
                              sort { $a cmp $b } keys %unsatisfied;
          die <<"END";
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
      }
  
      if (defined $self->{CONFIGURE}) {
          if (ref $self->{CONFIGURE} eq 'CODE') {
              %configure_att = %{&{$self->{CONFIGURE}}};
              _convert_compat_attrs(\%configure_att);
              $self = { %$self, %configure_att };
          } else {
              croak "Attribute 'CONFIGURE' to WriteMakefile() not a code reference\n";
          }
      }
  
      my $newclass = ++$PACKNAME;
      local @Parent = @Parent;    # Protect against non-local exits
      {
          print "Blessing Object into class [$newclass]\n" if $Verbose>=2;
          mv_all_methods("MY",$newclass);
          bless $self, $newclass;
          push @Parent, $self;
          require ExtUtils::MY;
  
          no strict 'refs';   ## no critic;
          @{"$newclass\:\:ISA"} = 'MM';
      }
  
      if (defined $Parent[-2]){
          $self->{PARENT} = $Parent[-2];
          for my $key (@Prepend_parent) {
              next unless defined $self->{PARENT}{$key};
  
              # Don't stomp on WriteMakefile() args.
              next if defined $self->{ARGS}{$key} and
                      $self->{ARGS}{$key} eq $self->{$key};
  
              $self->{$key} = $self->{PARENT}{$key};
  
              if ($Is_VMS && $key =~ /PERL$/) {
                  # PERL or FULLPERL will be a command verb or even a
                  # command with an argument instead of a full file
                  # specification under VMS.  So, don't turn the command
                  # into a filespec, but do add a level to the path of
                  # the argument if not already absolute.
                  my @cmd = split /\s+/, $self->{$key};
                  $cmd[1] = $self->catfile('[-]',$cmd[1])
                    unless (@cmd < 2) || $self->file_name_is_absolute($cmd[1]);
                  $self->{$key} = join(' ', @cmd);
              } else {
                  my $value = $self->{$key};
                  # not going to test in FS so only stripping start
                  $value =~ s/"// if $key =~ /PERL$/ and $self->is_make_type('dmake');
                  $value =~ s/^"// if $key =~ /PERL$/;
                  $value = $self->catdir("..", $value)
                    unless $self->file_name_is_absolute($value);
                  $value = qq{"$value} if $key =~ /PERL$/;
                  $self->{$key} = $value;
              }
          }
          if ($self->{PARENT}) {
              $self->{PARENT}->{CHILDREN}->{$newclass} = $self;
              foreach my $opt (qw(POLLUTE PERL_CORE LINKTYPE AR FULL_AR CC CCFLAGS
                                  OPTIMIZE LD LDDLFLAGS LDFLAGS PERL_ARCHLIB DESTDIR)) {
                  if (exists $self->{PARENT}->{$opt}
                      and not exists $self->{$opt})
                      {
                          # inherit, but only if already unspecified
                          $self->{$opt} = $self->{PARENT}->{$opt};
                      }
              }
          }
          my @fm = grep /^FIRST_MAKEFILE=/, @ARGV;
          parse_args($self,@fm) if @fm;
      }
      else {
          parse_args($self, _shellwords($ENV{PERL_MM_OPT} || ''),@ARGV);
      }
  
      # RT#91540 PREREQ_FATAL not recognized on command line
      if (%unsatisfied && $self->{PREREQ_FATAL}){
          my $failedprereqs = join "\n", map {"    $_ $unsatisfied{$_}"}
                              sort { $a cmp $b } keys %unsatisfied;
          die <<"END";
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
      }
  
      $self->{NAME} ||= $self->guess_name;
  
      warn "Warning: NAME must be a package name\n"
        unless $self->{NAME} =~ m!^[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*$!;
  
      ($self->{NAME_SYM} = $self->{NAME}) =~ s/\W+/_/g;
  
      $self->init_MAKE;
      $self->init_main;
      $self->init_VERSION;
      $self->init_dist;
      $self->init_INST;
      $self->init_INSTALL;
      $self->init_DEST;
      $self->init_dirscan;
      $self->init_PM;
      $self->init_MANPODS;
      $self->init_xs;
      $self->init_PERL;
      $self->init_DIRFILESEP;
      $self->init_linker;
      $self->init_ABSTRACT;
  
      $self->arch_check(
          $INC{'Config.pm'},
          $self->catfile($Config{'archlibexp'}, "Config.pm")
      );
  
      $self->init_tools();
      $self->init_others();
      $self->init_platform();
      $self->init_PERM();
      my @args = @ARGV;
      @args = map { Encode::decode(locale => $_) } @args if $CAN_DECODE;
      my($argv) = neatvalue(\@args);
      $argv =~ s/^\[/(/;
      $argv =~ s/\]$/)/;
  
      push @{$self->{RESULT}}, <<END;
  # This Makefile is for the $self->{NAME} extension to perl.
  #
  # It was generated automatically by MakeMaker version
  # $VERSION (Revision: $Revision) from the contents of
  # Makefile.PL. Don't edit this file, edit Makefile.PL instead.
  #
  #       ANY CHANGES MADE HERE WILL BE LOST!
  #
  #   MakeMaker ARGV: $argv
  #
  END
  
      push @{$self->{RESULT}}, $self->_MakeMaker_Parameters_section(\%initial_att);
  
      if (defined $self->{CONFIGURE}) {
         push @{$self->{RESULT}}, <<END;
  
  #   MakeMaker 'CONFIGURE' Parameters:
  END
          if (scalar(keys %configure_att) > 0) {
              foreach my $key (sort keys %configure_att){
                 next if $key eq 'ARGS';
                 my($v) = neatvalue($configure_att{$key});
                 $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
                 $v =~ tr/\n/ /s;
                 push @{$self->{RESULT}}, "#     $key => $v";
              }
          }
          else
          {
             push @{$self->{RESULT}}, "# no values returned";
          }
          undef %configure_att;  # free memory
      }
  
      # turn the SKIP array into a SKIPHASH hash
      for my $skip (@{$self->{SKIP} || []}) {
          $self->{SKIPHASH}{$skip} = 1;
      }
      delete $self->{SKIP}; # free memory
  
      if ($self->{PARENT}) {
          for (qw/install dist dist_basics dist_core distdir dist_test dist_ci/) {
              $self->{SKIPHASH}{$_} = 1;
          }
      }
  
      # We run all the subdirectories now. They don't have much to query
      # from the parent, but the parent has to query them: if they need linking!
      unless ($self->{NORECURS}) {
          $self->eval_in_subdirs if @{$self->{DIR}};
      }
  
      foreach my $section ( @MM_Sections ){
          # Support for new foo_target() methods.
          my $method = $section;
          $method .= '_target' unless $self->can($method);
  
          print "Processing Makefile '$section' section\n" if ($Verbose >= 2);
          my($skipit) = $self->skipcheck($section);
          if ($skipit){
              push @{$self->{RESULT}}, "\n# --- MakeMaker $section section $skipit.";
          } else {
              my(%a) = %{$self->{$section} || {}};
              push @{$self->{RESULT}}, "\n# --- MakeMaker $section section:";
              push @{$self->{RESULT}}, "# " . join ", ", %a if $Verbose && %a;
              push @{$self->{RESULT}}, $self->maketext_filter(
                  $self->$method( %a )
              );
          }
      }
  
      push @{$self->{RESULT}}, "\n# End.";
  
      $self;
  }
  
  sub WriteEmptyMakefile {
      croak "WriteEmptyMakefile: Need an even number of args" if @_ % 2;
  
      my %att = @_;
      $att{DIR} = [] unless $att{DIR}; # don't recurse by default
      my $self = MM->new(\%att);
  
      my $new = $self->{MAKEFILE};
      my $old = $self->{MAKEFILE_OLD};
      if (-f $old) {
          _unlink($old) or warn "unlink $old: $!";
      }
      if ( -f $new ) {
          _rename($new, $old) or warn "rename $new => $old: $!"
      }
      open my $mfh, '>', $new or die "open $new for write: $!";
      print $mfh <<'EOP';
  all :
  
  manifypods :
  
  subdirs :
  
  dynamic :
  
  static :
  
  clean :
  
  install :
  
  makemakerdflt :
  
  test :
  
  test_dynamic :
  
  test_static :
  
  EOP
      close $mfh or die "close $new for write: $!";
  }
  
  
  =begin private
  
  =head3 _installed_file_for_module
  
    my $file = MM->_installed_file_for_module($module);
  
  Return the first installed .pm $file associated with the $module.  The
  one which will show up when you C<use $module>.
  
  $module is something like "strict" or "Test::More".
  
  =end private
  
  =cut
  
  sub _installed_file_for_module {
      my $class  = shift;
      my $prereq = shift;
  
      my $file = "$prereq.pm";
      $file =~ s{::}{/}g;
  
      my $path;
      for my $dir (@INC) {
          my $tmp = File::Spec->catfile($dir, $file);
          if ( -r $tmp ) {
              $path = $tmp;
              last;
          }
      }
  
      return $path;
  }
  
  
  # Extracted from MakeMaker->new so we can test it
  sub _MakeMaker_Parameters_section {
      my $self = shift;
      my $att  = shift;
  
      my @result = <<'END';
  #   MakeMaker Parameters:
  END
  
      foreach my $key (sort keys %$att){
          next if $key eq 'ARGS';
          my $v;
          if ($key eq 'PREREQ_PM') {
              # CPAN.pm takes prereqs from this field in 'Makefile'
              # and does not know about BUILD_REQUIRES
              $v = neatvalue({
                  %{ $att->{PREREQ_PM} || {} },
                  %{ $att->{BUILD_REQUIRES} || {} },
                  %{ $att->{TEST_REQUIRES} || {} },
              });
          } else {
              $v = neatvalue($att->{$key});
          }
  
          $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
          $v =~ tr/\n/ /s;
          push @result, "#     $key => $v";
      }
  
      return @result;
  }
  
  # _shellwords and _parseline borrowed from Text::ParseWords
  sub _shellwords {
      my (@lines) = @_;
      my @allwords;
  
      foreach my $line (@lines) {
        $line =~ s/^\s+//;
        my @words = _parse_line('\s+', 0, $line);
        pop @words if (@words and !defined $words[-1]);
        return() unless (@words || !length($line));
        push(@allwords, @words);
      }
      return(@allwords);
  }
  
  sub _parse_line {
      my($delimiter, $keep, $line) = @_;
      my($word, @pieces);
  
      no warnings 'uninitialized';  # we will be testing undef strings
  
      while (length($line)) {
          # This pattern is optimised to be stack conservative on older perls.
          # Do not refactor without being careful and testing it on very long strings.
          # See Perl bug #42980 for an example of a stack busting input.
          $line =~ s/^
                      (?:
                          # double quoted string
                          (")                             # $quote
                          ((?>[^\\"]*(?:\\.[^\\"]*)*))"   # $quoted
          | # --OR--
                          # singe quoted string
                          (')                             # $quote
                          ((?>[^\\']*(?:\\.[^\\']*)*))'   # $quoted
                      |   # --OR--
                          # unquoted string
              (                               # $unquoted
                              (?:\\.|[^\\"'])*?
                          )
                          # followed by
              (                               # $delim
                              \Z(?!\n)                    # EOL
                          |   # --OR--
                              (?-x:$delimiter)            # delimiter
                          |   # --OR--
                              (?!^)(?=["'])               # a quote
                          )
          )//xs or return;    # extended layout
          my ($quote, $quoted, $unquoted, $delim) = (($1 ? ($1,$2) : ($3,$4)), $5, $6);
  
  
    return() unless( defined($quote) || length($unquoted) || length($delim));
  
          if ($keep) {
        $quoted = "$quote$quoted$quote";
    }
          else {
        $unquoted =~ s/\\(.)/$1/sg;
        if (defined $quote) {
      $quoted =~ s/\\(.)/$1/sg if ($quote eq '"');
      #$quoted =~ s/\\([\\'])/$1/g if ( $PERL_SINGLE_QUOTE && $quote eq "'");
              }
    }
          $word .= substr($line, 0, 0); # leave results tainted
          $word .= defined $quote ? $quoted : $unquoted;
  
          if (length($delim)) {
              push(@pieces, $word);
              push(@pieces, $delim) if ($keep eq 'delimiters');
              undef $word;
          }
          if (!length($line)) {
              push(@pieces, $word);
    }
      }
      return(@pieces);
  }
  
  sub check_manifest {
      print "Checking if your kit is complete...\n";
      require ExtUtils::Manifest;
      # avoid warning
      $ExtUtils::Manifest::Quiet = $ExtUtils::Manifest::Quiet = 1;
      my(@missed) = ExtUtils::Manifest::manicheck();
      if (@missed) {
          print "Warning: the following files are missing in your kit:\n";
          print "\t", join "\n\t", @missed;
          print "\n";
          print "Please inform the author.\n";
      } else {
          print "Looks good\n";
      }
  }
  
  sub parse_args{
      my($self, @args) = @_;
      @args = map { Encode::decode(locale => $_) } @args if $CAN_DECODE;
      foreach (@args) {
          unless (m/(.*?)=(.*)/) {
              ++$Verbose if m/^verb/;
              next;
          }
          my($name, $value) = ($1, $2);
          if ($value =~ m/^~(\w+)?/) { # tilde with optional username
              $value =~ s [^~(\w*)]
                  [$1 ?
                   ((getpwnam($1))[7] || "~$1") :
                   (getpwuid($>))[7]
                   ]ex;
          }
  
          # Remember the original args passed it.  It will be useful later.
          $self->{ARGS}{uc $name} = $self->{uc $name} = $value;
      }
  
      # catch old-style 'potential_libs' and inform user how to 'upgrade'
      if (defined $self->{potential_libs}){
          my($msg)="'potential_libs' => '$self->{potential_libs}' should be";
          if ($self->{potential_libs}){
              print "$msg changed to:\n\t'LIBS' => ['$self->{potential_libs}']\n";
          } else {
              print "$msg deleted.\n";
          }
          $self->{LIBS} = [$self->{potential_libs}];
          delete $self->{potential_libs};
      }
      # catch old-style 'ARMAYBE' and inform user how to 'upgrade'
      if (defined $self->{ARMAYBE}){
          my($armaybe) = $self->{ARMAYBE};
          print "ARMAYBE => '$armaybe' should be changed to:\n",
                          "\t'dynamic_lib' => {ARMAYBE => '$armaybe'}\n";
          my(%dl) = %{$self->{dynamic_lib} || {}};
          $self->{dynamic_lib} = { %dl, ARMAYBE => $armaybe};
          delete $self->{ARMAYBE};
      }
      if (defined $self->{LDTARGET}){
          print "LDTARGET should be changed to LDFROM\n";
          $self->{LDFROM} = $self->{LDTARGET};
          delete $self->{LDTARGET};
      }
      # Turn a DIR argument on the command line into an array
      if (defined $self->{DIR} && ref \$self->{DIR} eq 'SCALAR') {
          # So they can choose from the command line, which extensions they want
          # the grep enables them to have some colons too much in case they
          # have to build a list with the shell
          $self->{DIR} = [grep $_, split ":", $self->{DIR}];
      }
      # Turn a INCLUDE_EXT argument on the command line into an array
      if (defined $self->{INCLUDE_EXT} && ref \$self->{INCLUDE_EXT} eq 'SCALAR') {
          $self->{INCLUDE_EXT} = [grep $_, split '\s+', $self->{INCLUDE_EXT}];
      }
      # Turn a EXCLUDE_EXT argument on the command line into an array
      if (defined $self->{EXCLUDE_EXT} && ref \$self->{EXCLUDE_EXT} eq 'SCALAR') {
          $self->{EXCLUDE_EXT} = [grep $_, split '\s+', $self->{EXCLUDE_EXT}];
      }
  
      foreach my $mmkey (sort keys %$self){
          next if $mmkey eq 'ARGS';
          print "  $mmkey => ", neatvalue($self->{$mmkey}), "\n" if $Verbose;
          print "'$mmkey' is not a known MakeMaker parameter name.\n"
              unless exists $Recognized_Att_Keys{$mmkey};
      }
      $| = 1 if $Verbose;
  }
  
  sub check_hints {
      my($self) = @_;
      # We allow extension-specific hints files.
  
      require File::Spec;
      my $curdir = File::Spec->curdir;
  
      my $hint_dir = File::Spec->catdir($curdir, "hints");
      return unless -d $hint_dir;
  
      # First we look for the best hintsfile we have
      my($hint)="${^O}_$Config{osvers}";
      $hint =~ s/\./_/g;
      $hint =~ s/_$//;
      return unless $hint;
  
      # Also try without trailing minor version numbers.
      while (1) {
          last if -f File::Spec->catfile($hint_dir, "$hint.pl");  # found
      } continue {
          last unless $hint =~ s/_[^_]*$//; # nothing to cut off
      }
      my $hint_file = File::Spec->catfile($hint_dir, "$hint.pl");
  
      return unless -f $hint_file;    # really there
  
      _run_hintfile($self, $hint_file);
  }
  
  sub _run_hintfile {
      our $self;
      local($self) = shift;       # make $self available to the hint file.
      my($hint_file) = shift;
  
      local($@, $!);
      print "Processing hints file $hint_file\n" if $Verbose;
  
      # Just in case the ./ isn't on the hint file, which File::Spec can
      # often strip off, we bung the curdir into @INC
      local @INC = (File::Spec->curdir, @INC);
      my $ret = do $hint_file;
      if( !defined $ret ) {
          my $error = $@ || $!;
          warn $error;
      }
  }
  
  sub mv_all_methods {
      my($from,$to) = @_;
      local $SIG{__WARN__} = sub {
          # can't use 'no warnings redefined', 5.6 only
          warn @_ unless $_[0] =~ /^Subroutine .* redefined/
      };
      foreach my $method (@Overridable) {
          next unless defined &{"${from}::$method"};
          no strict 'refs';   ## no critic
          *{"${to}::$method"} = \&{"${from}::$method"};
  
          # If we delete a method, then it will be undefined and cannot
          # be called.  But as long as we have Makefile.PLs that rely on
          # %MY:: being intact, we have to fill the hole with an
          # inheriting method:
  
          {
              package MY;
              my $super = "SUPER::".$method;
              *{$method} = sub {
                  shift->$super(@_);
              };
          }
      }
  }
  
  sub skipcheck {
      my($self) = shift;
      my($section) = @_;
      return 'skipped' if $section eq 'metafile' && $UNDER_CORE;
      if ($section eq 'dynamic') {
          print "Warning (non-fatal): Target 'dynamic' depends on targets ",
          "in skipped section 'dynamic_bs'\n"
              if $self->{SKIPHASH}{dynamic_bs} && $Verbose;
          print "Warning (non-fatal): Target 'dynamic' depends on targets ",
          "in skipped section 'dynamic_lib'\n"
              if $self->{SKIPHASH}{dynamic_lib} && $Verbose;
      }
      if ($section eq 'dynamic_lib') {
          print "Warning (non-fatal): Target '\$(INST_DYNAMIC)' depends on ",
          "targets in skipped section 'dynamic_bs'\n"
              if $self->{SKIPHASH}{dynamic_bs} && $Verbose;
      }
      if ($section eq 'static') {
          print "Warning (non-fatal): Target 'static' depends on targets ",
          "in skipped section 'static_lib'\n"
              if $self->{SKIPHASH}{static_lib} && $Verbose;
      }
      return 'skipped' if $self->{SKIPHASH}{$section};
      return '';
  }
  
  # returns filehandle, dies on fail. :raw so no :crlf
  sub open_for_writing {
      my ($file) = @_;
      open my $fh ,">", $file or die "Unable to open $file: $!";
      my @layers = ':raw';
      push @layers, join ' ', ':encoding(locale)' if $CAN_DECODE;
      binmode $fh, join ' ', @layers;
      $fh;
  }
  
  sub flush {
      my $self = shift;
  
      my $finalname = $self->{MAKEFILE};
      printf "Generating a %s %s\n", $self->make_type, $finalname if $Verbose || !$self->{PARENT};
      print "Writing $finalname for $self->{NAME}\n" if $Verbose || !$self->{PARENT};
  
      unlink($finalname, "MakeMaker.tmp", $Is_VMS ? 'Descrip.MMS' : ());
  
      write_file_via_tmp($finalname, $self->{RESULT});
  
      # Write MYMETA.yml to communicate metadata up to the CPAN clients
      print "Writing MYMETA.yml and MYMETA.json\n"
        if !$self->{NO_MYMETA} and $self->write_mymeta( $self->mymeta );
  
      # save memory
      if ($self->{PARENT} && !$self->{_KEEP_AFTER_FLUSH}) {
          my %keep = map { ($_ => 1) } qw(NEEDS_LINKING HAS_LINK_CODE);
          delete $self->{$_} for grep !$keep{$_}, keys %$self;
      }
  
      system("$Config::Config{eunicefix} $finalname")
        if $Config::Config{eunicefix} ne ":";
  
      return;
  }
  
  sub write_file_via_tmp {
      my ($finalname, $contents) = @_;
      my $fh = open_for_writing("MakeMaker.tmp");
      die "write_file_via_tmp: 2nd arg must be ref" unless ref $contents;
      for my $chunk (@$contents) {
          my $to_write = $chunk;
          utf8::encode $to_write if !$CAN_DECODE && "$]" > 5.008;
          print $fh "$to_write\n" or die "Can't write to MakeMaker.tmp: $!";
      }
      close $fh or die "Can't write to MakeMaker.tmp: $!";
      _rename("MakeMaker.tmp", $finalname) or
        warn "rename MakeMaker.tmp => $finalname: $!";
      chmod 0644, $finalname if !$Is_VMS;
      return;
  }
  
  # This is a rename for OS's where the target must be unlinked first.
  sub _rename {
      my($src, $dest) = @_;
      _unlink($dest);
      return rename $src, $dest;
  }
  
  # This is an unlink for OS's where the target must be writable first.
  sub _unlink {
      my @files = @_;
      chmod 0666, @files;
      return unlink @files;
  }
  
  
  # The following mkbootstrap() is only for installations that are calling
  # the pre-4.1 mkbootstrap() from their old Makefiles. This MakeMaker
  # writes Makefiles, that use ExtUtils::Mkbootstrap directly.
  sub mkbootstrap {
      die <<END;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  }
  
  # Ditto for mksymlists() as of MakeMaker 5.17
  sub mksymlists {
      die <<END;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  }
  
  sub neatvalue {
      my($v) = @_;
      return "undef" unless defined $v;
      my($t) = ref $v;
      return "q[$v]" unless $t;
      if ($t eq 'ARRAY') {
          my(@m, @neat);
          push @m, "[";
          foreach my $elem (@$v) {
              push @neat, "q[$elem]";
          }
          push @m, join ", ", @neat;
          push @m, "]";
          return join "", @m;
      }
      return $v unless $t eq 'HASH';
      my(@m, $key, $val);
      for my $key (sort keys %$v) {
          last unless defined $key; # cautious programming in case (undef,undef) is true
          push @m,"$key=>".neatvalue($v->{$key});
      }
      return "{ ".join(', ',@m)." }";
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      return $value if $UNDER_CORE;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
          if ( $magic->TYPE eq 'V' ) {
              $tvalue = $magic->PTR;
              $tvalue =~ s/^v?(.+)$/v$1/;
              last;
          }
          else {
              $magic = $magic->MOREMAGIC;
          }
      }
      return $tvalue;
  }
  
  sub selfdocument {
      my($self) = @_;
      my(@m);
      if ($Verbose){
          push @m, "\n# Full list of MakeMaker attribute values:";
          foreach my $key (sort keys %$self){
              next if $key eq 'RESULT' || $key =~ /^[A-Z][a-z]/;
              my($v) = neatvalue($self->{$key});
              $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
              $v =~ tr/\n/ /s;
              push @m, "# $key => $v";
          }
      }
      # added here as selfdocument is not overridable
      push @m, <<'EOF';
  
  # here so even if top_targets is overridden, these will still be defined
  # gmake will silently still work if any are .PHONY-ed but nmake won't
  EOF
      push @m, join "\n", map "$_ ::\n\t\$(NOECHO) \$(NOOP)\n",
          # config is so manifypods won't puke if no subdirs
          grep !$self->{SKIPHASH}{$_},
          qw(static dynamic config);
      join "\n", @m;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::MakeMaker - Create a module Makefile
  
  =head1 SYNOPSIS
  
    use ExtUtils::MakeMaker;
  
    WriteMakefile(
        NAME              => "Foo::Bar",
        VERSION_FROM      => "lib/Foo/Bar.pm",
    );
  
  =head1 DESCRIPTION
  
  This utility is designed to write a Makefile for an extension module
  from a Makefile.PL. It is based on the Makefile.SH model provided by
  Andy Dougherty and the perl5-porters.
  
  It splits the task of generating the Makefile into several subroutines
  that can be individually overridden.  Each subroutine returns the text
  it wishes to have written to the Makefile.
  
  As there are various Make programs with incompatible syntax, which
  use operating system shells, again with incompatible syntax, it is
  important for users of this module to know which flavour of Make
  a Makefile has been written for so they'll use the correct one and
  won't have to face the possibly bewildering errors resulting from
  using the wrong one.
  
  On POSIX systems, that program will likely be GNU Make; on Microsoft
  Windows, it will be either Microsoft NMake, DMake or GNU Make.
  See the section on the L</"MAKE"> parameter for details.
  
  ExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current
  directory that contains a Makefile.PL is treated as a separate
  object. This makes it possible to write an unlimited number of
  Makefiles with a single invocation of WriteMakefile().
  
  All inputs to WriteMakefile are Unicode characters, not just octets. EUMM
  seeks to handle all of these correctly. It is currently still not possible
  to portably use Unicode characters in module names, because this requires
  Perl to handle Unicode filenames, which is not yet the case on Windows.
  
  =head2 How To Write A Makefile.PL
  
  See L<ExtUtils::MakeMaker::Tutorial>.
  
  The long answer is the rest of the manpage :-)
  
  =head2 Default Makefile Behaviour
  
  The generated Makefile enables the user of the extension to invoke
  
    perl Makefile.PL # optionally "perl Makefile.PL verbose"
    make
    make test        # optionally set TEST_VERBOSE=1
    make install     # See below
  
  The Makefile to be produced may be altered by adding arguments of the
  form C<KEY=VALUE>. E.g.
  
    perl Makefile.PL INSTALL_BASE=~
  
  Other interesting targets in the generated Makefile are
  
    make config     # to check if the Makefile is up-to-date
    make clean      # delete local temp files (Makefile gets renamed)
    make realclean  # delete derived files (including ./blib)
    make ci         # check in all the files in the MANIFEST file
    make dist       # see below the Distribution Support section
  
  =head2 make test
  
  MakeMaker checks for the existence of a file named F<test.pl> in the
  current directory, and if it exists it executes the script with the
  proper set of perl C<-I> options.
  
  MakeMaker also checks for any files matching glob("t/*.t"). It will
  execute all matching files in alphabetical order via the
  L<Test::Harness> module with the C<-I> switches set correctly.
  
  You can also organize your tests within subdirectories in the F<t/> directory.
  To do so, use the F<test> directive in your I<Makefile.PL>. For example, if you
  had tests in:
  
      t/foo
      t/foo/bar
  
  You could tell make to run tests in both of those directories with the
  following directives:
  
      test => {TESTS => 't/*/*.t t/*/*/*.t'}
      test => {TESTS => 't/foo/*.t t/foo/bar/*.t'}
  
  The first will run all test files in all first-level subdirectories and all
  subdirectories they contain. The second will run tests in only the F<t/foo>
  and F<t/foo/bar>.
  
  If you'd like to see the raw output of your tests, set the
  C<TEST_VERBOSE> variable to true.
  
    make test TEST_VERBOSE=1
  
  If you want to run particular test files, set the C<TEST_FILES> variable.
  It is possible to use globbing with this mechanism.
  
    make test TEST_FILES='t/foobar.t t/dagobah*.t'
  
  Windows users who are using C<nmake> should note that due to a bug in C<nmake>,
  when specifying C<TEST_FILES> you must use back-slashes instead of forward-slashes.
  
    nmake test TEST_FILES='t\foobar.t t\dagobah*.t'
  
  =head2 make testdb
  
  A useful variation of the above is the target C<testdb>. It runs the
  test under the Perl debugger (see L<perldebug>). If the file
  F<test.pl> exists in the current directory, it is used for the test.
  
  If you want to debug some other testfile, set the C<TEST_FILE> variable
  thusly:
  
    make testdb TEST_FILE=t/mytest.t
  
  By default the debugger is called using C<-d> option to perl. If you
  want to specify some other option, set the C<TESTDB_SW> variable:
  
    make testdb TESTDB_SW=-Dx
  
  =head2 make install
  
  make alone puts all relevant files into directories that are named by
  the macros INST_LIB, INST_ARCHLIB, INST_SCRIPT, INST_MAN1DIR and
  INST_MAN3DIR.  All these default to something below ./blib if you are
  I<not> building below the perl source directory. If you I<are>
  building below the perl source, INST_LIB and INST_ARCHLIB default to
  ../../lib, and INST_SCRIPT is not defined.
  
  The I<install> target of the generated Makefile copies the files found
  below each of the INST_* directories to their INSTALL*
  counterparts. Which counterparts are chosen depends on the setting of
  INSTALLDIRS according to the following table:
  
                                   INSTALLDIRS set to
                             perl        site          vendor
  
                   PERLPREFIX      SITEPREFIX          VENDORPREFIX
    INST_ARCHLIB   INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
    INST_LIB       INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
    INST_BIN       INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
    INST_SCRIPT    INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
    INST_MAN1DIR   INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
    INST_MAN3DIR   INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR
  
  The INSTALL... macros in turn default to their %Config
  ($Config{installprivlib}, $Config{installarchlib}, etc.) counterparts.
  
  You can check the values of these variables on your system with
  
      perl '-V:install.*'
  
  And to check the sequence in which the library directories are
  searched by perl, run
  
      perl -le 'print join $/, @INC'
  
  Sometimes older versions of the module you're installing live in other
  directories in @INC.  Because Perl loads the first version of a module it
  finds, not the newest, you might accidentally get one of these older
  versions even after installing a brand new version.  To delete I<all other
  versions of the module you're installing> (not simply older ones) set the
  C<UNINST> variable.
  
      make install UNINST=1
  
  
  =head2 INSTALL_BASE
  
  INSTALL_BASE can be passed into Makefile.PL to change where your
  module will be installed.  INSTALL_BASE is more like what everyone
  else calls "prefix" than PREFIX is.
  
  To have everything installed in your home directory, do the following.
  
      # Unix users, INSTALL_BASE=~ works fine
      perl Makefile.PL INSTALL_BASE=/path/to/your/home/dir
  
  Like PREFIX, it sets several INSTALL* attributes at once.  Unlike
  PREFIX it is easy to predict where the module will end up.  The
  installation pattern looks like this:
  
      INSTALLARCHLIB     INSTALL_BASE/lib/perl5/$Config{archname}
      INSTALLPRIVLIB     INSTALL_BASE/lib/perl5
      INSTALLBIN         INSTALL_BASE/bin
      INSTALLSCRIPT      INSTALL_BASE/bin
      INSTALLMAN1DIR     INSTALL_BASE/man/man1
      INSTALLMAN3DIR     INSTALL_BASE/man/man3
  
  INSTALL_BASE in MakeMaker and C<--install_base> in Module::Build (as
  of 0.28) install to the same location.  If you want MakeMaker and
  Module::Build to install to the same location simply set INSTALL_BASE
  and C<--install_base> to the same location.
  
  INSTALL_BASE was added in 6.31.
  
  
  =head2 PREFIX and LIB attribute
  
  PREFIX and LIB can be used to set several INSTALL* attributes in one
  go.  Here's an example for installing into your home directory.
  
      # Unix users, PREFIX=~ works fine
      perl Makefile.PL PREFIX=/path/to/your/home/dir
  
  This will install all files in the module under your home directory,
  with man pages and libraries going into an appropriate place (usually
  ~/man and ~/lib).  How the exact location is determined is complicated
  and depends on how your Perl was configured.  INSTALL_BASE works more
  like what other build systems call "prefix" than PREFIX and we
  recommend you use that instead.
  
  Another way to specify many INSTALL directories with a single
  parameter is LIB.
  
      perl Makefile.PL LIB=~/lib
  
  This will install the module's architecture-independent files into
  ~/lib, the architecture-dependent files into ~/lib/$archname.
  
  Note, that in both cases the tilde expansion is done by MakeMaker, not
  by perl by default, nor by make.
  
  Conflicts between parameters LIB, PREFIX and the various INSTALL*
  arguments are resolved so that:
  
  =over 4
  
  =item *
  
  setting LIB overrides any setting of INSTALLPRIVLIB, INSTALLARCHLIB,
  INSTALLSITELIB, INSTALLSITEARCH (and they are not affected by PREFIX);
  
  =item *
  
  without LIB, setting PREFIX replaces the initial C<$Config{prefix}>
  part of those INSTALL* arguments, even if the latter are explicitly
  set (but are set to still start with C<$Config{prefix}>).
  
  =back
  
  If the user has superuser privileges, and is not working on AFS or
  relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB,
  INSTALLSCRIPT, etc. will be appropriate, and this incantation will be
  the best:
  
      perl Makefile.PL;
      make;
      make test
      make install
  
  make install by default writes some documentation of what has been
  done into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This feature
  can be bypassed by calling make pure_install.
  
  =head2 AFS users
  
  will have to specify the installation directories as these most
  probably have changed since perl itself has been installed. They will
  have to do this by calling
  
      perl Makefile.PL INSTALLSITELIB=/afs/here/today \
          INSTALLSCRIPT=/afs/there/now INSTALLMAN3DIR=/afs/for/manpages
      make
  
  Be careful to repeat this procedure every time you recompile an
  extension, unless you are sure the AFS installation directories are
  still valid.
  
  =head2 Static Linking of a new Perl Binary
  
  An extension that is built with the above steps is ready to use on
  systems supporting dynamic loading. On systems that do not support
  dynamic loading, any newly created extension has to be linked together
  with the available resources. MakeMaker supports the linking process
  by creating appropriate targets in the Makefile whenever an extension
  is built. You can invoke the corresponding section of the makefile with
  
      make perl
  
  That produces a new perl binary in the current directory with all
  extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP,
  and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on
  UNIX, this is called F<Makefile.aperl> (may be system dependent). If you
  want to force the creation of a new perl, it is recommended that you
  delete this F<Makefile.aperl>, so the directories are searched through
  for linkable libraries again.
  
  The binary can be installed into the directory where perl normally
  resides on your machine with
  
      make inst_perl
  
  To produce a perl binary with a different name than C<perl>, either say
  
      perl Makefile.PL MAP_TARGET=myperl
      make myperl
      make inst_perl
  
  or say
  
      perl Makefile.PL
      make myperl MAP_TARGET=myperl
      make inst_perl MAP_TARGET=myperl
  
  In any case you will be prompted with the correct invocation of the
  C<inst_perl> target that installs the new binary into INSTALLBIN.
  
  make inst_perl by default writes some documentation of what has been
  done into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This
  can be bypassed by calling make pure_inst_perl.
  
  Warning: the inst_perl: target will most probably overwrite your
  existing perl binary. Use with care!
  
  Sometimes you might want to build a statically linked perl although
  your system supports dynamic loading. In this case you may explicitly
  set the linktype with the invocation of the Makefile.PL or make:
  
      perl Makefile.PL LINKTYPE=static    # recommended
  
  or
  
      make LINKTYPE=static                # works on most systems
  
  =head2 Determination of Perl Library and Installation Locations
  
  MakeMaker needs to know, or to guess, where certain things are
  located.  Especially INST_LIB and INST_ARCHLIB (where to put the files
  during the make(1) run), PERL_LIB and PERL_ARCHLIB (where to read
  existing modules from), and PERL_INC (header files and C<libperl*.*>).
  
  Extensions may be built either using the contents of the perl source
  directory tree or from the installed perl library. The recommended way
  is to build extensions after you have run 'make install' on perl
  itself. You can do that in any directory on your hard disk that is not
  below the perl source tree. The support for extensions below the ext
  directory of the perl distribution is only good for the standard
  extensions that come with perl.
  
  If an extension is being built below the C<ext/> directory of the perl
  source then MakeMaker will set PERL_SRC automatically (e.g.,
  C<../..>).  If PERL_SRC is defined and the extension is recognized as
  a standard extension, then other variables default to the following:
  
    PERL_INC     = PERL_SRC
    PERL_LIB     = PERL_SRC/lib
    PERL_ARCHLIB = PERL_SRC/lib
    INST_LIB     = PERL_LIB
    INST_ARCHLIB = PERL_ARCHLIB
  
  If an extension is being built away from the perl source then MakeMaker
  will leave PERL_SRC undefined and default to using the installed copy
  of the perl library. The other variables default to the following:
  
    PERL_INC     = $archlibexp/CORE
    PERL_LIB     = $privlibexp
    PERL_ARCHLIB = $archlibexp
    INST_LIB     = ./blib/lib
    INST_ARCHLIB = ./blib/arch
  
  If perl has not yet been installed then PERL_SRC can be defined on the
  command line as shown in the previous section.
  
  
  =head2 Which architecture dependent directory?
  
  If you don't want to keep the defaults for the INSTALL* macros,
  MakeMaker helps you to minimize the typing needed: the usual
  relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined
  by Configure at perl compilation time. MakeMaker supports the user who
  sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not,
  then MakeMaker defaults the latter to be the same subdirectory of
  INSTALLPRIVLIB as Configure decided for the counterparts in %Config,
  otherwise it defaults to INSTALLPRIVLIB. The same relationship holds
  for INSTALLSITELIB and INSTALLSITEARCH.
  
  MakeMaker gives you much more freedom than needed to configure
  internal variables and get different results. It is worth mentioning
  that make(1) also lets you configure most of the variables that are
  used in the Makefile. But in the majority of situations this will not
  be necessary, and should only be done if the author of a package
  recommends it (or you know what you're doing).
  
  =head2 Using Attributes and Parameters
  
  The following attributes may be specified as arguments to WriteMakefile()
  or as NAME=VALUE pairs on the command line. Attributes that became
  available with later versions of MakeMaker are indicated.
  
  In order to maintain portability of attributes with older versions of
  MakeMaker you may want to use L<App::EUMM::Upgrade> with your C<Makefile.PL>.
  
  =over 2
  
  =item ABSTRACT
  
  One line description of the module. Will be included in PPD file.
  
  =item ABSTRACT_FROM
  
  Name of the file that contains the package description. MakeMaker looks
  for a line in the POD matching /^($package\s-\s)(.*)/. This is typically
  the first line in the "=head1 NAME" section. $2 becomes the abstract.
  
  =item AUTHOR
  
  Array of strings containing name (and email address) of package author(s).
  Is used in CPAN Meta files (META.yml or META.json) and PPD
  (Perl Package Description) files for PPM (Perl Package Manager).
  
  =item BINARY_LOCATION
  
  Used when creating PPD files for binary packages.  It can be set to a
  full or relative path or URL to the binary archive for a particular
  architecture.  For example:
  
          perl Makefile.PL BINARY_LOCATION=x86/Agent.tar.gz
  
  builds a PPD package that references a binary of the C<Agent> package,
  located in the C<x86> directory relative to the PPD itself.
  
  =item BUILD_REQUIRES
  
  Available in version 6.55_03 and above.
  
  A hash of modules that are needed to build your module but not run it.
  
  This will go into the C<build_requires> field of your F<META.yml> and the C<build> of the C<prereqs> field of your F<META.json>.
  
  Defaults to C<<< { "ExtUtils::MakeMaker" => 0 } >>> if this attribute is not specified.
  
  The format is the same as PREREQ_PM.
  
  =item C
  
  Ref to array of *.c file names. Initialised from a directory scan
  and the values portion of the XS attribute hash. This is not
  currently used by MakeMaker but may be handy in Makefile.PLs.
  
  =item CCFLAGS
  
  String that will be included in the compiler call command line between
  the arguments INC and OPTIMIZE.
  
  =item CONFIG
  
  Arrayref. E.g. [qw(archname manext)] defines ARCHNAME & MANEXT from
  config.sh. MakeMaker will add to CONFIG the following values anyway:
  ar
  cc
  cccdlflags
  ccdlflags
  dlext
  dlsrc
  ld
  lddlflags
  ldflags
  libc
  lib_ext
  obj_ext
  ranlib
  sitelibexp
  sitearchexp
  so
  
  =item CONFIGURE
  
  CODE reference. The subroutine should return a hash reference. The
  hash may contain further attributes, e.g. {LIBS =E<gt> ...}, that have to
  be determined by some evaluation method.
  
  =item CONFIGURE_REQUIRES
  
  Available in version 6.52 and above.
  
  A hash of modules that are required to run Makefile.PL itself, but not
  to run your distribution.
  
  This will go into the C<configure_requires> field of your F<META.yml> and the C<configure> of the C<prereqs> field of your F<META.json>.
  
  Defaults to C<<< { "ExtUtils::MakeMaker" => 0 } >>> if this attribute is not specified.
  
  The format is the same as PREREQ_PM.
  
  =item DEFINE
  
  Something like C<"-DHAVE_UNISTD_H">
  
  =item DESTDIR
  
  This is the root directory into which the code will be installed.  It
  I<prepends itself to the normal prefix>.  For example, if your code
  would normally go into F</usr/local/lib/perl> you could set DESTDIR=~/tmp/
  and installation would go into F<~/tmp/usr/local/lib/perl>.
  
  This is primarily of use for people who repackage Perl modules.
  
  NOTE: Due to the nature of make, it is important that you put the trailing
  slash on your DESTDIR.  F<~/tmp/> not F<~/tmp>.
  
  =item DIR
  
  Ref to array of subdirectories containing Makefile.PLs e.g. ['sdbm']
  in ext/SDBM_File
  
  =item DISTNAME
  
  A safe filename for the package.
  
  Defaults to NAME below but with :: replaced with -.
  
  For example, Foo::Bar becomes Foo-Bar.
  
  =item DISTVNAME
  
  Your name for distributing the package with the version number
  included.  This is used by 'make dist' to name the resulting archive
  file.
  
  Defaults to DISTNAME-VERSION.
  
  For example, version 1.04 of Foo::Bar becomes Foo-Bar-1.04.
  
  On some OS's where . has special meaning VERSION_SYM may be used in
  place of VERSION.
  
  =item DLEXT
  
  Specifies the extension of the module's loadable object. For example:
  
    DLEXT => 'unusual_ext', # Default value is $Config{so}
  
  NOTE: When using this option to alter the extension of a module's
  loadable object, it is also necessary that the module's pm file
  specifies the same change:
  
    local $DynaLoader::dl_dlext = 'unusual_ext';
  
  =item DL_FUNCS
  
  Hashref of symbol names for routines to be made available as universal
  symbols.  Each key/value pair consists of the package name and an
  array of routine names in that package.  Used only under AIX, OS/2,
  VMS and Win32 at present.  The routine names supplied will be expanded
  in the same way as XSUB names are expanded by the XS() macro.
  Defaults to
  
    {"$(NAME)" => ["boot_$(NAME)" ] }
  
  e.g.
  
    {"RPC" => [qw( boot_rpcb rpcb_gettime getnetconfigent )],
     "NetconfigPtr" => [ 'DESTROY'] }
  
  Please see the L<ExtUtils::Mksymlists> documentation for more information
  about the DL_FUNCS, DL_VARS and FUNCLIST attributes.
  
  =item DL_VARS
  
  Array of symbol names for variables to be made available as universal symbols.
  Used only under AIX, OS/2, VMS and Win32 at present.  Defaults to [].
  (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])
  
  =item EXCLUDE_EXT
  
  Array of extension names to exclude when doing a static build.  This
  is ignored if INCLUDE_EXT is present.  Consult INCLUDE_EXT for more
  details.  (e.g.  [ qw( Socket POSIX ) ] )
  
  This attribute may be most useful when specified as a string on the
  command line:  perl Makefile.PL EXCLUDE_EXT='Socket Safe'
  
  =item EXE_FILES
  
  Ref to array of executable files. The files will be copied to the
  INST_SCRIPT directory. Make realclean will delete them from there
  again.
  
  If your executables start with something like #!perl or
  #!/usr/bin/perl MakeMaker will change this to the path of the perl
  'Makefile.PL' was invoked with so the programs will be sure to run
  properly even if perl is not in /usr/bin/perl.
  
  =item FIRST_MAKEFILE
  
  The name of the Makefile to be produced.  This is used for the second
  Makefile that will be produced for the MAP_TARGET.
  
  Defaults to 'Makefile' or 'Descrip.MMS' on VMS.
  
  (Note: we couldn't use MAKEFILE because dmake uses this for something
  else).
  
  =item FULLPERL
  
  Perl binary able to run this extension, load XS modules, etc...
  
  =item FULLPERLRUN
  
  Like PERLRUN, except it uses FULLPERL.
  
  =item FULLPERLRUNINST
  
  Like PERLRUNINST, except it uses FULLPERL.
  
  =item FUNCLIST
  
  This provides an alternate means to specify function names to be
  exported from the extension.  Its value is a reference to an
  array of function names to be exported by the extension.  These
  names are passed through unaltered to the linker options file.
  
  =item H
  
  Ref to array of *.h file names. Similar to C.
  
  =item IMPORTS
  
  This attribute is used to specify names to be imported into the
  extension. Takes a hash ref.
  
  It is only used on OS/2 and Win32.
  
  =item INC
  
  Include file dirs eg: C<"-I/usr/5include -I/path/to/inc">
  
  =item INCLUDE_EXT
  
  Array of extension names to be included when doing a static build.
  MakeMaker will normally build with all of the installed extensions when
  doing a static build, and that is usually the desired behavior.  If
  INCLUDE_EXT is present then MakeMaker will build only with those extensions
  which are explicitly mentioned. (e.g.  [ qw( Socket POSIX ) ])
  
  It is not necessary to mention DynaLoader or the current extension when
  filling in INCLUDE_EXT.  If the INCLUDE_EXT is mentioned but is empty then
  only DynaLoader and the current extension will be included in the build.
  
  This attribute may be most useful when specified as a string on the
  command line:  perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'
  
  =item INSTALLARCHLIB
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to perl.
  
  =item INSTALLBIN
  
  Directory to install binary files (e.g. tkperl) into if
  INSTALLDIRS=perl.
  
  =item INSTALLDIRS
  
  Determines which of the sets of installation directories to choose:
  perl, site or vendor.  Defaults to site.
  
  =item INSTALLMAN1DIR
  
  =item INSTALLMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=perl.  Defaults to $Config{installman*dir}.
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLPRIVLIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to perl.
  
  Defaults to $Config{installprivlib}.
  
  =item INSTALLSCRIPT
  
  Available in version 6.30_02 and above.
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS=perl.
  
  =item INSTALLSITEARCH
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITEBIN
  
  Used by 'make install', which copies files from INST_BIN to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITELIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITEMAN1DIR
  
  =item INSTALLSITEMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=site (default).  Defaults to
  $(SITEPREFIX)/man/man$(MAN*EXT).
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLSITESCRIPT
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLVENDORARCH
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to vendor. Note that if you do not set
  this, the value of INSTALLVENDORLIB will be used, which is probably not
  what you want.
  
  =item INSTALLVENDORBIN
  
  Used by 'make install', which copies files from INST_BIN to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORLIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORMAN1DIR
  
  =item INSTALLVENDORMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=vendor.  Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLVENDORSCRIPT
  
  Available in version 6.30_02 and above.
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INST_ARCHLIB
  
  Same as INST_LIB for architecture dependent files.
  
  =item INST_BIN
  
  Directory to put real binary files during 'make'. These will be copied
  to INSTALLBIN during 'make install'
  
  =item INST_LIB
  
  Directory where we put library files of this extension while building
  it.
  
  =item INST_MAN1DIR
  
  Directory to hold the man pages at 'make' time
  
  =item INST_MAN3DIR
  
  Directory to hold the man pages at 'make' time
  
  =item INST_SCRIPT
  
  Directory where executable files should be installed during
  'make'. Defaults to "./blib/script", just to have a dummy location during
  testing. make install will copy the files in INST_SCRIPT to
  INSTALLSCRIPT.
  
  =item LD
  
  Program to be used to link libraries for dynamic loading.
  
  Defaults to $Config{ld}.
  
  =item LDDLFLAGS
  
  Any special flags that might need to be passed to ld to create a
  shared library suitable for dynamic loading.  It is up to the makefile
  to use it.  (See L<Config/lddlflags>)
  
  Defaults to $Config{lddlflags}.
  
  =item LDFROM
  
  Defaults to "$(OBJECT)" and is used in the ld command to specify
  what files to link/load from (also see dynamic_lib below for how to
  specify ld flags)
  
  =item LIB
  
  LIB should only be set at C<perl Makefile.PL> time but is allowed as a
  MakeMaker argument. It has the effect of setting both INSTALLPRIVLIB
  and INSTALLSITELIB to that value regardless any explicit setting of
  those arguments (or of PREFIX).  INSTALLARCHLIB and INSTALLSITEARCH
  are set to the corresponding architecture subdirectory.
  
  =item LIBPERL_A
  
  The filename of the perllibrary that will be used together with this
  extension. Defaults to libperl.a.
  
  =item LIBS
  
  An anonymous array of alternative library
  specifications to be searched for (in order) until
  at least one library is found. E.g.
  
    'LIBS' => ["-lgdbm", "-ldbm -lfoo", "-L/path -ldbm.nfs"]
  
  Mind, that any element of the array
  contains a complete set of arguments for the ld
  command. So do not specify
  
    'LIBS' => ["-ltcl", "-ltk", "-lX11"]
  
  See ODBM_File/Makefile.PL for an example, where an array is needed. If
  you specify a scalar as in
  
    'LIBS' => "-ltcl -ltk -lX11"
  
  MakeMaker will turn it into an array with one element.
  
  =item LICENSE
  
  Available in version 6.31 and above.
  
  The licensing terms of your distribution.  Generally it's "perl_5" for the
  same license as Perl itself.
  
  See L<CPAN::Meta::Spec> for the list of options.
  
  Defaults to "unknown".
  
  =item LINKTYPE
  
  'static' or 'dynamic' (default unless usedl=undef in
  config.sh). Should only be used to force static linking (also see
  linkext below).
  
  =item MAGICXS
  
  Available in version 6.8305 and above.
  
  When this is set to C<1>, C<OBJECT> will be automagically derived from
  C<O_FILES>.
  
  =item MAKE
  
  Available in version 6.30_01 and above.
  
  Variant of make you intend to run the generated Makefile with.  This
  parameter lets Makefile.PL know what make quirks to account for when
  generating the Makefile.
  
  MakeMaker also honors the MAKE environment variable.  This parameter
  takes precedence.
  
  Currently the only significant values are 'dmake' and 'nmake' for Windows
  users, instructing MakeMaker to generate a Makefile in the flavour of
  DMake ("Dennis Vadura's Make") or Microsoft NMake respectively.
  
  Defaults to $Config{make}, which may go looking for a Make program
  in your environment.
  
  How are you supposed to know what flavour of Make a Makefile has
  been generated for if you didn't specify a value explicitly? Search
  the generated Makefile for the definition of the MAKE variable,
  which is used to recursively invoke the Make utility. That will tell
  you what Make you're supposed to invoke the Makefile with.
  
  =item MAKEAPERL
  
  Boolean which tells MakeMaker that it should include the rules to
  make a perl. This is handled automatically as a switch by
  MakeMaker. The user normally does not need it.
  
  =item MAKEFILE_OLD
  
  When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be
  backed up at this location.
  
  Defaults to $(FIRST_MAKEFILE).old or $(FIRST_MAKEFILE)_old on VMS.
  
  =item MAN1PODS
  
  Hashref of pod-containing files. MakeMaker will default this to all
  EXE_FILES files that include POD directives. The files listed
  here will be converted to man pages and installed as was requested
  at Configure time.
  
  This hash should map POD files (or scripts containing POD) to the
  man file names under the C<blib/man1/> directory, as in the following
  example:
  
    MAN1PODS            => {
      'doc/command.pod'    => 'blib/man1/command.1',
      'scripts/script.pl'  => 'blib/man1/script.1',
    }
  
  =item MAN3PODS
  
  Hashref that assigns to *.pm and *.pod files the files into which the
  manpages are to be written. MakeMaker parses all *.pod and *.pm files
  for POD directives. Files that contain POD will be the default keys of
  the MAN3PODS hashref. These will then be converted to man pages during
  C<make> and will be installed during C<make install>.
  
  Example similar to MAN1PODS.
  
  =item MAP_TARGET
  
  If it is intended that a new perl binary be produced, this variable
  may hold a name for that binary. Defaults to perl
  
  =item META_ADD
  
  =item META_MERGE
  
  Available in version 6.46 and above.
  
  A hashref of items to add to the CPAN Meta file (F<META.yml> or
  F<META.json>).
  
  They differ in how they behave if they have the same key as the
  default metadata.  META_ADD will override the default value with its
  own.  META_MERGE will merge its value with the default.
  
  Unless you want to override the defaults, prefer META_MERGE so as to
  get the advantage of any future defaults.
  
  Where prereqs are concerned, if META_MERGE is used, prerequisites are merged
  with their counterpart C<WriteMakefile()> argument
  (PREREQ_PM is merged into {prereqs}{runtime}{requires},
  BUILD_REQUIRES into C<{prereqs}{build}{requires}>,
  CONFIGURE_REQUIRES into C<{prereqs}{configure}{requires}>,
  and TEST_REQUIRES into C<{prereqs}{test}{requires})>.
  When prereqs are specified with META_ADD, the only prerequisites added to the
  file come from the metadata, not C<WriteMakefile()> arguments.
  
  Note that these configuration options are only used for generating F<META.yml>
  and F<META.json> -- they are NOT used for F<MYMETA.yml> and F<MYMETA.json>.
  Therefore data in these fields should NOT be used for dynamic (user-side)
  configuration.
  
  By default CPAN Meta specification C<1.4> is used. In order to use
  CPAN Meta specification C<2.0>, indicate with C<meta-spec> the version
  you want to use.
  
    META_MERGE        => {
  
      "meta-spec" => { version => 2 },
  
      resources => {
  
        repository => {
            type => 'git',
            url => 'git://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker.git',
            web => 'https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker',
        },
  
      },
  
    },
  
  =item MIN_PERL_VERSION
  
  Available in version 6.48 and above.
  
  The minimum required version of Perl for this distribution.
  
  Either the 5.006001 or the 5.6.1 format is acceptable.
  
  =item MYEXTLIB
  
  If the extension links to a library that it builds, set this to the
  name of the library (see SDBM_File)
  
  =item NAME
  
  The package representing the distribution. For example, C<Test::More>
  or C<ExtUtils::MakeMaker>. It will be used to derive information about
  the distribution such as the L</DISTNAME>, installation locations
  within the Perl library and where XS files will be looked for by
  default (see L</XS>).
  
  C<NAME> I<must> be a valid Perl package name and it I<must> have an
  associated C<.pm> file. For example, C<Foo::Bar> is a valid C<NAME>
  and there must exist F<Foo/Bar.pm>.  Any XS code should be in
  F<Bar.xs> unless stated otherwise.
  
  Your distribution B<must> have a C<NAME>.
  
  =item NEEDS_LINKING
  
  MakeMaker will figure out if an extension contains linkable code
  anywhere down the directory tree, and will set this variable
  accordingly, but you can speed it up a very little bit if you define
  this boolean variable yourself.
  
  =item NOECHO
  
  Command so make does not print the literal commands it's running.
  
  By setting it to an empty string you can generate a Makefile that
  prints all commands. Mainly used in debugging MakeMaker itself.
  
  Defaults to C<@>.
  
  =item NORECURS
  
  Boolean.  Attribute to inhibit descending into subdirectories.
  
  =item NO_META
  
  When true, suppresses the generation and addition to the MANIFEST of
  the META.yml and META.json module meta-data files during 'make distdir'.
  
  Defaults to false.
  
  =item NO_MYMETA
  
  Available in version 6.57_02 and above.
  
  When true, suppresses the generation of MYMETA.yml and MYMETA.json module
  meta-data files during 'perl Makefile.PL'.
  
  Defaults to false.
  
  =item NO_PACKLIST
  
  Available in version 6.7501 and above.
  
  When true, suppresses the writing of C<packlist> files for installs.
  
  Defaults to false.
  
  =item NO_PERLLOCAL
  
  Available in version 6.7501 and above.
  
  When true, suppresses the appending of installations to C<perllocal>.
  
  Defaults to false.
  
  =item NO_VC
  
  In general, any generated Makefile checks for the current version of
  MakeMaker and the version the Makefile was built under. If NO_VC is
  set, the version check is neglected. Do not write this into your
  Makefile.PL, use it interactively instead.
  
  =item OBJECT
  
  List of object files, defaults to '$(BASEEXT)$(OBJ_EXT)', but can be a long
  string or an array containing all object files, e.g. "tkpBind.o
  tkpButton.o tkpCanvas.o" or ["tkpBind.o", "tkpButton.o", "tkpCanvas.o"]
  
  (Where BASEEXT is the last component of NAME, and OBJ_EXT is $Config{obj_ext}.)
  
  =item OPTIMIZE
  
  Defaults to C<-O>. Set it to C<-g> to turn debugging on. The flag is
  passed to subdirectory makes.
  
  =item PERL
  
  Perl binary for tasks that can be done by miniperl. If it contains
  spaces or other shell metacharacters, it needs to be quoted in a way
  that protects them, since this value is intended to be inserted in a
  shell command line in the Makefile. E.g.:
  
    # Perl executable lives in "C:/Program Files/Perl/bin"
    # Normally you don't need to set this yourself!
    $ perl Makefile.PL PERL='"C:/Program Files/Perl/bin/perl.exe" -w'
  
  =item PERL_CORE
  
  Set only when MakeMaker is building the extensions of the Perl core
  distribution.
  
  =item PERLMAINCC
  
  The call to the program that is able to compile perlmain.c. Defaults
  to $(CC).
  
  =item PERL_ARCHLIB
  
  Same as for PERL_LIB, but for architecture dependent files.
  
  Used only when MakeMaker is building the extensions of the Perl core
  distribution (because normally $(PERL_ARCHLIB) is automatically in @INC,
  and adding it would get in the way of PERL5LIB).
  
  =item PERL_LIB
  
  Directory containing the Perl library to use.
  
  Used only when MakeMaker is building the extensions of the Perl core
  distribution (because normally $(PERL_LIB) is automatically in @INC,
  and adding it would get in the way of PERL5LIB).
  
  =item PERL_MALLOC_OK
  
  defaults to 0.  Should be set to TRUE if the extension can work with
  the memory allocation routines substituted by the Perl malloc() subsystem.
  This should be applicable to most extensions with exceptions of those
  
  =over 4
  
  =item *
  
  with bugs in memory allocations which are caught by Perl's malloc();
  
  =item *
  
  which interact with the memory allocator in other ways than via
  malloc(), realloc(), free(), calloc(), sbrk() and brk();
  
  =item *
  
  which rely on special alignment which is not provided by Perl's malloc().
  
  =back
  
  B<NOTE.>  Neglecting to set this flag in I<any one> of the loaded extension
  nullifies many advantages of Perl's malloc(), such as better usage of
  system resources, error detection, memory usage reporting, catchable failure
  of memory allocations, etc.
  
  =item PERLPREFIX
  
  Directory under which core modules are to be installed.
  
  Defaults to $Config{installprefixexp}, falling back to
  $Config{installprefix}, $Config{prefixexp} or $Config{prefix} should
  $Config{installprefixexp} not exist.
  
  Overridden by PREFIX.
  
  =item PERLRUN
  
  Use this instead of $(PERL) when you wish to run perl.  It will set up
  extra necessary flags for you.
  
  =item PERLRUNINST
  
  Use this instead of $(PERL) when you wish to run perl to work with
  modules.  It will add things like -I$(INST_ARCH) and other necessary
  flags so perl can see the modules you're about to install.
  
  =item PERL_SRC
  
  Directory containing the Perl source code (use of this should be
  avoided, it may be undefined)
  
  =item PERM_DIR
  
  Available in version 6.51_01 and above.
  
  Desired permission for directories. Defaults to C<755>.
  
  =item PERM_RW
  
  Desired permission for read/writable files. Defaults to C<644>.
  
  =item PERM_RWX
  
  Desired permission for executable files. Defaults to C<755>.
  
  =item PL_FILES
  
  MakeMaker can run programs to generate files for you at build time.
  By default any file named *.PL (except Makefile.PL and Build.PL) in
  the top level directory will be assumed to be a Perl program and run
  passing its own basename in as an argument.  This basename is actually a build
  target, and there is an intention, but not a requirement, that the *.PL file
  make the file passed to to as an argument. For example...
  
      perl foo.PL foo
  
  This behavior can be overridden by supplying your own set of files to
  search.  PL_FILES accepts a hash ref, the key being the file to run
  and the value is passed in as the first argument when the PL file is run.
  
      PL_FILES => {'bin/foobar.PL' => 'bin/foobar'}
  
      PL_FILES => {'foo.PL' => 'foo.c'}
  
  Would run bin/foobar.PL like this:
  
      perl bin/foobar.PL bin/foobar
  
  If multiple files from one program are desired an array ref can be used.
  
      PL_FILES => {'bin/foobar.PL' => [qw(bin/foobar1 bin/foobar2)]}
  
  In this case the program will be run multiple times using each target file.
  
      perl bin/foobar.PL bin/foobar1
      perl bin/foobar.PL bin/foobar2
  
  If an output file depends on extra input files beside the script itself,
  a hash ref can be used in version 7.36 and above:
  
      PL_FILES => { 'foo.PL' => {
          'foo.out' => 'foo.in',
          'bar.out' => [qw(bar1.in bar2.in)],
      }
  
  In this case the extra input files will be passed to the program after
  the target file:
  
     perl foo.PL foo.out foo.in
     perl foo.PL bar.out bar1.in bar2.in
  
  PL files are normally run B<after> pm_to_blib and include INST_LIB and
  INST_ARCH in their C<@INC>, so the just built modules can be
  accessed... unless the PL file is making a module (or anything else in
  PM) in which case it is run B<before> pm_to_blib and does not include
  INST_LIB and INST_ARCH in its C<@INC>.  This apparently odd behavior
  is there for backwards compatibility (and it's somewhat DWIM).  The argument
  passed to the .PL is set up as a target to build in the Makefile.  In other
  sections such as C<postamble> you can specify a dependency on the
  filename/argument that the .PL is supposed (or will have, now that that is
  is a dependency) to generate.  Note the file to be generated will still be
  generated and the .PL will still run even without an explicit dependency created
  by you, since the C<all> target still depends on running all eligible to run.PL
  files.
  
  =item PM
  
  Hashref of .pm files and *.pl files to be installed.  e.g.
  
    {'name_of_file.pm' => '$(INST_LIB)/install_as.pm'}
  
  By default this will include *.pm and *.pl and the files found in
  the PMLIBDIRS directories.  Defining PM in the
  Makefile.PL will override PMLIBDIRS.
  
  =item PMLIBDIRS
  
  Ref to array of subdirectories containing library files.  Defaults to
  [ 'lib', $(BASEEXT) ]. The directories will be scanned and I<any> files
  they contain will be installed in the corresponding location in the
  library.  A libscan() method can be used to alter the behaviour.
  Defining PM in the Makefile.PL will override PMLIBDIRS.
  
  (Where BASEEXT is the last component of NAME.)
  
  =item PM_FILTER
  
  A filter program, in the traditional Unix sense (input from stdin, output
  to stdout) that is passed on each .pm file during the build (in the
  pm_to_blib() phase).  It is empty by default, meaning no filtering is done.
  You could use:
  
    PM_FILTER => 'perl -ne "print unless /^\\#/"',
  
  to remove all the leading comments on the fly during the build.  In order
  to be as portable as possible, please consider using a Perl one-liner
  rather than Unix (or other) utilities, as above.  The # is escaped for
  the Makefile, since what is going to be generated will then be:
  
    PM_FILTER = perl -ne "print unless /^\#/"
  
  Without the \ before the #, we'd have the start of a Makefile comment,
  and the macro would be incorrectly defined.
  
  You will almost certainly be better off using the C<PL_FILES> system,
  instead. See above, or the L<ExtUtils::MakeMaker::FAQ> entry.
  
  =item POLLUTE
  
  Release 5.005 grandfathered old global symbol names by providing preprocessor
  macros for extension source compatibility.  As of release 5.6, these
  preprocessor definitions are not available by default.  The POLLUTE flag
  specifies that the old names should still be defined:
  
    perl Makefile.PL POLLUTE=1
  
  Please inform the module author if this is necessary to successfully install
  a module under 5.6 or later.
  
  =item PPM_INSTALL_EXEC
  
  Name of the executable used to run C<PPM_INSTALL_SCRIPT> below. (e.g. perl)
  
  =item PPM_INSTALL_SCRIPT
  
  Name of the script that gets executed by the Perl Package Manager after
  the installation of a package.
  
  =item PPM_UNINSTALL_EXEC
  
  Available in version 6.8502 and above.
  
  Name of the executable used to run C<PPM_UNINSTALL_SCRIPT> below. (e.g. perl)
  
  =item PPM_UNINSTALL_SCRIPT
  
  Available in version 6.8502 and above.
  
  Name of the script that gets executed by the Perl Package Manager before
  the removal of a package.
  
  =item PREFIX
  
  This overrides all the default install locations.  Man pages,
  libraries, scripts, etc...  MakeMaker will try to make an educated
  guess about where to place things under the new PREFIX based on your
  Config defaults.  Failing that, it will fall back to a structure
  which should be sensible for your platform.
  
  If you specify LIB or any INSTALL* variables they will not be affected
  by the PREFIX.
  
  =item PREREQ_FATAL
  
  Bool. If this parameter is true, failing to have the required modules
  (or the right versions thereof) will be fatal. C<perl Makefile.PL>
  will C<die> instead of simply informing the user of the missing dependencies.
  
  It is I<extremely> rare to have to use C<PREREQ_FATAL>. Its use by module
  authors is I<strongly discouraged> and should never be used lightly.
  
  For dependencies that are required in order to run C<Makefile.PL>,
  see C<CONFIGURE_REQUIRES>.
  
  Module installation tools have ways of resolving unmet dependencies but
  to do that they need a F<Makefile>.  Using C<PREREQ_FATAL> breaks this.
  That's bad.
  
  Assuming you have good test coverage, your tests should fail with
  missing dependencies informing the user more strongly that something
  is wrong.  You can write a F<t/00compile.t> test which will simply
  check that your code compiles and stop "make test" prematurely if it
  doesn't.  See L<Test::More/BAIL_OUT> for more details.
  
  
  =item PREREQ_PM
  
  A hash of modules that are needed to run your module.  The keys are
  the module names ie. Test::More, and the minimum version is the
  value. If the required version number is 0 any version will do.
  The versions given may be a Perl v-string (see L<version>) or a range
  (see L<CPAN::Meta::Requirements>).
  
  This will go into the C<requires> field of your F<META.yml> and the
  C<runtime> of the C<prereqs> field of your F<META.json>.
  
      PREREQ_PM => {
          # Require Test::More at least 0.47
          "Test::More" => "0.47",
  
          # Require any version of Acme::Buffy
          "Acme::Buffy" => 0,
      }
  
  =item PREREQ_PRINT
  
  Bool.  If this parameter is true, the prerequisites will be printed to
  stdout and MakeMaker will exit.  The output format is an evalable hash
  ref.
  
    $PREREQ_PM = {
                   'A::B' => Vers1,
                   'C::D' => Vers2,
                   ...
                 };
  
  If a distribution defines a minimal required perl version, this is
  added to the output as an additional line of the form:
  
    $MIN_PERL_VERSION = '5.008001';
  
  If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.
  
  =item PRINT_PREREQ
  
  RedHatism for C<PREREQ_PRINT>.  The output format is different, though:
  
      perl(A::B)>=Vers1 perl(C::D)>=Vers2 ...
  
  A minimal required perl version, if present, will look like this:
  
      perl(perl)>=5.008001
  
  =item SITEPREFIX
  
  Like PERLPREFIX, but only for the site install locations.
  
  Defaults to $Config{siteprefixexp}.  Perls prior to 5.6.0 didn't have
  an explicit siteprefix in the Config.  In those cases
  $Config{installprefix} will be used.
  
  Overridable by PREFIX
  
  =item SIGN
  
  Available in version 6.18 and above.
  
  When true, perform the generation and addition to the MANIFEST of the
  SIGNATURE file in the distdir during 'make distdir', via 'cpansign
  -s'.
  
  Note that you need to install the Module::Signature module to
  perform this operation.
  
  Defaults to false.
  
  =item SKIP
  
  Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the
  Makefile. Caution! Do not use the SKIP attribute for the negligible
  speedup. It may seriously damage the resulting Makefile. Only use it
  if you really need it.
  
  =item TEST_REQUIRES
  
  Available in version 6.64 and above.
  
  A hash of modules that are needed to test your module but not run or
  build it.
  
  This will go into the C<build_requires> field of your F<META.yml> and the C<test> of the C<prereqs> field of your F<META.json>.
  
  The format is the same as PREREQ_PM.
  
  =item TYPEMAPS
  
  Ref to array of typemap file names.  Use this when the typemaps are
  in some directory other than the current directory or when they are
  not named B<typemap>.  The last typemap in the list takes
  precedence.  A typemap in the current directory has highest
  precedence, even if it isn't listed in TYPEMAPS.  The default system
  typemap has lowest precedence.
  
  =item VENDORPREFIX
  
  Like PERLPREFIX, but only for the vendor install locations.
  
  Defaults to $Config{vendorprefixexp}.
  
  Overridable by PREFIX
  
  =item VERBINST
  
  If true, make install will be verbose
  
  =item VERSION
  
  Your version number for distributing the package.  This defaults to
  0.1.
  
  =item VERSION_FROM
  
  Instead of specifying the VERSION in the Makefile.PL you can let
  MakeMaker parse a file to determine the version number. The parsing
  routine requires that the file named by VERSION_FROM contains one
  single line to compute the version number. The first line in the file
  that contains something like a $VERSION assignment or C<package Name
  VERSION> will be used. The following lines will be parsed o.k.:
  
      # Good
      package Foo::Bar 1.23;                      # 1.23
      $VERSION   = '1.00';                        # 1.00
      *VERSION   = \'1.01';                       # 1.01
      ($VERSION) = q$Revision$ =~ /(\d+)/g;       # The digits in $Revision$
      $FOO::VERSION = '1.10';                     # 1.10
      *FOO::VERSION = \'1.11';                    # 1.11
  
  but these will fail:
  
      # Bad
      my $VERSION         = '1.01';
      local $VERSION      = '1.02';
      local $FOO::VERSION = '1.30';
  
  (Putting C<my> or C<local> on the preceding line will work o.k.)
  
  "Version strings" are incompatible and should not be used.
  
      # Bad
      $VERSION = 1.2.3;
      $VERSION = v1.2.3;
  
  L<version> objects are fine.  As of MakeMaker 6.35 version.pm will be
  automatically loaded, but you must declare the dependency on version.pm.
  For compatibility with older MakeMaker you should load on the same line
  as $VERSION is declared.
  
      # All on one line
      use version; our $VERSION = qv(1.2.3);
  
  The file named in VERSION_FROM is not added as a dependency to
  Makefile. This is not really correct, but it would be a major pain
  during development to have to rewrite the Makefile for any smallish
  change in that file. If you want to make sure that the Makefile
  contains the correct VERSION macro after any change of the file, you
  would have to do something like
  
      depend => { Makefile => '$(VERSION_FROM)' }
  
  See attribute C<depend> below.
  
  =item VERSION_SYM
  
  A sanitized VERSION with . replaced by _.  For places where . has
  special meaning (some filesystems, RCS labels, etc...)
  
  =item XS
  
  Hashref of .xs files. MakeMaker will default this.  e.g.
  
    {'name_of_file.xs' => 'name_of_file.c'}
  
  The .c files will automatically be included in the list of files
  deleted by a make clean.
  
  =item XSBUILD
  
  Available in version 7.12 and above.
  
  Hashref with options controlling the operation of C<XSMULTI>:
  
    {
      xs => {
          all => {
              # options applying to all .xs files for this distribution
          },
          'lib/Class/Name/File' => { # specifically for this file
              DEFINE => '-Dfunktastic', # defines for only this file
              INC => "-I$funkyliblocation", # include flags for only this file
              # OBJECT => 'lib/Class/Name/File$(OBJ_EXT)', # default
              LDFROM => "lib/Class/Name/File\$(OBJ_EXT) $otherfile\$(OBJ_EXT)", # what's linked
          },
      },
    }
  
  Note C<xs> is the file-extension. More possibilities may arise in the
  future. Note that object names are specified without their XS extension.
  
  C<LDFROM> defaults to the same as C<OBJECT>. C<OBJECT> defaults to,
  for C<XSMULTI>, just the XS filename with the extension replaced with
  the compiler-specific object-file extension.
  
  The distinction between C<OBJECT> and C<LDFROM>: C<OBJECT> is the make
  target, so make will try to build it. However, C<LDFROM> is what will
  actually be linked together to make the shared object or static library
  (SO/SL), so if you override it, make sure it includes what you want to
  make the final SO/SL, almost certainly including the XS basename with
  C<$(OBJ_EXT)> appended.
  
  =item XSMULTI
  
  Available in version 7.12 and above.
  
  When this is set to C<1>, multiple XS files may be placed under F<lib/>
  next to their corresponding C<*.pm> files (this is essential for compiling
  with the correct C<VERSION> values). This feature should be considered
  experimental, and details of it may change.
  
  This feature was inspired by, and small portions of code copied from,
  L<ExtUtils::MakeMaker::BigHelper>. Hopefully this feature will render
  that module mainly obsolete.
  
  =item XSOPT
  
  String of options to pass to xsubpp.  This might include C<-C++> or
  C<-extern>.  Do not include typemaps here; the TYPEMAP parameter exists for
  that purpose.
  
  =item XSPROTOARG
  
  May be set to C<-protoypes>, C<-noprototypes> or the empty string.  The
  empty string is equivalent to the xsubpp default, or C<-noprototypes>.
  See the xsubpp documentation for details.  MakeMaker
  defaults to the empty string.
  
  =item XS_VERSION
  
  Your version number for the .xs file of this package.  This defaults
  to the value of the VERSION attribute.
  
  =back
  
  =head2 Additional lowercase attributes
  
  can be used to pass parameters to the methods which implement that
  part of the Makefile.  Parameters are specified as a hash ref but are
  passed to the method as a hash.
  
  =over 2
  
  =item clean
  
    {FILES => "*.xyz foo"}
  
  =item depend
  
    {ANY_TARGET => ANY_DEPENDENCY, ...}
  
  (ANY_TARGET must not be given a double-colon rule by MakeMaker.)
  
  =item dist
  
    {TARFLAGS => 'cvfF', COMPRESS => 'gzip', SUFFIX => '.gz',
    SHAR => 'shar -m', DIST_CP => 'ln', ZIP => '/bin/zip',
    ZIPFLAGS => '-rl', DIST_DEFAULT => 'private tardist' }
  
  If you specify COMPRESS, then SUFFIX should also be altered, as it is
  needed to tell make the target file of the compression. Setting
  DIST_CP to ln can be useful, if you need to preserve the timestamps on
  your files. DIST_CP can take the values 'cp', which copies the file,
  'ln', which links the file, and 'best' which copies symbolic links and
  links the rest. Default is 'best'.
  
  =item dynamic_lib
  
    {ARMAYBE => 'ar', OTHERLDFLAGS => '...', INST_DYNAMIC_DEP => '...'}
  
  =item linkext
  
    {LINKTYPE => 'static', 'dynamic' or ''}
  
  NB: Extensions that have nothing but *.pm files had to say
  
    {LINKTYPE => ''}
  
  with Pre-5.0 MakeMakers. Since version 5.00 of MakeMaker such a line
  can be deleted safely. MakeMaker recognizes when there's nothing to
  be linked.
  
  =item macro
  
    {ANY_MACRO => ANY_VALUE, ...}
  
  =item postamble
  
  Anything put here will be passed to MY::postamble() if you have one.
  
  =item realclean
  
    {FILES => '$(INST_ARCHAUTODIR)/*.xyz'}
  
  =item test
  
  Specify the targets for testing.
  
    {TESTS => 't/*.t'}
  
  C<RECURSIVE_TEST_FILES> can be used to include all directories
  recursively under C<t> that contain C<.t> files. It will be ignored if
  you provide your own C<TESTS> attribute, defaults to false.
  
    {RECURSIVE_TEST_FILES=>1}
  
  This is supported since 6.76
  
  =item tool_autosplit
  
    {MAXLEN => 8}
  
  =back
  
  =head2 Overriding MakeMaker Methods
  
  If you cannot achieve the desired Makefile behaviour by specifying
  attributes you may define private subroutines in the Makefile.PL.
  Each subroutine returns the text it wishes to have written to
  the Makefile. To override a section of the Makefile you can
  either say:
  
          sub MY::c_o { "new literal text" }
  
  or you can edit the default by saying something like:
  
          package MY; # so that "SUPER" works right
          sub c_o {
              my $inherited = shift->SUPER::c_o(@_);
              $inherited =~ s/old text/new text/;
              $inherited;
          }
  
  If you are running experiments with embedding perl as a library into
  other applications, you might find MakeMaker is not sufficient. You'd
  better have a look at ExtUtils::Embed which is a collection of utilities
  for embedding.
  
  If you still need a different solution, try to develop another
  subroutine that fits your needs and submit the diffs to
  C<makemaker@perl.org>
  
  For a complete description of all MakeMaker methods see
  L<ExtUtils::MM_Unix>.
  
  Here is a simple example of how to add a new target to the generated
  Makefile:
  
      sub MY::postamble {
          return <<'MAKE_FRAG';
      $(MYEXTLIB): sdbm/Makefile
              cd sdbm && $(MAKE) all
  
      MAKE_FRAG
      }
  
  =head2 The End Of Cargo Cult Programming
  
  WriteMakefile() now does some basic sanity checks on its parameters to
  protect against typos and malformatted values.  This means some things
  which happened to work in the past will now throw warnings and
  possibly produce internal errors.
  
  Some of the most common mistakes:
  
  =over 2
  
  =item C<< MAN3PODS => ' ' >>
  
  This is commonly used to suppress the creation of man pages.  MAN3PODS
  takes a hash ref not a string, but the above worked by accident in old
  versions of MakeMaker.
  
  The correct code is C<< MAN3PODS => { } >>.
  
  =back
  
  
  =head2 Hintsfile support
  
  MakeMaker.pm uses the architecture-specific information from
  Config.pm. In addition it evaluates architecture specific hints files
  in a C<hints/> directory. The hints files are expected to be named
  like their counterparts in C<PERL_SRC/hints>, but with an C<.pl> file
  name extension (eg. C<next_3_2.pl>). They are simply C<eval>ed by
  MakeMaker within the WriteMakefile() subroutine, and can be used to
  execute commands as well as to include special variables. The rules
  which hintsfile is chosen are the same as in Configure.
  
  The hintsfile is eval()ed immediately after the arguments given to
  WriteMakefile are stuffed into a hash reference $self but before this
  reference becomes blessed. So if you want to do the equivalent to
  override or create an attribute you would say something like
  
      $self->{LIBS} = ['-ldbm -lucb -lc'];
  
  =head2 Distribution Support
  
  For authors of extensions MakeMaker provides several Makefile
  targets. Most of the support comes from the ExtUtils::Manifest module,
  where additional documentation can be found.
  
  =over 4
  
  =item    make distcheck
  
  reports which files are below the build directory but not in the
  MANIFEST file and vice versa. (See ExtUtils::Manifest::fullcheck() for
  details)
  
  =item    make skipcheck
  
  reports which files are skipped due to the entries in the
  C<MANIFEST.SKIP> file (See ExtUtils::Manifest::skipcheck() for
  details)
  
  =item    make distclean
  
  does a realclean first and then the distcheck. Note that this is not
  needed to build a new distribution as long as you are sure that the
  MANIFEST file is ok.
  
  =item    make veryclean
  
  does a realclean first and then removes backup files such as C<*~>,
  C<*.bak>, C<*.old> and C<*.orig>
  
  =item    make manifest
  
  rewrites the MANIFEST file, adding all remaining files found (See
  ExtUtils::Manifest::mkmanifest() for details)
  
  =item    make distdir
  
  Copies all the files that are in the MANIFEST file to a newly created
  directory with the name C<$(DISTNAME)-$(VERSION)>. If that directory
  exists, it will be removed first.
  
  Additionally, it will create META.yml and META.json module meta-data file
  in the distdir and add this to the distdir's MANIFEST.  You can shut this
  behavior off with the NO_META flag.
  
  =item   make disttest
  
  Makes a distdir first, and runs a C<perl Makefile.PL>, a make, and
  a make test in that directory.
  
  =item    make tardist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command, followed by $(TO_UNIX), which defaults to a null command under
  UNIX, and will convert files in distribution directory to UNIX format
  otherwise. Next it runs C<tar> on that directory into a tarfile and
  deletes the directory. Finishes with a command $(POSTOP) which
  defaults to a null command.
  
  =item    make dist
  
  Defaults to $(DIST_DEFAULT) which in turn defaults to tardist.
  
  =item    make uutardist
  
  Runs a tardist first and uuencodes the tarfile.
  
  =item    make shdist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command. Next it runs C<shar> on that directory into a sharfile and
  deletes the intermediate directory again. Finishes with a command
  $(POSTOP) which defaults to a null command.  Note: For shdist to work
  properly a C<shar> program that can handle directories is mandatory.
  
  =item    make zipdist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command. Runs C<$(ZIP) $(ZIPFLAGS)> on that directory into a
  zipfile. Then deletes that directory. Finishes with a command
  $(POSTOP) which defaults to a null command.
  
  =item    make ci
  
  Does a $(CI) and a $(RCS_LABEL) on all files in the MANIFEST file.
  
  =back
  
  Customization of the dist targets can be done by specifying a hash
  reference to the dist attribute of the WriteMakefile call. The
  following parameters are recognized:
  
      CI           ('ci -u')
      COMPRESS     ('gzip --best')
      POSTOP       ('@ :')
      PREOP        ('@ :')
      TO_UNIX      (depends on the system)
      RCS_LABEL    ('rcs -q -Nv$(VERSION_SYM):')
      SHAR         ('shar')
      SUFFIX       ('.gz')
      TAR          ('tar')
      TARFLAGS     ('cvf')
      ZIP          ('zip')
      ZIPFLAGS     ('-r')
  
  An example:
  
      WriteMakefile(
          ...other options...
          dist => {
              COMPRESS => "bzip2",
              SUFFIX   => ".bz2"
          }
      );
  
  
  =head2 Module Meta-Data (META and MYMETA)
  
  Long plaguing users of MakeMaker based modules has been the problem of
  getting basic information about the module out of the sources
  I<without> running the F<Makefile.PL> and doing a bunch of messy
  heuristics on the resulting F<Makefile>.  Over the years, it has become
  standard to keep this information in one or more CPAN Meta files
  distributed with each distribution.
  
  The original format of CPAN Meta files was L<YAML> and the corresponding
  file was called F<META.yml>.  In 2010, version 2 of the L<CPAN::Meta::Spec>
  was released, which mandates JSON format for the metadata in order to
  overcome certain compatibility issues between YAML serializers and to
  avoid breaking older clients unable to handle a new version of the spec.
  The L<CPAN::Meta> library is now standard for accessing old and new-style
  Meta files.
  
  If L<CPAN::Meta> is installed, MakeMaker will automatically generate
  F<META.json> and F<META.yml> files for you and add them to your F<MANIFEST> as
  part of the 'distdir' target (and thus the 'dist' target).  This is intended to
  seamlessly and rapidly populate CPAN with module meta-data.  If you wish to
  shut this feature off, set the C<NO_META> C<WriteMakefile()> flag to true.
  
  At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agreed
  to use the CPAN Meta format to communicate post-configuration requirements
  between toolchain components.  These files, F<MYMETA.json> and F<MYMETA.yml>,
  are generated when F<Makefile.PL> generates a F<Makefile> (if L<CPAN::Meta>
  is installed).  Clients like L<CPAN> or L<CPANPLUS> will read these
  files to see what prerequisites must be fulfilled before building or testing
  the distribution.  If you wish to shut this feature off, set the C<NO_MYMETA>
  C<WriteMakeFile()> flag to true.
  
  =head2 Disabling an extension
  
  If some events detected in F<Makefile.PL> imply that there is no way
  to create the Module, but this is a normal state of things, then you
  can create a F<Makefile> which does nothing, but succeeds on all the
  "usual" build targets.  To do so, use
  
      use ExtUtils::MakeMaker qw(WriteEmptyMakefile);
      WriteEmptyMakefile();
  
  instead of WriteMakefile().
  
  This may be useful if other modules expect this module to be I<built>
  OK, as opposed to I<work> OK (say, this system-dependent module builds
  in a subdirectory of some other distribution, or is listed as a
  dependency in a CPAN::Bundle, but the functionality is supported by
  different means on the current architecture).
  
  =head2 Other Handy Functions
  
  =over 4
  
  =item prompt
  
      my $value = prompt($message);
      my $value = prompt($message, $default);
  
  The C<prompt()> function provides an easy way to request user input
  used to write a makefile.  It displays the $message as a prompt for
  input.  If a $default is provided it will be used as a default.  The
  function returns the $value selected by the user.
  
  If C<prompt()> detects that it is not running interactively and there
  is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable
  is set to true, the $default will be used without prompting.  This
  prevents automated processes from blocking on user input.
  
  If no $default is provided an empty string will be used instead.
  
  =item os_unsupported
  
    os_unsupported();
    os_unsupported if $^O eq 'MSWin32';
  
  The C<os_unsupported()> function provides a way to correctly exit your
  C<Makefile.PL> before calling C<WriteMakefile>. It is essentially a
  C<die> with the message "OS unsupported".
  
  This is supported since 7.26
  
  =back
  
  =head2 Supported versions of Perl
  
  Please note that while this module works on Perl 5.6, it is no longer
  being routinely tested on 5.6 - the earliest Perl version being routinely
  tested, and expressly supported, is 5.8.1. However, patches to repair
  any breakage on 5.6 are still being accepted.
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item PERL_MM_OPT
  
  Command line options used by C<MakeMaker-E<gt>new()>, and thus by
  C<WriteMakefile()>.  The string is split as the shell would, and the result
  is processed before any actual command line arguments are processed.
  
    PERL_MM_OPT='CCFLAGS="-Wl,-rpath -Wl,/foo/bar/lib" LIBS="-lwibble -lwobble"'
  
  =item PERL_MM_USE_DEFAULT
  
  If set to a true value then MakeMaker's prompt function will
  always return the default without waiting for user input.
  
  =item PERL_CORE
  
  Same as the PERL_CORE parameter.  The parameter overrides this.
  
  =back
  
  =head1 SEE ALSO
  
  L<Module::Build> is a pure-Perl alternative to MakeMaker which does
  not rely on make or any other external utility.  It is easier to
  extend to suit your needs.
  
  L<Module::Install> is a wrapper around MakeMaker which adds features
  not normally available.
  
  L<ExtUtils::ModuleMaker> and L<Module::Starter> are both modules to
  help you setup your distribution.
  
  L<CPAN::Meta> and L<CPAN::Meta::Spec> explain CPAN Meta files in detail.
  
  L<File::ShareDir::Install> makes it easy to install static, sometimes
  also referred to as 'shared' files. L<File::ShareDir> helps accessing
  the shared files after installation.
  
  L<Dist::Zilla> makes it easy for the module author to create MakeMaker-based
  distributions with lots of bells and whistles.
  
  =head1 AUTHORS
  
  Andy Dougherty C<doughera@lafayette.edu>, Andreas KE<ouml>nig
  C<andreas.koenig@mind.de>, Tim Bunce C<timb@cpan.org>.  VMS
  support by Charles Bailey C<bailey@newman.upenn.edu>.  OS/2 support
  by Ilya Zakharevich C<ilya@math.ohio-state.edu>.
  
  Currently maintained by Michael G Schwern C<schwern@pobox.com>
  
  Send patches and ideas to C<makemaker@perl.org>.
  
  Send bug reports via http://rt.cpan.org/.  Please send your
  generated Makefile along with your report.
  
  For more up-to-date information, see L<https://metacpan.org/release/ExtUtils-MakeMaker>.
  
  Repository available at L<https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker>.
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  
  =cut
EXTUTILS_MAKEMAKER

$fatpacked{"ExtUtils/MakeMaker/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_CONFIG';
  package ExtUtils::MakeMaker::Config;
  
  use strict;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  use Config ();
  
  # Give us an overridable config.
  our %Config = %Config::Config;
  
  sub import {
      my $caller = caller;
  
      no strict 'refs';   ## no critic
      *{$caller.'::Config'} = \%Config;
  }
  
  1;
  
  
  =head1 NAME
  
  ExtUtils::MakeMaker::Config - Wrapper around Config.pm
  
  
  =head1 SYNOPSIS
  
    use ExtUtils::MakeMaker::Config;
    print $Config{installbin};  # or whatever
  
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  A very thin wrapper around Config.pm so MakeMaker is easier to test.
  
  =cut
EXTUTILS_MAKEMAKER_CONFIG

$fatpacked{"ExtUtils/MakeMaker/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_LOCALE';
  package ExtUtils::MakeMaker::Locale;
  
  use strict;
  our $VERSION = "7.38";
  $VERSION =~ tr/_//d;
  
  use base 'Exporter';
  our @EXPORT_OK = qw(
      decode_argv env
      $ENCODING_LOCALE $ENCODING_LOCALE_FS
      $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT
  );
  
  use Encode ();
  use Encode::Alias ();
  
  our $ENCODING_LOCALE;
  our $ENCODING_LOCALE_FS;
  our $ENCODING_CONSOLE_IN;
  our $ENCODING_CONSOLE_OUT;
  
  sub DEBUG () { 0 }
  
  sub _init {
      if ($^O eq "MSWin32") {
  	unless ($ENCODING_LOCALE) {
  	    # Try to obtain what the Windows ANSI code page is
  	    eval {
  		unless (defined &GetConsoleCP) {
  		    require Win32;
                      # manually "import" it since Win32->import refuses
  		    *GetConsoleCP = sub { &Win32::GetConsoleCP } if defined &Win32::GetConsoleCP;
  		}
  		unless (defined &GetConsoleCP) {
  		    require Win32::API;
  		    Win32::API->Import('kernel32', 'int GetConsoleCP()');
  		}
  		if (defined &GetConsoleCP) {
  		    my $cp = GetConsoleCP();
  		    $ENCODING_LOCALE = "cp$cp" if $cp;
  		}
  	    };
  	}
  
  	unless ($ENCODING_CONSOLE_IN) {
              # only test one since set together
              unless (defined &GetInputCP) {
                  eval {
                      require Win32;
                      eval {
                          local $SIG{__WARN__} = sub {} if ( "$]" < 5.014 ); # suppress deprecation warning for inherited AUTOLOAD of Win32::GetConsoleCP()
                          Win32::GetConsoleCP();
                      };
                      # manually "import" it since Win32->import refuses
                      *GetInputCP = sub { &Win32::GetConsoleCP } if defined &Win32::GetConsoleCP;
                      *GetOutputCP = sub { &Win32::GetConsoleOutputCP } if defined &Win32::GetConsoleOutputCP;
                  };
                  unless (defined &GetInputCP) {
                      eval {
                          # try Win32::Console module for codepage to use
                          require Win32::Console;
                          *GetInputCP = sub { &Win32::Console::InputCP }
                              if defined &Win32::Console::InputCP;
                          *GetOutputCP = sub { &Win32::Console::OutputCP }
                              if defined &Win32::Console::OutputCP;
                      };
                  }
                  unless (defined &GetInputCP) {
                      # final fallback
                      *GetInputCP = *GetOutputCP = sub {
                          # another fallback that could work is:
                          # reg query HKLM\System\CurrentControlSet\Control\Nls\CodePage /v ACP
                          ((qx(chcp) || '') =~ /^Active code page: (\d+)/)
                              ? $1 : ();
                      };
                  }
  	    }
              my $cp = GetInputCP();
              $ENCODING_CONSOLE_IN = "cp$cp" if $cp;
              $cp = GetOutputCP();
              $ENCODING_CONSOLE_OUT = "cp$cp" if $cp;
  	}
      }
  
      unless ($ENCODING_LOCALE) {
  	eval {
  	    require I18N::Langinfo;
  	    $ENCODING_LOCALE = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
  
  	    # Workaround of Encode < v2.25.  The "646" encoding  alias was
  	    # introduced in Encode-2.25, but we don't want to require that version
  	    # quite yet.  Should avoid the CPAN testers failure reported from
  	    # openbsd-4.7/perl-5.10.0 combo.
  	    $ENCODING_LOCALE = "ascii" if $ENCODING_LOCALE eq "646";
  
  	    # https://rt.cpan.org/Ticket/Display.html?id=66373
  	    $ENCODING_LOCALE = "hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8";
  	};
  	$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN;
      }
  
      # Workaround of Encode < v2.71 for "cp65000" and "cp65001"
      # The "cp65000" and "cp65001" aliases were added in [Encode v2.71](https://github.com/dankogai/p5-encode/commit/7874bd95aa10967a3b5dbae333d16bcd703ac6c6)
      # via commit <https://github.com/dankogai/p5-encode/commit/84b9c1101d5251d37e226f80d1c6781718779047>.
      # This will avoid test failures for Win32 machines using the UTF-7 or UTF-8 code pages.
      $ENCODING_LOCALE = 'UTF-7' if $ENCODING_LOCALE && lc($ENCODING_LOCALE) eq "cp65000";
      $ENCODING_LOCALE = 'utf-8-strict' if $ENCODING_LOCALE && lc($ENCODING_LOCALE) eq "cp65001";
  
      if ($^O eq "darwin") {
  	$ENCODING_LOCALE_FS ||= "UTF-8";
      }
  
      # final fallback
      $ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";
      $ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;
  
      unless (Encode::find_encoding($ENCODING_LOCALE)) {
  	my $foundit;
  	if (lc($ENCODING_LOCALE) eq "gb18030") {
  	    eval {
  		require Encode::HanExtra;
  	    };
  	    if ($@) {
  		die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped";
  	    }
  	    $foundit++ if Encode::find_encoding($ENCODING_LOCALE);
  	}
  	die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped"
  	    unless $foundit;
  
      }
  
      # use Data::Dump; ddx $ENCODING_LOCALE, $ENCODING_LOCALE_FS, $ENCODING_CONSOLE_IN, $ENCODING_CONSOLE_OUT;
  }
  
  _init();
  Encode::Alias::define_alias(sub {
      no strict 'refs';
      no warnings 'once';
      return ${"ENCODING_" . uc(shift)};
  }, "locale");
  
  sub _flush_aliases {
      no strict 'refs';
      for my $a (sort keys %Encode::Alias::Alias) {
  	if (defined ${"ENCODING_" . uc($a)}) {
  	    delete $Encode::Alias::Alias{$a};
  	    warn "Flushed alias cache for $a" if DEBUG;
  	}
      }
  }
  
  sub reinit {
      $ENCODING_LOCALE = shift;
      $ENCODING_LOCALE_FS = shift;
      $ENCODING_CONSOLE_IN = $ENCODING_LOCALE;
      $ENCODING_CONSOLE_OUT = $ENCODING_LOCALE;
      _init();
      _flush_aliases();
  }
  
  sub decode_argv {
      die if defined wantarray;
      for (@ARGV) {
  	$_ = Encode::decode(locale => $_, @_);
      }
  }
  
  sub env {
      my $k = Encode::encode(locale => shift);
      my $old = $ENV{$k};
      if (@_) {
  	my $v = shift;
  	if (defined $v) {
  	    $ENV{$k} = Encode::encode(locale => $v);
  	}
  	else {
  	    delete $ENV{$k};
  	}
      }
      return Encode::decode(locale => $old) if defined wantarray;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::MakeMaker::Locale - bundled Encode::Locale
  
  =head1 SYNOPSIS
  
    use Encode::Locale;
    use Encode;
  
    $string = decode(locale => $bytes);
    $bytes = encode(locale => $string);
  
    if (-t) {
        binmode(STDIN, ":encoding(console_in)");
        binmode(STDOUT, ":encoding(console_out)");
        binmode(STDERR, ":encoding(console_out)");
    }
  
    # Processing file names passed in as arguments
    my $uni_filename = decode(locale => $ARGV[0]);
    open(my $fh, "<", encode(locale_fs => $uni_filename))
       || die "Can't open '$uni_filename': $!";
    binmode($fh, ":encoding(locale)");
    ...
  
  =head1 DESCRIPTION
  
  In many applications it's wise to let Perl use Unicode for the strings it
  processes.  Most of the interfaces Perl has to the outside world are still byte
  based.  Programs therefore need to decode byte strings that enter the program
  from the outside and encode them again on the way out.
  
  The POSIX locale system is used to specify both the language conventions
  requested by the user and the preferred character set to consume and
  output.  The C<Encode::Locale> module looks up the charset and encoding (called
  a CODESET in the locale jargon) and arranges for the L<Encode> module to know
  this encoding under the name "locale".  It means bytes obtained from the
  environment can be converted to Unicode strings by calling C<<
  Encode::encode(locale => $bytes) >> and converted back again with C<<
  Encode::decode(locale => $string) >>.
  
  Where file systems interfaces pass file names in and out of the program we also
  need care.  The trend is for operating systems to use a fixed file encoding
  that don't actually depend on the locale; and this module determines the most
  appropriate encoding for file names. The L<Encode> module will know this
  encoding under the name "locale_fs".  For traditional Unix systems this will
  be an alias to the same encoding as "locale".
  
  For programs running in a terminal window (called a "Console" on some systems)
  the "locale" encoding is usually a good choice for what to expect as input and
  output.  Some systems allows us to query the encoding set for the terminal and
  C<Encode::Locale> will do that if available and make these encodings known
  under the C<Encode> aliases "console_in" and "console_out".  For systems where
  we can't determine the terminal encoding these will be aliased as the same
  encoding as "locale".  The advice is to use "console_in" for input known to
  come from the terminal and "console_out" for output to the terminal.
  
  In addition to arranging for various Encode aliases the following functions and
  variables are provided:
  
  =over
  
  =item decode_argv( )
  
  =item decode_argv( Encode::FB_CROAK )
  
  This will decode the command line arguments to perl (the C<@ARGV> array) in-place.
  
  The function will by default replace characters that can't be decoded by
  "\x{FFFD}", the Unicode replacement character.
  
  Any argument provided is passed as CHECK to underlying Encode::decode() call.
  Pass the value C<Encode::FB_CROAK> to have the decoding croak if not all the
  command line arguments can be decoded.  See L<Encode/"Handling Malformed Data">
  for details on other options for CHECK.
  
  =item env( $uni_key )
  
  =item env( $uni_key => $uni_value )
  
  Interface to get/set environment variables.  Returns the current value as a
  Unicode string. The $uni_key and $uni_value arguments are expected to be
  Unicode strings as well.  Passing C<undef> as $uni_value deletes the
  environment variable named $uni_key.
  
  The returned value will have the characters that can't be decoded replaced by
  "\x{FFFD}", the Unicode replacement character.
  
  There is no interface to request alternative CHECK behavior as for
  decode_argv().  If you need that you need to call encode/decode yourself.
  For example:
  
      my $key = Encode::encode(locale => $uni_key, Encode::FB_CROAK);
      my $uni_value = Encode::decode(locale => $ENV{$key}, Encode::FB_CROAK);
  
  =item reinit( )
  
  =item reinit( $encoding )
  
  Reinitialize the encodings from the locale.  You want to call this function if
  you changed anything in the environment that might influence the locale.
  
  This function will croak if the determined encoding isn't recognized by
  the Encode module.
  
  With argument force $ENCODING_... variables to set to the given value.
  
  =item $ENCODING_LOCALE
  
  The encoding name determined to be suitable for the current locale.
  L<Encode> know this encoding as "locale".
  
  =item $ENCODING_LOCALE_FS
  
  The encoding name determined to be suitable for file system interfaces
  involving file names.
  L<Encode> know this encoding as "locale_fs".
  
  =item $ENCODING_CONSOLE_IN
  
  =item $ENCODING_CONSOLE_OUT
  
  The encodings to be used for reading and writing output to the a console.
  L<Encode> know these encodings as "console_in" and "console_out".
  
  =back
  
  =head1 NOTES
  
  This table summarizes the mapping of the encodings set up
  by the C<Encode::Locale> module:
  
    Encode      |         |              |
    Alias       | Windows | Mac OS X     | POSIX
    ------------+---------+--------------+------------
    locale      | ANSI    | nl_langinfo  | nl_langinfo
    locale_fs   | ANSI    | UTF-8        | nl_langinfo
    console_in  | OEM     | nl_langinfo  | nl_langinfo
    console_out | OEM     | nl_langinfo  | nl_langinfo
  
  =head2 Windows
  
  Windows has basically 2 sets of APIs.  A wide API (based on passing UTF-16
  strings) and a byte based API based a character set called ANSI.  The
  regular Perl interfaces to the OS currently only uses the ANSI APIs.
  Unfortunately ANSI is not a single character set.
  
  The encoding that corresponds to ANSI varies between different editions of
  Windows.  For many western editions of Windows ANSI corresponds to CP-1252
  which is a character set similar to ISO-8859-1.  Conceptually the ANSI
  character set is a similar concept to the POSIX locale CODESET so this module
  figures out what the ANSI code page is and make this available as
  $ENCODING_LOCALE and the "locale" Encoding alias.
  
  Windows systems also operate with another byte based character set.
  It's called the OEM code page.  This is the encoding that the Console
  takes as input and output.  It's common for the OEM code page to
  differ from the ANSI code page.
  
  =head2 Mac OS X
  
  On Mac OS X the file system encoding is always UTF-8 while the locale
  can otherwise be set up as normal for POSIX systems.
  
  File names on Mac OS X will at the OS-level be converted to
  NFD-form.  A file created by passing a NFC-filename will come
  in NFD-form from readdir().  See L<Unicode::Normalize> for details
  of NFD/NFC.
  
  Actually, Apple does not follow the Unicode NFD standard since not all
  character ranges are decomposed.  The claim is that this avoids problems with
  round trip conversions from old Mac text encodings.  See L<Encode::UTF8Mac> for
  details.
  
  =head2 POSIX (Linux and other Unixes)
  
  File systems might vary in what encoding is to be used for
  filenames.  Since this module has no way to actually figure out
  what the is correct it goes with the best guess which is to
  assume filenames are encoding according to the current locale.
  Users are advised to always specify UTF-8 as the locale charset.
  
  =head1 SEE ALSO
  
  L<I18N::Langinfo>, L<Encode>, L<Term::Encoding>
  
  =head1 AUTHOR
  
  Copyright 2010 Gisle Aas <gisle@aas.no>.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
EXTUTILS_MAKEMAKER_LOCALE

$fatpacked{"ExtUtils/MakeMaker/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION';
  #--------------------------------------------------------------------------#
  # This is a modified copy of version.pm 0.9909, bundled exclusively for
  # use by ExtUtils::Makemaker and its dependencies to bootstrap when
  # version.pm is not available.  It should not be used by ordinary modules.
  #
  # When loaded, it will try to load version.pm.  If that fails, it will load
  # ExtUtils::MakeMaker::version::vpp and alias various *version functions
  # to functions in that module.  It will also override UNIVERSAL::VERSION.
  #--------------------------------------------------------------------------#
  
  package ExtUtils::MakeMaker::version;
  
  use 5.006001;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  $CLASS = 'version';
  
  {
      local $SIG{'__DIE__'};
      eval "use version";
      if ( $@ ) { # don't have any version.pm installed
          eval "use ExtUtils::MakeMaker::version::vpp";
          die "$@" if ( $@ );
          local $^W;
          delete $INC{'version.pm'};
          $INC{'version.pm'} = $INC{'ExtUtils/MakeMaker/version.pm'};
          push @version::ISA, "ExtUtils::MakeMaker::version::vpp";
          $version::VERSION = $VERSION;
          *version::qv = \&ExtUtils::MakeMaker::version::vpp::qv;
          *version::declare = \&ExtUtils::MakeMaker::version::vpp::declare;
          *version::_VERSION = \&ExtUtils::MakeMaker::version::vpp::_VERSION;
          *version::vcmp = \&ExtUtils::MakeMaker::version::vpp::vcmp;
          *version::new = \&ExtUtils::MakeMaker::version::vpp::new;
          if ("$]" >= 5.009000) {
              no strict 'refs';
              *version::stringify = \&ExtUtils::MakeMaker::version::vpp::stringify;
              *{'version::(""'} = \&ExtUtils::MakeMaker::version::vpp::stringify;
              *{'version::(<=>'} = \&ExtUtils::MakeMaker::version::vpp::vcmp;
              *version::parse = \&ExtUtils::MakeMaker::version::vpp::parse;
          }
          require ExtUtils::MakeMaker::version::regex;
          *version::is_lax = \&ExtUtils::MakeMaker::version::regex::is_lax;
          *version::is_strict = \&ExtUtils::MakeMaker::version::regex::is_strict;
          *LAX = \$ExtUtils::MakeMaker::version::regex::LAX;
          *STRICT = \$ExtUtils::MakeMaker::version::regex::STRICT;
      }
      elsif ( ! version->can('is_qv') ) {
          *version::is_qv = sub { exists $_[0]->{qv} };
      }
  }
  
  1;
EXTUTILS_MAKEMAKER_VERSION

$fatpacked{"ExtUtils/MakeMaker/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION_REGEX';
  #--------------------------------------------------------------------------#
  # This is a modified copy of version.pm 0.9909, bundled exclusively for
  # use by ExtUtils::Makemaker and its dependencies to bootstrap when
  # version.pm is not available.  It should not be used by ordinary modules.
  #--------------------------------------------------------------------------#
  
  package ExtUtils::MakeMaker::version::regex;
  
  use strict;
  
  use vars qw($VERSION $CLASS $STRICT $LAX);
  
  $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
EXTUTILS_MAKEMAKER_VERSION_REGEX

$fatpacked{"ExtUtils/MakeMaker/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION_VPP';
  #--------------------------------------------------------------------------#
  # This is a modified copy of version.pm 0.9909, bundled exclusively for
  # use by ExtUtils::Makemaker and its dependencies to bootstrap when
  # version.pm is not available.  It should not be used by ordinary modules.
  #--------------------------------------------------------------------------#
  
  package ExtUtils::MakeMaker::charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package ExtUtils::MakeMaker::version::vpp;
  
  use 5.006001;
  use strict;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT);
  $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  $CLASS = 'ExtUtils::MakeMaker::version::vpp';
  
  require ExtUtils::MakeMaker::version::regex;
  *ExtUtils::MakeMaker::version::vpp::is_strict = \&ExtUtils::MakeMaker::version::regex::is_strict;
  *ExtUtils::MakeMaker::version::vpp::is_lax = \&ExtUtils::MakeMaker::version::regex::is_lax;
  *LAX = \$ExtUtils::MakeMaker::version::regex::LAX;
  *STRICT = \$ExtUtils::MakeMaker::version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  eval "use warnings";
  if ($@) {
      eval '
  	package
  	warnings;
  	sub enabled {return $^W;}
  	1;
      ';
  }
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new ExtUtils::MakeMaker::charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos)) {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) ) {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale} && eval { require POSIX } ) {
        require locale;
  	my $currlocale = POSIX::setlocale(&POSIX::LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( POSIX::localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn("Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $width = $self->{width} || 3;
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      for ( my $i = 1 ; $i < $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	if ( $width < 3 ) {
  	    my $denom = 10**(3-$width);
  	    my $quot = int($digit/$denom);
  	    my $rem = $digit - ($quot * $denom);
  	    $string .= sprintf("%0".$width."d_%d", $quot, $rem);
  	}
  	else {
  	    $string .= sprintf("%03d", $digit);
  	}
      }
  
      if ( $len > 0 ) {
  	$digit = $self->{version}[$len];
  	if ( $alpha && $width == 3 ) {
  	    $string .= "_";
  	}
  	$string .= sprintf("%0".$width."d", $digit);
      }
      else # $len = 0
      {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i < $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len > 0 ) {
  	$digit = $self->{version}[$len];
  	if ( $alpha ) {
  	    $string .= sprintf("_%0d", $digit);
  	}
  	else {
  	    $string .= sprintf(".%0d", $digit);
  	}
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      require UNIVERSAL;
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # tiebreaker for alpha with identical terms
      if ( $retval == 0
  	&& $l == $r
  	&& $left->{version}[$m] == $right->{version}[$m]
  	&& ( $lalpha || $ralpha ) ) {
  
  	if ( $lalpha && !$ralpha ) {
  	    $retval = -1;
  	}
  	elsif ( $ralpha && !$lalpha) {
  	    $retval = +1;
  	}
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new ExtUtils::MakeMaker::charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 3 && $value !~ /[._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( "$]" >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( "$]" >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+){2,}$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and "$]" >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if "$]" <= 5.008;
  	$version = ExtUtils::MakeMaker::version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg = "$]" < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = ExtUtils::MakeMaker::version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
EXTUTILS_MAKEMAKER_VERSION_VPP

$fatpacked{"ExtUtils/Mkbootstrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKBOOTSTRAP';
  package ExtUtils::Mkbootstrap;
  
  # There's just too much Dynaloader incest here to turn on strict vars.
  use strict 'refs';
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  our @ISA = ('Exporter');
  our @EXPORT = ('&Mkbootstrap');
  
  use Config;
  
  our $Verbose = 0;
  
  
  sub Mkbootstrap {
      my($baseext, @bsloadlibs)=@_;
      @bsloadlibs = grep($_, @bsloadlibs); # strip empty libs
  
      print "	bsloadlibs=@bsloadlibs\n" if $Verbose;
  
      # We need DynaLoader here because we and/or the *_BS file may
      # call dl_findfile(). We don't say `use' here because when
      # first building perl extensions the DynaLoader will not have
      # been built when MakeMaker gets first used.
      require DynaLoader;
  
      rename "$baseext.bs", "$baseext.bso"
        if -s "$baseext.bs";
  
      if (-f "${baseext}_BS"){
  	$_ = "${baseext}_BS";
  	package DynaLoader; # execute code as if in DynaLoader
  	local($osname, $dlsrc) = (); # avoid warnings
  	($osname, $dlsrc) = @Config::Config{qw(osname dlsrc)};
  	$bscode = "";
  	unshift @INC, ".";
  	require $_;
  	shift @INC;
      }
  
      if ($Config{'dlsrc'} =~ /^dl_dld/){
  	package DynaLoader;
  	push(@dl_resolve_using, dl_findfile('-lc'));
      }
  
      my(@all) = (@bsloadlibs, @DynaLoader::dl_resolve_using);
      my($method) = '';
      if (@all || (defined $DynaLoader::bscode && length $DynaLoader::bscode)){
  	open my $bs, ">", "$baseext.bs"
  		or die "Unable to open $baseext.bs: $!";
  	print "Writing $baseext.bs\n";
  	print "	containing: @all" if $Verbose;
  	print $bs "# $baseext DynaLoader bootstrap file for $^O architecture.\n";
  	print $bs "# Do not edit this file, changes will be lost.\n";
  	print $bs "# This file was automatically generated by the\n";
  	print $bs "# Mkbootstrap routine in ExtUtils::Mkbootstrap (v$VERSION).\n";
  	if (@all) {
  	    print $bs "\@DynaLoader::dl_resolve_using = ";
  	    # If @all contains names in the form -lxxx or -Lxxx then it's asking for
  	    # runtime library location so we automatically add a call to dl_findfile()
  	    if (" @all" =~ m/ -[lLR]/){
  		print $bs "  dl_findfile(qw(\n  @all\n  ));\n";
  	    } else {
  		print $bs "  qw(@all);\n";
  	    }
  	}
  	# write extra code if *_BS says so
  	print $bs $DynaLoader::bscode if $DynaLoader::bscode;
  	print $bs "\n1;\n";
  	close $bs;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader
  
  =head1 SYNOPSIS
  
    Mkbootstrap
  
  =head1 DESCRIPTION
  
  Mkbootstrap typically gets called from an extension Makefile.
  
  There is no C<*.bs> file supplied with the extension. Instead, there may
  be a C<*_BS> file which has code for the special cases, like posix for
  berkeley db on the NeXT.
  
  This file will get parsed, and produce a maybe empty
  C<@DynaLoader::dl_resolve_using> array for the current architecture.
  That will be extended by $BSLOADLIBS, which was computed by
  ExtUtils::Liblist::ext(). If this array still is empty, we do nothing,
  else we write a .bs file with an C<@DynaLoader::dl_resolve_using>
  array.
  
  The C<*_BS> file can put some code into the generated C<*.bs> file by
  placing it in C<$bscode>. This is a handy 'escape' mechanism that may
  prove useful in complex situations.
  
  If @DynaLoader::dl_resolve_using contains C<-L*> or C<-l*> entries then
  Mkbootstrap will automatically add a dl_findfile() call to the
  generated C<*.bs> file.
  
  =cut
EXTUTILS_MKBOOTSTRAP

$fatpacked{"ExtUtils/Mksymlists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKSYMLISTS';
  package ExtUtils::Mksymlists;
  
  use 5.006;
  use strict qw[ subs refs ];
  # no strict 'vars';  # until filehandles are exempted
  
  use Carp;
  use Exporter;
  use Config;
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(&Mksymlists);
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  sub Mksymlists {
      my(%spec) = @_;
      my($osname) = $^O;
  
      croak("Insufficient information specified to Mksymlists")
          unless ( $spec{NAME} or
                   ($spec{FILE} and ($spec{DL_FUNCS} or $spec{FUNCLIST})) );
  
      $spec{DL_VARS} = [] unless $spec{DL_VARS};
      ($spec{FILE} = $spec{NAME}) =~ s/.*::// unless $spec{FILE};
      $spec{FUNCLIST} = [] unless $spec{FUNCLIST};
      $spec{DL_FUNCS} = { $spec{NAME} => [] }
          unless ( ($spec{DL_FUNCS} and keys %{$spec{DL_FUNCS}}) or
                   @{$spec{FUNCLIST}});
      if (defined $spec{DL_FUNCS}) {
          foreach my $package (sort keys %{$spec{DL_FUNCS}}) {
              my($packprefix,$bootseen);
              ($packprefix = $package) =~ s/\W/_/g;
              foreach my $sym (@{$spec{DL_FUNCS}->{$package}}) {
                  if ($sym =~ /^boot_/) {
                      push(@{$spec{FUNCLIST}},$sym);
                      $bootseen++;
                  }
                  else {
                      push(@{$spec{FUNCLIST}},"XS_${packprefix}_$sym");
                  }
              }
              push(@{$spec{FUNCLIST}},"boot_$packprefix") unless $bootseen;
          }
      }
  
  #    We'll need this if we ever add any OS which uses mod2fname
  #    not as pseudo-builtin.
  #    require DynaLoader;
      if (defined &DynaLoader::mod2fname and not $spec{DLBASE}) {
          $spec{DLBASE} = DynaLoader::mod2fname([ split(/::/,$spec{NAME}) ]);
      }
  
      if    ($osname eq 'aix') { _write_aix(\%spec); }
      elsif ($osname eq 'MacOS'){ _write_aix(\%spec) }
      elsif ($osname eq 'VMS') { _write_vms(\%spec) }
      elsif ($osname eq 'os2') { _write_os2(\%spec) }
      elsif ($osname eq 'MSWin32') { _write_win32(\%spec) }
      else {
          croak("Don't know how to create linker option file for $osname\n");
      }
  }
  
  
  sub _write_aix {
      my($data) = @_;
  
      rename "$data->{FILE}.exp", "$data->{FILE}.exp_old";
  
      open( my $exp, ">", "$data->{FILE}.exp")
          or croak("Can't create $data->{FILE}.exp: $!\n");
      print $exp join("\n",@{$data->{DL_VARS}}, "\n") if @{$data->{DL_VARS}};
      print $exp join("\n",@{$data->{FUNCLIST}}, "\n") if @{$data->{FUNCLIST}};
      close $exp;
  }
  
  
  sub _write_os2 {
      my($data) = @_;
      require Config;
      my $threaded = ($Config::Config{archname} =~ /-thread/ ? " threaded" : "");
  
      if (not $data->{DLBASE}) {
          ($data->{DLBASE} = $data->{NAME}) =~ s/.*:://;
          $data->{DLBASE} = substr($data->{DLBASE},0,7) . '_';
      }
      my $distname = $data->{DISTNAME} || $data->{NAME};
      $distname = "Distribution $distname";
      my $patchlevel = " pl$Config{perl_patchlevel}" || '';
      my $comment = sprintf "Perl (v%s%s%s) module %s",
        $Config::Config{version}, $threaded, $patchlevel, $data->{NAME};
      chomp $comment;
      if ($data->{INSTALLDIRS} and $data->{INSTALLDIRS} eq 'perl') {
          $distname = 'perl5-porters@perl.org';
          $comment = "Core $comment";
      }
      $comment = "$comment (Perl-config: $Config{config_args})";
      $comment = substr($comment, 0, 200) . "...)" if length $comment > 203;
      rename "$data->{FILE}.def", "$data->{FILE}_def.old";
  
      open(my $def, ">", "$data->{FILE}.def")
          or croak("Can't create $data->{FILE}.def: $!\n");
      print $def "LIBRARY '$data->{DLBASE}' INITINSTANCE TERMINSTANCE\n";
      print $def "DESCRIPTION '\@#$distname:$data->{VERSION}#\@ $comment'\n";
      print $def "CODE LOADONCALL\n";
      print $def "DATA LOADONCALL NONSHARED MULTIPLE\n";
      print $def "EXPORTS\n  ";
      print $def join("\n  ",@{$data->{DL_VARS}}, "\n") if @{$data->{DL_VARS}};
      print $def join("\n  ",@{$data->{FUNCLIST}}, "\n") if @{$data->{FUNCLIST}};
      _print_imports($def, $data);
      close $def;
  }
  
  sub _print_imports {
      my ($def, $data)= @_;
      my $imports= $data->{IMPORTS}
          or return;
      if ( keys %$imports ) {
          print $def "IMPORTS\n";
          foreach my $name (sort keys %$imports) {
              print $def "  $name=$imports->{$name}\n";
          }
      }
  }
  
  sub _write_win32 {
      my($data) = @_;
  
      require Config;
      if (not $data->{DLBASE}) {
          ($data->{DLBASE} = $data->{NAME}) =~ s/.*:://;
          $data->{DLBASE} = substr($data->{DLBASE},0,7) . '_';
      }
      rename "$data->{FILE}.def", "$data->{FILE}_def.old";
  
      open( my $def, ">", "$data->{FILE}.def" )
          or croak("Can't create $data->{FILE}.def: $!\n");
      # put library name in quotes (it could be a keyword, like 'Alias')
      if ($Config::Config{'cc'} !~ /\bgcc/i) {
          print $def "LIBRARY \"$data->{DLBASE}\"\n";
      }
      print $def "EXPORTS\n  ";
      my @syms;
      # Export public symbols both with and without underscores to
      # ensure compatibility between DLLs from Borland C and Visual C
      # NOTE: DynaLoader itself only uses the names without underscores,
      # so this is only to cover the case when the extension DLL may be
      # linked to directly from C. GSAR 97-07-10
  
      #bcc dropped in 5.16, so dont create useless extra symbols for export table
      unless("$]" >= 5.016) {
          if ($Config::Config{'cc'} =~ /^bcc/i) {
              push @syms, "_$_", "$_ = _$_"
                  for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}});
          }
          else {
              push @syms, "$_", "_$_ = $_"
                  for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}});
          }
      } else {
          push @syms, "$_"
              for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}});
      }
      print $def join("\n  ",@syms, "\n") if @syms;
      _print_imports($def, $data);
      close $def;
  }
  
  
  sub _write_vms {
      my($data) = @_;
  
      require Config; # a reminder for once we do $^O
      require ExtUtils::XSSymSet;
  
      my($isvax) = $Config::Config{'archname'} =~ /VAX/i;
      my($set) = new ExtUtils::XSSymSet;
  
      rename "$data->{FILE}.opt", "$data->{FILE}.opt_old";
  
      open(my $opt,">", "$data->{FILE}.opt")
          or croak("Can't create $data->{FILE}.opt: $!\n");
  
      # Options file declaring universal symbols
      # Used when linking shareable image for dynamic extension,
      # or when linking PerlShr into which we've added this package
      # as a static extension
      # We don't do anything to preserve order, so we won't relax
      # the GSMATCH criteria for a dynamic extension
  
      print $opt "case_sensitive=yes\n"
          if $Config::Config{d_vms_case_sensitive_symbols};
  
      foreach my $sym (@{$data->{FUNCLIST}}) {
          my $safe = $set->addsym($sym);
          if ($isvax) { print $opt "UNIVERSAL=$safe\n" }
          else        { print $opt "SYMBOL_VECTOR=($safe=PROCEDURE)\n"; }
      }
  
      foreach my $sym (@{$data->{DL_VARS}}) {
          my $safe = $set->addsym($sym);
          print $opt "PSECT_ATTR=${sym},PIC,OVR,RD,NOEXE,WRT,NOSHR\n";
          if ($isvax) { print $opt "UNIVERSAL=$safe\n" }
          else        { print $opt "SYMBOL_VECTOR=($safe=DATA)\n"; }
      }
  
      close $opt;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Mksymlists - write linker options files for dynamic extension
  
  =head1 SYNOPSIS
  
      use ExtUtils::Mksymlists;
      Mksymlists(  NAME     => $name ,
                   DL_VARS  => [ $var1, $var2, $var3 ],
                   DL_FUNCS => { $pkg1 => [ $func1, $func2 ],
                                 $pkg2 => [ $func3 ] );
  
  =head1 DESCRIPTION
  
  C<ExtUtils::Mksymlists> produces files used by the linker under some OSs
  during the creation of shared libraries for dynamic extensions.  It is
  normally called from a MakeMaker-generated Makefile when the extension
  is built.  The linker option file is generated by calling the function
  C<Mksymlists>, which is exported by default from C<ExtUtils::Mksymlists>.
  It takes one argument, a list of key-value pairs, in which the following
  keys are recognized:
  
  =over 4
  
  =item DLBASE
  
  This item specifies the name by which the linker knows the
  extension, which may be different from the name of the
  extension itself (for instance, some linkers add an '_' to the
  name of the extension).  If it is not specified, it is derived
  from the NAME attribute.  It is presently used only by OS2 and Win32.
  
  =item DL_FUNCS
  
  This is identical to the DL_FUNCS attribute available via MakeMaker,
  from which it is usually taken.  Its value is a reference to an
  associative array, in which each key is the name of a package, and
  each value is an a reference to an array of function names which
  should be exported by the extension.  For instance, one might say
  C<DL_FUNCS =E<gt> { Homer::Iliad =E<gt> [ qw(trojans greeks) ],
  Homer::Odyssey =E<gt> [ qw(travellers family suitors) ] }>.  The
  function names should be identical to those in the XSUB code;
  C<Mksymlists> will alter the names written to the linker option
  file to match the changes made by F<xsubpp>.  In addition, if
  none of the functions in a list begin with the string B<boot_>,
  C<Mksymlists> will add a bootstrap function for that package,
  just as xsubpp does.  (If a B<boot_E<lt>pkgE<gt>> function is
  present in the list, it is passed through unchanged.)  If
  DL_FUNCS is not specified, it defaults to the bootstrap
  function for the extension specified in NAME.
  
  =item DL_VARS
  
  This is identical to the DL_VARS attribute available via MakeMaker,
  and, like DL_FUNCS, it is usually specified via MakeMaker.  Its
  value is a reference to an array of variable names which should
  be exported by the extension.
  
  =item FILE
  
  This key can be used to specify the name of the linker option file
  (minus the OS-specific extension), if for some reason you do not
  want to use the default value, which is the last word of the NAME
  attribute (I<e.g.> for C<Tk::Canvas>, FILE defaults to C<Canvas>).
  
  =item FUNCLIST
  
  This provides an alternate means to specify function names to be
  exported from the extension.  Its value is a reference to an
  array of function names to be exported by the extension.  These
  names are passed through unaltered to the linker options file.
  Specifying a value for the FUNCLIST attribute suppresses automatic
  generation of the bootstrap function for the package. To still create
  the bootstrap name you have to specify the package name in the
  DL_FUNCS hash:
  
      Mksymlists(  NAME     => $name ,
  		 FUNCLIST => [ $func1, $func2 ],
                   DL_FUNCS => { $pkg => [] } );
  
  
  =item IMPORTS
  
  This attribute is used to specify names to be imported into the
  extension. It is currently only used by OS/2 and Win32.
  
  =item NAME
  
  This gives the name of the extension (I<e.g.> C<Tk::Canvas>) for which
  the linker option file will be produced.
  
  =back
  
  When calling C<Mksymlists>, one should always specify the NAME
  attribute.  In most cases, this is all that's necessary.  In
  the case of unusual extensions, however, the other attributes
  can be used to provide additional information to the linker.
  
  =head1 AUTHOR
  
  Charles Bailey I<E<lt>bailey@newman.upenn.eduE<gt>>
  
  =head1 REVISION
  
  Last revised 14-Feb-1996, for Perl 5.002.
EXTUTILS_MKSYMLISTS

$fatpacked{"ExtUtils/testlib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TESTLIB';
  package ExtUtils::testlib;
  
  use strict;
  use warnings;
  
  our $VERSION = '7.38';
  $VERSION =~ tr/_//d;
  
  use Cwd;
  use File::Spec;
  
  # So the tests can chdir around and not break @INC.
  # We use getcwd() because otherwise rel2abs will blow up under taint
  # mode pre-5.8.  We detaint is so @INC won't be tainted.  This is
  # no worse, and probably better, than just shoving an untainted,
  # relative "blib/lib" onto @INC.
  my $cwd;
  BEGIN {
      ($cwd) = getcwd() =~ /(.*)/;
  }
  use lib map { File::Spec->rel2abs($_, $cwd) } qw(blib/arch blib/lib);
  1;
  __END__
  
  =head1 NAME
  
  ExtUtils::testlib - add blib/* directories to @INC
  
  =head1 SYNOPSIS
  
    use ExtUtils::testlib;
  
  =head1 DESCRIPTION
  
  After an extension has been built and before it is installed it may be
  desirable to test it bypassing C<make test>. By adding
  
      use ExtUtils::testlib;
  
  to a test program the intermediate directories used by C<make> are
  added to @INC.
  
EXTUTILS_TESTLIB

$fatpacked{"File/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PATH';
  package File::Path;
  
  use 5.005_04;
  use strict;
  
  use Cwd 'getcwd';
  use File::Basename ();
  use File::Spec     ();
  
  BEGIN {
      if ( $] < 5.006 ) {
  
          # can't say 'opendir my $dh, $dirname'
          # need to initialise $dh
          eval 'use Symbol';
      }
  }
  
  use Exporter ();
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  $VERSION   = '2.16';
  $VERSION   = eval $VERSION;
  @ISA       = qw(Exporter);
  @EXPORT    = qw(mkpath rmtree);
  @EXPORT_OK = qw(make_path remove_tree);
  
  BEGIN {
    for (qw(VMS MacOS MSWin32 os2)) {
      no strict 'refs';
      *{"_IS_\U$_"} = $^O eq $_ ? sub () { 1 } : sub () { 0 };
    }
  
    # These OSes complain if you want to remove a file that you have no
    # write permission to:
    *_FORCE_WRITABLE = (
      grep { $^O eq $_ } qw(amigaos dos epoc MSWin32 MacOS os2)
    ) ? sub () { 1 } : sub () { 0 };
  
    # Unix-like systems need to stat each directory in order to detect
    # race condition. MS-Windows is immune to this particular attack.
    *_NEED_STAT_CHECK = !(_IS_MSWIN32()) ? sub () { 1 } : sub () { 0 };
  }
  
  sub _carp {
      require Carp;
      goto &Carp::carp;
  }
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub _error {
      my $arg     = shift;
      my $message = shift;
      my $object  = shift;
  
      if ( $arg->{error} ) {
          $object = '' unless defined $object;
          $message .= ": $!" if $!;
          push @{ ${ $arg->{error} } }, { $object => $message };
      }
      else {
          _carp( defined($object) ? "$message for $object: $!" : "$message: $!" );
      }
  }
  
  sub __is_arg {
      my ($arg) = @_;
  
      # If client code blessed an array ref to HASH, this will not work
      # properly. We could have done $arg->isa() wrapped in eval, but
      # that would be expensive. This implementation should suffice.
      # We could have also used Scalar::Util:blessed, but we choose not
      # to add this dependency
      return ( ref $arg eq 'HASH' );
  }
  
  sub make_path {
      push @_, {} unless @_ and __is_arg( $_[-1] );
      goto &mkpath;
  }
  
  sub mkpath {
      my $old_style = !( @_ and __is_arg( $_[-1] ) );
  
      my $data;
      my $paths;
  
      if ($old_style) {
          my ( $verbose, $mode );
          ( $paths, $verbose, $mode ) = @_;
          $paths = [$paths] unless UNIVERSAL::isa( $paths, 'ARRAY' );
          $data->{verbose} = $verbose;
          $data->{mode} = defined $mode ? $mode : oct '777';
      }
      else {
          my %args_permitted = map { $_ => 1 } ( qw|
              chmod
              error
              group
              mask
              mode
              owner
              uid
              user
              verbose
          | );
          my %not_on_win32_args = map { $_ => 1 } ( qw|
              group
              owner
              uid
              user
          | );
          my @bad_args = ();
          my @win32_implausible_args = ();
          my $arg = pop @_;
          for my $k (sort keys %{$arg}) {
              if (! $args_permitted{$k}) {
                  push @bad_args, $k;
              }
              elsif ($not_on_win32_args{$k} and _IS_MSWIN32) {
                  push @win32_implausible_args, $k;
              }
              else {
                  $data->{$k} = $arg->{$k};
              }
          }
          _carp("Unrecognized option(s) passed to mkpath() or make_path(): @bad_args")
              if @bad_args;
          _carp("Option(s) implausible on Win32 passed to mkpath() or make_path(): @win32_implausible_args")
              if @win32_implausible_args;
          $data->{mode} = delete $data->{mask} if exists $data->{mask};
          $data->{mode} = oct '777' unless exists $data->{mode};
          ${ $data->{error} } = [] if exists $data->{error};
          unless (@win32_implausible_args) {
              $data->{owner} = delete $data->{user} if exists $data->{user};
              $data->{owner} = delete $data->{uid}  if exists $data->{uid};
              if ( exists $data->{owner} and $data->{owner} =~ /\D/ ) {
                  my $uid = ( getpwnam $data->{owner} )[2];
                  if ( defined $uid ) {
                      $data->{owner} = $uid;
                  }
                  else {
                      _error( $data,
                              "unable to map $data->{owner} to a uid, ownership not changed"
                            );
                      delete $data->{owner};
                  }
              }
              if ( exists $data->{group} and $data->{group} =~ /\D/ ) {
                  my $gid = ( getgrnam $data->{group} )[2];
                  if ( defined $gid ) {
                      $data->{group} = $gid;
                  }
                  else {
                      _error( $data,
                              "unable to map $data->{group} to a gid, group ownership not changed"
                      );
                      delete $data->{group};
                  }
              }
              if ( exists $data->{owner} and not exists $data->{group} ) {
                  $data->{group} = -1;    # chown will leave group unchanged
              }
              if ( exists $data->{group} and not exists $data->{owner} ) {
                  $data->{owner} = -1;    # chown will leave owner unchanged
              }
          }
          $paths = [@_];
      }
      return _mkpath( $data, $paths );
  }
  
  sub _mkpath {
      my $data   = shift;
      my $paths = shift;
  
      my ( @created );
      foreach my $path ( @{$paths} ) {
          next unless defined($path) and length($path);
          $path .= '/' if _IS_OS2 and $path =~ /^\w:\z/s; # feature of CRT
  
          # Logic wants Unix paths, so go with the flow.
          if (_IS_VMS) {
              next if $path eq '/';
              $path = VMS::Filespec::unixify($path);
          }
          next if -d $path;
          my $parent = File::Basename::dirname($path);
          # Coverage note:  It's not clear how we would test the condition:
          # '-d $parent or $path eq $parent'
          unless ( -d $parent or $path eq $parent ) {
              push( @created, _mkpath( $data, [$parent] ) );
          }
          print "mkdir $path\n" if $data->{verbose};
          if ( mkdir( $path, $data->{mode} ) ) {
              push( @created, $path );
              if ( exists $data->{owner} ) {
  
                  # NB: $data->{group} guaranteed to be set during initialisation
                  if ( !chown $data->{owner}, $data->{group}, $path ) {
                      _error( $data,
                          "Cannot change ownership of $path to $data->{owner}:$data->{group}"
                      );
                  }
              }
              if ( exists $data->{chmod} ) {
                  # Coverage note:  It's not clear how we would trigger the next
                  # 'if' block.  Failure of 'chmod' might first result in a
                  # system error: "Permission denied".
                  if ( !chmod $data->{chmod}, $path ) {
                      _error( $data,
                          "Cannot change permissions of $path to $data->{chmod}" );
                  }
              }
          }
          else {
              my $save_bang = $!;
  
              # From 'perldoc perlvar': $EXTENDED_OS_ERROR ($^E) is documented
              # as:
              # Error information specific to the current operating system. At the
              # moment, this differs from "$!" under only VMS, OS/2, and Win32
              # (and for MacPerl). On all other platforms, $^E is always just the
              # same as $!.
  
              my ( $e, $e1 ) = ( $save_bang, $^E );
              $e .= "; $e1" if $e ne $e1;
  
              # allow for another process to have created it meanwhile
              if ( ! -d $path ) {
                  $! = $save_bang;
                  if ( $data->{error} ) {
                      push @{ ${ $data->{error} } }, { $path => $e };
                  }
                  else {
                      _croak("mkdir $path: $e");
                  }
              }
          }
      }
      return @created;
  }
  
  sub remove_tree {
      push @_, {} unless @_ and __is_arg( $_[-1] );
      goto &rmtree;
  }
  
  sub _is_subdir {
      my ( $dir, $test ) = @_;
  
      my ( $dv, $dd ) = File::Spec->splitpath( $dir,  1 );
      my ( $tv, $td ) = File::Spec->splitpath( $test, 1 );
  
      # not on same volume
      return 0 if $dv ne $tv;
  
      my @d = File::Spec->splitdir($dd);
      my @t = File::Spec->splitdir($td);
  
      # @t can't be a subdir if it's shorter than @d
      return 0 if @t < @d;
  
      return join( '/', @d ) eq join( '/', splice @t, 0, +@d );
  }
  
  sub rmtree {
      my $old_style = !( @_ and __is_arg( $_[-1] ) );
  
      my ($arg, $data, $paths);
  
      if ($old_style) {
          my ( $verbose, $safe );
          ( $paths, $verbose, $safe ) = @_;
          $data->{verbose} = $verbose;
          $data->{safe} = defined $safe ? $safe : 0;
  
          if ( defined($paths) and length($paths) ) {
              $paths = [$paths] unless UNIVERSAL::isa( $paths, 'ARRAY' );
          }
          else {
              _carp("No root path(s) specified\n");
              return 0;
          }
      }
      else {
          my %args_permitted = map { $_ => 1 } ( qw|
              error
              keep_root
              result
              safe
              verbose
          | );
          my @bad_args = ();
          my $arg = pop @_;
          for my $k (sort keys %{$arg}) {
              if (! $args_permitted{$k}) {
                  push @bad_args, $k;
              }
              else {
                  $data->{$k} = $arg->{$k};
              }
          }
          _carp("Unrecognized option(s) passed to remove_tree(): @bad_args")
              if @bad_args;
          ${ $data->{error} }  = [] if exists $data->{error};
          ${ $data->{result} } = [] if exists $data->{result};
  
          # Wouldn't it make sense to do some validation on @_ before assigning
          # to $paths here?
          # In the $old_style case we guarantee that each path is both defined
          # and non-empty.  We don't check that here, which means we have to
          # check it later in the first condition in this line:
          #     if ( $ortho_root_length && _is_subdir( $ortho_root, $ortho_cwd ) ) {
          # Granted, that would be a change in behavior for the two
          # non-old-style interfaces.
  
          $paths = [@_];
      }
  
      $data->{prefix} = '';
      $data->{depth}  = 0;
  
      my @clean_path;
      $data->{cwd} = getcwd() or do {
          _error( $data, "cannot fetch initial working directory" );
          return 0;
      };
      for ( $data->{cwd} ) { /\A(.*)\Z/s; $_ = $1 }    # untaint
  
      for my $p (@$paths) {
  
          # need to fixup case and map \ to / on Windows
          my $ortho_root = _IS_MSWIN32 ? _slash_lc($p) : $p;
          my $ortho_cwd =
            _IS_MSWIN32 ? _slash_lc( $data->{cwd} ) : $data->{cwd};
          my $ortho_root_length = length($ortho_root);
          $ortho_root_length-- if _IS_VMS;   # don't compare '.' with ']'
          if ( $ortho_root_length && _is_subdir( $ortho_root, $ortho_cwd ) ) {
              local $! = 0;
              _error( $data, "cannot remove path when cwd is $data->{cwd}", $p );
              next;
          }
  
          if (_IS_MACOS) {
              $p = ":$p" unless $p =~ /:/;
              $p .= ":" unless $p =~ /:\z/;
          }
          elsif ( _IS_MSWIN32 ) {
              $p =~ s{[/\\]\z}{};
          }
          else {
              $p =~ s{/\z}{};
          }
          push @clean_path, $p;
      }
  
      @{$data}{qw(device inode)} = ( lstat $data->{cwd} )[ 0, 1 ] or do {
          _error( $data, "cannot stat initial working directory", $data->{cwd} );
          return 0;
      };
  
      return _rmtree( $data, \@clean_path );
  }
  
  sub _rmtree {
      my $data   = shift;
      my $paths = shift;
  
      my $count  = 0;
      my $curdir = File::Spec->curdir();
      my $updir  = File::Spec->updir();
  
      my ( @files, $root );
    ROOT_DIR:
      foreach my $root (@$paths) {
  
          # since we chdir into each directory, it may not be obvious
          # to figure out where we are if we generate a message about
          # a file name. We therefore construct a semi-canonical
          # filename, anchored from the directory being unlinked (as
          # opposed to being truly canonical, anchored from the root (/).
  
          my $canon =
            $data->{prefix}
            ? File::Spec->catfile( $data->{prefix}, $root )
            : $root;
  
          my ( $ldev, $lino, $perm ) = ( lstat $root )[ 0, 1, 2 ]
            or next ROOT_DIR;
  
          if ( -d _ ) {
              $root = VMS::Filespec::vmspath( VMS::Filespec::pathify($root) )
                if _IS_VMS;
  
              if ( !chdir($root) ) {
  
                  # see if we can escalate privileges to get in
                  # (e.g. funny protection mask such as -w- instead of rwx)
                  # This uses fchmod to avoid traversing outside of the proper
                  # location (CVE-2017-6512)
                  my $root_fh;
                  if (open($root_fh, '<', $root)) {
                      my ($fh_dev, $fh_inode) = (stat $root_fh )[0,1];
                      $perm &= oct '7777';
                      my $nperm = $perm | oct '700';
                      local $@;
                      if (
                          !(
                              $data->{safe}
                             or $nperm == $perm
                             or !-d _
                             or $fh_dev ne $ldev
                             or $fh_inode ne $lino
                             or eval { chmod( $nperm, $root_fh ) }
                          )
                        )
                      {
                          _error( $data,
                              "cannot make child directory read-write-exec", $canon );
                          next ROOT_DIR;
                      }
                      close $root_fh;
                  }
                  if ( !chdir($root) ) {
                      _error( $data, "cannot chdir to child", $canon );
                      next ROOT_DIR;
                  }
              }
  
              my ( $cur_dev, $cur_inode, $perm ) = ( stat $curdir )[ 0, 1, 2 ]
                or do {
                  _error( $data, "cannot stat current working directory", $canon );
                  next ROOT_DIR;
                };
  
              if (_NEED_STAT_CHECK) {
                  ( $ldev eq $cur_dev and $lino eq $cur_inode )
                    or _croak(
  "directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting."
                    );
              }
  
              $perm &= oct '7777';    # don't forget setuid, setgid, sticky bits
              my $nperm = $perm | oct '700';
  
              # notabene: 0700 is for making readable in the first place,
              # it's also intended to change it to writable in case we have
              # to recurse in which case we are better than rm -rf for
              # subtrees with strange permissions
  
              if (
                  !(
                         $data->{safe}
                      or $nperm == $perm
                      or chmod( $nperm, $curdir )
                  )
                )
              {
                  _error( $data, "cannot make directory read+writeable", $canon );
                  $nperm = $perm;
              }
  
              my $d;
              $d = gensym() if $] < 5.006;
              if ( !opendir $d, $curdir ) {
                  _error( $data, "cannot opendir", $canon );
                  @files = ();
              }
              else {
                  if ( !defined ${^TAINT} or ${^TAINT} ) {
                      # Blindly untaint dir names if taint mode is active
                      @files = map { /\A(.*)\z/s; $1 } readdir $d;
                  }
                  else {
                      @files = readdir $d;
                  }
                  closedir $d;
              }
  
              if (_IS_VMS) {
  
                  # Deleting large numbers of files from VMS Files-11
                  # filesystems is faster if done in reverse ASCIIbetical order.
                  # include '.' to '.;' from blead patch #31775
                  @files = map { $_ eq '.' ? '.;' : $_ } reverse @files;
              }
  
              @files = grep { $_ ne $updir and $_ ne $curdir } @files;
  
              if (@files) {
  
                  # remove the contained files before the directory itself
                  my $narg = {%$data};
                  @{$narg}{qw(device inode cwd prefix depth)} =
                    ( $cur_dev, $cur_inode, $updir, $canon, $data->{depth} + 1 );
                  $count += _rmtree( $narg, \@files );
              }
  
              # restore directory permissions of required now (in case the rmdir
              # below fails), while we are still in the directory and may do so
              # without a race via '.'
              if ( $nperm != $perm and not chmod( $perm, $curdir ) ) {
                  _error( $data, "cannot reset chmod", $canon );
              }
  
              # don't leave the client code in an unexpected directory
              chdir( $data->{cwd} )
                or
                _croak("cannot chdir to $data->{cwd} from $canon: $!, aborting.");
  
              # ensure that a chdir upwards didn't take us somewhere other
              # than we expected (see CVE-2002-0435)
              ( $cur_dev, $cur_inode ) = ( stat $curdir )[ 0, 1 ]
                or _croak(
                  "cannot stat prior working directory $data->{cwd}: $!, aborting."
                );
  
              if (_NEED_STAT_CHECK) {
                  ( $data->{device} eq $cur_dev and $data->{inode} eq $cur_inode )
                    or _croak(  "previous directory $data->{cwd} "
                              . "changed before entering $canon, "
                              . "expected dev=$ldev ino=$lino, "
                              . "actual dev=$cur_dev ino=$cur_inode, aborting."
                    );
              }
  
              if ( $data->{depth} or !$data->{keep_root} ) {
                  if ( $data->{safe}
                      && ( _IS_VMS
                          ? !&VMS::Filespec::candelete($root)
                          : !-w $root ) )
                  {
                      print "skipped $root\n" if $data->{verbose};
                      next ROOT_DIR;
                  }
                  if ( _FORCE_WRITABLE and !chmod $perm | oct '700', $root ) {
                      _error( $data, "cannot make directory writeable", $canon );
                  }
                  print "rmdir $root\n" if $data->{verbose};
                  if ( rmdir $root ) {
                      push @{ ${ $data->{result} } }, $root if $data->{result};
                      ++$count;
                  }
                  else {
                      _error( $data, "cannot remove directory", $canon );
                      if (
                          _FORCE_WRITABLE
                          && !chmod( $perm,
                              ( _IS_VMS ? VMS::Filespec::fileify($root) : $root )
                          )
                        )
                      {
                          _error(
                              $data,
                              sprintf( "cannot restore permissions to 0%o",
                                  $perm ),
                              $canon
                          );
                      }
                  }
              }
          }
          else {
              # not a directory
              $root = VMS::Filespec::vmsify("./$root")
                if _IS_VMS
                && !File::Spec->file_name_is_absolute($root)
                && ( $root !~ m/(?<!\^)[\]>]+/ );    # not already in VMS syntax
  
              if (
                  $data->{safe}
                  && (
                      _IS_VMS
                      ? !&VMS::Filespec::candelete($root)
                      : !( -l $root || -w $root )
                  )
                )
              {
                  print "skipped $root\n" if $data->{verbose};
                  next ROOT_DIR;
              }
  
              my $nperm = $perm & oct '7777' | oct '600';
              if (    _FORCE_WRITABLE
                  and $nperm != $perm
                  and not chmod $nperm, $root )
              {
                  _error( $data, "cannot make file writeable", $canon );
              }
              print "unlink $canon\n" if $data->{verbose};
  
              # delete all versions under VMS
              for ( ; ; ) {
                  if ( unlink $root ) {
                      push @{ ${ $data->{result} } }, $root if $data->{result};
                  }
                  else {
                      _error( $data, "cannot unlink file", $canon );
                      _FORCE_WRITABLE and chmod( $perm, $root )
                        or _error( $data,
                          sprintf( "cannot restore permissions to 0%o", $perm ),
                          $canon );
                      last;
                  }
                  ++$count;
                  last unless _IS_VMS && lstat $root;
              }
          }
      }
      return $count;
  }
  
  sub _slash_lc {
  
      # fix up slashes and case on MSWin32 so that we can determine that
      # c:\path\to\dir is underneath C:/Path/To
      my $path = shift;
      $path =~ tr{\\}{/};
      return lc($path);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Path - Create or remove directory trees
  
  =head1 VERSION
  
  2.16 - released August 31 2018.
  
  =head1 SYNOPSIS
  
      use File::Path qw(make_path remove_tree);
  
      @created = make_path('foo/bar/baz', '/zug/zwang');
      @created = make_path('foo/bar/baz', '/zug/zwang', {
          verbose => 1,
          mode => 0711,
      });
      make_path('foo/bar/baz', '/zug/zwang', {
          chmod => 0777,
      });
  
      $removed_count = remove_tree('foo/bar/baz', '/zug/zwang', {
          verbose => 1,
          error  => \my $err_list,
          safe => 1,
      });
  
      # legacy (interface promoted before v2.00)
      @created = mkpath('/foo/bar/baz');
      @created = mkpath('/foo/bar/baz', 1, 0711);
      @created = mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
      $removed_count = rmtree('foo/bar/baz', 1, 1);
      $removed_count = rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);
  
      # legacy (interface promoted before v2.06)
      @created = mkpath('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
      $removed_count = rmtree('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
  
  =head1 DESCRIPTION
  
  This module provides a convenient way to create directories of
  arbitrary depth and to delete an entire directory subtree from the
  filesystem.
  
  The following functions are provided:
  
  =over
  
  =item make_path( $dir1, $dir2, .... )
  
  =item make_path( $dir1, $dir2, ...., \%opts )
  
  The C<make_path> function creates the given directories if they don't
  exist before, much like the Unix command C<mkdir -p>.
  
  The function accepts a list of directories to be created. Its
  behaviour may be tuned by an optional hashref appearing as the last
  parameter on the call.
  
  The function returns the list of directories actually created during
  the call; in scalar context the number of directories created.
  
  The following keys are recognised in the option hash:
  
  =over
  
  =item mode => $num
  
  The numeric permissions mode to apply to each created directory
  (defaults to C<0777>), to be modified by the current C<umask>. If the
  directory already exists (and thus does not need to be created),
  the permissions will not be modified.
  
  C<mask> is recognised as an alias for this parameter.
  
  =item chmod => $num
  
  Takes a numeric mode to apply to each created directory (not
  modified by the current C<umask>). If the directory already exists
  (and thus does not need to be created), the permissions will
  not be modified.
  
  =item verbose => $bool
  
  If present, will cause C<make_path> to print the name of each directory
  as it is created. By default nothing is printed.
  
  =item error => \$err
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store any errors that are encountered.  See the L</"ERROR
  HANDLING"> section for more information.
  
  If this parameter is not used, certain error conditions may raise
  a fatal error that will cause the program to halt, unless trapped
  in an C<eval> block.
  
  =item owner => $owner
  
  =item user => $owner
  
  =item uid => $owner
  
  If present, will cause any created directory to be owned by C<$owner>.
  If the value is numeric, it will be interpreted as a uid; otherwise a
  username is assumed. An error will be issued if the username cannot be
  mapped to a uid, the uid does not exist or the process lacks the
  privileges to change ownership.
  
  Ownership of directories that already exist will not be changed.
  
  C<user> and C<uid> are aliases of C<owner>.
  
  =item group => $group
  
  If present, will cause any created directory to be owned by the group
  C<$group>.  If the value is numeric, it will be interpreted as a gid;
  otherwise a group name is assumed. An error will be issued if the
  group name cannot be mapped to a gid, the gid does not exist or the
  process lacks the privileges to change group ownership.
  
  Group ownership of directories that already exist will not be changed.
  
      make_path '/var/tmp/webcache', {owner=>'nobody', group=>'nogroup'};
  
  =back
  
  =item mkpath( $dir )
  
  =item mkpath( $dir, $verbose, $mode )
  
  =item mkpath( [$dir1, $dir2,...], $verbose, $mode )
  
  =item mkpath( $dir1, $dir2,..., \%opt )
  
  The C<mkpath()> function provide the legacy interface of
  C<make_path()> with a different interpretation of the arguments
  passed.  The behaviour and return value of the function is otherwise
  identical to C<make_path()>.
  
  =item remove_tree( $dir1, $dir2, .... )
  
  =item remove_tree( $dir1, $dir2, ...., \%opts )
  
  The C<remove_tree> function deletes the given directories and any
  files and subdirectories they might contain, much like the Unix
  command C<rm -rf> or the Windows commands C<rmdir /s> and C<rd /s>.
  
  The function accepts a list of directories to be removed. (In point of fact,
  it will also accept filesystem entries which are not directories, such as
  regular files and symlinks.  But, as its name suggests, its intent is to
  remove trees rather than individual files.)
  
  C<remove_tree()>'s behaviour may be tuned by an optional hashref
  appearing as the last parameter on the call.  If an empty string is
  passed to C<remove_tree>, an error will occur.
  
  B<NOTE:>  For security reasons, we strongly advise use of the
  hashref-as-final-argument syntax -- specifically, with a setting of the C<safe>
  element to a true value.
  
      remove_tree( $dir1, $dir2, ....,
          {
              safe => 1,
              ...         # other key-value pairs
          },
      );
  
  The function returns the number of files successfully deleted.
  
  The following keys are recognised in the option hash:
  
  =over
  
  =item verbose => $bool
  
  If present, will cause C<remove_tree> to print the name of each file as
  it is unlinked. By default nothing is printed.
  
  =item safe => $bool
  
  When set to a true value, will cause C<remove_tree> to skip the files
  for which the process lacks the required privileges needed to delete
  files, such as delete privileges on VMS. In other words, the code
  will make no attempt to alter file permissions. Thus, if the process
  is interrupted, no filesystem object will be left in a more
  permissive mode.
  
  =item keep_root => $bool
  
  When set to a true value, will cause all files and subdirectories
  to be removed, except the initially specified directories. This comes
  in handy when cleaning out an application's scratch directory.
  
      remove_tree( '/tmp', {keep_root => 1} );
  
  =item result => \$res
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store all files and directories unlinked
  during the call. If nothing is unlinked, the array will be empty.
  
      remove_tree( '/tmp', {result => \my $list} );
      print "unlinked $_\n" for @$list;
  
  This is a useful alternative to the C<verbose> key.
  
  =item error => \$err
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store any errors that are encountered.  See the L</"ERROR
  HANDLING"> section for more information.
  
  Removing things is a much more dangerous proposition than
  creating things. As such, there are certain conditions that
  C<remove_tree> may encounter that are so dangerous that the only
  sane action left is to kill the program.
  
  Use C<error> to trap all that is reasonable (problems with
  permissions and the like), and let it die if things get out
  of hand. This is the safest course of action.
  
  =back
  
  =item rmtree( $dir )
  
  =item rmtree( $dir, $verbose, $safe )
  
  =item rmtree( [$dir1, $dir2,...], $verbose, $safe )
  
  =item rmtree( $dir1, $dir2,..., \%opt )
  
  The C<rmtree()> function provide the legacy interface of
  C<remove_tree()> with a different interpretation of the arguments
  passed. The behaviour and return value of the function is otherwise
  identical to C<remove_tree()>.
  
  B<NOTE:>  For security reasons, we strongly advise use of the
  hashref-as-final-argument syntax, specifically with a setting of the C<safe>
  element to a true value.
  
      rmtree( $dir1, $dir2, ....,
          {
              safe => 1,
              ...         # other key-value pairs
          },
      );
  
  =back
  
  =head2 ERROR HANDLING
  
  =over 4
  
  =item B<NOTE:>
  
  The following error handling mechanism is consistent throughout all
  code paths EXCEPT in cases where the ROOT node is nonexistent.  In
  version 2.11 the maintainers attempted to rectify this inconsistency
  but too many downstream modules encountered problems.  In such case,
  if you require root node evaluation or error checking prior to calling
  C<make_path> or C<remove_tree>, you should take additional precautions.
  
  =back
  
  If C<make_path> or C<remove_tree> encounters an error, a diagnostic
  message will be printed to C<STDERR> via C<carp> (for non-fatal
  errors) or via C<croak> (for fatal errors).
  
  If this behaviour is not desirable, the C<error> attribute may be
  used to hold a reference to a variable, which will be used to store
  the diagnostics. The variable is made a reference to an array of hash
  references.  Each hash contain a single key/value pair where the key
  is the name of the file, and the value is the error message (including
  the contents of C<$!> when appropriate).  If a general error is
  encountered the diagnostic key will be empty.
  
  An example usage looks like:
  
    remove_tree( 'foo/bar', 'bar/rat', {error => \my $err} );
    if ($err && @$err) {
        for my $diag (@$err) {
            my ($file, $message) = %$diag;
            if ($file eq '') {
                print "general error: $message\n";
            }
            else {
                print "problem unlinking $file: $message\n";
            }
        }
    }
    else {
        print "No error encountered\n";
    }
  
  Note that if no errors are encountered, C<$err> will reference an
  empty array.  This means that C<$err> will always end up TRUE; so you
  need to test C<@$err> to determine if errors occurred.
  
  =head2 NOTES
  
  C<File::Path> blindly exports C<mkpath> and C<rmtree> into the
  current namespace. These days, this is considered bad style, but
  to change it now would break too much code. Nonetheless, you are
  invited to specify what it is you are expecting to use:
  
    use File::Path 'rmtree';
  
  The routines C<make_path> and C<remove_tree> are B<not> exported
  by default. You must specify which ones you want to use.
  
    use File::Path 'remove_tree';
  
  Note that a side-effect of the above is that C<mkpath> and C<rmtree>
  are no longer exported at all. This is due to the way the C<Exporter>
  module works. If you are migrating a codebase to use the new
  interface, you will have to list everything explicitly. But that's
  just good practice anyway.
  
    use File::Path qw(remove_tree rmtree);
  
  =head3 API CHANGES
  
  The API was changed in the 2.0 branch. For a time, C<mkpath> and
  C<rmtree> tried, unsuccessfully, to deal with the two different
  calling mechanisms. This approach was considered a failure.
  
  The new semantics are now only available with C<make_path> and
  C<remove_tree>. The old semantics are only available through
  C<mkpath> and C<rmtree>. Users are strongly encouraged to upgrade
  to at least 2.08 in order to avoid surprises.
  
  =head3 SECURITY CONSIDERATIONS
  
  There were race conditions in the 1.x implementations of File::Path's
  C<rmtree> function (although sometimes patched depending on the OS
  distribution or platform). The 2.0 version contains code to avoid the
  problem mentioned in CVE-2002-0435.
  
  See the following pages for more information:
  
      http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=286905
      http://www.nntp.perl.org/group/perl.perl5.porters/2005/01/msg97623.html
      http://www.debian.org/security/2005/dsa-696
  
  Additionally, unless the C<safe> parameter is set (or the
  third parameter in the traditional interface is TRUE), should a
  C<remove_tree> be interrupted, files that were originally in read-only
  mode may now have their permissions set to a read-write (or "delete
  OK") mode.
  
  The following CVE reports were previously filed against File-Path and are
  believed to have been addressed:
  
  =over 4
  
  =item * L<http://cve.circl.lu/cve/CVE-2004-0452>
  
  =item * L<http://cve.circl.lu/cve/CVE-2005-0448>
  
  =back
  
  In February 2017 the cPanel Security Team reported an additional vulnerability
  in File-Path.  The C<chmod()> logic to make directories traversable can be
  abused to set the mode on an attacker-chosen file to an attacker-chosen value.
  This is due to the time-of-check-to-time-of-use (TOCTTOU) race condition
  (L<https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use>) between the
  C<stat()> that decides the inode is a directory and the C<chmod()> that tries
  to make it user-rwx.  CPAN versions 2.13 and later incorporate a patch
  provided by John Lightsey to address this problem.  This vulnerability has
  been reported as CVE-2017-6512.
  
  =head1 DIAGNOSTICS
  
  FATAL errors will cause the program to halt (C<croak>), since the
  problem is so severe that it would be dangerous to continue. (This
  can always be trapped with C<eval>, but it's not a good idea. Under
  the circumstances, dying is the best thing to do).
  
  SEVERE errors may be trapped using the modern interface. If the
  they are not trapped, or if the old interface is used, such an error
  will cause the program will halt.
  
  All other errors may be trapped using the modern interface, otherwise
  they will be C<carp>ed about. Program execution will not be halted.
  
  =over 4
  
  =item mkdir [path]: [errmsg] (SEVERE)
  
  C<make_path> was unable to create the path. Probably some sort of
  permissions error at the point of departure or insufficient resources
  (such as free inodes on Unix).
  
  =item No root path(s) specified
  
  C<make_path> was not given any paths to create. This message is only
  emitted if the routine is called with the traditional interface.
  The modern interface will remain silent if given nothing to do.
  
  =item No such file or directory
  
  On Windows, if C<make_path> gives you this warning, it may mean that
  you have exceeded your filesystem's maximum path length.
  
  =item cannot fetch initial working directory: [errmsg]
  
  C<remove_tree> attempted to determine the initial directory by calling
  C<Cwd::getcwd>, but the call failed for some reason. No attempt
  will be made to delete anything.
  
  =item cannot stat initial working directory: [errmsg]
  
  C<remove_tree> attempted to stat the initial directory (after having
  successfully obtained its name via C<getcwd>), however, the call
  failed for some reason. No attempt will be made to delete anything.
  
  =item cannot chdir to [dir]: [errmsg]
  
  C<remove_tree> attempted to set the working directory in order to
  begin deleting the objects therein, but was unsuccessful. This is
  usually a permissions issue. The routine will continue to delete
  other things, but this directory will be left intact.
  
  =item directory [dir] changed before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
  
  C<remove_tree> recorded the device and inode of a directory, and then
  moved into it. It then performed a C<stat> on the current directory
  and detected that the device and inode were no longer the same. As
  this is at the heart of the race condition problem, the program
  will die at this point.
  
  =item cannot make directory [dir] read+writeable: [errmsg]
  
  C<remove_tree> attempted to change the permissions on the current directory
  to ensure that subsequent unlinkings would not run into problems,
  but was unable to do so. The permissions remain as they were, and
  the program will carry on, doing the best it can.
  
  =item cannot read [dir]: [errmsg]
  
  C<remove_tree> tried to read the contents of the directory in order
  to acquire the names of the directory entries to be unlinked, but
  was unsuccessful. This is usually a permissions issue. The
  program will continue, but the files in this directory will remain
  after the call.
  
  =item cannot reset chmod [dir]: [errmsg]
  
  C<remove_tree>, after having deleted everything in a directory, attempted
  to restore its permissions to the original state but failed. The
  directory may wind up being left behind.
  
  =item cannot remove [dir] when cwd is [dir]
  
  The current working directory of the program is F</some/path/to/here>
  and you are attempting to remove an ancestor, such as F</some/path>.
  The directory tree is left untouched.
  
  The solution is to C<chdir> out of the child directory to a place
  outside the directory tree to be removed.
  
  =item cannot chdir to [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)
  
  C<remove_tree>, after having deleted everything and restored the permissions
  of a directory, was unable to chdir back to the parent. The program
  halts to avoid a race condition from occurring.
  
  =item cannot stat prior working directory [dir]: [errmsg], aborting. (FATAL)
  
  C<remove_tree> was unable to stat the parent directory after having returned
  from the child. Since there is no way of knowing if we returned to
  where we think we should be (by comparing device and inode) the only
  way out is to C<croak>.
  
  =item previous directory [parent-dir] changed before entering [child-dir], expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
  
  When C<remove_tree> returned from deleting files in a child directory, a
  check revealed that the parent directory it returned to wasn't the one
  it started out from. This is considered a sign of malicious activity.
  
  =item cannot make directory [dir] writeable: [errmsg]
  
  Just before removing a directory (after having successfully removed
  everything it contained), C<remove_tree> attempted to set the permissions
  on the directory to ensure it could be removed and failed. Program
  execution continues, but the directory may possibly not be deleted.
  
  =item cannot remove directory [dir]: [errmsg]
  
  C<remove_tree> attempted to remove a directory, but failed. This may be because
  some objects that were unable to be removed remain in the directory, or
  it could be a permissions issue. The directory will be left behind.
  
  =item cannot restore permissions of [dir] to [0nnn]: [errmsg]
  
  After having failed to remove a directory, C<remove_tree> was unable to
  restore its permissions from a permissive state back to a possibly
  more restrictive setting. (Permissions given in octal).
  
  =item cannot make file [file] writeable: [errmsg]
  
  C<remove_tree> attempted to force the permissions of a file to ensure it
  could be deleted, but failed to do so. It will, however, still attempt
  to unlink the file.
  
  =item cannot unlink file [file]: [errmsg]
  
  C<remove_tree> failed to remove a file. Probably a permissions issue.
  
  =item cannot restore permissions of [file] to [0nnn]: [errmsg]
  
  After having failed to remove a file, C<remove_tree> was also unable
  to restore the permissions on the file to a possibly less permissive
  setting. (Permissions given in octal).
  
  =item unable to map [owner] to a uid, ownership not changed");
  
  C<make_path> was instructed to give the ownership of created
  directories to the symbolic name [owner], but C<getpwnam> did
  not return the corresponding numeric uid. The directory will
  be created, but ownership will not be changed.
  
  =item unable to map [group] to a gid, group ownership not changed
  
  C<make_path> was instructed to give the group ownership of created
  directories to the symbolic name [group], but C<getgrnam> did
  not return the corresponding numeric gid. The directory will
  be created, but group ownership will not be changed.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<File::Remove>
  
  Allows files and directories to be moved to the Trashcan/Recycle
  Bin (where they may later be restored if necessary) if the operating
  system supports such functionality. This feature may one day be
  made available directly in C<File::Path>.
  
  =item *
  
  L<File::Find::Rule>
  
  When removing directory trees, if you want to examine each file to
  decide whether to delete it (and possibly leaving large swathes
  alone), F<File::Find::Rule> offers a convenient and flexible approach
  to examining directory trees.
  
  =back
  
  =head1 BUGS AND LIMITATIONS
  
  The following describes F<File::Path> limitations and how to report bugs.
  
  =head2 MULTITHREADED APPLICATIONS
  
  F<File::Path> C<rmtree> and C<remove_tree> will not work with
  multithreaded applications due to its use of C<chdir>.  At this time,
  no warning or error is generated in this situation.  You will
  certainly encounter unexpected results.
  
  The implementation that surfaces this limitation will not be changed. See the
  F<File::Path::Tiny> module for functionality similar to F<File::Path> but which does
  not C<chdir>.
  
  =head2 NFS Mount Points
  
  F<File::Path> is not responsible for triggering the automounts, mirror mounts,
  and the contents of network mounted filesystems.  If your NFS implementation
  requires an action to be performed on the filesystem in order for
  F<File::Path> to perform operations, it is strongly suggested you assure
  filesystem availability by reading the root of the mounted filesystem.
  
  =head2 REPORTING BUGS
  
  Please report all bugs on the RT queue, either via the web interface:
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-Path>
  
  or by email:
  
      bug-File-Path@rt.cpan.org
  
  In either case, please B<attach> patches to the bug report rather than
  including them inline in the web post or the body of the email.
  
  You can also send pull requests to the Github repository:
  
  L<https://github.com/rpcme/File-Path>
  
  =head1 ACKNOWLEDGEMENTS
  
  Paul Szabo identified the race condition originally, and Brendan
  O'Dea wrote an implementation for Debian that addressed the problem.
  That code was used as a basis for the current code. Their efforts
  are greatly appreciated.
  
  Gisle Aas made a number of improvements to the documentation for
  2.07 and his advice and assistance is also greatly appreciated.
  
  =head1 AUTHORS
  
  Prior authors and maintainers: Tim Bunce, Charles Bailey, and
  David Landgren <F<david@landgren.net>>.
  
  Current maintainers are Richard Elberger <F<riche@cpan.org>> and
  James (Jim) Keenan <F<jkeenan@cpan.org>>.
  
  =head1 CONTRIBUTORS
  
  Contributors to File::Path, in alphabetical order by first name.
  
  =over 1
  
  =item <F<bulkdd@cpan.org>>
  
  =item Charlie Gonzalez <F<itcharlie@cpan.org>>
  
  =item Craig A. Berry <F<craigberry@mac.com>>
  
  =item James E Keenan <F<jkeenan@cpan.org>>
  
  =item John Lightsey <F<john@perlsec.org>>
  
  =item Nigel Horne <F<njh@bandsman.co.uk>>
  
  =item Richard Elberger <F<riche@cpan.org>>
  
  =item Ryan Yee <F<ryee@cpan.org>>
  
  =item Skye Shaw <F<shaw@cpan.org>>
  
  =item Tom Lutz <F<tommylutz@gmail.com>>
  
  =item Will Sheppard <F<willsheppard@github>>
  
  =back
  
  =head1 COPYRIGHT
  
  This module is copyright (C) Charles Bailey, Tim Bunce, David Landgren,
  James Keenan and Richard Elberger 1995-2018. All rights reserved.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_PATH

$fatpacked{"File/Temp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_TEMP';
  package File::Temp; # git description: v0.2308-7-g3bb4d88
  # ABSTRACT: return name and handle of a temporary file safely
  
  our $VERSION = '0.2309';
  
  #pod =begin :__INTERNALS
  #pod
  #pod =head1 PORTABILITY
  #pod
  #pod This section is at the top in order to provide easier access to
  #pod porters.  It is not expected to be rendered by a standard pod
  #pod formatting tool. Please skip straight to the SYNOPSIS section if you
  #pod are not trying to port this module to a new platform.
  #pod
  #pod This module is designed to be portable across operating systems and it
  #pod currently supports Unix, VMS, DOS, OS/2, Windows and Mac OS
  #pod (Classic). When porting to a new OS there are generally three main
  #pod issues that have to be solved:
  #pod
  #pod =over 4
  #pod
  #pod =item *
  #pod
  #pod Can the OS unlink an open file? If it can not then the
  #pod C<_can_unlink_opened_file> method should be modified.
  #pod
  #pod =item *
  #pod
  #pod Are the return values from C<stat> reliable? By default all the
  #pod return values from C<stat> are compared when unlinking a temporary
  #pod file using the filename and the handle. Operating systems other than
  #pod unix do not always have valid entries in all fields. If utility function
  #pod C<File::Temp::unlink0> fails then the C<stat> comparison should be
  #pod modified accordingly.
  #pod
  #pod =item *
  #pod
  #pod Security. Systems that can not support a test for the sticky bit
  #pod on a directory can not use the MEDIUM and HIGH security tests.
  #pod The C<_can_do_level> method should be modified accordingly.
  #pod
  #pod =back
  #pod
  #pod =end :__INTERNALS
  #pod
  #pod =head1 SYNOPSIS
  #pod
  #pod   use File::Temp qw/ tempfile tempdir /;
  #pod
  #pod   $fh = tempfile();
  #pod   ($fh, $filename) = tempfile();
  #pod
  #pod   ($fh, $filename) = tempfile( $template, DIR => $dir);
  #pod   ($fh, $filename) = tempfile( $template, SUFFIX => '.dat');
  #pod   ($fh, $filename) = tempfile( $template, TMPDIR => 1 );
  #pod
  #pod   binmode( $fh, ":utf8" );
  #pod
  #pod   $dir = tempdir( CLEANUP => 1 );
  #pod   ($fh, $filename) = tempfile( DIR => $dir );
  #pod
  #pod Object interface:
  #pod
  #pod   require File::Temp;
  #pod   use File::Temp ();
  #pod   use File::Temp qw/ :seekable /;
  #pod
  #pod   $fh = File::Temp->new();
  #pod   $fname = $fh->filename;
  #pod
  #pod   $fh = File::Temp->new(TEMPLATE => $template);
  #pod   $fname = $fh->filename;
  #pod
  #pod   $tmp = File::Temp->new( UNLINK => 0, SUFFIX => '.dat' );
  #pod   print $tmp "Some data\n";
  #pod   print "Filename is $tmp\n";
  #pod   $tmp->seek( 0, SEEK_END );
  #pod
  #pod   $dir = File::Temp->newdir(); # CLEANUP => 1 by default
  #pod
  #pod The following interfaces are provided for compatibility with
  #pod existing APIs. They should not be used in new code.
  #pod
  #pod MkTemp family:
  #pod
  #pod   use File::Temp qw/ :mktemp  /;
  #pod
  #pod   ($fh, $file) = mkstemp( "tmpfileXXXXX" );
  #pod   ($fh, $file) = mkstemps( "tmpfileXXXXXX", $suffix);
  #pod
  #pod   $tmpdir = mkdtemp( $template );
  #pod
  #pod   $unopened_file = mktemp( $template );
  #pod
  #pod POSIX functions:
  #pod
  #pod   use File::Temp qw/ :POSIX /;
  #pod
  #pod   $file = tmpnam();
  #pod   $fh = tmpfile();
  #pod
  #pod   ($fh, $file) = tmpnam();
  #pod
  #pod Compatibility functions:
  #pod
  #pod   $unopened_file = File::Temp::tempnam( $dir, $pfx );
  #pod
  #pod =head1 DESCRIPTION
  #pod
  #pod C<File::Temp> can be used to create and open temporary files in a safe
  #pod way.  There is both a function interface and an object-oriented
  #pod interface.  The File::Temp constructor or the tempfile() function can
  #pod be used to return the name and the open filehandle of a temporary
  #pod file.  The tempdir() function can be used to create a temporary
  #pod directory.
  #pod
  #pod The security aspect of temporary file creation is emphasized such that
  #pod a filehandle and filename are returned together.  This helps guarantee
  #pod that a race condition can not occur where the temporary file is
  #pod created by another process between checking for the existence of the
  #pod file and its opening.  Additional security levels are provided to
  #pod check, for example, that the sticky bit is set on world writable
  #pod directories.  See L<"safe_level"> for more information.
  #pod
  #pod For compatibility with popular C library functions, Perl implementations of
  #pod the mkstemp() family of functions are provided. These are, mkstemp(),
  #pod mkstemps(), mkdtemp() and mktemp().
  #pod
  #pod Additionally, implementations of the standard L<POSIX|POSIX>
  #pod tmpnam() and tmpfile() functions are provided if required.
  #pod
  #pod Implementations of mktemp(), tmpnam(), and tempnam() are provided,
  #pod but should be used with caution since they return only a filename
  #pod that was valid when function was called, so cannot guarantee
  #pod that the file will not exist by the time the caller opens the filename.
  #pod
  #pod Filehandles returned by these functions support the seekable methods.
  #pod
  #pod =cut
  
  # Toolchain targets v5.8.1, but we'll try to support back to v5.6 anyway.
  # It might be possible to make this v5.5, but many v5.6isms are creeping
  # into the code and tests.
  use 5.006;
  use strict;
  use Carp;
  use File::Spec 0.8;
  use Cwd ();
  use File::Path 2.06 qw/ rmtree /;
  use Fcntl 1.03;
  use IO::Seekable;               # For SEEK_*
  use Errno;
  use Scalar::Util 'refaddr';
  require VMS::Stdio if $^O eq 'VMS';
  
  # pre-emptively load Carp::Heavy. If we don't when we run out of file
  # handles and attempt to call croak() we get an error message telling
  # us that Carp::Heavy won't load rather than an error telling us we
  # have run out of file handles. We either preload croak() or we
  # switch the calls to croak from _gettemp() to use die.
  eval { require Carp::Heavy; };
  
  # Need the Symbol package if we are running older perl
  require Symbol if $] < 5.006;
  
  ### For the OO interface
  use parent 0.221 qw/ IO::Handle IO::Seekable /;
  use overload '""' => "STRINGIFY", '0+' => "NUMIFY",
    fallback => 1;
  
  our $DEBUG = 0;
  our $KEEP_ALL = 0;
  
  # We are exporting functions
  
  use Exporter 5.57 'import';   # 5.57 lets us import 'import'
  
  # Export list - to allow fine tuning of export table
  
  our @EXPORT_OK = qw{
                   tempfile
                   tempdir
                   tmpnam
                   tmpfile
                   mktemp
                   mkstemp
                   mkstemps
                   mkdtemp
                   unlink0
                   cleanup
                   SEEK_SET
                   SEEK_CUR
                   SEEK_END
               };
  
  # Groups of functions for export
  
  our %EXPORT_TAGS = (
                  'POSIX' => [qw/ tmpnam tmpfile /],
                  'mktemp' => [qw/ mktemp mkstemp mkstemps mkdtemp/],
                  'seekable' => [qw/ SEEK_SET SEEK_CUR SEEK_END /],
                 );
  
  # add contents of these tags to @EXPORT
  Exporter::export_tags('POSIX','mktemp','seekable');
  
  # This is a list of characters that can be used in random filenames
  
  my @CHARS = (qw/ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                   a b c d e f g h i j k l m n o p q r s t u v w x y z
                   0 1 2 3 4 5 6 7 8 9 _
                 /);
  
  # Maximum number of tries to make a temp file before failing
  
  use constant MAX_TRIES => 1000;
  
  # Minimum number of X characters that should be in a template
  use constant MINX => 4;
  
  # Default template when no template supplied
  
  use constant TEMPXXX => 'X' x 10;
  
  # Constants for the security level
  
  use constant STANDARD => 0;
  use constant MEDIUM   => 1;
  use constant HIGH     => 2;
  
  # OPENFLAGS. If we defined the flag to use with Sysopen here this gives
  # us an optimisation when many temporary files are requested
  
  my $OPENFLAGS = O_CREAT | O_EXCL | O_RDWR;
  my $LOCKFLAG;
  
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ NOFOLLOW BINARY LARGEFILE NOINHERIT /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      no strict 'refs';
      $OPENFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
    # Special case O_EXLOCK
    $LOCKFLAG = eval {
      local $SIG{__DIE__} = sub {};
      local $SIG{__WARN__} = sub {};
      &Fcntl::O_EXLOCK();
    };
  }
  
  # On some systems the O_TEMPORARY flag can be used to tell the OS
  # to automatically remove the file when it is closed. This is fine
  # in most cases but not if tempfile is called with UNLINK=>0 and
  # the filename is requested -- in the case where the filename is to
  # be passed to another routine. This happens on windows. We overcome
  # this by using a second open flags variable
  
  my $OPENTEMPFLAGS = $OPENFLAGS;
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ TEMPORARY /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      local($@);
      no strict 'refs';
      $OPENTEMPFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
  }
  
  # Private hash tracking which files have been created by each process id via the OO interface
  my %FILES_CREATED_BY_OBJECT;
  
  # INTERNAL ROUTINES - not to be used outside of package
  
  # Generic routine for getting a temporary filename
  # modelled on OpenBSD _gettemp() in mktemp.c
  
  # The template must contain X's that are to be replaced
  # with the random values
  
  #  Arguments:
  
  #  TEMPLATE   - string containing the XXXXX's that is converted
  #           to a random filename and opened if required
  
  # Optionally, a hash can also be supplied containing specific options
  #   "open" => if true open the temp file, else just return the name
  #             default is 0
  #   "mkdir"=> if true, we are creating a temp directory rather than tempfile
  #             default is 0
  #   "suffixlen" => number of characters at end of PATH to be ignored.
  #                  default is 0.
  #   "unlink_on_close" => indicates that, if possible,  the OS should remove
  #                        the file as soon as it is closed. Usually indicates
  #                        use of the O_TEMPORARY flag to sysopen.
  #                        Usually irrelevant on unix
  #   "use_exlock" => Indicates that O_EXLOCK should be used. Default is false.
  
  # Optionally a reference to a scalar can be passed into the function
  # On error this will be used to store the reason for the error
  #   "ErrStr"  => \$errstr
  
  # "open" and "mkdir" can not both be true
  # "unlink_on_close" is not used when "mkdir" is true.
  
  # The default options are equivalent to mktemp().
  
  # Returns:
  #   filehandle - open file handle (if called with doopen=1, else undef)
  #   temp name  - name of the temp file or directory
  
  # For example:
  #   ($fh, $name) = _gettemp($template, "open" => 1);
  
  # for the current version, failures are associated with
  # stored in an error string and returned to give the reason whilst debugging
  # This routine is not called by any external function
  sub _gettemp {
  
    croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);'
      unless scalar(@_) >= 1;
  
    # the internal error string - expect it to be overridden
    # Need this in case the caller decides not to supply us a value
    # need an anonymous scalar
    my $tempErrStr;
  
    # Default options
    my %options = (
                   "open" => 0,
                   "mkdir" => 0,
                   "suffixlen" => 0,
                   "unlink_on_close" => 0,
                   "use_exlock" => 0,
                   "ErrStr" => \$tempErrStr,
                  );
  
    # Read the template
    my $template = shift;
    if (ref($template)) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: template must not be a reference";
      return ();
    }
  
    # Check that the number of entries on stack are even
    if (scalar(@_) % 2 != 0) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: Must have even number of options";
      return ();
    }
  
    # Read the options and merge with defaults
    %options = (%options, @_)  if @_;
  
    # Make sure the error string is set to undef
    ${$options{ErrStr}} = undef;
  
    # Can not open the file and make a directory in a single call
    if ($options{"open"} && $options{"mkdir"}) {
      ${$options{ErrStr}} = "doopen and domkdir can not both be true\n";
      return ();
    }
  
    # Find the start of the end of the  Xs (position of last X)
    # Substr starts from 0
    my $start = length($template) - 1 - $options{"suffixlen"};
  
    # Check that we have at least MINX x X (e.g. 'XXXX") at the end of the string
    # (taking suffixlen into account). Any fewer is insecure.
  
    # Do it using substr - no reason to use a pattern match since
    # we know where we are looking and what we are looking for
  
    if (substr($template, $start - MINX + 1, MINX) ne 'X' x MINX) {
      ${$options{ErrStr}} = "The template must end with at least ".
        MINX . " 'X' characters\n";
      return ();
    }
  
    # Replace all the X at the end of the substring with a
    # random character or just all the XX at the end of a full string.
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # and generate a full path from the template
  
    my $path = _replace_XX($template, $options{"suffixlen"});
  
  
    # Split the path into constituent parts - eventually we need to check
    # whether the directory exists
    # We need to know whether we are making a temp directory
    # or a tempfile
  
    my ($volume, $directories, $file);
    my $parent;                   # parent directory
    if ($options{"mkdir"}) {
      # There is no filename at the end
      ($volume, $directories, $file) = File::Spec->splitpath( $path, 1);
  
      # The parent is then $directories without the last directory
      # Split the directory and put it back together again
      my @dirs = File::Spec->splitdir($directories);
  
      # If @dirs only has one entry (i.e. the directory template) that means
      # we are in the current directory
      if ($#dirs == 0) {
        $parent = File::Spec->curdir;
      } else {
  
        if ($^O eq 'VMS') {     # need volume to avoid relative dir spec
          $parent = File::Spec->catdir($volume, @dirs[0..$#dirs-1]);
          $parent = 'sys$disk:[]' if $parent eq '';
        } else {
  
          # Put it back together without the last one
          $parent = File::Spec->catdir(@dirs[0..$#dirs-1]);
  
          # ...and attach the volume (no filename)
          $parent = File::Spec->catpath($volume, $parent, '');
        }
  
      }
  
    } else {
  
      # Get rid of the last filename (use File::Basename for this?)
      ($volume, $directories, $file) = File::Spec->splitpath( $path );
  
      # Join up without the file part
      $parent = File::Spec->catpath($volume,$directories,'');
  
      # If $parent is empty replace with curdir
      $parent = File::Spec->curdir
        unless $directories ne '';
  
    }
  
    # Check that the parent directories exist
    # Do this even for the case where we are simply returning a name
    # not a file -- no point returning a name that includes a directory
    # that does not exist or is not writable
  
    unless (-e $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) does not exist";
      return ();
    }
    unless (-d $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) is not a directory";
      return ();
    }
  
    # Check the stickiness of the directory and chown giveaway if required
    # If the directory is world writable the sticky bit
    # must be set
  
    if (File::Temp->safe_level == MEDIUM) {
      my $safeerr;
      unless (_is_safe($parent,\$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    } elsif (File::Temp->safe_level == HIGH) {
      my $safeerr;
      unless (_is_verysafe($parent, \$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    }
  
  
    # Now try MAX_TRIES time to open the file
    for (my $i = 0; $i < MAX_TRIES; $i++) {
  
      # Try to open the file if requested
      if ($options{"open"}) {
        my $fh;
  
        # If we are running before perl5.6.0 we can not auto-vivify
        if ($] < 5.006) {
          $fh = &Symbol::gensym;
        }
  
        # Try to make sure this will be marked close-on-exec
        # XXX: Win32 doesn't respect this, nor the proper fcntl,
        #      but may have O_NOINHERIT. This may or may not be in Fcntl.
        local $^F = 2;
  
        # Attempt to open the file
        my $open_success = undef;
        if ( $^O eq 'VMS' and $options{"unlink_on_close"} && !$KEEP_ALL) {
          # make it auto delete on close by setting FAB$V_DLT bit
          $fh = VMS::Stdio::vmssysopen($path, $OPENFLAGS, 0600, 'fop=dlt');
          $open_success = $fh;
        } else {
          my $flags = ( ($options{"unlink_on_close"} && !$KEEP_ALL) ?
                        $OPENTEMPFLAGS :
                        $OPENFLAGS );
          $flags |= $LOCKFLAG if (defined $LOCKFLAG && $options{use_exlock});
          $open_success = sysopen($fh, $path, $flags, 0600);
        }
        if ( $open_success ) {
  
          # in case of odd umask force rw
          chmod(0600, $path);
  
          # Opened successfully - return file handle and name
          return ($fh, $path);
  
        } else {
  
          # Error opening file - abort with error
          # if the reason was anything but EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create temp file $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
      } elsif ($options{"mkdir"}) {
  
        # Open the temp directory
        if (mkdir( $path, 0700)) {
          # in case of odd umask
          chmod(0700, $path);
  
          return undef, $path;
        } else {
  
          # Abort with error if the reason for failure was anything
          # except EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create directory $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
  
      } else {
  
        # Return true if the file can not be found
        # Directory has been checked previously
  
        return (undef, $path) unless -e $path;
  
        # Try again until MAX_TRIES
  
      }
  
      # Did not successfully open the tempfile/dir
      # so try again with a different set of random letters
      # No point in trying to increment unless we have only
      # 1 X say and the randomness could come up with the same
      # file MAX_TRIES in a row.
  
      # Store current attempt - in principle this implies that the
      # 3rd time around the open attempt that the first temp file
      # name could be generated again. Probably should store each
      # attempt and make sure that none are repeated
  
      my $original = $path;
      my $counter = 0;            # Stop infinite loop
      my $MAX_GUESS = 50;
  
      do {
  
        # Generate new name from original template
        $path = _replace_XX($template, $options{"suffixlen"});
  
        $counter++;
  
      } until ($path ne $original || $counter > $MAX_GUESS);
  
      # Check for out of control looping
      if ($counter > $MAX_GUESS) {
        ${$options{ErrStr}} = "Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";
        return ();
      }
  
    }
  
    # If we get here, we have run out of tries
    ${ $options{ErrStr} } = "Have exceeded the maximum number of attempts ("
      . MAX_TRIES . ") to open temp file/dir";
  
    return ();
  
  }
  
  # Internal routine to replace the XXXX... with random characters
  # This has to be done by _gettemp() every time it fails to
  # open a temp file/dir
  
  # Arguments:  $template (the template with XXX),
  #             $ignore   (number of characters at end to ignore)
  
  # Returns:    modified template
  
  sub _replace_XX {
  
    croak 'Usage: _replace_XX($template, $ignore)'
      unless scalar(@_) == 2;
  
    my ($path, $ignore) = @_;
  
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # Alternatively, could simply set $ignore to length($path)-1
    # Don't want to always use substr when not required though.
    my $end = ( $] >= 5.006 ? "\\z" : "\\Z" );
  
    if ($ignore) {
      substr($path, 0, - $ignore) =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    } else {
      $path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    }
    return $path;
  }
  
  # Internal routine to force a temp file to be writable after
  # it is created so that we can unlink it. Windows seems to occasionally
  # force a file to be readonly when written to certain temp locations
  sub _force_writable {
    my $file = shift;
    chmod 0600, $file;
  }
  
  
  # internal routine to check to see if the directory is safe
  # First checks to see if the directory is not owned by the
  # current user or root. Then checks to see if anyone else
  # can write to the directory and if so, checks to see if
  # it has the sticky bit set
  
  # Will not work on systems that do not support sticky bit
  
  #Args:  directory path to check
  #       Optionally: reference to scalar to contain error message
  # Returns true if the path is safe and false otherwise.
  # Returns undef if can not even run stat() on the path
  
  # This routine based on version written by Tom Christiansen
  
  # Presumably, by the time we actually attempt to create the
  # file or directory in this directory, it may not be safe
  # anymore... Have to run _is_safe directly after the open.
  
  sub _is_safe {
  
    my $path = shift;
    my $err_ref = shift;
  
    # Stat path
    my @info = stat($path);
    unless (scalar(@info)) {
      $$err_ref = "stat(path) returned no values";
      return 0;
    }
    ;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    # Check to see whether owner is neither superuser (or a system uid) nor me
    # Use the effective uid from the $> variable
    # UID is in [4]
    if ($info[4] > File::Temp->top_system_uid() && $info[4] != $>) {
  
      Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",
                  File::Temp->top_system_uid());
  
      $$err_ref = "Directory owned neither by root nor the current user"
        if ref($err_ref);
      return 0;
    }
  
    # check whether group or other can write file
    # use 066 to detect either reading or writing
    # use 022 to check writability
    # Do it with S_IWOTH and S_IWGRP for portability (maybe)
    # mode is in info[2]
    if (($info[2] & &Fcntl::S_IWGRP) ||  # Is group writable?
        ($info[2] & &Fcntl::S_IWOTH) ) { # Is world writable?
      # Must be a directory
      unless (-d $path) {
        $$err_ref = "Path ($path) is not a directory"
          if ref($err_ref);
        return 0;
      }
      # Must have sticky bit set
      unless (-k $path) {
        $$err_ref = "Sticky bit not set on $path when dir is group|world writable"
          if ref($err_ref);
        return 0;
      }
    }
  
    return 1;
  }
  
  # Internal routine to check whether a directory is safe
  # for temp files. Safer than _is_safe since it checks for
  # the possibility of chown giveaway and if that is a possibility
  # checks each directory in the path to see if it is safe (with _is_safe)
  
  # If _PC_CHOWN_RESTRICTED is not set, does the full test of each
  # directory anyway.
  
  # Takes optional second arg as scalar ref to error reason
  
  sub _is_verysafe {
  
    # Need POSIX - but only want to bother if really necessary due to overhead
    require POSIX;
  
    my $path = shift;
    print "_is_verysafe testing $path\n" if $DEBUG;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    my $err_ref = shift;
  
    # Should Get the value of _PC_CHOWN_RESTRICTED if it is defined
    # and If it is not there do the extensive test
    local($@);
    my $chown_restricted;
    $chown_restricted = &POSIX::_PC_CHOWN_RESTRICTED()
      if eval { &POSIX::_PC_CHOWN_RESTRICTED(); 1};
  
    # If chown_resticted is set to some value we should test it
    if (defined $chown_restricted) {
  
      # Return if the current directory is safe
      return _is_safe($path,$err_ref) if POSIX::sysconf( $chown_restricted );
  
    }
  
    # To reach this point either, the _PC_CHOWN_RESTRICTED symbol
    # was not available or the symbol was there but chown giveaway
    # is allowed. Either way, we now have to test the entire tree for
    # safety.
  
    # Convert path to an absolute directory if required
    unless (File::Spec->file_name_is_absolute($path)) {
      $path = File::Spec->rel2abs($path);
    }
  
    # Split directory into components - assume no file
    my ($volume, $directories, undef) = File::Spec->splitpath( $path, 1);
  
    # Slightly less efficient than having a function in File::Spec
    # to chop off the end of a directory or even a function that
    # can handle ../ in a directory tree
    # Sometimes splitdir() returns a blank at the end
    # so we will probably check the bottom directory twice in some cases
    my @dirs = File::Spec->splitdir($directories);
  
    # Concatenate one less directory each time around
    foreach my $pos (0.. $#dirs) {
      # Get a directory name
      my $dir = File::Spec->catpath($volume,
                                    File::Spec->catdir(@dirs[0.. $#dirs - $pos]),
                                    ''
                                   );
  
      print "TESTING DIR $dir\n" if $DEBUG;
  
      # Check the directory
      return 0 unless _is_safe($dir,$err_ref);
  
    }
  
    return 1;
  }
  
  
  
  # internal routine to determine whether unlink works on this
  # platform for files that are currently open.
  # Returns true if we can, false otherwise.
  
  # Currently WinNT, OS/2 and VMS can not unlink an opened file
  # On VMS this is because the O_EXCL flag is used to open the
  # temporary file. Currently I do not know enough about the issues
  # on VMS to decide whether O_EXCL is a requirement.
  
  sub _can_unlink_opened_file {
  
    if (grep { $^O eq $_ } qw/MSWin32 os2 VMS dos MacOS haiku/) {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # internal routine to decide which security levels are allowed
  # see safe_level() for more information on this
  
  # Controls whether the supplied security level is allowed
  
  #   $cando = _can_do_level( $level )
  
  sub _can_do_level {
  
    # Get security level
    my $level = shift;
  
    # Always have to be able to do STANDARD
    return 1 if $level == STANDARD;
  
    # Currently, the systems that can do HIGH or MEDIUM are identical
    if ( $^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix') {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # This routine sets up a deferred unlinking of a specified
  # filename and filehandle. It is used in the following cases:
  #  - Called by unlink0 if an opened file can not be unlinked
  #  - Called by tempfile() if files are to be removed on shutdown
  #  - Called by tempdir() if directories are to be removed on shutdown
  
  # Arguments:
  #   _deferred_unlink( $fh, $fname, $isdir );
  #
  #   - filehandle (so that it can be explicitly closed if open
  #   - filename   (the thing we want to remove)
  #   - isdir      (flag to indicate that we are being given a directory)
  #                 [and hence no filehandle]
  
  # Status is not referred to since all the magic is done with an END block
  
  {
    # Will set up two lexical variables to contain all the files to be
    # removed. One array for files, another for directories They will
    # only exist in this block.
  
    #  This means we only have to set up a single END block to remove
    #  all files. 
  
    # in order to prevent child processes inadvertently deleting the parent
    # temp files we use a hash to store the temp files and directories
    # created by a particular process id.
  
    # %files_to_unlink contains values that are references to an array of
    # array references containing the filehandle and filename associated with
    # the temp file.
    my (%files_to_unlink, %dirs_to_unlink);
  
    # Set up an end block to use these arrays
    END {
      local($., $@, $!, $^E, $?);
      cleanup(at_exit => 1);
    }
  
    # Cleanup function. Always triggered on END (with at_exit => 1) but
    # can be invoked manually.
    sub cleanup {
      my %h = @_;
      my $at_exit = delete $h{at_exit};
      $at_exit = 0 if not defined $at_exit;
      { my @k = sort keys %h; die "unrecognized parameters: @k" if @k }
  
      if (!$KEEP_ALL) {
        # Files
        my @files = (exists $files_to_unlink{$$} ?
                     @{ $files_to_unlink{$$} } : () );
        foreach my $file (@files) {
          # close the filehandle without checking its state
          # in order to make real sure that this is closed
          # if its already closed then I don't care about the answer
          # probably a better way to do this
          close($file->[0]);      # file handle is [0]
  
          if (-f $file->[1]) {       # file name is [1]
            _force_writable( $file->[1] ); # for windows
            unlink $file->[1] or warn "Error removing ".$file->[1];
          }
        }
        # Dirs
        my @dirs = (exists $dirs_to_unlink{$$} ?
                    @{ $dirs_to_unlink{$$} } : () );
        my ($cwd, $cwd_to_remove);
        foreach my $dir (@dirs) {
          if (-d $dir) {
            # Some versions of rmtree will abort if you attempt to remove
            # the directory you are sitting in. For automatic cleanup
            # at program exit, we avoid this by chdir()ing out of the way
            # first. If not at program exit, it's best not to mess with the
            # current directory, so just let it fail with a warning.
            if ($at_exit) {
              $cwd = Cwd::abs_path(File::Spec->curdir) if not defined $cwd;
              my $abs = Cwd::abs_path($dir);
              if ($abs eq $cwd) {
                $cwd_to_remove = $dir;
                next;
              }
            }
            eval { rmtree($dir, $DEBUG, 0); };
            warn $@ if ($@ && $^W);
          }
        }
  
        if (defined $cwd_to_remove) {
          # We do need to clean up the current directory, and everything
          # else is done, so get out of there and remove it.
          chdir $cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";
          my $updir = File::Spec->updir;
          chdir $updir or die "cannot chdir to $updir: $!";
          eval { rmtree($cwd_to_remove, $DEBUG, 0); };
          warn $@ if ($@ && $^W);
        }
  
        # clear the arrays
        @{ $files_to_unlink{$$} } = ()
          if exists $files_to_unlink{$$};
        @{ $dirs_to_unlink{$$} } = ()
          if exists $dirs_to_unlink{$$};
      }
    }
  
  
    # This is the sub called to register a file for deferred unlinking
    # This could simply store the input parameters and defer everything
    # until the END block. For now we do a bit of checking at this
    # point in order to make sure that (1) we have a file/dir to delete
    # and (2) we have been called with the correct arguments.
    sub _deferred_unlink {
  
      croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)'
        unless scalar(@_) == 3;
  
      my ($fh, $fname, $isdir) = @_;
  
      warn "Setting up deferred removal of $fname\n"
        if $DEBUG;
  
      # make sure we save the absolute path for later cleanup
      # OK to untaint because we only ever use this internally
      # as a file path, never interpolating into the shell
      $fname = Cwd::abs_path($fname);
      ($fname) = $fname =~ /^(.*)$/;
  
      # If we have a directory, check that it is a directory
      if ($isdir) {
  
        if (-d $fname) {
  
          # Directory exists so store it
          # first on VMS turn []foo into [.foo] for rmtree
          $fname = VMS::Filespec::vmspath($fname) if $^O eq 'VMS';
          $dirs_to_unlink{$$} = [] 
            unless exists $dirs_to_unlink{$$};
          push (@{ $dirs_to_unlink{$$} }, $fname);
  
        } else {
          carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W;
        }
  
      } else {
  
        if (-f $fname) {
  
          # file exists so store handle and name for later removal
          $files_to_unlink{$$} = []
            unless exists $files_to_unlink{$$};
          push(@{ $files_to_unlink{$$} }, [$fh, $fname]);
  
        } else {
          carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W;
        }
  
      }
  
    }
  
  
  }
  
  # normalize argument keys to upper case and do consistent handling
  # of leading template vs TEMPLATE
  sub _parse_args {
    my $leading_template = (scalar(@_) % 2 == 1 ? shift(@_) : '' );
    my %args = @_;
    %args = map { uc($_), $args{$_} } keys %args;
  
    # template (store it in an array so that it will
    # disappear from the arg list of tempfile)
    my @template = (
      exists $args{TEMPLATE}  ? $args{TEMPLATE} :
      $leading_template       ? $leading_template : ()
    );
    delete $args{TEMPLATE};
  
    return( \@template, \%args );
  }
  
  #pod =head1 OBJECT-ORIENTED INTERFACE
  #pod
  #pod This is the primary interface for interacting with
  #pod C<File::Temp>. Using the OO interface a temporary file can be created
  #pod when the object is constructed and the file can be removed when the
  #pod object is no longer required.
  #pod
  #pod Note that there is no method to obtain the filehandle from the
  #pod C<File::Temp> object. The object itself acts as a filehandle.  The object
  #pod isa C<IO::Handle> and isa C<IO::Seekable> so all those methods are
  #pod available.
  #pod
  #pod Also, the object is configured such that it stringifies to the name of the
  #pod temporary file and so can be compared to a filename directly.  It numifies
  #pod to the C<refaddr> the same as other handles and so can be compared to other
  #pod handles with C<==>.
  #pod
  #pod     $fh eq $filename       # as a string
  #pod     $fh != \*STDOUT        # as a number
  #pod
  #pod Available since 0.14.
  #pod
  #pod =over 4
  #pod
  #pod =item B<new>
  #pod
  #pod Create a temporary file object.
  #pod
  #pod   my $tmp = File::Temp->new();
  #pod
  #pod by default the object is constructed as if C<tempfile>
  #pod was called without options, but with the additional behaviour
  #pod that the temporary file is removed by the object destructor
  #pod if UNLINK is set to true (the default).
  #pod
  #pod Supported arguments are the same as for C<tempfile>: UNLINK
  #pod (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename
  #pod template is specified using the TEMPLATE option. The OPEN option
  #pod is not supported (the file is always opened).
  #pod
  #pod  $tmp = File::Temp->new( TEMPLATE => 'tempXXXXX',
  #pod                         DIR => 'mydir',
  #pod                         SUFFIX => '.dat');
  #pod
  #pod Arguments are case insensitive.
  #pod
  #pod Can call croak() if an error occurs.
  #pod
  #pod Available since 0.14.
  #pod
  #pod TEMPLATE available since 0.23
  #pod
  #pod =cut
  
  sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
  
    my ($maybe_template, $args) = _parse_args(@_);
  
    # see if they are unlinking (defaulting to yes)
    my $unlink = (exists $args->{UNLINK} ? $args->{UNLINK} : 1 );
    delete $args->{UNLINK};
  
    # Protect OPEN
    delete $args->{OPEN};
  
    # Open the file and retain file handle and file name
    my ($fh, $path) = tempfile( @$maybe_template, %$args );
  
    print "Tmp: $fh - $path\n" if $DEBUG;
  
    # Store the filename in the scalar slot
    ${*$fh} = $path;
  
    # Cache the filename by pid so that the destructor can decide whether to remove it
    $FILES_CREATED_BY_OBJECT{$$}{$path} = 1;
  
    # Store unlink information in hash slot (plus other constructor info)
    %{*$fh} = %$args;
  
    # create the object
    bless $fh, $class;
  
    # final method-based configuration
    $fh->unlink_on_destroy( $unlink );
  
    return $fh;
  }
  
  #pod =item B<newdir>
  #pod
  #pod Create a temporary directory using an object oriented interface.
  #pod
  #pod   $dir = File::Temp->newdir();
  #pod
  #pod By default the directory is deleted when the object goes out of scope.
  #pod
  #pod Supports the same options as the C<tempdir> function. Note that directories
  #pod created with this method default to CLEANUP => 1.
  #pod
  #pod   $dir = File::Temp->newdir( $template, %options );
  #pod
  #pod A template may be specified either with a leading template or
  #pod with a TEMPLATE argument.
  #pod
  #pod Available since 0.19.
  #pod
  #pod TEMPLATE available since 0.23.
  #pod
  #pod =cut
  
  sub newdir {
    my $self = shift;
  
    my ($maybe_template, $args) = _parse_args(@_);
  
    # handle CLEANUP without passing CLEANUP to tempdir
    my $cleanup = (exists $args->{CLEANUP} ? $args->{CLEANUP} : 1 );
    delete $args->{CLEANUP};
  
    my $tempdir = tempdir( @$maybe_template, %$args);
  
    # get a safe absolute path for cleanup, just like
    # happens in _deferred_unlink
    my $real_dir = Cwd::abs_path( $tempdir );
    ($real_dir) = $real_dir =~ /^(.*)$/;
  
    return bless { DIRNAME => $tempdir,
                   REALNAME => $real_dir,
                   CLEANUP => $cleanup,
                   LAUNCHPID => $$,
                 }, "File::Temp::Dir";
  }
  
  #pod =item B<filename>
  #pod
  #pod Return the name of the temporary file associated with this object
  #pod (if the object was created using the "new" constructor).
  #pod
  #pod   $filename = $tmp->filename;
  #pod
  #pod This method is called automatically when the object is used as
  #pod a string.
  #pod
  #pod Current API available since 0.14
  #pod
  #pod =cut
  
  sub filename {
    my $self = shift;
    return ${*$self};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->filename;
  }
  
  # For reference, can't use '0+'=>\&Scalar::Util::refaddr directly because
  # refaddr() demands one parameter only, whereas overload.pm calls with three
  # even for unary operations like '0+'.
  sub NUMIFY {
    return refaddr($_[0]);
  }
  
  #pod =item B<dirname>
  #pod
  #pod Return the name of the temporary directory associated with this
  #pod object (if the object was created using the "newdir" constructor).
  #pod
  #pod   $dirname = $tmpdir->dirname;
  #pod
  #pod This method is called automatically when the object is used in string context.
  #pod
  #pod =item B<unlink_on_destroy>
  #pod
  #pod Control whether the file is unlinked when the object goes out of scope.
  #pod The file is removed if this value is true and $KEEP_ALL is not.
  #pod
  #pod  $fh->unlink_on_destroy( 1 );
  #pod
  #pod Default is for the file to be removed.
  #pod
  #pod Current API available since 0.15
  #pod
  #pod =cut
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      ${*$self}{UNLINK} = shift;
    }
    return ${*$self}{UNLINK};
  }
  
  #pod =item B<DESTROY>
  #pod
  #pod When the object goes out of scope, the destructor is called. This
  #pod destructor will attempt to unlink the file (using L<unlink1|"unlink1">)
  #pod if the constructor was called with UNLINK set to 1 (the default state
  #pod if UNLINK is not specified).
  #pod
  #pod No error is given if the unlink fails.
  #pod
  #pod If the object has been passed to a child process during a fork, the
  #pod file will be deleted when the object goes out of scope in the parent.
  #pod
  #pod For a temporary directory object the directory will be removed unless
  #pod the CLEANUP argument was used in the constructor (and set to false) or
  #pod C<unlink_on_destroy> was modified after creation.  Note that if a temp
  #pod directory is your current directory, it cannot be removed - a warning
  #pod will be given in this case.  C<chdir()> out of the directory before
  #pod letting the object go out of scope.
  #pod
  #pod If the global variable $KEEP_ALL is true, the file or directory
  #pod will not be removed.
  #pod
  #pod =cut
  
  sub DESTROY {
    local($., $@, $!, $^E, $?);
    my $self = shift;
  
    # Make sure we always remove the file from the global hash
    # on destruction. This prevents the hash from growing uncontrollably
    # and post-destruction there is no reason to know about the file.
    my $file = $self->filename;
    my $was_created_by_proc;
    if (exists $FILES_CREATED_BY_OBJECT{$$}{$file}) {
      $was_created_by_proc = 1;
      delete $FILES_CREATED_BY_OBJECT{$$}{$file};
    }
  
    if (${*$self}{UNLINK} && !$KEEP_ALL) {
      print "# --------->   Unlinking $self\n" if $DEBUG;
  
      # only delete if this process created it
      return unless $was_created_by_proc;
  
      # The unlink1 may fail if the file has been closed
      # by the caller. This leaves us with the decision
      # of whether to refuse to remove the file or simply
      # do an unlink without test. Seems to be silly
      # to do this when we are trying to be careful
      # about security
      _force_writable( $file ); # for windows
      unlink1( $self, $file )
        or unlink($file);
    }
  }
  
  #pod =back
  #pod
  #pod =head1 FUNCTIONS
  #pod
  #pod This section describes the recommended interface for generating
  #pod temporary files and directories.
  #pod
  #pod =over 4
  #pod
  #pod =item B<tempfile>
  #pod
  #pod This is the basic function to generate temporary files.
  #pod The behaviour of the file can be changed using various options:
  #pod
  #pod   $fh = tempfile();
  #pod   ($fh, $filename) = tempfile();
  #pod
  #pod Create a temporary file in  the directory specified for temporary
  #pod files, as specified by the tmpdir() function in L<File::Spec>.
  #pod
  #pod   ($fh, $filename) = tempfile($template);
  #pod
  #pod Create a temporary file in the current directory using the supplied
  #pod template.  Trailing `X' characters are replaced with random letters to
  #pod generate the filename.  At least four `X' characters must be present
  #pod at the end of the template.
  #pod
  #pod   ($fh, $filename) = tempfile($template, SUFFIX => $suffix)
  #pod
  #pod Same as previously, except that a suffix is added to the template
  #pod after the `X' translation.  Useful for ensuring that a temporary
  #pod filename has a particular extension when needed by other applications.
  #pod But see the WARNING at the end.
  #pod
  #pod   ($fh, $filename) = tempfile($template, DIR => $dir);
  #pod
  #pod Translates the template as before except that a directory name
  #pod is specified.
  #pod
  #pod   ($fh, $filename) = tempfile($template, TMPDIR => 1);
  #pod
  #pod Equivalent to specifying a DIR of "File::Spec->tmpdir", writing the file
  #pod into the same temporary directory as would be used if no template was
  #pod specified at all.
  #pod
  #pod   ($fh, $filename) = tempfile($template, UNLINK => 1);
  #pod
  #pod Return the filename and filehandle as before except that the file is
  #pod automatically removed when the program exits (dependent on
  #pod $KEEP_ALL). Default is for the file to be removed if a file handle is
  #pod requested and to be kept if the filename is requested. In a scalar
  #pod context (where no filename is returned) the file is always deleted
  #pod either (depending on the operating system) on exit or when it is
  #pod closed (unless $KEEP_ALL is true when the temp file is created).
  #pod
  #pod Use the object-oriented interface if fine-grained control of when
  #pod a file is removed is required.
  #pod
  #pod If the template is not specified, a template is always
  #pod automatically generated. This temporary file is placed in tmpdir()
  #pod (L<File::Spec>) unless a directory is specified explicitly with the
  #pod DIR option.
  #pod
  #pod   $fh = tempfile( DIR => $dir );
  #pod
  #pod If called in scalar context, only the filehandle is returned and the
  #pod file will automatically be deleted when closed on operating systems
  #pod that support this (see the description of tmpfile() elsewhere in this
  #pod document).  This is the preferred mode of operation, as if you only
  #pod have a filehandle, you can never create a race condition by fumbling
  #pod with the filename. On systems that can not unlink an open file or can
  #pod not mark a file as temporary when it is opened (for example, Windows
  #pod NT uses the C<O_TEMPORARY> flag) the file is marked for deletion when
  #pod the program ends (equivalent to setting UNLINK to 1). The C<UNLINK>
  #pod flag is ignored if present.
  #pod
  #pod   (undef, $filename) = tempfile($template, OPEN => 0);
  #pod
  #pod This will return the filename based on the template but
  #pod will not open this file.  Cannot be used in conjunction with
  #pod UNLINK set to true. Default is to always open the file
  #pod to protect from possible race conditions. A warning is issued
  #pod if warnings are turned on. Consider using the tmpnam()
  #pod and mktemp() functions described elsewhere in this document
  #pod if opening the file is not required.
  #pod
  #pod To open the temporary filehandle with O_EXLOCK (open with exclusive
  #pod file lock) use C<< EXLOCK=>1 >>. This is supported only by some
  #pod operating systems (most notably BSD derived systems). By default
  #pod EXLOCK will be false. Former C<File::Temp> versions set EXLOCK to
  #pod true, so to be sure to get an unlocked filehandle also with older
  #pod versions, explicitly set C<< EXLOCK=>0 >>.
  #pod
  #pod   ($fh, $filename) = tempfile($template, EXLOCK => 1);
  #pod
  #pod Options can be combined as required.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Available since 0.05.
  #pod
  #pod UNLINK flag available since 0.10.
  #pod
  #pod TMPDIR flag available since 0.19.
  #pod
  #pod EXLOCK flag available since 0.19.
  #pod
  #pod =cut
  
  sub tempfile {
    if ( @_ && $_[0] eq 'File::Temp' ) {
        croak "'tempfile' can't be called as a method";
    }
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "DIR"    => undef, # Directory prefix
                   "SUFFIX" => '',    # Template suffix
                   "UNLINK" => 0,     # Do not unlink file on exit
                   "OPEN"   => 1,     # Open file
                   "TMPDIR" => 0, # Place tempfile in tempdir if template specified
                   "EXLOCK" => 0, # Open file with O_EXLOCK
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my ($maybe_template, $args) = _parse_args(@_);
    my $template = @$maybe_template ? $maybe_template->[0] : undef;
  
    # Read the options and merge with defaults
    %options = (%options, %$args);
  
    # First decision is whether or not to open the file
    if (! $options{"OPEN"}) {
  
      warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n"
        if $^W;
  
    }
  
    if ($options{"DIR"} and $^O eq 'VMS') {
  
      # on VMS turn []foo into [.foo] for concatenation
      $options{"DIR"} = VMS::Filespec::vmspath($options{"DIR"});
    }
  
    # Construct the template
  
    # Have a choice of trying to work around the mkstemp/mktemp/tmpnam etc
    # functions or simply constructing a template and using _gettemp()
    # explicitly. Go for the latter
  
    # First generate a template if not defined and prefix the directory
    # If no template must prefix the temp directory
    if (defined $template) {
      # End up with current directory if neither DIR not TMPDIR are set
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, $template);
  
      } elsif ($options{TMPDIR}) {
  
        $template = File::Spec->catfile(_wrap_file_spec_tmpdir(), $template );
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catfile(_wrap_file_spec_tmpdir(), TEMPXXX);
  
      }
  
    }
  
    # Now add a suffix
    $template .= $options{"SUFFIX"};
  
    # Determine whether we should tell _gettemp to unlink the file
    # On unix this is irrelevant and can be worked out after the file is
    # opened (simply by unlinking the open filehandle). On Windows or VMS
    # we have to indicate temporary-ness when we open the file. In general
    # we only want a true temporary file if we are returning just the
    # filehandle - if the user wants the filename they probably do not
    # want the file to disappear as soon as they close it (which may be
    # important if they want a child process to use the file)
    # For this reason, tie unlink_on_close to the return context regardless
    # of OS.
    my $unlink_on_close = ( wantarray ? 0 : 1);
  
    # Create the file
    my ($fh, $path, $errstr);
    croak "Error in tempfile() using template $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => $options{'OPEN'},
                                      "mkdir"=> 0 ,
                                      "unlink_on_close" => $unlink_on_close,
                                      "suffixlen" => length($options{'SUFFIX'}),
                                      "ErrStr" => \$errstr,
                                      "use_exlock" => $options{EXLOCK},
                                     ) );
  
    # Set up an exit handler that can do whatever is right for the
    # system. This removes files at exit when requested explicitly or when
    # system is asked to unlink_on_close but is unable to do so because
    # of OS limitations.
    # The latter should be achieved by using a tied filehandle.
    # Do not check return status since this is all done with END blocks.
    _deferred_unlink($fh, $path, 0) if $options{"UNLINK"};
  
    # Return
    if (wantarray()) {
  
      if ($options{'OPEN'}) {
        return ($fh, $path);
      } else {
        return (undef, $path);
      }
  
    } else {
  
      # Unlink the file. It is up to unlink0 to decide what to do with
      # this (whether to unlink now or to defer until later)
      unlink0($fh, $path) or croak "Error unlinking file $path using unlink0";
  
      # Return just the filehandle.
      return $fh;
    }
  
  
  }
  
  # On Windows under taint mode, File::Spec could suggest "C:\" as a tempdir
  # which might not be writable.  If that is the case, we fallback to a
  # user directory.  See https://rt.cpan.org/Ticket/Display.html?id=60340
  
  {
    my ($alt_tmpdir, $checked);
  
    sub _wrap_file_spec_tmpdir {
      return File::Spec->tmpdir unless $^O eq "MSWin32" && ${^TAINT};
  
      if ( $checked ) {
        return $alt_tmpdir ? $alt_tmpdir : File::Spec->tmpdir;
      }
  
      # probe what File::Spec gives and find a fallback
      my $xxpath = _replace_XX( "X" x 10, 0 );
  
      # First, see if File::Spec->tmpdir is writable
      my $tmpdir = File::Spec->tmpdir;
      my $testpath = File::Spec->catdir( $tmpdir, $xxpath );
      if (mkdir( $testpath, 0700) ) {
        $checked = 1;
        rmdir $testpath;
        return $tmpdir;
      }
  
      # Next, see if CSIDL_LOCAL_APPDATA is writable
      require Win32;
      my $local_app = File::Spec->catdir(
        Win32::GetFolderPath( Win32::CSIDL_LOCAL_APPDATA() ), 'Temp'
      );
      $testpath = File::Spec->catdir( $local_app, $xxpath );
      if ( -e $local_app or mkdir( $local_app, 0700 ) ) {
        if (mkdir( $testpath, 0700) ) {
          $checked = 1;
          rmdir $testpath;
          return $alt_tmpdir = $local_app;
        }
      }
  
      # Can't find something writable
      croak << "HERE";
  Couldn't find a writable temp directory in taint mode. Tried:
    $tmpdir
    $local_app
  
  Try setting and untainting the TMPDIR environment variable.
  HERE
  
    }
  }
  
  #pod =item B<tempdir>
  #pod
  #pod This is the recommended interface for creation of temporary
  #pod directories.  By default the directory will not be removed on exit
  #pod (that is, it won't be temporary; this behaviour can not be changed
  #pod because of issues with backwards compatibility). To enable removal
  #pod either use the CLEANUP option which will trigger removal on program
  #pod exit, or consider using the "newdir" method in the object interface which
  #pod will allow the directory to be cleaned up when the object goes out of
  #pod scope.
  #pod
  #pod The behaviour of the function depends on the arguments:
  #pod
  #pod   $tempdir = tempdir();
  #pod
  #pod Create a directory in tmpdir() (see L<File::Spec|File::Spec>).
  #pod
  #pod   $tempdir = tempdir( $template );
  #pod
  #pod Create a directory from the supplied template. This template is
  #pod similar to that described for tempfile(). `X' characters at the end
  #pod of the template are replaced with random letters to construct the
  #pod directory name. At least four `X' characters must be in the template.
  #pod
  #pod   $tempdir = tempdir ( DIR => $dir );
  #pod
  #pod Specifies the directory to use for the temporary directory.
  #pod The temporary directory name is derived from an internal template.
  #pod
  #pod   $tempdir = tempdir ( $template, DIR => $dir );
  #pod
  #pod Prepend the supplied directory name to the template. The template
  #pod should not include parent directory specifications itself. Any parent
  #pod directory specifications are removed from the template before
  #pod prepending the supplied directory.
  #pod
  #pod   $tempdir = tempdir ( $template, TMPDIR => 1 );
  #pod
  #pod Using the supplied template, create the temporary directory in
  #pod a standard location for temporary files. Equivalent to doing
  #pod
  #pod   $tempdir = tempdir ( $template, DIR => File::Spec->tmpdir);
  #pod
  #pod but shorter. Parent directory specifications are stripped from the
  #pod template itself. The C<TMPDIR> option is ignored if C<DIR> is set
  #pod explicitly.  Additionally, C<TMPDIR> is implied if neither a template
  #pod nor a directory are supplied.
  #pod
  #pod   $tempdir = tempdir( $template, CLEANUP => 1);
  #pod
  #pod Create a temporary directory using the supplied template, but
  #pod attempt to remove it (and all files inside it) when the program
  #pod exits. Note that an attempt will be made to remove all files from
  #pod the directory even if they were not created by this module (otherwise
  #pod why ask to clean it up?). The directory removal is made with
  #pod the rmtree() function from the L<File::Path|File::Path> module.
  #pod Of course, if the template is not specified, the temporary directory
  #pod will be created in tmpdir() and will also be removed at program exit.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Current API available since 0.05.
  #pod
  #pod =cut
  
  # '
  
  sub tempdir  {
    if ( @_ && $_[0] eq 'File::Temp' ) {
        croak "'tempdir' can't be called as a method";
    }
  
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "CLEANUP"    => 0, # Remove directory on exit
                   "DIR"        => '', # Root directory
                   "TMPDIR"     => 0,  # Use tempdir with template
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my ($maybe_template, $args) = _parse_args(@_);
    my $template = @$maybe_template ? $maybe_template->[0] : undef;
  
    # Read the options and merge with defaults
    %options = (%options, %$args);
  
    # Modify or generate the template
  
    # Deal with the DIR and TMPDIR options
    if (defined $template) {
  
      # Need to strip directory path if using DIR or TMPDIR
      if ($options{'TMPDIR'} || $options{'DIR'}) {
  
        # Strip parent directory from the filename
        #
        # There is no filename at the end
        $template = VMS::Filespec::vmspath($template) if $^O eq 'VMS';
        my ($volume, $directories, undef) = File::Spec->splitpath( $template, 1);
  
        # Last directory is then our template
        $template = (File::Spec->splitdir($directories))[-1];
  
        # Prepend the supplied directory or temp dir
        if ($options{"DIR"}) {
  
          $template = File::Spec->catdir($options{"DIR"}, $template);
  
        } elsif ($options{TMPDIR}) {
  
          # Prepend tmpdir
          $template = File::Spec->catdir(_wrap_file_spec_tmpdir(), $template);
  
        }
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catdir($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catdir(_wrap_file_spec_tmpdir(), TEMPXXX);
  
      }
  
    }
  
    # Create the directory
    my $tempdir;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
  
    my $errstr;
    croak "Error in tempdir() using $template: $errstr"
      unless ((undef, $tempdir) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 1 ,
                                           "suffixlen" => $suffixlen,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    # Install exit handler; must be dynamic to get lexical
    if ( $options{'CLEANUP'} && -d $tempdir) {
      _deferred_unlink(undef, $tempdir, 1);
    }
  
    # Return the dir name
    return $tempdir;
  
  }
  
  #pod =back
  #pod
  #pod =head1 MKTEMP FUNCTIONS
  #pod
  #pod The following functions are Perl implementations of the
  #pod mktemp() family of temp file generation system calls.
  #pod
  #pod =over 4
  #pod
  #pod =item B<mkstemp>
  #pod
  #pod Given a template, returns a filehandle to the temporary file and the name
  #pod of the file.
  #pod
  #pod   ($fh, $name) = mkstemp( $template );
  #pod
  #pod In scalar context, just the filehandle is returned.
  #pod
  #pod The template may be any filename with some number of X's appended
  #pod to it, for example F</tmp/temp.XXXX>. The trailing X's are replaced
  #pod with unique alphanumeric combinations.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Current API available since 0.05.
  #pod
  #pod =cut
  
  
  
  sub mkstemp {
  
    croak "Usage: mkstemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemp using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => 0,
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  
  #pod =item B<mkstemps>
  #pod
  #pod Similar to mkstemp(), except that an extra argument can be supplied
  #pod with a suffix to be appended to the template.
  #pod
  #pod   ($fh, $name) = mkstemps( $template, $suffix );
  #pod
  #pod For example a template of C<testXXXXXX> and suffix of C<.dat>
  #pod would generate a file similar to F<testhGji_w.dat>.
  #pod
  #pod Returns just the filehandle alone when called in scalar context.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Current API available since 0.05.
  #pod
  #pod =cut
  
  sub mkstemps {
  
    croak "Usage: mkstemps(template, suffix)"
      if scalar(@_) != 2;
  
  
    my $template = shift;
    my $suffix   = shift;
  
    $template .= $suffix;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemps using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => length($suffix),
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  #pod =item B<mkdtemp>
  #pod
  #pod Create a directory from a template. The template must end in
  #pod X's that are replaced by the routine.
  #pod
  #pod   $tmpdir_name = mkdtemp($template);
  #pod
  #pod Returns the name of the temporary directory created.
  #pod
  #pod Directory must be removed by the caller.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Current API available since 0.05.
  #pod
  #pod =cut
  
  #' # for emacs
  
  sub mkdtemp {
  
    croak "Usage: mkdtemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
    my ($junk, $tmpdir, $errstr);
    croak "Error creating temp directory from template $template\: $errstr"
      unless (($junk, $tmpdir) = _gettemp($template,
                                          "open" => 0,
                                          "mkdir"=> 1 ,
                                          "suffixlen" => $suffixlen,
                                          "ErrStr" => \$errstr,
                                         ) );
  
    return $tmpdir;
  
  }
  
  #pod =item B<mktemp>
  #pod
  #pod Returns a valid temporary filename but does not guarantee
  #pod that the file will not be opened by someone else.
  #pod
  #pod   $unopened_file = mktemp($template);
  #pod
  #pod Template is the same as that required by mkstemp().
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Current API available since 0.05.
  #pod
  #pod =cut
  
  sub mktemp {
  
    croak "Usage: mktemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($tmpname, $junk, $errstr);
    croak "Error getting name to temp file from template $template: $errstr"
      unless (($junk, $tmpname) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 0 ,
                                           "suffixlen" => 0,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    return $tmpname;
  }
  
  #pod =back
  #pod
  #pod =head1 POSIX FUNCTIONS
  #pod
  #pod This section describes the re-implementation of the tmpnam()
  #pod and tmpfile() functions described in L<POSIX>
  #pod using the mkstemp() from this module.
  #pod
  #pod Unlike the L<POSIX|POSIX> implementations, the directory used
  #pod for the temporary file is not specified in a system include
  #pod file (C<P_tmpdir>) but simply depends on the choice of tmpdir()
  #pod returned by L<File::Spec|File::Spec>. On some implementations this
  #pod location can be set using the C<TMPDIR> environment variable, which
  #pod may not be secure.
  #pod If this is a problem, simply use mkstemp() and specify a template.
  #pod
  #pod =over 4
  #pod
  #pod =item B<tmpnam>
  #pod
  #pod When called in scalar context, returns the full name (including path)
  #pod of a temporary file (uses mktemp()). The only check is that the file does
  #pod not already exist, but there is no guarantee that that condition will
  #pod continue to apply.
  #pod
  #pod   $file = tmpnam();
  #pod
  #pod When called in list context, a filehandle to the open file and
  #pod a filename are returned. This is achieved by calling mkstemp()
  #pod after constructing a suitable template.
  #pod
  #pod   ($fh, $file) = tmpnam();
  #pod
  #pod If possible, this form should be used to prevent possible
  #pod race conditions.
  #pod
  #pod See L<File::Spec/tmpdir> for information on the choice of temporary
  #pod directory for a particular operating system.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Current API available since 0.05.
  #pod
  #pod =cut
  
  sub tmpnam {
  
    # Retrieve the temporary directory name
    my $tmpdir = _wrap_file_spec_tmpdir();
  
    # XXX I don't know under what circumstances this occurs, -- xdg 2016-04-02
    croak "Error temporary directory is not writable"
      if $tmpdir eq '';
  
    # Use a ten character template and append to tmpdir
    my $template = File::Spec->catfile($tmpdir, TEMPXXX);
  
    if (wantarray() ) {
      return mkstemp($template);
    } else {
      return mktemp($template);
    }
  
  }
  
  #pod =item B<tmpfile>
  #pod
  #pod Returns the filehandle of a temporary file.
  #pod
  #pod   $fh = tmpfile();
  #pod
  #pod The file is removed when the filehandle is closed or when the program
  #pod exits. No access to the filename is provided.
  #pod
  #pod If the temporary file can not be created undef is returned.
  #pod Currently this command will probably not work when the temporary
  #pod directory is on an NFS file system.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Available since 0.05.
  #pod
  #pod Returning undef if unable to create file added in 0.12.
  #pod
  #pod =cut
  
  sub tmpfile {
  
    # Simply call tmpnam() in a list context
    my ($fh, $file) = tmpnam();
  
    # Make sure file is removed when filehandle is closed
    # This will fail on NFS
    unlink0($fh, $file)
      or return undef;
  
    return $fh;
  
  }
  
  #pod =back
  #pod
  #pod =head1 ADDITIONAL FUNCTIONS
  #pod
  #pod These functions are provided for backwards compatibility
  #pod with common tempfile generation C library functions.
  #pod
  #pod They are not exported and must be addressed using the full package
  #pod name.
  #pod
  #pod =over 4
  #pod
  #pod =item B<tempnam>
  #pod
  #pod Return the name of a temporary file in the specified directory
  #pod using a prefix. The file is guaranteed not to exist at the time
  #pod the function was called, but such guarantees are good for one
  #pod clock tick only.  Always use the proper form of C<sysopen>
  #pod with C<O_CREAT | O_EXCL> if you must open such a filename.
  #pod
  #pod   $filename = File::Temp::tempnam( $dir, $prefix );
  #pod
  #pod Equivalent to running mktemp() with $dir/$prefixXXXXXXXX
  #pod (using unix file convention as an example)
  #pod
  #pod Because this function uses mktemp(), it can suffer from race conditions.
  #pod
  #pod Will croak() if there is an error.
  #pod
  #pod Current API available since 0.05.
  #pod
  #pod =cut
  
  sub tempnam {
  
    croak 'Usage tempnam($dir, $prefix)' unless scalar(@_) == 2;
  
    my ($dir, $prefix) = @_;
  
    # Add a string to the prefix
    $prefix .= 'XXXXXXXX';
  
    # Concatenate the directory to the file
    my $template = File::Spec->catfile($dir, $prefix);
  
    return mktemp($template);
  
  }
  
  #pod =back
  #pod
  #pod =head1 UTILITY FUNCTIONS
  #pod
  #pod Useful functions for dealing with the filehandle and filename.
  #pod
  #pod =over 4
  #pod
  #pod =item B<unlink0>
  #pod
  #pod Given an open filehandle and the associated filename, make a safe
  #pod unlink. This is achieved by first checking that the filename and
  #pod filehandle initially point to the same file and that the number of
  #pod links to the file is 1 (all fields returned by stat() are compared).
  #pod Then the filename is unlinked and the filehandle checked once again to
  #pod verify that the number of links on that file is now 0.  This is the
  #pod closest you can come to making sure that the filename unlinked was the
  #pod same as the file whose descriptor you hold.
  #pod
  #pod   unlink0($fh, $path)
  #pod      or die "Error unlinking file $path safely";
  #pod
  #pod Returns false on error but croaks() if there is a security
  #pod anomaly. The filehandle is not closed since on some occasions this is
  #pod not required.
  #pod
  #pod On some platforms, for example Windows NT, it is not possible to
  #pod unlink an open file (the file must be closed first). On those
  #pod platforms, the actual unlinking is deferred until the program ends and
  #pod good status is returned. A check is still performed to make sure that
  #pod the filehandle and filename are pointing to the same thing (but not at
  #pod the time the end block is executed since the deferred removal may not
  #pod have access to the filehandle).
  #pod
  #pod Additionally, on Windows NT not all the fields returned by stat() can
  #pod be compared. For example, the C<dev> and C<rdev> fields seem to be
  #pod different.  Also, it seems that the size of the file returned by stat()
  #pod does not always agree, with C<stat(FH)> being more accurate than
  #pod C<stat(filename)>, presumably because of caching issues even when
  #pod using autoflush (this is usually overcome by waiting a while after
  #pod writing to the tempfile before attempting to C<unlink0> it).
  #pod
  #pod Finally, on NFS file systems the link count of the file handle does
  #pod not always go to zero immediately after unlinking. Currently, this
  #pod command is expected to fail on NFS disks.
  #pod
  #pod This function is disabled if the global variable $KEEP_ALL is true
  #pod and an unlink on open file is supported. If the unlink is to be deferred
  #pod to the END block, the file is still registered for removal.
  #pod
  #pod This function should not be called if you are using the object oriented
  #pod interface since the it will interfere with the object destructor deleting
  #pod the file.
  #pod
  #pod Available Since 0.05.
  #pod
  #pod If can not unlink open file, defer removal until later available since 0.06.
  #pod
  #pod =cut
  
  sub unlink0 {
  
    croak 'Usage: unlink0(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # attempt remove the file (does not work on some platforms)
    if (_can_unlink_opened_file()) {
  
      # return early (Without unlink) if we have been instructed to retain files.
      return 1 if $KEEP_ALL;
  
      # XXX: do *not* call this on a directory; possible race
      #      resulting in recursive removal
      croak "unlink0: $path has become a directory!" if -d $path;
      unlink($path) or return 0;
  
      # Stat the filehandle
      my @fh = stat $fh;
  
      print "Link count = $fh[3] \n" if $DEBUG;
  
      # Make sure that the link count is zero
      # - Cygwin provides deferred unlinking, however,
      #   on Win9x the link count remains 1
      # On NFS the link count may still be 1 but we can't know that
      # we are on NFS.  Since we can't be sure, we'll defer it
  
      return 1 if $fh[3] == 0 || $^O eq 'cygwin';
    }
    # fall-through if we can't unlink now
    _deferred_unlink($fh, $path, 0);
    return 1;
  }
  
  #pod =item B<cmpstat>
  #pod
  #pod Compare C<stat> of filehandle with C<stat> of provided filename.  This
  #pod can be used to check that the filename and filehandle initially point
  #pod to the same file and that the number of links to the file is 1 (all
  #pod fields returned by stat() are compared).
  #pod
  #pod   cmpstat($fh, $path)
  #pod      or die "Error comparing handle with file";
  #pod
  #pod Returns false if the stat information differs or if the link count is
  #pod greater than 1. Calls croak if there is a security anomaly.
  #pod
  #pod On certain platforms, for example Windows, not all the fields returned by stat()
  #pod can be compared. For example, the C<dev> and C<rdev> fields seem to be
  #pod different in Windows.  Also, it seems that the size of the file
  #pod returned by stat() does not always agree, with C<stat(FH)> being more
  #pod accurate than C<stat(filename)>, presumably because of caching issues
  #pod even when using autoflush (this is usually overcome by waiting a while
  #pod after writing to the tempfile before attempting to C<unlink0> it).
  #pod
  #pod Not exported by default.
  #pod
  #pod Current API available since 0.14.
  #pod
  #pod =cut
  
  sub cmpstat {
  
    croak 'Usage: cmpstat(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    warn "Comparing stat\n"
      if $DEBUG;
  
    # Stat the filehandle - which may be closed if someone has manually
    # closed the file. Can not turn off warnings without using $^W
    # unless we upgrade to 5.006 minimum requirement
    my @fh;
    {
      local ($^W) = 0;
      @fh = stat $fh;
    }
    return unless @fh;
  
    if ($fh[3] > 1 && $^W) {
      carp "unlink0: fstat found too many links; SB=@fh" if $^W;
    }
  
    # Stat the path
    my @path = stat $path;
  
    unless (@path) {
      carp "unlink0: $path is gone already" if $^W;
      return;
    }
  
    # this is no longer a file, but may be a directory, or worse
    unless (-f $path) {
      confess "panic: $path is no longer a file: SB=@fh";
    }
  
    # Do comparison of each member of the array
    # On WinNT dev and rdev seem to be different
    # depending on whether it is a file or a handle.
    # Cannot simply compare all members of the stat return
    # Select the ones we can use
    my @okstat = (0..$#fh);       # Use all by default
    if ($^O eq 'MSWin32') {
      @okstat = (1,2,3,4,5,7,8,9,10);
    } elsif ($^O eq 'os2') {
      @okstat = (0, 2..$#fh);
    } elsif ($^O eq 'VMS') {      # device and file ID are sufficient
      @okstat = (0, 1);
    } elsif ($^O eq 'dos') {
      @okstat = (0,2..7,11..$#fh);
    } elsif ($^O eq 'mpeix') {
      @okstat = (0..4,8..10);
    }
  
    # Now compare each entry explicitly by number
    for (@okstat) {
      print "Comparing: $_ : $fh[$_] and $path[$_]\n" if $DEBUG;
      # Use eq rather than == since rdev, blksize, and blocks (6, 11,
      # and 12) will be '' on platforms that do not support them.  This
      # is fine since we are only comparing integers.
      unless ($fh[$_] eq $path[$_]) {
        warn "Did not match $_ element of stat\n" if $DEBUG;
        return 0;
      }
    }
  
    return 1;
  }
  
  #pod =item B<unlink1>
  #pod
  #pod Similar to C<unlink0> except after file comparison using cmpstat, the
  #pod filehandle is closed prior to attempting to unlink the file. This
  #pod allows the file to be removed without using an END block, but does
  #pod mean that the post-unlink comparison of the filehandle state provided
  #pod by C<unlink0> is not available.
  #pod
  #pod   unlink1($fh, $path)
  #pod      or die "Error closing and unlinking file";
  #pod
  #pod Usually called from the object destructor when using the OO interface.
  #pod
  #pod Not exported by default.
  #pod
  #pod This function is disabled if the global variable $KEEP_ALL is true.
  #pod
  #pod Can call croak() if there is a security anomaly during the stat()
  #pod comparison.
  #pod
  #pod Current API available since 0.14.
  #pod
  #pod =cut
  
  sub unlink1 {
    croak 'Usage: unlink1(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # Close the file
    close( $fh ) or return 0;
  
    # Make sure the file is writable (for windows)
    _force_writable( $path );
  
    # return early (without unlink) if we have been instructed to retain files.
    return 1 if $KEEP_ALL;
  
    # remove the file
    return unlink($path);
  }
  
  #pod =item B<cleanup>
  #pod
  #pod Calling this function will cause any temp files or temp directories
  #pod that are registered for removal to be removed. This happens automatically
  #pod when the process exits but can be triggered manually if the caller is sure
  #pod that none of the temp files are required. This method can be registered as
  #pod an Apache callback.
  #pod
  #pod Note that if a temp directory is your current directory, it cannot be
  #pod removed.  C<chdir()> out of the directory first before calling
  #pod C<cleanup()>. (For the cleanup at program exit when the CLEANUP flag
  #pod is set, this happens automatically.)
  #pod
  #pod On OSes where temp files are automatically removed when the temp file
  #pod is closed, calling this function will have no effect other than to remove
  #pod temporary directories (which may include temporary files).
  #pod
  #pod   File::Temp::cleanup();
  #pod
  #pod Not exported by default.
  #pod
  #pod Current API available since 0.15.
  #pod
  #pod =back
  #pod
  #pod =head1 PACKAGE VARIABLES
  #pod
  #pod These functions control the global state of the package.
  #pod
  #pod =over 4
  #pod
  #pod =item B<safe_level>
  #pod
  #pod Controls the lengths to which the module will go to check the safety of the
  #pod temporary file or directory before proceeding.
  #pod Options are:
  #pod
  #pod =over 8
  #pod
  #pod =item STANDARD
  #pod
  #pod Do the basic security measures to ensure the directory exists and is
  #pod writable, that temporary files are opened only if they do not already
  #pod exist, and that possible race conditions are avoided.  Finally the
  #pod L<unlink0|"unlink0"> function is used to remove files safely.
  #pod
  #pod =item MEDIUM
  #pod
  #pod In addition to the STANDARD security, the output directory is checked
  #pod to make sure that it is owned either by root or the user running the
  #pod program. If the directory is writable by group or by other, it is then
  #pod checked to make sure that the sticky bit is set.
  #pod
  #pod Will not work on platforms that do not support the C<-k> test
  #pod for sticky bit.
  #pod
  #pod =item HIGH
  #pod
  #pod In addition to the MEDIUM security checks, also check for the
  #pod possibility of ``chown() giveaway'' using the L<POSIX|POSIX>
  #pod sysconf() function. If this is a possibility, each directory in the
  #pod path is checked in turn for safeness, recursively walking back to the
  #pod root directory.
  #pod
  #pod For platforms that do not support the L<POSIX|POSIX>
  #pod C<_PC_CHOWN_RESTRICTED> symbol (for example, Windows NT) it is
  #pod assumed that ``chown() giveaway'' is possible and the recursive test
  #pod is performed.
  #pod
  #pod =back
  #pod
  #pod The level can be changed as follows:
  #pod
  #pod   File::Temp->safe_level( File::Temp::HIGH );
  #pod
  #pod The level constants are not exported by the module.
  #pod
  #pod Currently, you must be running at least perl v5.6.0 in order to
  #pod run with MEDIUM or HIGH security. This is simply because the
  #pod safety tests use functions from L<Fcntl|Fcntl> that are not
  #pod available in older versions of perl. The problem is that the version
  #pod number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though
  #pod they are different versions.
  #pod
  #pod On systems that do not support the HIGH or MEDIUM safety levels
  #pod (for example Win NT or OS/2) any attempt to change the level will
  #pod be ignored. The decision to ignore rather than raise an exception
  #pod allows portable programs to be written with high security in mind
  #pod for the systems that can support this without those programs failing
  #pod on systems where the extra tests are irrelevant.
  #pod
  #pod If you really need to see whether the change has been accepted
  #pod simply examine the return value of C<safe_level>.
  #pod
  #pod   $newlevel = File::Temp->safe_level( File::Temp::HIGH );
  #pod   die "Could not change to high security"
  #pod       if $newlevel != File::Temp::HIGH;
  #pod
  #pod Available since 0.05.
  #pod
  #pod =cut
  
  {
    # protect from using the variable itself
    my $LEVEL = STANDARD;
    sub safe_level {
      my $self = shift;
      if (@_) {
        my $level = shift;
        if (($level != STANDARD) && ($level != MEDIUM) && ($level != HIGH)) {
          carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W;
        } else {
          # Don't allow this on perl 5.005 or earlier
          if ($] < 5.006 && $level != STANDARD) {
            # Cant do MEDIUM or HIGH checks
            croak "Currently requires perl 5.006 or newer to do the safe checks";
          }
          # Check that we are allowed to change level
          # Silently ignore if we can not.
          $LEVEL = $level if _can_do_level($level);
        }
      }
      return $LEVEL;
    }
  }
  
  #pod =item TopSystemUID
  #pod
  #pod This is the highest UID on the current system that refers to a root
  #pod UID. This is used to make sure that the temporary directory is
  #pod owned by a system UID (C<root>, C<bin>, C<sys> etc) rather than
  #pod simply by root.
  #pod
  #pod This is required since on many unix systems C</tmp> is not owned
  #pod by root.
  #pod
  #pod Default is to assume that any UID less than or equal to 10 is a root
  #pod UID.
  #pod
  #pod   File::Temp->top_system_uid(10);
  #pod   my $topid = File::Temp->top_system_uid;
  #pod
  #pod This value can be adjusted to reduce security checking if required.
  #pod The value is only relevant when C<safe_level> is set to MEDIUM or higher.
  #pod
  #pod Available since 0.05.
  #pod
  #pod =cut
  
  {
    my $TopSystemUID = 10;
    $TopSystemUID = 197108 if $^O eq 'interix'; # "Administrator"
    sub top_system_uid {
      my $self = shift;
      if (@_) {
        my $newuid = shift;
        croak "top_system_uid: UIDs should be numeric"
          unless $newuid =~ /^\d+$/s;
        $TopSystemUID = $newuid;
      }
      return $TopSystemUID;
    }
  }
  
  #pod =item B<$KEEP_ALL>
  #pod
  #pod Controls whether temporary files and directories should be retained
  #pod regardless of any instructions in the program to remove them
  #pod automatically.  This is useful for debugging but should not be used in
  #pod production code.
  #pod
  #pod   $File::Temp::KEEP_ALL = 1;
  #pod
  #pod Default is for files to be removed as requested by the caller.
  #pod
  #pod In some cases, files will only be retained if this variable is true
  #pod when the file is created. This means that you can not create a temporary
  #pod file, set this variable and expect the temp file to still be around
  #pod when the program exits.
  #pod
  #pod =item B<$DEBUG>
  #pod
  #pod Controls whether debugging messages should be enabled.
  #pod
  #pod   $File::Temp::DEBUG = 1;
  #pod
  #pod Default is for debugging mode to be disabled.
  #pod
  #pod Available since 0.15.
  #pod
  #pod =back
  #pod
  #pod =head1 WARNING
  #pod
  #pod For maximum security, endeavour always to avoid ever looking at,
  #pod touching, or even imputing the existence of the filename.  You do not
  #pod know that that filename is connected to the same file as the handle
  #pod you have, and attempts to check this can only trigger more race
  #pod conditions.  It's far more secure to use the filehandle alone and
  #pod dispense with the filename altogether.
  #pod
  #pod If you need to pass the handle to something that expects a filename
  #pod then on a unix system you can use C<"/dev/fd/" . fileno($fh)> for
  #pod arbitrary programs. Perl code that uses the 2-argument version of
  #pod C<< open >> can be passed C<< "+<=&" . fileno($fh) >>. Otherwise you
  #pod will need to pass the filename. You will have to clear the
  #pod close-on-exec bit on that file descriptor before passing it to another
  #pod process.
  #pod
  #pod     use Fcntl qw/F_SETFD F_GETFD/;
  #pod     fcntl($tmpfh, F_SETFD, 0)
  #pod         or die "Can't clear close-on-exec flag on temp fh: $!\n";
  #pod
  #pod =head2 Temporary files and NFS
  #pod
  #pod Some problems are associated with using temporary files that reside
  #pod on NFS file systems and it is recommended that a local filesystem
  #pod is used whenever possible. Some of the security tests will most probably
  #pod fail when the temp file is not local. Additionally, be aware that
  #pod the performance of I/O operations over NFS will not be as good as for
  #pod a local disk.
  #pod
  #pod =head2 Forking
  #pod
  #pod In some cases files created by File::Temp are removed from within an
  #pod END block. Since END blocks are triggered when a child process exits
  #pod (unless C<POSIX::_exit()> is used by the child) File::Temp takes care
  #pod to only remove those temp files created by a particular process ID. This
  #pod means that a child will not attempt to remove temp files created by the
  #pod parent process.
  #pod
  #pod If you are forking many processes in parallel that are all creating
  #pod temporary files, you may need to reset the random number seed using
  #pod srand(EXPR) in each child else all the children will attempt to walk
  #pod through the same set of random file names and may well cause
  #pod themselves to give up if they exceed the number of retry attempts.
  #pod
  #pod =head2 Directory removal
  #pod
  #pod Note that if you have chdir'ed into the temporary directory and it is
  #pod subsequently cleaned up (either in the END block or as part of object
  #pod destruction), then you will get a warning from File::Path::rmtree().
  #pod
  #pod =head2 Taint mode
  #pod
  #pod If you need to run code under taint mode, updating to the latest
  #pod L<File::Spec> is highly recommended.  On Windows, if the directory
  #pod given by L<File::Spec::tmpdir> isn't writable, File::Temp will attempt
  #pod to fallback to the user's local application data directory or croak
  #pod with an error.
  #pod
  #pod =head2 BINMODE
  #pod
  #pod The file returned by File::Temp will have been opened in binary mode
  #pod if such a mode is available. If that is not correct, use the C<binmode()>
  #pod function to change the mode of the filehandle.
  #pod
  #pod Note that you can modify the encoding of a file opened by File::Temp
  #pod also by using C<binmode()>.
  #pod
  #pod =head1 HISTORY
  #pod
  #pod Originally began life in May 1999 as an XS interface to the system
  #pod mkstemp() function. In March 2000, the OpenBSD mkstemp() code was
  #pod translated to Perl for total control of the code's
  #pod security checking, to ensure the presence of the function regardless of
  #pod operating system and to help with portability. The module was shipped
  #pod as a standard part of perl from v5.6.1.
  #pod
  #pod Thanks to Tom Christiansen for suggesting that this module
  #pod should be written and providing ideas for code improvements and
  #pod security enhancements.
  #pod
  #pod =head1 SEE ALSO
  #pod
  #pod L<POSIX/tmpnam>, L<POSIX/tmpfile>, L<File::Spec>, L<File::Path>
  #pod
  #pod See L<IO::File> and L<File::MkTemp>, L<Apache::TempFile> for
  #pod different implementations of temporary file handling.
  #pod
  #pod See L<File::Tempdir> for an alternative object-oriented wrapper for
  #pod the C<tempdir> function.
  #pod
  #pod =cut
  
  package ## hide from PAUSE
    File::Temp::Dir;
  
  our $VERSION = '0.2309';
  
  use File::Path qw/ rmtree /;
  use strict;
  use overload '""' => "STRINGIFY",
    '0+' => \&File::Temp::NUMIFY,
    fallback => 1;
  
  # private class specifically to support tempdir objects
  # created by File::Temp->newdir
  
  # ostensibly the same method interface as File::Temp but without
  # inheriting all the IO::Seekable methods and other cruft
  
  # Read-only - returns the name of the temp directory
  
  sub dirname {
    my $self = shift;
    return $self->{DIRNAME};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->dirname;
  }
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      $self->{CLEANUP} = shift;
    }
    return $self->{CLEANUP};
  }
  
  sub DESTROY {
    my $self = shift;
    local($., $@, $!, $^E, $?);
    if ($self->unlink_on_destroy && 
        $$ == $self->{LAUNCHPID} && !$File::Temp::KEEP_ALL) {
      if (-d $self->{REALNAME}) {
        # Some versions of rmtree will abort if you attempt to remove
        # the directory you are sitting in. We protect that and turn it
        # into a warning. We do this because this occurs during object
        # destruction and so can not be caught by the user.
        eval { rmtree($self->{REALNAME}, $File::Temp::DEBUG, 0); };
        warn $@ if ($@ && $^W);
      }
    }
  }
  
  1;
  
  
  # vim: ts=2 sts=2 sw=2 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Temp - return name and handle of a temporary file safely
  
  =head1 VERSION
  
  version 0.2309
  
  =head1 SYNOPSIS
  
    use File::Temp qw/ tempfile tempdir /;
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
    ($fh, $filename) = tempfile( $template, DIR => $dir);
    ($fh, $filename) = tempfile( $template, SUFFIX => '.dat');
    ($fh, $filename) = tempfile( $template, TMPDIR => 1 );
  
    binmode( $fh, ":utf8" );
  
    $dir = tempdir( CLEANUP => 1 );
    ($fh, $filename) = tempfile( DIR => $dir );
  
  Object interface:
  
    require File::Temp;
    use File::Temp ();
    use File::Temp qw/ :seekable /;
  
    $fh = File::Temp->new();
    $fname = $fh->filename;
  
    $fh = File::Temp->new(TEMPLATE => $template);
    $fname = $fh->filename;
  
    $tmp = File::Temp->new( UNLINK => 0, SUFFIX => '.dat' );
    print $tmp "Some data\n";
    print "Filename is $tmp\n";
    $tmp->seek( 0, SEEK_END );
  
    $dir = File::Temp->newdir(); # CLEANUP => 1 by default
  
  The following interfaces are provided for compatibility with
  existing APIs. They should not be used in new code.
  
  MkTemp family:
  
    use File::Temp qw/ :mktemp  /;
  
    ($fh, $file) = mkstemp( "tmpfileXXXXX" );
    ($fh, $file) = mkstemps( "tmpfileXXXXXX", $suffix);
  
    $tmpdir = mkdtemp( $template );
  
    $unopened_file = mktemp( $template );
  
  POSIX functions:
  
    use File::Temp qw/ :POSIX /;
  
    $file = tmpnam();
    $fh = tmpfile();
  
    ($fh, $file) = tmpnam();
  
  Compatibility functions:
  
    $unopened_file = File::Temp::tempnam( $dir, $pfx );
  
  =head1 DESCRIPTION
  
  C<File::Temp> can be used to create and open temporary files in a safe
  way.  There is both a function interface and an object-oriented
  interface.  The File::Temp constructor or the tempfile() function can
  be used to return the name and the open filehandle of a temporary
  file.  The tempdir() function can be used to create a temporary
  directory.
  
  The security aspect of temporary file creation is emphasized such that
  a filehandle and filename are returned together.  This helps guarantee
  that a race condition can not occur where the temporary file is
  created by another process between checking for the existence of the
  file and its opening.  Additional security levels are provided to
  check, for example, that the sticky bit is set on world writable
  directories.  See L<"safe_level"> for more information.
  
  For compatibility with popular C library functions, Perl implementations of
  the mkstemp() family of functions are provided. These are, mkstemp(),
  mkstemps(), mkdtemp() and mktemp().
  
  Additionally, implementations of the standard L<POSIX|POSIX>
  tmpnam() and tmpfile() functions are provided if required.
  
  Implementations of mktemp(), tmpnam(), and tempnam() are provided,
  but should be used with caution since they return only a filename
  that was valid when function was called, so cannot guarantee
  that the file will not exist by the time the caller opens the filename.
  
  Filehandles returned by these functions support the seekable methods.
  
  =begin :__INTERNALS
  
  =head1 PORTABILITY
  
  This section is at the top in order to provide easier access to
  porters.  It is not expected to be rendered by a standard pod
  formatting tool. Please skip straight to the SYNOPSIS section if you
  are not trying to port this module to a new platform.
  
  This module is designed to be portable across operating systems and it
  currently supports Unix, VMS, DOS, OS/2, Windows and Mac OS
  (Classic). When porting to a new OS there are generally three main
  issues that have to be solved:
  
  =over 4
  
  =item *
  
  Can the OS unlink an open file? If it can not then the
  C<_can_unlink_opened_file> method should be modified.
  
  =item *
  
  Are the return values from C<stat> reliable? By default all the
  return values from C<stat> are compared when unlinking a temporary
  file using the filename and the handle. Operating systems other than
  unix do not always have valid entries in all fields. If utility function
  C<File::Temp::unlink0> fails then the C<stat> comparison should be
  modified accordingly.
  
  =item *
  
  Security. Systems that can not support a test for the sticky bit
  on a directory can not use the MEDIUM and HIGH security tests.
  The C<_can_do_level> method should be modified accordingly.
  
  =back
  
  =end :__INTERNALS
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This is the primary interface for interacting with
  C<File::Temp>. Using the OO interface a temporary file can be created
  when the object is constructed and the file can be removed when the
  object is no longer required.
  
  Note that there is no method to obtain the filehandle from the
  C<File::Temp> object. The object itself acts as a filehandle.  The object
  isa C<IO::Handle> and isa C<IO::Seekable> so all those methods are
  available.
  
  Also, the object is configured such that it stringifies to the name of the
  temporary file and so can be compared to a filename directly.  It numifies
  to the C<refaddr> the same as other handles and so can be compared to other
  handles with C<==>.
  
      $fh eq $filename       # as a string
      $fh != \*STDOUT        # as a number
  
  Available since 0.14.
  
  =over 4
  
  =item B<new>
  
  Create a temporary file object.
  
    my $tmp = File::Temp->new();
  
  by default the object is constructed as if C<tempfile>
  was called without options, but with the additional behaviour
  that the temporary file is removed by the object destructor
  if UNLINK is set to true (the default).
  
  Supported arguments are the same as for C<tempfile>: UNLINK
  (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename
  template is specified using the TEMPLATE option. The OPEN option
  is not supported (the file is always opened).
  
   $tmp = File::Temp->new( TEMPLATE => 'tempXXXXX',
                          DIR => 'mydir',
                          SUFFIX => '.dat');
  
  Arguments are case insensitive.
  
  Can call croak() if an error occurs.
  
  Available since 0.14.
  
  TEMPLATE available since 0.23
  
  =item B<newdir>
  
  Create a temporary directory using an object oriented interface.
  
    $dir = File::Temp->newdir();
  
  By default the directory is deleted when the object goes out of scope.
  
  Supports the same options as the C<tempdir> function. Note that directories
  created with this method default to CLEANUP => 1.
  
    $dir = File::Temp->newdir( $template, %options );
  
  A template may be specified either with a leading template or
  with a TEMPLATE argument.
  
  Available since 0.19.
  
  TEMPLATE available since 0.23.
  
  =item B<filename>
  
  Return the name of the temporary file associated with this object
  (if the object was created using the "new" constructor).
  
    $filename = $tmp->filename;
  
  This method is called automatically when the object is used as
  a string.
  
  Current API available since 0.14
  
  =item B<dirname>
  
  Return the name of the temporary directory associated with this
  object (if the object was created using the "newdir" constructor).
  
    $dirname = $tmpdir->dirname;
  
  This method is called automatically when the object is used in string context.
  
  =item B<unlink_on_destroy>
  
  Control whether the file is unlinked when the object goes out of scope.
  The file is removed if this value is true and $KEEP_ALL is not.
  
   $fh->unlink_on_destroy( 1 );
  
  Default is for the file to be removed.
  
  Current API available since 0.15
  
  =item B<DESTROY>
  
  When the object goes out of scope, the destructor is called. This
  destructor will attempt to unlink the file (using L<unlink1|"unlink1">)
  if the constructor was called with UNLINK set to 1 (the default state
  if UNLINK is not specified).
  
  No error is given if the unlink fails.
  
  If the object has been passed to a child process during a fork, the
  file will be deleted when the object goes out of scope in the parent.
  
  For a temporary directory object the directory will be removed unless
  the CLEANUP argument was used in the constructor (and set to false) or
  C<unlink_on_destroy> was modified after creation.  Note that if a temp
  directory is your current directory, it cannot be removed - a warning
  will be given in this case.  C<chdir()> out of the directory before
  letting the object go out of scope.
  
  If the global variable $KEEP_ALL is true, the file or directory
  will not be removed.
  
  =back
  
  =head1 FUNCTIONS
  
  This section describes the recommended interface for generating
  temporary files and directories.
  
  =over 4
  
  =item B<tempfile>
  
  This is the basic function to generate temporary files.
  The behaviour of the file can be changed using various options:
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
  Create a temporary file in  the directory specified for temporary
  files, as specified by the tmpdir() function in L<File::Spec>.
  
    ($fh, $filename) = tempfile($template);
  
  Create a temporary file in the current directory using the supplied
  template.  Trailing `X' characters are replaced with random letters to
  generate the filename.  At least four `X' characters must be present
  at the end of the template.
  
    ($fh, $filename) = tempfile($template, SUFFIX => $suffix)
  
  Same as previously, except that a suffix is added to the template
  after the `X' translation.  Useful for ensuring that a temporary
  filename has a particular extension when needed by other applications.
  But see the WARNING at the end.
  
    ($fh, $filename) = tempfile($template, DIR => $dir);
  
  Translates the template as before except that a directory name
  is specified.
  
    ($fh, $filename) = tempfile($template, TMPDIR => 1);
  
  Equivalent to specifying a DIR of "File::Spec->tmpdir", writing the file
  into the same temporary directory as would be used if no template was
  specified at all.
  
    ($fh, $filename) = tempfile($template, UNLINK => 1);
  
  Return the filename and filehandle as before except that the file is
  automatically removed when the program exits (dependent on
  $KEEP_ALL). Default is for the file to be removed if a file handle is
  requested and to be kept if the filename is requested. In a scalar
  context (where no filename is returned) the file is always deleted
  either (depending on the operating system) on exit or when it is
  closed (unless $KEEP_ALL is true when the temp file is created).
  
  Use the object-oriented interface if fine-grained control of when
  a file is removed is required.
  
  If the template is not specified, a template is always
  automatically generated. This temporary file is placed in tmpdir()
  (L<File::Spec>) unless a directory is specified explicitly with the
  DIR option.
  
    $fh = tempfile( DIR => $dir );
  
  If called in scalar context, only the filehandle is returned and the
  file will automatically be deleted when closed on operating systems
  that support this (see the description of tmpfile() elsewhere in this
  document).  This is the preferred mode of operation, as if you only
  have a filehandle, you can never create a race condition by fumbling
  with the filename. On systems that can not unlink an open file or can
  not mark a file as temporary when it is opened (for example, Windows
  NT uses the C<O_TEMPORARY> flag) the file is marked for deletion when
  the program ends (equivalent to setting UNLINK to 1). The C<UNLINK>
  flag is ignored if present.
  
    (undef, $filename) = tempfile($template, OPEN => 0);
  
  This will return the filename based on the template but
  will not open this file.  Cannot be used in conjunction with
  UNLINK set to true. Default is to always open the file
  to protect from possible race conditions. A warning is issued
  if warnings are turned on. Consider using the tmpnam()
  and mktemp() functions described elsewhere in this document
  if opening the file is not required.
  
  To open the temporary filehandle with O_EXLOCK (open with exclusive
  file lock) use C<< EXLOCK=>1 >>. This is supported only by some
  operating systems (most notably BSD derived systems). By default
  EXLOCK will be false. Former C<File::Temp> versions set EXLOCK to
  true, so to be sure to get an unlocked filehandle also with older
  versions, explicitly set C<< EXLOCK=>0 >>.
  
    ($fh, $filename) = tempfile($template, EXLOCK => 1);
  
  Options can be combined as required.
  
  Will croak() if there is an error.
  
  Available since 0.05.
  
  UNLINK flag available since 0.10.
  
  TMPDIR flag available since 0.19.
  
  EXLOCK flag available since 0.19.
  
  =item B<tempdir>
  
  This is the recommended interface for creation of temporary
  directories.  By default the directory will not be removed on exit
  (that is, it won't be temporary; this behaviour can not be changed
  because of issues with backwards compatibility). To enable removal
  either use the CLEANUP option which will trigger removal on program
  exit, or consider using the "newdir" method in the object interface which
  will allow the directory to be cleaned up when the object goes out of
  scope.
  
  The behaviour of the function depends on the arguments:
  
    $tempdir = tempdir();
  
  Create a directory in tmpdir() (see L<File::Spec|File::Spec>).
  
    $tempdir = tempdir( $template );
  
  Create a directory from the supplied template. This template is
  similar to that described for tempfile(). `X' characters at the end
  of the template are replaced with random letters to construct the
  directory name. At least four `X' characters must be in the template.
  
    $tempdir = tempdir ( DIR => $dir );
  
  Specifies the directory to use for the temporary directory.
  The temporary directory name is derived from an internal template.
  
    $tempdir = tempdir ( $template, DIR => $dir );
  
  Prepend the supplied directory name to the template. The template
  should not include parent directory specifications itself. Any parent
  directory specifications are removed from the template before
  prepending the supplied directory.
  
    $tempdir = tempdir ( $template, TMPDIR => 1 );
  
  Using the supplied template, create the temporary directory in
  a standard location for temporary files. Equivalent to doing
  
    $tempdir = tempdir ( $template, DIR => File::Spec->tmpdir);
  
  but shorter. Parent directory specifications are stripped from the
  template itself. The C<TMPDIR> option is ignored if C<DIR> is set
  explicitly.  Additionally, C<TMPDIR> is implied if neither a template
  nor a directory are supplied.
  
    $tempdir = tempdir( $template, CLEANUP => 1);
  
  Create a temporary directory using the supplied template, but
  attempt to remove it (and all files inside it) when the program
  exits. Note that an attempt will be made to remove all files from
  the directory even if they were not created by this module (otherwise
  why ask to clean it up?). The directory removal is made with
  the rmtree() function from the L<File::Path|File::Path> module.
  Of course, if the template is not specified, the temporary directory
  will be created in tmpdir() and will also be removed at program exit.
  
  Will croak() if there is an error.
  
  Current API available since 0.05.
  
  =back
  
  =head1 MKTEMP FUNCTIONS
  
  The following functions are Perl implementations of the
  mktemp() family of temp file generation system calls.
  
  =over 4
  
  =item B<mkstemp>
  
  Given a template, returns a filehandle to the temporary file and the name
  of the file.
  
    ($fh, $name) = mkstemp( $template );
  
  In scalar context, just the filehandle is returned.
  
  The template may be any filename with some number of X's appended
  to it, for example F</tmp/temp.XXXX>. The trailing X's are replaced
  with unique alphanumeric combinations.
  
  Will croak() if there is an error.
  
  Current API available since 0.05.
  
  =item B<mkstemps>
  
  Similar to mkstemp(), except that an extra argument can be supplied
  with a suffix to be appended to the template.
  
    ($fh, $name) = mkstemps( $template, $suffix );
  
  For example a template of C<testXXXXXX> and suffix of C<.dat>
  would generate a file similar to F<testhGji_w.dat>.
  
  Returns just the filehandle alone when called in scalar context.
  
  Will croak() if there is an error.
  
  Current API available since 0.05.
  
  =item B<mkdtemp>
  
  Create a directory from a template. The template must end in
  X's that are replaced by the routine.
  
    $tmpdir_name = mkdtemp($template);
  
  Returns the name of the temporary directory created.
  
  Directory must be removed by the caller.
  
  Will croak() if there is an error.
  
  Current API available since 0.05.
  
  =item B<mktemp>
  
  Returns a valid temporary filename but does not guarantee
  that the file will not be opened by someone else.
  
    $unopened_file = mktemp($template);
  
  Template is the same as that required by mkstemp().
  
  Will croak() if there is an error.
  
  Current API available since 0.05.
  
  =back
  
  =head1 POSIX FUNCTIONS
  
  This section describes the re-implementation of the tmpnam()
  and tmpfile() functions described in L<POSIX>
  using the mkstemp() from this module.
  
  Unlike the L<POSIX|POSIX> implementations, the directory used
  for the temporary file is not specified in a system include
  file (C<P_tmpdir>) but simply depends on the choice of tmpdir()
  returned by L<File::Spec|File::Spec>. On some implementations this
  location can be set using the C<TMPDIR> environment variable, which
  may not be secure.
  If this is a problem, simply use mkstemp() and specify a template.
  
  =over 4
  
  =item B<tmpnam>
  
  When called in scalar context, returns the full name (including path)
  of a temporary file (uses mktemp()). The only check is that the file does
  not already exist, but there is no guarantee that that condition will
  continue to apply.
  
    $file = tmpnam();
  
  When called in list context, a filehandle to the open file and
  a filename are returned. This is achieved by calling mkstemp()
  after constructing a suitable template.
  
    ($fh, $file) = tmpnam();
  
  If possible, this form should be used to prevent possible
  race conditions.
  
  See L<File::Spec/tmpdir> for information on the choice of temporary
  directory for a particular operating system.
  
  Will croak() if there is an error.
  
  Current API available since 0.05.
  
  =item B<tmpfile>
  
  Returns the filehandle of a temporary file.
  
    $fh = tmpfile();
  
  The file is removed when the filehandle is closed or when the program
  exits. No access to the filename is provided.
  
  If the temporary file can not be created undef is returned.
  Currently this command will probably not work when the temporary
  directory is on an NFS file system.
  
  Will croak() if there is an error.
  
  Available since 0.05.
  
  Returning undef if unable to create file added in 0.12.
  
  =back
  
  =head1 ADDITIONAL FUNCTIONS
  
  These functions are provided for backwards compatibility
  with common tempfile generation C library functions.
  
  They are not exported and must be addressed using the full package
  name.
  
  =over 4
  
  =item B<tempnam>
  
  Return the name of a temporary file in the specified directory
  using a prefix. The file is guaranteed not to exist at the time
  the function was called, but such guarantees are good for one
  clock tick only.  Always use the proper form of C<sysopen>
  with C<O_CREAT | O_EXCL> if you must open such a filename.
  
    $filename = File::Temp::tempnam( $dir, $prefix );
  
  Equivalent to running mktemp() with $dir/$prefixXXXXXXXX
  (using unix file convention as an example)
  
  Because this function uses mktemp(), it can suffer from race conditions.
  
  Will croak() if there is an error.
  
  Current API available since 0.05.
  
  =back
  
  =head1 UTILITY FUNCTIONS
  
  Useful functions for dealing with the filehandle and filename.
  
  =over 4
  
  =item B<unlink0>
  
  Given an open filehandle and the associated filename, make a safe
  unlink. This is achieved by first checking that the filename and
  filehandle initially point to the same file and that the number of
  links to the file is 1 (all fields returned by stat() are compared).
  Then the filename is unlinked and the filehandle checked once again to
  verify that the number of links on that file is now 0.  This is the
  closest you can come to making sure that the filename unlinked was the
  same as the file whose descriptor you hold.
  
    unlink0($fh, $path)
       or die "Error unlinking file $path safely";
  
  Returns false on error but croaks() if there is a security
  anomaly. The filehandle is not closed since on some occasions this is
  not required.
  
  On some platforms, for example Windows NT, it is not possible to
  unlink an open file (the file must be closed first). On those
  platforms, the actual unlinking is deferred until the program ends and
  good status is returned. A check is still performed to make sure that
  the filehandle and filename are pointing to the same thing (but not at
  the time the end block is executed since the deferred removal may not
  have access to the filehandle).
  
  Additionally, on Windows NT not all the fields returned by stat() can
  be compared. For example, the C<dev> and C<rdev> fields seem to be
  different.  Also, it seems that the size of the file returned by stat()
  does not always agree, with C<stat(FH)> being more accurate than
  C<stat(filename)>, presumably because of caching issues even when
  using autoflush (this is usually overcome by waiting a while after
  writing to the tempfile before attempting to C<unlink0> it).
  
  Finally, on NFS file systems the link count of the file handle does
  not always go to zero immediately after unlinking. Currently, this
  command is expected to fail on NFS disks.
  
  This function is disabled if the global variable $KEEP_ALL is true
  and an unlink on open file is supported. If the unlink is to be deferred
  to the END block, the file is still registered for removal.
  
  This function should not be called if you are using the object oriented
  interface since the it will interfere with the object destructor deleting
  the file.
  
  Available Since 0.05.
  
  If can not unlink open file, defer removal until later available since 0.06.
  
  =item B<cmpstat>
  
  Compare C<stat> of filehandle with C<stat> of provided filename.  This
  can be used to check that the filename and filehandle initially point
  to the same file and that the number of links to the file is 1 (all
  fields returned by stat() are compared).
  
    cmpstat($fh, $path)
       or die "Error comparing handle with file";
  
  Returns false if the stat information differs or if the link count is
  greater than 1. Calls croak if there is a security anomaly.
  
  On certain platforms, for example Windows, not all the fields returned by stat()
  can be compared. For example, the C<dev> and C<rdev> fields seem to be
  different in Windows.  Also, it seems that the size of the file
  returned by stat() does not always agree, with C<stat(FH)> being more
  accurate than C<stat(filename)>, presumably because of caching issues
  even when using autoflush (this is usually overcome by waiting a while
  after writing to the tempfile before attempting to C<unlink0> it).
  
  Not exported by default.
  
  Current API available since 0.14.
  
  =item B<unlink1>
  
  Similar to C<unlink0> except after file comparison using cmpstat, the
  filehandle is closed prior to attempting to unlink the file. This
  allows the file to be removed without using an END block, but does
  mean that the post-unlink comparison of the filehandle state provided
  by C<unlink0> is not available.
  
    unlink1($fh, $path)
       or die "Error closing and unlinking file";
  
  Usually called from the object destructor when using the OO interface.
  
  Not exported by default.
  
  This function is disabled if the global variable $KEEP_ALL is true.
  
  Can call croak() if there is a security anomaly during the stat()
  comparison.
  
  Current API available since 0.14.
  
  =item B<cleanup>
  
  Calling this function will cause any temp files or temp directories
  that are registered for removal to be removed. This happens automatically
  when the process exits but can be triggered manually if the caller is sure
  that none of the temp files are required. This method can be registered as
  an Apache callback.
  
  Note that if a temp directory is your current directory, it cannot be
  removed.  C<chdir()> out of the directory first before calling
  C<cleanup()>. (For the cleanup at program exit when the CLEANUP flag
  is set, this happens automatically.)
  
  On OSes where temp files are automatically removed when the temp file
  is closed, calling this function will have no effect other than to remove
  temporary directories (which may include temporary files).
  
    File::Temp::cleanup();
  
  Not exported by default.
  
  Current API available since 0.15.
  
  =back
  
  =head1 PACKAGE VARIABLES
  
  These functions control the global state of the package.
  
  =over 4
  
  =item B<safe_level>
  
  Controls the lengths to which the module will go to check the safety of the
  temporary file or directory before proceeding.
  Options are:
  
  =over 8
  
  =item STANDARD
  
  Do the basic security measures to ensure the directory exists and is
  writable, that temporary files are opened only if they do not already
  exist, and that possible race conditions are avoided.  Finally the
  L<unlink0|"unlink0"> function is used to remove files safely.
  
  =item MEDIUM
  
  In addition to the STANDARD security, the output directory is checked
  to make sure that it is owned either by root or the user running the
  program. If the directory is writable by group or by other, it is then
  checked to make sure that the sticky bit is set.
  
  Will not work on platforms that do not support the C<-k> test
  for sticky bit.
  
  =item HIGH
  
  In addition to the MEDIUM security checks, also check for the
  possibility of ``chown() giveaway'' using the L<POSIX|POSIX>
  sysconf() function. If this is a possibility, each directory in the
  path is checked in turn for safeness, recursively walking back to the
  root directory.
  
  For platforms that do not support the L<POSIX|POSIX>
  C<_PC_CHOWN_RESTRICTED> symbol (for example, Windows NT) it is
  assumed that ``chown() giveaway'' is possible and the recursive test
  is performed.
  
  =back
  
  The level can be changed as follows:
  
    File::Temp->safe_level( File::Temp::HIGH );
  
  The level constants are not exported by the module.
  
  Currently, you must be running at least perl v5.6.0 in order to
  run with MEDIUM or HIGH security. This is simply because the
  safety tests use functions from L<Fcntl|Fcntl> that are not
  available in older versions of perl. The problem is that the version
  number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though
  they are different versions.
  
  On systems that do not support the HIGH or MEDIUM safety levels
  (for example Win NT or OS/2) any attempt to change the level will
  be ignored. The decision to ignore rather than raise an exception
  allows portable programs to be written with high security in mind
  for the systems that can support this without those programs failing
  on systems where the extra tests are irrelevant.
  
  If you really need to see whether the change has been accepted
  simply examine the return value of C<safe_level>.
  
    $newlevel = File::Temp->safe_level( File::Temp::HIGH );
    die "Could not change to high security"
        if $newlevel != File::Temp::HIGH;
  
  Available since 0.05.
  
  =item TopSystemUID
  
  This is the highest UID on the current system that refers to a root
  UID. This is used to make sure that the temporary directory is
  owned by a system UID (C<root>, C<bin>, C<sys> etc) rather than
  simply by root.
  
  This is required since on many unix systems C</tmp> is not owned
  by root.
  
  Default is to assume that any UID less than or equal to 10 is a root
  UID.
  
    File::Temp->top_system_uid(10);
    my $topid = File::Temp->top_system_uid;
  
  This value can be adjusted to reduce security checking if required.
  The value is only relevant when C<safe_level> is set to MEDIUM or higher.
  
  Available since 0.05.
  
  =item B<$KEEP_ALL>
  
  Controls whether temporary files and directories should be retained
  regardless of any instructions in the program to remove them
  automatically.  This is useful for debugging but should not be used in
  production code.
  
    $File::Temp::KEEP_ALL = 1;
  
  Default is for files to be removed as requested by the caller.
  
  In some cases, files will only be retained if this variable is true
  when the file is created. This means that you can not create a temporary
  file, set this variable and expect the temp file to still be around
  when the program exits.
  
  =item B<$DEBUG>
  
  Controls whether debugging messages should be enabled.
  
    $File::Temp::DEBUG = 1;
  
  Default is for debugging mode to be disabled.
  
  Available since 0.15.
  
  =back
  
  =head1 WARNING
  
  For maximum security, endeavour always to avoid ever looking at,
  touching, or even imputing the existence of the filename.  You do not
  know that that filename is connected to the same file as the handle
  you have, and attempts to check this can only trigger more race
  conditions.  It's far more secure to use the filehandle alone and
  dispense with the filename altogether.
  
  If you need to pass the handle to something that expects a filename
  then on a unix system you can use C<"/dev/fd/" . fileno($fh)> for
  arbitrary programs. Perl code that uses the 2-argument version of
  C<< open >> can be passed C<< "+<=&" . fileno($fh) >>. Otherwise you
  will need to pass the filename. You will have to clear the
  close-on-exec bit on that file descriptor before passing it to another
  process.
  
      use Fcntl qw/F_SETFD F_GETFD/;
      fcntl($tmpfh, F_SETFD, 0)
          or die "Can't clear close-on-exec flag on temp fh: $!\n";
  
  =head2 Temporary files and NFS
  
  Some problems are associated with using temporary files that reside
  on NFS file systems and it is recommended that a local filesystem
  is used whenever possible. Some of the security tests will most probably
  fail when the temp file is not local. Additionally, be aware that
  the performance of I/O operations over NFS will not be as good as for
  a local disk.
  
  =head2 Forking
  
  In some cases files created by File::Temp are removed from within an
  END block. Since END blocks are triggered when a child process exits
  (unless C<POSIX::_exit()> is used by the child) File::Temp takes care
  to only remove those temp files created by a particular process ID. This
  means that a child will not attempt to remove temp files created by the
  parent process.
  
  If you are forking many processes in parallel that are all creating
  temporary files, you may need to reset the random number seed using
  srand(EXPR) in each child else all the children will attempt to walk
  through the same set of random file names and may well cause
  themselves to give up if they exceed the number of retry attempts.
  
  =head2 Directory removal
  
  Note that if you have chdir'ed into the temporary directory and it is
  subsequently cleaned up (either in the END block or as part of object
  destruction), then you will get a warning from File::Path::rmtree().
  
  =head2 Taint mode
  
  If you need to run code under taint mode, updating to the latest
  L<File::Spec> is highly recommended.  On Windows, if the directory
  given by L<File::Spec::tmpdir> isn't writable, File::Temp will attempt
  to fallback to the user's local application data directory or croak
  with an error.
  
  =head2 BINMODE
  
  The file returned by File::Temp will have been opened in binary mode
  if such a mode is available. If that is not correct, use the C<binmode()>
  function to change the mode of the filehandle.
  
  Note that you can modify the encoding of a file opened by File::Temp
  also by using C<binmode()>.
  
  =head1 HISTORY
  
  Originally began life in May 1999 as an XS interface to the system
  mkstemp() function. In March 2000, the OpenBSD mkstemp() code was
  translated to Perl for total control of the code's
  security checking, to ensure the presence of the function regardless of
  operating system and to help with portability. The module was shipped
  as a standard part of perl from v5.6.1.
  
  Thanks to Tom Christiansen for suggesting that this module
  should be written and providing ideas for code improvements and
  security enhancements.
  
  =head1 SEE ALSO
  
  L<POSIX/tmpnam>, L<POSIX/tmpfile>, L<File::Spec>, L<File::Path>
  
  See L<IO::File> and L<File::MkTemp>, L<Apache::TempFile> for
  different implementations of temporary file handling.
  
  See L<File::Tempdir> for an alternative object-oriented wrapper for
  the C<tempdir> function.
  
  =for Pod::Coverage STRINGIFY NUMIFY top_system_uid
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp>
  (or L<bug-File-Temp@rt.cpan.org|mailto:bug-File-Temp@rt.cpan.org>).
  
  There is also a mailing list available for users of this distribution, at
  L<http://lists.perl.org/list/cpan-workers.html>.
  
  There is also an irc channel available for users of this distribution, at
  L<C<#toolchain> on C<irc.perl.org>|irc://irc.perl.org/#toolchain>.
  
  =head1 AUTHOR
  
  Tim Jenness <tjenness@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords David Golden Karen Etheridge Slaven Rezic Peter Rabbitson Olivier Mengue Kevin Ryde John Acklam James E. Keenan Brian Mowrey Dagfinn Ilmari Mannsker Steinbrunner Ed Avis Guillem Jover Ben Tilly
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Slaven Rezic <slaven@rezic.de>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Olivier Mengue <dolmen@cpan.org>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Kevin Ryde <user42@zip.com.au>
  
  =item *
  
  Peter John Acklam <pjacklam@online.no>
  
  =item *
  
  Slaven Rezic <slaven.rezic@idealo.de>
  
  =item *
  
  James E. Keenan <jkeen@verizon.net>
  
  =item *
  
  Brian Mowrey <brian@drlabs.org>
  
  =item *
  
  Dagfinn Ilmari Mannsker <ilmari@ilmari.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Ed Avis <eda@linux01.wcl.local>
  
  =item *
  
  Guillem Jover <guillem@hadrons.org>
  
  =item *
  
  Ben Tilly <btilly@gmail.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2019 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_TEMP

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;
  use warnings;
  
  package File::pushd;
  # ABSTRACT: change directory temporarily for a limited scope
  
  our $VERSION = '1.016';
  
  our @EXPORT = qw( pushd tempd );
  our @ISA    = qw( Exporter );
  
  use Exporter;
  use Carp;
  use Cwd qw( getcwd abs_path );
  use File::Path qw( rmtree );
  use File::Temp qw();
  use File::Spec;
  
  use overload
    q{""}    => sub { File::Spec->canonpath( $_[0]->{_pushd} ) },
    fallback => 1;
  
  #--------------------------------------------------------------------------#
  # pushd()
  #--------------------------------------------------------------------------#
  
  sub pushd {
      # Called in void context?
      unless (defined wantarray) {
          warnings::warnif(void => 'Useless use of File::pushd::pushd in void context');
          return
      }
  
      my ( $target_dir, $options ) = @_;
      $options->{untaint_pattern} ||= qr{^([-+@\w./]+)$};
  
      $target_dir = "." unless defined $target_dir;
      croak "Can't locate directory $target_dir" unless -d $target_dir;
  
      my $tainted_orig = getcwd;
      my $orig;
      if ( $tainted_orig =~ $options->{untaint_pattern} ) {
          $orig = $1;
      }
      else {
          $orig = $tainted_orig;
      }
  
      my $tainted_dest;
      eval { $tainted_dest = $target_dir ? abs_path($target_dir) : $orig };
      croak "Can't locate absolute path for $target_dir: $@" if $@;
  
      my $dest;
      if ( $tainted_dest =~ $options->{untaint_pattern} ) {
          $dest = $1;
      }
      else {
          $dest = $tainted_dest;
      }
  
      if ( $dest ne $orig ) {
          chdir $dest or croak "Can't chdir to $dest\: $!";
      }
  
      my $self = bless {
          _pushd    => $dest,
          _original => $orig
        },
        __PACKAGE__;
  
      return $self;
  }
  
  #--------------------------------------------------------------------------#
  # tempd()
  #--------------------------------------------------------------------------#
  
  sub tempd {
      # Called in void context?
      unless (defined wantarray) {
          warnings::warnif(void => 'Useless use of File::pushd::tempd in void context');
          return
      }
  
      my ($options) = @_;
      my $dir;
      eval { $dir = pushd( File::Temp::tempdir( CLEANUP => 0 ), $options ) };
      croak $@ if $@;
      $dir->{_tempd} = 1;
      $dir->{_owner} = $$;
      return $dir;
  }
  
  #--------------------------------------------------------------------------#
  # preserve()
  #--------------------------------------------------------------------------#
  
  sub preserve {
      my $self = shift;
      return 1 if !$self->{"_tempd"};
      if ( @_ == 0 ) {
          return $self->{_preserve} = 1;
      }
      else {
          return $self->{_preserve} = $_[0] ? 1 : 0;
      }
  }
  
  #--------------------------------------------------------------------------#
  # DESTROY()
  # Revert to original directory as object is destroyed and cleanup
  # if necessary
  #--------------------------------------------------------------------------#
  
  sub DESTROY {
      my ($self) = @_;
      my $orig = $self->{_original};
      chdir $orig if $orig; # should always be so, but just in case...
      if ( $self->{_tempd}
          && $self->{_owner} == $$
          && !$self->{_preserve} )
      {
          # don't destroy existing $@ if there is no error.
          my $err = do {
              local $@;
              eval { rmtree( $self->{_pushd} ) };
              $@;
          };
          carp $err if $err;
      }
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::pushd - change directory temporarily for a limited scope
  
  =head1 VERSION
  
  version 1.016
  
  =head1 SYNOPSIS
  
   use File::pushd;
  
   chdir $ENV{HOME};
  
   # change directory again for a limited scope
   {
       my $dir = pushd( '/tmp' );
       # working directory changed to /tmp
   }
   # working directory has reverted to $ENV{HOME}
  
   # tempd() is equivalent to pushd( File::Temp::tempdir )
   {
       my $dir = tempd();
   }
  
   # object stringifies naturally as an absolute path
   {
      my $dir = pushd( '/tmp' );
      my $filename = File::Spec->catfile( $dir, "somefile.txt" );
      # gives /tmp/somefile.txt
   }
  
  =head1 DESCRIPTION
  
  File::pushd does a temporary C<chdir> that is easily and automatically
  reverted, similar to C<pushd> in some Unix command shells.  It works by
  creating an object that caches the original working directory.  When the object
  is destroyed, the destructor calls C<chdir> to revert to the original working
  directory.  By storing the object in a lexical variable with a limited scope,
  this happens automatically at the end of the scope.
  
  This is very handy when working with temporary directories for tasks like
  testing; a function is provided to streamline getting a temporary
  directory from L<File::Temp>.
  
  For convenience, the object stringifies as the canonical form of the absolute
  pathname of the directory entered.
  
  B<Warning>: if you create multiple C<pushd> objects in the same lexical scope,
  their destruction order is not guaranteed and you might not wind up in the
  directory you expect.
  
  =head1 USAGE
  
   use File::pushd;
  
  Using File::pushd automatically imports the C<pushd> and C<tempd> functions.
  
  =head2 pushd
  
   {
       my $dir = pushd( $target_directory );
   }
  
  Caches the current working directory, calls C<chdir> to change to the target
  directory, and returns a File::pushd object.  When the object is
  destroyed, the working directory reverts to the original directory.
  
  The provided target directory can be a relative or absolute path. If
  called with no arguments, it uses the current directory as its target and
  returns to the current directory when the object is destroyed.
  
  If the target directory does not exist or if the directory change fails
  for some reason, C<pushd> will die with an error message.
  
  Can be given a hashref as an optional second argument.  The only supported
  option is C<untaint_pattern>, which is used to untaint file paths involved.
  It defaults to {qr{^(L<-+@\w./>+)$}}, which is reasonably restrictive (e.g.
  it does not even allow spaces in the path).  Change this to suit your
  circumstances and security needs if running under taint mode. *Note*: you
  must include the parentheses in the pattern to capture the untainted
  portion of the path.
  
  =head2 tempd
  
   {
       my $dir = tempd();
   }
  
  This function is like C<pushd> but automatically creates and calls C<chdir> to
  a temporary directory created by L<File::Temp>. Unlike normal L<File::Temp>
  cleanup which happens at the end of the program, this temporary directory is
  removed when the object is destroyed. (But also see C<preserve>.)  A warning
  will be issued if the directory cannot be removed.
  
  As with C<pushd>, C<tempd> will die if C<chdir> fails.
  
  It may be given a single options hash that will be passed internally
  to C<pushd>.
  
  =head2 preserve
  
   {
       my $dir = tempd();
       $dir->preserve;      # mark to preserve at end of scope
       $dir->preserve(0);   # mark to delete at end of scope
   }
  
  Controls whether a temporary directory will be cleaned up when the object is
  destroyed.  With no arguments, C<preserve> sets the directory to be preserved.
  With an argument, the directory will be preserved if the argument is true, or
  marked for cleanup if the argument is false.  Only C<tempd> objects may be
  marked for cleanup.  (Target directories to C<pushd> are always preserved.)
  C<preserve> returns true if the directory will be preserved, and false
  otherwise.
  
  =head1 DIAGNOSTICS
  
  C<pushd> and C<tempd> warn with message
  C<"Useless use of File::pushd::I<%s> in void context"> if called in
  void context and the warnings category C<void> is enabled.
  
    {
      use warnings 'void';
  
      pushd();
    }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<File::chdir>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/File-pushd/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/File-pushd>
  
    git clone https://github.com/dagolden/File-pushd.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Diab Jerius Graham Ollis Olivier Mengu Shoichi Kaji
  
  =over 4
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  Olivier Mengu <dolmen@cpan.org>
  
  =item *
  
  Shoichi Kaji <skaji@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2018 by David A Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
  
  __END__
  
  
  # vim: ts=4 sts=4 sw=4 et:
FILE_PUSHD

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;
  
  use strict;
  use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);
  use Module::Pluggable::Object;
  
  use if $] > 5.017, 'deprecate';
  
  # ObQuote:
  # Bob Porter: Looks like you've been missing a lot of work lately.
  # Peter Gibbons: I wouldn't say I've been missing it, Bob!
  
  
  $VERSION = '5.2';
  $FORCE_SEARCH_ALL_PATHS = 0;
  
  sub import {
      my $class        = shift;
      my %opts         = @_;
  
      my ($pkg, $file) = caller;
      # the default name for the method is 'plugins'
      my $sub          = $opts{'sub_name'}  || 'plugins';
      # get our package
      my ($package)    = $opts{'package'} || $pkg;
      $opts{filename}  = $file;
      $opts{package}   = $package;
      $opts{force_search_all_paths} = $FORCE_SEARCH_ALL_PATHS unless exists $opts{force_search_all_paths};
  
  
      my $finder       = Module::Pluggable::Object->new(%opts);
      my $subroutine   = sub { my $self = shift; return $finder->plugins(@_) };
  
      my $searchsub = sub {
                my $self = shift;
                my ($action,@paths) = @_;
  
                $finder->{'search_path'} = ["${package}::Plugin"] if ($action eq 'add'  and not   $finder->{'search_path'} );
                push @{$finder->{'search_path'}}, @paths      if ($action eq 'add');
                $finder->{'search_path'}       = \@paths      if ($action eq 'new');
                return $finder->{'search_path'};
      };
  
  
      my $onlysub = sub {
          my ($self, $only) = @_;
  
          if (defined $only) {
              $finder->{'only'} = $only;
          };
  
          return $finder->{'only'};
      };
  
      my $exceptsub = sub {
          my ($self, $except) = @_;
  
          if (defined $except) {
              $finder->{'except'} = $except;
          };
  
          return $finder->{'except'};
      };
  
  
      no strict 'refs';
      no warnings qw(redefine prototype);
  
      *{"$package\::$sub"}        = $subroutine;
      *{"$package\::search_path"} = $searchsub;
      *{"$package\::only"}        = $onlysub;
      *{"$package\::except"}      = $exceptsub;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable;
  
  
  and then later ...
  
      use MyClass;
      my $mc = MyClass->new();
      # returns the names of all plugins installed under MyClass::Plugin::*
      my @plugins = $mc->plugins();
  
  =head1 EXAMPLE
  
  Why would you want to do this? Say you have something that wants to pass an
  object to a number of different plugins in turn. For example you may
  want to extract meta-data from every email you get sent and do something
  with it. Plugins make sense here because then you can keep adding new
  meta data parsers and all the logic and docs for each one will be
  self contained and new handlers are easy to add without changing the
  core code. For that, you might do something like ...
  
      package Email::Examiner;
  
      use strict;
      use Email::Simple;
      use Module::Pluggable require => 1;
  
      sub handle_email {
          my $self  = shift;
          my $email = shift;
  
          foreach my $plugin ($self->plugins) {
              $plugin->examine($email);
          }
  
          return 1;
      }
  
  
  
  .. and all the plugins will get a chance in turn to look at it.
  
  This can be trivially extended so that plugins could save the email
  somewhere and then no other plugin should try and do that.
  Simply have it so that the C<examine> method returns C<1> if
  it has saved the email somewhere. You might also want to be paranoid
  and check to see if the plugin has an C<examine> method.
  
          foreach my $plugin ($self->plugins) {
              next unless $plugin->can('examine');
              last if     $plugin->examine($email);
          }
  
  
  And so on. The sky's the limit.
  
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that
  looks through a search path for .pm files and turn those into class names.
  
  Optionally it instantiates those classes for you.
  
  =head1 ADVANCED USAGE
  
  Alternatively, if you don't want to use 'plugins' as the method ...
  
      package MyClass;
      use Module::Pluggable sub_name => 'foo';
  
  
  and then later ...
  
      my @plugins = $mc->foo();
  
  
  Or if you want to look in another namespace
  
      package MyClass;
      use Module::Pluggable search_path => ['Acme::MyClass::Plugin', 'MyClass::Extend'];
  
  or directory
  
      use Module::Pluggable search_dirs => ['mylibs/Foo'];
  
  
  Or if you want to instantiate each plugin rather than just return the name
  
      package MyClass;
      use Module::Pluggable instantiate => 'new';
  
  and then
  
      # whatever is passed to 'plugins' will be passed
      # to 'new' for each plugin
      my @plugins = $mc->plugins(@options);
  
  
  alternatively you can just require the module without instantiating it
  
      package MyClass;
      use Module::Pluggable require => 1;
  
  since requiring automatically searches inner packages, which may not be desirable, you can turn this off
  
  
      package MyClass;
      use Module::Pluggable require => 1, inner => 0;
  
  
  You can limit the plugins loaded using the except option, either as a string,
  array ref or regex
  
      package MyClass;
      use Module::Pluggable except => 'MyClass::Plugin::Foo';
  
  or
  
      package MyClass;
      use Module::Pluggable except => ['MyClass::Plugin::Foo', 'MyClass::Plugin::Bar'];
  
  or
  
      package MyClass;
      use Module::Pluggable except => qr/^MyClass::Plugin::(Foo|Bar)$/;
  
  
  and similarly for only which will only load plugins which match.
  
  Remember you can use the module more than once
  
      package MyClass;
      use Module::Pluggable search_path => 'MyClass::Filters' sub_name => 'filters';
      use Module::Pluggable search_path => 'MyClass::Plugins' sub_name => 'plugins';
  
  and then later ...
  
      my @filters = $self->filters;
      my @plugins = $self->plugins;
  
  =head1 PLUGIN SEARCHING
  
  Every time you call 'plugins' the whole search path is walked again. This allows
  for dynamically loading plugins even at run time. However this can get expensive
  and so if you don't expect to want to add new plugins at run time you could do
  
  
    package Foo;
    use strict;
    use Module::Pluggable sub_name => '_plugins';
  
    our @PLUGINS;
    sub plugins { @PLUGINS ||= shift->_plugins }
    1;
  
  =head1 INNER PACKAGES
  
  If you have, for example, a file B<lib/Something/Plugin/Foo.pm> that
  contains package definitions for both C<Something::Plugin::Foo> and
  C<Something::Plugin::Bar> then as long as you either have either
  the B<require> or B<instantiate> option set then we'll also find
  C<Something::Plugin::Bar>. Nifty!
  
  =head1 OPTIONS
  
  You can pass a hash of options when importing this module.
  
  The options can be ...
  
  =head2 sub_name
  
  The name of the subroutine to create in your namespace.
  
  By default this is 'plugins'
  
  =head2 search_path
  
  An array ref of namespaces to look in.
  
  =head2 search_dirs
  
  An array ref of directories to look in before @INC.
  
  =head2 instantiate
  
  Call this method on the class. In general this will probably be 'new'
  but it can be whatever you want. Whatever arguments are passed to 'plugins'
  will be passed to the method.
  
  The default is 'undef' i.e just return the class name.
  
  =head2 require
  
  Just require the class, don't instantiate (overrides 'instantiate');
  
  =head2 inner
  
  If set to 0 will B<not> search inner packages.
  If set to 1 will override C<require>.
  
  =head2 only
  
  Takes a string, array ref or regex describing the names of the only plugins to
  return. Whilst this may seem perverse ... well, it is. But it also
  makes sense. Trust me.
  
  =head2 except
  
  Similar to C<only> it takes a description of plugins to exclude
  from returning. This is slightly less perverse.
  
  =head2 package
  
  This is for use by extension modules which build on C<Module::Pluggable>:
  passing a C<package> option allows you to place the plugin method in a
  different package other than your own.
  
  =head2 file_regex
  
  By default C<Module::Pluggable> only looks for I<.pm> files.
  
  By supplying a new C<file_regex> then you can change this behaviour e.g
  
      file_regex => qr/\.plugin$/
  
  =head2 include_editor_junk
  
  By default C<Module::Pluggable> ignores files that look like they were
  left behind by editors. Currently this means files ending in F<~> (~),
  the extensions F<.swp> or F<.swo>, or files beginning with F<.#>.
  
  Setting C<include_editor_junk> changes C<Module::Pluggable> so it does
  not ignore any files it finds.
  
  =head2 follow_symlinks
  
  Whether, when searching directories, to follow symlinks.
  
  Defaults to 1 i.e do follow symlinks.
  
  =head2 min_depth, max_depth
  
  This will allow you to set what 'depth' of plugin will be allowed.
  
  So, for example, C<MyClass::Plugin::Foo> will have a depth of 3 and
  C<MyClass::Plugin::Foo::Bar> will have a depth of 4 so to only get the former
  (i.e C<MyClass::Plugin::Foo>) do
  
          package MyClass;
          use Module::Pluggable max_depth => 3;
  
  and to only get the latter (i.e C<MyClass::Plugin::Foo::Bar>)
  
          package MyClass;
          use Module::Pluggable min_depth => 4;
  
  
  =head1 TRIGGERS
  
  Various triggers can also be passed in to the options.
  
  If any of these triggers return 0 then the plugin will not be returned.
  
  =head2 before_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will not be required either.
  
  =head2 on_require_error <plugin> <err>
  
  Gets called when there's an error on requiring the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_require_error handler is to C<carp> the error and return 0.
  
  =head2 on_instantiate_error <plugin> <err>
  
  Gets called when there's an error on instantiating the plugin.
  
  Gets passed the plugin name and the error.
  
  The default on_instantiate_error handler is to C<carp> the error and return 0.
  
  =head2 after_require <plugin>
  
  Gets passed the plugin name.
  
  If 0 is returned then this plugin will be required but not returned as a plugin.
  
  =head1 METHODs
  
  =head2 search_path
  
  The method C<search_path> is exported into you namespace as well.
  You can call that at any time to change or replace the
  search_path.
  
      $self->search_path( add => "New::Path" ); # add
      $self->search_path( new => "New::Path" ); # replace
  
  =head1 BEHAVIOUR UNDER TEST ENVIRONMENT
  
  In order to make testing reliable we exclude anything not from blib if blib.pm is
  in %INC.
  
  However if the module being tested used another module that itself used C<Module::Pluggable>
  then the second module would fail. This was fixed by checking to see if the caller
  had (^|/)blib/ in their filename.
  
  There's an argument that this is the wrong behaviour and that modules should explicitly
  trigger this behaviour but that particular code has been around for 7 years now and I'm
  reluctant to change the default behaviour.
  
  You can now (as of version 4.1) force Module::Pluggable to look outside blib in a test environment by doing either
  
          require Module::Pluggable;
          $Module::Pluggable::FORCE_SEARCH_ALL_PATHS = 1;
          import Module::Pluggable;
  
  or
  
          use Module::Pluggable force_search_all_paths => 1;
  
  =head1 @INC hooks and App::FatPacker
  
  If a module's @INC has a hook and that hook is an object which has a C<files()> method then we will
  try and require those files too. See C<t/26inc_hook.t> for an example.
  
  This has allowed L<App::FatPacker> (as of version 0.10.0) to provide support for Module::Pluggable.
  
  This should also, theoretically, allow someone to modify PAR to do the same thing.
  
  =head1 Module::Require recommended
  
  Up until version 5.2 L<Module::Pluggable> used a string C<eval> to require plugins.
  
  This has now been changed to optionally use L<Module::Runtime> and it's C<require_module> method when
  available and fall back to using a path based C<require> when not.
  
  It's recommended, but not required, that you install Module::Runtime.
  
  =head1 FUTURE PLANS
  
  This does everything I need and I can't really think of any other
  features I want to add. Famous last words of course (not least
  because we're up to version 5.0 at the time of writing).
  
  However suggestions (and patches) are always welcome.
  
  =head1 DEVELOPMENT
  
  The master repo for this module is at
  
  https://github.com/simonwistow/Module-Pluggable
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<File::Find>, L<File::Basename>, L<Class::Factory::Util>, L<Module::Pluggable::Ordered>
  
  =cut
  
  
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;
  
  use strict;
  use File::Find ();
  use File::Basename;
  use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);
  use Carp qw(croak carp confess);
  use Devel::InnerPackage;
  use vars qw($VERSION $MR);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '5.2';
  
  BEGIN {
      eval {  require Module::Runtime };
      unless ($@) {
          Module::Runtime->import('require_module');
      } else {
          *require_module = sub {
              my $module = shift;
              my $path   = $module . ".pm";
              $path =~ s{::}{/}g;
              require $path;
          };
      }
  }
  
  
  sub new {
      my $class = shift;
      my %opts  = @_;
  
      return bless \%opts, $class;
  
  }
  
  ### Eugggh, this code smells 
  ### This is what happens when you keep adding patches
  ### *sigh*
  
  
  sub plugins {
      my $self = shift;
      my @args = @_;
  
      # override 'require'
      $self->{'require'} = 1 if $self->{'inner'};
  
      my $filename   = $self->{'filename'};
      my $pkg        = $self->{'package'};
  
      # Get the exception params instantiated
      $self->_setup_exceptions;
  
      # automatically turn a scalar search path or namespace into a arrayref
      for (qw(search_path search_dirs)) {
          $self->{$_} = [ $self->{$_} ] if exists $self->{$_} && !ref($self->{$_});
      }
  
      # default search path is '<Module>::<Name>::Plugin'
      $self->{'search_path'} ||= ["${pkg}::Plugin"]; 
  
      # default error handler
      $self->{'on_require_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't require $plugin : $err"; return 0 };
      $self->{'on_instantiate_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't instantiate $plugin: $err"; return 0 };
  
      # default whether to follow symlinks
      $self->{'follow_symlinks'} = 1 unless exists $self->{'follow_symlinks'};
  
      # check to see if we're running under test
      my @SEARCHDIR = exists $INC{"blib.pm"} && defined $filename && $filename =~ m!(^|/)blib/! && !$self->{'force_search_all_paths'} ? grep {/blib/} @INC : @INC;
  
      # add any search_dir params
      unshift @SEARCHDIR, @{$self->{'search_dirs'}} if defined $self->{'search_dirs'};
  
      # set our @INC up to include and prefer our search_dirs if necessary
      my @tmp = @INC;
      unshift @tmp, @{$self->{'search_dirs'} || []};
      local @INC = @tmp if defined $self->{'search_dirs'};
  
      my @plugins = $self->search_directories(@SEARCHDIR);
      push(@plugins, $self->handle_inc_hooks($_, @SEARCHDIR)) for @{$self->{'search_path'}};
      push(@plugins, $self->handle_innerpackages($_)) for @{$self->{'search_path'}};
      
      # return blank unless we've found anything
      return () unless @plugins;
  
      # remove duplicates
      # probably not necessary but hey ho
      my %plugins;
      for(@plugins) {
          next unless $self->_is_legit($_);
          $plugins{$_} = 1;
      }
  
      # are we instantiating or requiring?
      if (defined $self->{'instantiate'}) {
          my $method = $self->{'instantiate'};
          my @objs   = ();
          foreach my $package (sort keys %plugins) {
              next unless $package->can($method);
              my $obj = eval { $package->$method(@_) };
              $self->{'on_instantiate_error'}->($package, $@) if $@;
              push @objs, $obj if $obj;           
          }
          return @objs;
      } else { 
          # no? just return the names
          my @objs= sort keys %plugins;
          return @objs;
      }
  }
  
  sub _setup_exceptions {
      my $self = shift;
  
      my %only;   
      my %except; 
      my $only;
      my $except;
  
      if (defined $self->{'only'}) {
          if (ref($self->{'only'}) eq 'ARRAY') {
              %only   = map { $_ => 1 } @{$self->{'only'}};
          } elsif (ref($self->{'only'}) eq 'Regexp') {
              $only = $self->{'only'}
          } elsif (ref($self->{'only'}) eq '') {
              $only{$self->{'only'}} = 1;
          }
      }
          
  
      if (defined $self->{'except'}) {
          if (ref($self->{'except'}) eq 'ARRAY') {
              %except   = map { $_ => 1 } @{$self->{'except'}};
          } elsif (ref($self->{'except'}) eq 'Regexp') {
              $except = $self->{'except'}
          } elsif (ref($self->{'except'}) eq '') {
              $except{$self->{'except'}} = 1;
          }
      }
      $self->{_exceptions}->{only_hash}   = \%only;
      $self->{_exceptions}->{only}        = $only;
      $self->{_exceptions}->{except_hash} = \%except;
      $self->{_exceptions}->{except}      = $except;
          
  }
  
  sub _is_legit {
      my $self   = shift;
      my $plugin = shift;
      my %only   = %{$self->{_exceptions}->{only_hash}||{}};
      my %except = %{$self->{_exceptions}->{except_hash}||{}};
      my $only   = $self->{_exceptions}->{only};
      my $except = $self->{_exceptions}->{except};
      my $depth  = () = split '::', $plugin, -1;
  
      return 0 if     (keys %only   && !$only{$plugin}     );
      return 0 unless (!defined $only || $plugin =~ m!$only!     );
  
      return 0 if     (keys %except &&  $except{$plugin}   );
      return 0 if     (defined $except &&  $plugin =~ m!$except! );
      
      return 0 if     defined $self->{max_depth} && $depth>$self->{max_depth};
      return 0 if     defined $self->{min_depth} && $depth<$self->{min_depth};
  
      return 1;
  }
  
  sub search_directories {
      my $self      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      # go through our @INC
      foreach my $dir (@SEARCHDIR) {
          push @plugins, $self->search_paths($dir);
      }
      return @plugins;
  }
  
  
  sub search_paths {
      my $self = shift;
      my $dir  = shift;
      my @plugins;
  
      my $file_regex = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # and each directory in our search path
      foreach my $searchpath (@{$self->{'search_path'}}) {
          # create the search directory in a cross platform goodness way
          my $sp = catdir($dir, (split /::/, $searchpath));
  
          # if it doesn't exist or it's not a dir then skip it
          next unless ( -e $sp && -d _ ); # Use the cached stat the second time
  
          my @files = $self->find_files($sp);
  
          # foreach one we've found 
          foreach my $file (@files) {
              # untaint the file; accept .pm only
              next unless ($file) = ($file =~ /(.*$file_regex)$/); 
              # parse the file to get the name
              my ($name, $directory, $suffix) = fileparse($file, $file_regex);
  
              next if (!$self->{include_editor_junk} && $self->_is_editor_junk($name));
  
              $directory = abs2rel($directory, $sp);
  
              # If we have a mixed-case package name, assume case has been preserved
              # correctly.  Otherwise, root through the file to locate the case-preserved
              # version of the package name.
              my @pkg_dirs = ();
              if ( $name eq lc($name) || $name eq uc($name) ) {
                  my $pkg_file = catfile($sp, $directory, "$name$suffix");
                  open PKGFILE, "<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";
                  my $in_pod = 0;
                  while ( my $line = <PKGFILE> ) {
                      $in_pod = 1 if $line =~ m/^=\w/;
                      $in_pod = 0 if $line =~ /^=cut/;
                      next if ($in_pod || $line =~ /^=cut/);  # skip pod text
                      next if $line =~ /^\s*#/;               # and comments
                      if ( $line =~ m/^\s*package\s+(.*::)?($name)\s*;/i ) {
                          @pkg_dirs = split /::/, $1 if defined $1;;
                          $name = $2;
                          last;
                      }
                  }
                  close PKGFILE;
              }
  
              # then create the class name in a cross platform way
              $directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);       # remove volume
              my @dirs = ();
              if ($directory) {
                  ($directory) = ($directory =~ /(.*)/);
                  @dirs = grep(length($_), splitdir($directory)) 
                      unless $directory eq curdir();
                  for my $d (reverse @dirs) {
                      my $pkg_dir = pop @pkg_dirs; 
                      last unless defined $pkg_dir;
                      $d =~ s/\Q$pkg_dir\E/$pkg_dir/i;  # Correct case
                  }
              } else {
                  $directory = "";
              }
              my $plugin = join '::', $searchpath, @dirs, $name;
  
              next unless $plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;
  
              $self->handle_finding_plugin($plugin, \@plugins)
          }
  
          # now add stuff that may have been in package
          # NOTE we should probably use all the stuff we've been given already
          # but then we can't unload it :(
          push @plugins, $self->handle_innerpackages($searchpath);
      } # foreach $searchpath
  
      return @plugins;
  }
  
  sub _is_editor_junk {
      my $self = shift;
      my $name = shift;
  
      # Emacs (and other Unix-y editors) leave temp files ending in a
      # tilde as a backup.
      return 1 if $name =~ /~$/;
      # Emacs makes these files while a buffer is edited but not yet
      # saved.
      return 1 if $name =~ /^\.#/;
      # Vim can leave these files behind if it crashes.
      return 1 if $name =~ /\.sw[po]$/;
  
      return 0;
  }
  
  sub handle_finding_plugin {
      my $self    = shift;
      my $plugin  = shift;
      my $plugins = shift;
      my $no_req  = shift || 0;
      
      return unless $self->_is_legit($plugin);
      unless (defined $self->{'instantiate'} || $self->{'require'}) {
          push @$plugins, $plugin;
          return;
      } 
  
      $self->{before_require}->($plugin) || return if defined $self->{before_require};
      unless ($no_req) {
          my $tmp = $@;
          my $res = eval { require_module($plugin) };
          my $err = $@;
          $@      = $tmp;
          if ($err) {
              if (defined $self->{on_require_error}) {
                  $self->{on_require_error}->($plugin, $err) || return; 
              } else {
                  return;
              }
          }
      }
      $self->{after_require}->($plugin) || return if defined $self->{after_require};
      push @$plugins, $plugin;
  }
  
  sub find_files {
      my $self         = shift;
      my $search_path  = shift;
      my $file_regex   = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # find all the .pm files in it
      # this isn't perfect and won't find multiple plugins per file
      #my $cwd = Cwd::getcwd;
      my @files = ();
      { # for the benefit of perl 5.6.1's Find, localize topic
          local $_;
          File::Find::find( { no_chdir => 1, 
                              follow   => $self->{'follow_symlinks'}, 
                              wanted   => sub { 
                               # Inlined from File::Find::Rule C< name => '*.pm' >
                               return unless $File::Find::name =~ /$file_regex/;
                               (my $path = $File::Find::name) =~ s#^\\./##;
                               push @files, $path;
                             }
                        }, $search_path );
      }
      #chdir $cwd;
      return @files;
  
  }
  
  sub handle_inc_hooks {
      my $self      = shift;
      my $path      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      for my $dir ( @SEARCHDIR ) {
          next unless ref $dir && eval { $dir->can( 'files' ) };
  
          foreach my $plugin ( $dir->files ) {
              $plugin =~ s/\.pm$//;
              $plugin =~ s{/}{::}g;
              next unless $plugin =~ m!^${path}::!;
              $self->handle_finding_plugin( $plugin, \@plugins );
          }
      }
      return @plugins;
  }
  
  sub handle_innerpackages {
      my $self = shift;
      return () if (exists $self->{inner} && !$self->{inner});
  
      my $path = shift;
      my @plugins;
  
      foreach my $plugin (Devel::InnerPackage::list_packages($path)) {
          $self->handle_finding_plugin($plugin, \@plugins, 1);
      }
      return @plugins;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable::Object - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable::Object;
      
      my $finder = Module::Pluggable::Object->new(%opts);
      print "My plugins are: ".join(", ", $finder->plugins)."\n";
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  This object is wrapped by C<Module::Pluggable>. If you want to do something
  odd or add non-general special features you're probably best to wrap this
  and produce your own subclass.
  
  =head1 OPTIONS
  
  See the C<Module::Pluggable> docs.
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<Module::Pluggable>
  
  =cut 
  
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
      use Module::Runtime qw(
  	$module_name_rx is_module_name check_module_name
  	module_notional_filename require_module);
  
      if($module_name =~ /\A$module_name_rx\z/o) { ...
      if(is_module_name($module_name)) { ...
      check_module_name($module_name);
  
      $notional_filename = module_notional_filename($module_name);
      require_module($module_name);
  
      use Module::Runtime qw(use_module use_package_optimistically);
  
      $bi = use_module("Math::BigInt", 1.31)->new("1_234");
      $widget = use_package_optimistically("Local::Widget")->new;
  
      use Module::Runtime qw(
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec check_module_spec
  	compose_module_name);
  
      if($spec =~ /\A$top_module_spec_rx\z/o) { ...
      if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
      if(is_module_spec("Standard::Prefix", $spec)) { ...
      check_module_spec("Standard::Prefix", $spec);
  
      $module_name = compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.016";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  I<Warning:> this optional module loading is liable to cause unreliable
  behaviour, including security problems.  It interacts especially badly
  with having C<.> in C<@INC>, which was the default state of affairs in
  Perls prior to 5.25.11.  If a package is actually defined by some means
  other than a module, then applying this function to it causes a spurious
  attempt to load a module that is expected to be non-existent.  If a
  module actually exists under that name then it will be unintentionally
  loaded.  If C<.> is in C<@INC> and this code is ever run with the current
  directory being one writable by a malicious user (such as F</tmp>), then
  the malicious user can easily cause the victim to run arbitrary code, by
  creating a module file under the predictable spuriously-loaded name in the
  writable directory.  Generally, optional module loading should be avoided.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014, 2017
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"if.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IF';
  package if;
  
  $VERSION = '0.0608';
  
  sub work {
    my $method = shift() ? 'import' : 'unimport';
    unless (@_ >= 2) {
      my $type = ($method eq 'import') ? 'use' : 'no';
      die "Too few arguments to '$type if' (some code returning an empty list in list context?)"
    }
    return unless shift;		# CONDITION
  
    my $p = $_[0];		# PACKAGE
    (my $file = "$p.pm") =~ s!::!/!g;
    require $file;		# Works even if $_[0] is a keyword (like open)
    my $m = $p->can($method);
    goto &$m if $m;
  }
  
  sub import   { shift; unshift @_, 1; goto &work }
  sub unimport { shift; unshift @_, 0; goto &work }
  
  1;
  __END__
  
  =head1 NAME
  
  if - C<use> a Perl module if a condition holds
  
  =head1 SYNOPSIS
  
      use if CONDITION, "MODULE", ARGUMENTS;
      no  if CONDITION, "MODULE", ARGUMENTS;
  
  =head1 DESCRIPTION
  
  =head2 C<use if>
  
  The C<if> module is used to conditionally load another module.  The construct:
  
      use if CONDITION, "MODULE", ARGUMENTS;
  
  ... will load C<MODULE> only if C<CONDITION> evaluates to true; it has no
  effect if C<CONDITION> evaluates to false.  (The module name, assuming it
  contains at least one C<::>, must be quoted when C<'use strict "subs";'> is in
  effect.)  If the CONDITION does evaluate to true, then the above line has the
  same effect as:
  
      use MODULE ARGUMENTS;
  
  For example, the F<Unicode::UCD> module's F<charinfo> function will use two functions from F<Unicode::Normalize> only if a certain condition is met:
  
      use if defined &DynaLoader::boot_DynaLoader,
          "Unicode::Normalize" => qw(getCombinClass NFD);
  
  Suppose you wanted C<ARGUMENTS> to be an empty list, I<i.e.>, to have the
  effect of:
  
      use MODULE ();
  
  You can't do this with the C<if> pragma; however, you can achieve
  exactly this effect, at compile time, with:
  
      BEGIN { require MODULE if CONDITION }
  
  =head2 C<no if>
  
  The C<no if> construct is mainly used to deactivate categories of warnings
  when those categories would produce superfluous output under specified
  versions of F<perl>.
  
  For example, the C<redundant> category of warnings was introduced in
  Perl-5.22.  This warning flags certain instances of superfluous arguments to
  C<printf> and C<sprintf>.  But if your code was running warnings-free on
  earlier versions of F<perl> and you don't care about C<redundant> warnings in
  more recent versions, you can call:
  
      use warnings;
      no if $] >= 5.022, q|warnings|, qw(redundant);
  
      my $test    = { fmt  => "%s", args => [ qw( x y ) ] };
      my $result  = sprintf $test->{fmt}, @{$test->{args}};
  
  The C<no if> construct assumes that a module or pragma has correctly
  implemented an C<unimport()> method -- but most modules and pragmata have not.
  That explains why the C<no if> construct is of limited applicability.
  
  =head1 BUGS
  
  The current implementation does not allow specification of the required
  version of the module.
  
  =head1 SEE ALSO
  
  L<Module::Requires> can be used to conditionally load one or modules,
  with constraints based on the version of the module.
  Unlike C<if> though, L<Module::Requires> is not a core module.
  
  L<Module::Load::Conditional> provides a number of functions you can use to
  query what modules are available, and then load one or more of them at runtime.
  
  The L<provide> module from CPAN can be used to select one of several possible
  modules to load based on the version of Perl that is running.
  
  =head1 AUTHOR
  
  Ilya Zakharevich L<mailto:ilyaz@cpan.org>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2002 by Ilya Zakharevich.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
IF

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  
  our $VERSION = '0.237';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_; # dies if a loop is detected
      };
  };
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafal Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-2017 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"x86_64-linux/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CWD';
  package Cwd;
  use strict;
  use Exporter;
  
  
  our $VERSION = '3.75';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  our @ISA = qw/ Exporter /;
  our @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  our @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__};
                     local @INC = @INC;
                     pop @INC if $INC[-1] eq '.';
                     require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) { # skipped on miniperl
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      if( $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	return undef;
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    return undef;
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    my $e = $!;
  	    closedir(PARENT);
  	    $! = $e;
  	    return undef;
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    closedir(PARENT);
  		    require Errno;
  		    $! = Errno::ENOENT();
  		    return undef;
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      defined $cwd or return undef;
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
  	require Errno;
  	$! = Errno::ENOENT();
  	return undef;
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    defined $link_target or return undef;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
  	return undef;
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.  On error returns C<undef>,
  with C<$!> set to indicate the error.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).  On error returns C<undef>, with C<$!>
  set to indicate the error.
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
X86_64-LINUX_CWD

$fatpacked{"x86_64-linux/Encode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE';
  #
  # $Id: Encode.pm,v 3.01 2019/03/13 00:25:25 dankogai Exp $
  #
  package Encode;
  use strict;
  use warnings;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  our $VERSION;
  BEGIN {
      $VERSION = sprintf "%d.%02d", q$Revision: 3.01 $ =~ /(\d+)/g;
      require XSLoader;
      XSLoader::load( __PACKAGE__, $VERSION );
  }
  
  use Exporter 5.57 'import';
  
  use Carp ();
  our @CARP_NOT = qw(Encode::Encoder);
  
  # Public, encouraged API is exported by default
  
  our @EXPORT = qw(
    decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
    encodings  find_encoding find_mime_encoding clone_encoding
  );
  our @FB_FLAGS = qw(
    DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
    PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
  );
  our @FB_CONSTS = qw(
    FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
    FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  );
  our @EXPORT_OK = (
      qw(
        _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
        is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
        ),
      @FB_FLAGS, @FB_CONSTS,
  );
  
  our %EXPORT_TAGS = (
      all          => [ @EXPORT,    @EXPORT_OK ],
      default      => [ @EXPORT ],
      fallbacks    => [ @FB_CONSTS ],
      fallback_all => [ @FB_CONSTS, @FB_FLAGS ],
  );
  
  # Documentation moved after __END__ for speed - NI-S
  
  our $ON_EBCDIC = ( ord("A") == 193 );
  
  use Encode::Alias ();
  use Encode::MIME::Name;
  
  use Storable;
  
  # Make a %Encoding package variable to allow a certain amount of cheating
  our %Encoding;
  our %ExtModule;
  require Encode::Config;
  #  See
  #  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
  #  to find why sig handlers inside eval{} are disabled.
  eval {
      local $SIG{__DIE__};
      local $SIG{__WARN__};
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Encode::ConfigLocal;
  };
  
  sub encodings {
      my %enc;
      my $arg  = $_[1] || '';
      if ( $arg eq ":all" ) {
          %enc = ( %Encoding, %ExtModule );
      }
      else {
          %enc = %Encoding;
          for my $mod ( map { m/::/ ? $_ : "Encode::$_" } @_ ) {
              DEBUG and warn $mod;
              for my $enc ( keys %ExtModule ) {
                  $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
              }
          }
      }
      return sort { lc $a cmp lc $b }
        grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
  }
  
  sub perlio_ok {
      my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
      $obj->can("perlio_ok") and return $obj->perlio_ok();
      return 0;    # safety net
  }
  
  sub define_encoding {
      my $obj  = shift;
      my $name = shift;
      $Encoding{$name} = $obj;
      my $lc = lc($name);
      define_alias( $lc => $obj ) unless $lc eq $name;
      while (@_) {
          my $alias = shift;
          define_alias( $alias, $obj );
      }
      my $class = ref($obj);
      push @Encode::CARP_NOT, $class unless grep { $_ eq $class } @Encode::CARP_NOT;
      push @Encode::Encoding::CARP_NOT, $class unless grep { $_ eq $class } @Encode::Encoding::CARP_NOT;
      return $obj;
  }
  
  sub getEncoding {
      my ( $class, $name, $skip_external ) = @_;
  
      defined($name) or return;
  
      $name =~ s/\s+//g; # https://rt.cpan.org/Ticket/Display.html?id=65796
  
      ref($name) && $name->can('renew') and return $name;
      exists $Encoding{$name} and return $Encoding{$name};
      my $lc = lc $name;
      exists $Encoding{$lc} and return $Encoding{$lc};
  
      my $oc = $class->find_alias($name);
      defined($oc) and return $oc;
      $lc ne $name and $oc = $class->find_alias($lc);
      defined($oc) and return $oc;
  
      unless ($skip_external) {
          if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
              $mod =~ s,::,/,g;
              $mod .= '.pm';
              eval { require $mod; };
              exists $Encoding{$name} and return $Encoding{$name};
          }
      }
      return;
  }
  
  # HACK: These two functions must be defined in Encode and because of
  # cyclic dependency between Encode and Encode::Alias, Exporter does not work
  sub find_alias {
      goto &Encode::Alias::find_alias;
  }
  sub define_alias {
      goto &Encode::Alias::define_alias;
  }
  
  sub find_encoding($;$) {
      my ( $name, $skip_external ) = @_;
      return __PACKAGE__->getEncoding( $name, $skip_external );
  }
  
  sub find_mime_encoding($;$) {
      my ( $mime_name, $skip_external ) = @_;
      my $name = Encode::MIME::Name::get_encode_name( $mime_name );
      return find_encoding( $name, $skip_external );
  }
  
  sub resolve_alias($) {
      my $obj = find_encoding(shift);
      defined $obj and return $obj->name;
      return;
  }
  
  sub clone_encoding($) {
      my $obj = find_encoding(shift);
      ref $obj or return;
      return Storable::dclone($obj);
  }
  
  onBOOT;
  
  if ($ON_EBCDIC) {
      package Encode::UTF_EBCDIC;
      use parent 'Encode::Encoding';
      my $obj = bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
      Encode::define_encoding($obj, 'Unicode');
      sub decode {
          my ( undef, $str, $chk ) = @_;
          my $res = '';
          for ( my $i = 0 ; $i < length($str) ; $i++ ) {
              $res .=
                chr(
                  utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
                );
          }
          $_[1] = '' if $chk;
          return $res;
      }
      sub encode {
          my ( undef, $str, $chk ) = @_;
          my $res = '';
          for ( my $i = 0 ; $i < length($str) ; $i++ ) {
              $res .=
                chr(
                  utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
                );
          }
          $_[1] = '' if $chk;
          return $res;
      }
  } else {
      package Encode::Internal;
      use parent 'Encode::Encoding';
      my $obj = bless { Name => "Internal" } => "Encode::Internal";
      Encode::define_encoding($obj, 'Unicode');
      sub decode {
          my ( undef, $str, $chk ) = @_;
          utf8::upgrade($str);
          $_[1] = '' if $chk;
          return $str;
      }
      *encode = \&decode;
  }
  
  {
      # https://rt.cpan.org/Public/Bug/Display.html?id=103253
      package Encode::XS;
      use parent 'Encode::Encoding';
  }
  
  {
      package Encode::utf8;
      use parent 'Encode::Encoding';
      my %obj = (
          'utf8'         => { Name => 'utf8' },
          'utf-8-strict' => { Name => 'utf-8-strict', strict_utf8 => 1 }
      );
      for ( keys %obj ) {
          bless $obj{$_} => __PACKAGE__;
          Encode::define_encoding( $obj{$_} => $_ );
      }
      sub cat_decode {
          # ($obj, $dst, $src, $pos, $trm, $chk)
          # currently ignores $chk
          my ( undef, undef, undef, $pos, $trm ) = @_;
          my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
          use bytes;
          if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
              $$rdst .=
                substr( $$rsrc, $pos, $npos - $pos + length($trm) );
              $$rpos = $npos + length($trm);
              return 1;
          }
          $$rdst .= substr( $$rsrc, $pos );
          $$rpos = length($$rsrc);
          return '';
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode - character encodings in Perl
  
  =head1 SYNOPSIS
  
      use Encode qw(decode encode);
      $characters = decode('UTF-8', $octets,     Encode::FB_CROAK);
      $octets     = encode('UTF-8', $characters, Encode::FB_CROAK);
  
  =head2 Table of Contents
  
  Encode consists of a collection of modules whose details are too extensive
  to fit in one document.  This one itself explains the top-level APIs
  and general topics at a glance.  For other topics and more details,
  see the documentation for these modules:
  
  =over 2
  
  =item L<Encode::Alias> - Alias definitions to encodings
  
  =item L<Encode::Encoding> - Encode Implementation Base Class
  
  =item L<Encode::Supported> - List of Supported Encodings
  
  =item L<Encode::CN> - Simplified Chinese Encodings
  
  =item L<Encode::JP> - Japanese Encodings
  
  =item L<Encode::KR> - Korean Encodings
  
  =item L<Encode::TW> - Traditional Chinese Encodings
  
  =back
  
  =head1 DESCRIPTION
  
  The C<Encode> module provides the interface between Perl strings
  and the rest of the system.  Perl strings are sequences of
  I<characters>.
  
  The repertoire of characters that Perl can represent is a superset of those
  defined by the Unicode Consortium. On most platforms the ordinal
  values of a character as returned by C<ord(I<S>)> is the I<Unicode
  codepoint> for that character. The exceptions are platforms where
  the legacy encoding is some variant of EBCDIC rather than a superset
  of ASCII; see L<perlebcdic>.
  
  During recent history, data is moved around a computer in 8-bit chunks,
  often called "bytes" but also known as "octets" in standards documents.
  Perl is widely used to manipulate data of many types: not only strings of
  characters representing human or computer languages, but also "binary"
  data, being the machine's representation of numbers, pixels in an image, or
  just about anything.
  
  When Perl is processing "binary data", the programmer wants Perl to
  process "sequences of bytes". This is not a problem for Perl: because a
  byte has 256 possible values, it easily fits in Perl's much larger
  "logical character".
  
  This document mostly explains the I<how>. L<perlunitut> and L<perlunifaq>
  explain the I<why>.
  
  =head2 TERMINOLOGY
  
  =head3 character
  
  A character in the range 0 .. 2**32-1 (or more);
  what Perl's strings are made of.
  
  =head3 byte
  
  A character in the range 0..255;
  a special case of a Perl character.
  
  =head3 octet
  
  8 bits of data, with ordinal values 0..255;
  term for bytes passed to or from a non-Perl context, such as a disk file,
  standard I/O stream, database, command-line argument, environment variable,
  socket etc.
  
  =head1 THE PERL ENCODING API
  
  =head2 Basic methods
  
  =head3 encode
  
    $octets  = encode(ENCODING, STRING[, CHECK])
  
  Encodes the scalar value I<STRING> from Perl's internal form into
  I<ENCODING> and returns a sequence of octets.  I<ENCODING> can be either a
  canonical name or an alias.  For encoding names and aliases, see
  L</"Defining Aliases">.  For CHECK, see L</"Handling Malformed Data">.
  
  B<CAVEAT>: the input scalar I<STRING> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert a string from Perl's internal format into
  ISO-8859-1, also known as Latin1:
  
    $octets = encode("iso-8859-1", $string);
  
  B<CAVEAT>: When you run C<$octets = encode("UTF-8", $string)>, then
  $octets I<might not be equal to> $string.  Though both contain the
  same data, the UTF8 flag for $octets is I<always> off.  When you
  encode anything, the UTF8 flag on the result is always off, even when it
  contains a completely valid UTF-8 string. See L</"The UTF8 flag"> below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  C<str2bytes> may be used as an alias for C<encode>.
  
  =head3 decode
  
    $string = decode(ENCODING, OCTETS[, CHECK])
  
  This function returns the string that results from decoding the scalar
  value I<OCTETS>, assumed to be a sequence of octets in I<ENCODING>, into
  Perl's internal form.  As with encode(),
  I<ENCODING> can be either a canonical name or an alias. For encoding names
  and aliases, see L</"Defining Aliases">; for I<CHECK>, see L</"Handling
  Malformed Data">.
  
  B<CAVEAT>: the input scalar I<OCTETS> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert ISO-8859-1 data into a string in Perl's
  internal format:
  
    $string = decode("iso-8859-1", $octets);
  
  B<CAVEAT>: When you run C<$string = decode("UTF-8", $octets)>, then $string
  I<might not be equal to> $octets.  Though both contain the same data, the
  UTF8 flag for $string is on.  See L</"The UTF8 flag">
  below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  C<bytes2str> may be used as an alias for C<decode>.
  
  =head3 find_encoding
  
    [$obj =] find_encoding(ENCODING)
  
  Returns the I<encoding object> corresponding to I<ENCODING>.  Returns
  C<undef> if no matching I<ENCODING> is find.  The returned object is
  what does the actual encoding or decoding.
  
    $string = decode($name, $bytes);
  
  is in fact
  
      $string = do {
          $obj = find_encoding($name);
          croak qq(encoding "$name" not found) unless ref $obj;
          $obj->decode($bytes);
      };
  
  with more error checking.
  
  You can therefore save time by reusing this object as follows;
  
      my $enc = find_encoding("iso-8859-1");
      while(<>) {
          my $string = $enc->decode($_);
          ... # now do something with $string;
      }
  
  Besides L</decode> and L</encode>, other methods are
  available as well.  For instance, C<name()> returns the canonical
  name of the encoding object.
  
    find_encoding("latin1")->name; # iso-8859-1
  
  See L<Encode::Encoding> for details.
  
  =head3 find_mime_encoding
  
    [$obj =] find_mime_encoding(MIME_ENCODING)
  
  Returns the I<encoding object> corresponding to I<MIME_ENCODING>.  Acts
  same as C<find_encoding()> but C<mime_name()> of returned object must
  match to I<MIME_ENCODING>.  So as opposite of C<find_encoding()>
  canonical names and aliases are not used when searching for object.
  
      find_mime_encoding("utf8"); # returns undef because "utf8" is not valid I<MIME_ENCODING>
      find_mime_encoding("utf-8"); # returns encode object "utf-8-strict"
      find_mime_encoding("UTF-8"); # same as "utf-8" because I<MIME_ENCODING> is case insensitive
      find_mime_encoding("utf-8-strict"); returns undef because "utf-8-strict" is not valid I<MIME_ENCODING>
  
  =head3 from_to
  
    [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
  
  Converts I<in-place> data between two encodings. The data in $octets
  must be encoded as octets and I<not> as characters in Perl's internal
  format. For example, to convert ISO-8859-1 data into Microsoft's CP1250
  encoding:
  
    from_to($octets, "iso-8859-1", "cp1250");
  
  and to convert it back:
  
    from_to($octets, "cp1250", "iso-8859-1");
  
  Because the conversion happens in place, the data to be
  converted cannot be a string constant: it must be a scalar variable.
  
  C<from_to()> returns the length of the converted string in octets on success,
  and C<undef> on error.
  
  B<CAVEAT>: The following operations may look the same, but are not:
  
    from_to($data, "iso-8859-1", "UTF-8"); #1
    $data = decode("iso-8859-1", $data);  #2
  
  Both #1 and #2 make $data consist of a completely valid UTF-8 string,
  but only #2 turns the UTF8 flag on.  #1 is equivalent to:
  
    $data = encode("UTF-8", decode("iso-8859-1", $data));
  
  See L</"The UTF8 flag"> below.
  
  Also note that:
  
    from_to($octets, $from, $to, $check);
  
  is equivalent to:
  
    $octets = encode($to, decode($from, $octets), $check);
  
  Yes, it does I<not> respect the $check during decoding.  It is
  deliberately done that way.  If you need minute control, use C<decode>
  followed by C<encode> as follows:
  
    $octets = encode($to, decode($from, $octets, $check_from), $check_to);
  
  =head3 encode_utf8
  
    $octets = encode_utf8($string);
  
  Equivalent to C<$octets = encode("utf8", $string)>.  The characters in
  $string are encoded in Perl's internal format, and the result is returned
  as a sequence of octets.  Because all possible characters in Perl have a
  (loose, not strict) utf8 representation, this function cannot fail.
  
  B<WARNING>: do not use this function for data exchange as it can produce
  not strict utf8 $octets! For strictly valid UTF-8 output use
  C<$octets = encode("UTF-8", $string)>.
  
  =head3 decode_utf8
  
    $string = decode_utf8($octets [, CHECK]);
  
  Equivalent to C<$string = decode("utf8", $octets [, CHECK])>.
  The sequence of octets represented by $octets is decoded
  from (loose, not strict) utf8 into a sequence of logical characters.
  Because not all sequences of octets are valid not strict utf8,
  it is quite possible for this function to fail.
  For CHECK, see L</"Handling Malformed Data">.
  
  B<WARNING>: do not use this function for data exchange as it can produce
  $string with not strict utf8 representation! For strictly valid UTF-8
  $string representation use C<$string = decode("UTF-8", $octets [, CHECK])>.
  
  B<CAVEAT>: the input I<$octets> might be modified in-place depending on
  what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  =head2 Listing available encodings
  
    use Encode;
    @list = Encode->encodings();
  
  Returns a list of canonical names of available encodings that have already
  been loaded.  To get a list of all available encodings including those that
  have not yet been loaded, say:
  
    @all_encodings = Encode->encodings(":all");
  
  Or you can give the name of a specific module:
  
    @with_jp = Encode->encodings("Encode::JP");
  
  When "C<::>" is not in the name, "C<Encode::>" is assumed.
  
    @ebcdic = Encode->encodings("EBCDIC");
  
  To find out in detail which encodings are supported by this package,
  see L<Encode::Supported>.
  
  =head2 Defining Aliases
  
  To add a new alias to a given encoding, use:
  
    use Encode;
    use Encode::Alias;
    define_alias(NEWNAME => ENCODING);
  
  After that, I<NEWNAME> can be used as an alias for I<ENCODING>.
  I<ENCODING> may be either the name of an encoding or an
  I<encoding object>.
  
  Before you do that, first make sure the alias is nonexistent using
  C<resolve_alias()>, which returns the canonical name thereof.
  For example:
  
    Encode::resolve_alias("latin1") eq "iso-8859-1" # true
    Encode::resolve_alias("iso-8859-12")   # false; nonexistent
    Encode::resolve_alias($name) eq $name  # true if $name is canonical
  
  C<resolve_alias()> does not need C<use Encode::Alias>; it can be
  imported via C<use Encode qw(resolve_alias)>.
  
  See L<Encode::Alias> for details.
  
  =head2 Finding IANA Character Set Registry names
  
  The canonical name of a given encoding does not necessarily agree with
  IANA Character Set Registry, commonly seen as C<< Content-Type:
  text/plain; charset=I<WHATEVER> >>.  For most cases, the canonical name
  works, but sometimes it does not, most notably with "utf-8-strict".
  
  As of C<Encode> version 2.21, a new method C<mime_name()> is therefore added.
  
    use Encode;
    my $enc = find_encoding("UTF-8");
    warn $enc->name;      # utf-8-strict
    warn $enc->mime_name; # UTF-8
  
  See also:  L<Encode::Encoding>
  
  =head1 Encoding via PerlIO
  
  If your perl supports C<PerlIO> (which is the default), you can use a
  C<PerlIO> layer to decode and encode directly via a filehandle.  The
  following two examples are fully identical in functionality:
  
    ### Version 1 via PerlIO
      open(INPUT,  "< :encoding(shiftjis)", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :encoding(euc-jp)",  $outfile)
          || die "Can't open > $output for writing: $!";
      while (<INPUT>) {   # auto decodes $_
          print OUTPUT;   # auto encodes $_
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
    ### Version 2 via from_to()
      open(INPUT,  "< :raw", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :raw",  $outfile)
          || die "Can't open > $output for writing: $!";
  
      while (<INPUT>) {
          from_to($_, "shiftjis", "euc-jp", 1);  # switch encoding
          print OUTPUT;   # emit raw (but properly encoded) data
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
  In the first version above, you let the appropriate encoding layer
  handle the conversion.  In the second, you explicitly translate
  from one encoding to the other.
  
  Unfortunately, it may be that encodings are not C<PerlIO>-savvy.  You can check
  to see whether your encoding is supported by C<PerlIO> by invoking the
  C<perlio_ok> method on it:
  
    Encode::perlio_ok("hz");             # false
    find_encoding("euc-cn")->perlio_ok;  # true wherever PerlIO is available
  
    use Encode qw(perlio_ok);            # imported upon request
    perlio_ok("euc-jp")
  
  Fortunately, all encodings that come with C<Encode> core are C<PerlIO>-savvy
  except for C<hz> and C<ISO-2022-kr>.  For the gory details, see
  L<Encode::Encoding> and L<Encode::PerlIO>.
  
  =head1 Handling Malformed Data
  
  The optional I<CHECK> argument tells C<Encode> what to do when
  encountering malformed data.  Without I<CHECK>, C<Encode::FB_DEFAULT>
  (== 0) is assumed.
  
  As of version 2.12, C<Encode> supports coderef values for C<CHECK>;
  see below.
  
  B<NOTE:> Not all encodings support this feature.
  Some encodings ignore the I<CHECK> argument.  For example,
  L<Encode::Unicode> ignores I<CHECK> and it always croaks on error.
  
  =head2 List of I<CHECK> values
  
  =head3 FB_DEFAULT
  
    I<CHECK> = Encode::FB_DEFAULT ( == 0)
  
  If I<CHECK> is 0, encoding and decoding replace any malformed character
  with a I<substitution character>.  When you encode, I<SUBCHAR> is used.
  When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is
  used.  If the data is supposed to be UTF-8, an optional lexical warning of
  warning category C<"utf8"> is given.
  
  =head3 FB_CROAK
  
    I<CHECK> = Encode::FB_CROAK ( == 1)
  
  If I<CHECK> is 1, methods immediately die with an error
  message.  Therefore, when I<CHECK> is 1, you should trap
  exceptions with C<eval{}>, unless you really want to let it C<die>.
  
  =head3 FB_QUIET
  
    I<CHECK> = Encode::FB_QUIET
  
  If I<CHECK> is set to C<Encode::FB_QUIET>, encoding and decoding immediately
  return the portion of the data that has been processed so far when an
  error occurs. The data argument is overwritten with everything
  after that point; that is, the unprocessed portion of the data.  This is
  handy when you have to call C<decode> repeatedly in the case where your
  source data may contain partial multi-byte character sequences,
  (that is, you are reading with a fixed-width buffer). Here's some sample
  code to do exactly that:
  
      my($buffer, $string) = ("", "");
      while (read($fh, $buffer, 256, length($buffer))) {
          $string .= decode($encoding, $buffer, Encode::FB_QUIET);
          # $buffer now contains the unprocessed partial character
      }
  
  =head3 FB_WARN
  
    I<CHECK> = Encode::FB_WARN
  
  This is the same as C<FB_QUIET> above, except that instead of being silent
  on errors, it issues a warning.  This is handy for when you are debugging.
  
  B<CAVEAT>: All warnings from Encode module are reported, independently of
  L<pragma warnings|warnings> settings. If you want to follow settings of
  lexical warnings configured by L<pragma warnings|warnings> then append
  also check value C<ENCODE::ONLY_PRAGMA_WARNINGS>. This value is available
  since Encode version 2.99.
  
  =head3 FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  
  =over 2
  
  =item perlqq mode (I<CHECK> = Encode::FB_PERLQQ)
  
  =item HTML charref mode (I<CHECK> = Encode::FB_HTMLCREF)
  
  =item XML charref mode (I<CHECK> = Encode::FB_XMLCREF)
  
  =back
  
  For encodings that are implemented by the C<Encode::XS> module, C<CHECK> C<==>
  C<Encode::FB_PERLQQ> puts C<encode> and C<decode> into C<perlqq> fallback mode.
  
  When you decode, C<\xI<HH>> is inserted for a malformed character, where
  I<HH> is the hex representation of the octet that could not be decoded to
  utf8.  When you encode, C<\x{I<HHHH>}> will be inserted, where I<HHHH> is
  the Unicode code point (in any number of hex digits) of the character that
  cannot be found in the character repertoire of the encoding.
  
  The HTML/XML character reference modes are about the same. In place of
  C<\x{I<HHHH>}>, HTML uses C<&#I<NNN>;> where I<NNN> is a decimal number, and
  XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal number.
  
  In C<Encode> 2.10 or later, C<LEAVE_SRC> is also implied.
  
  =head3 The bitmask
  
  These modes are all actually set via a bitmask.  Here is how the C<FB_I<XXX>>
  constants are laid out.  You can import the C<FB_I<XXX>> constants via
  C<use Encode qw(:fallbacks)>, and you can import the generic bitmask
  constants via C<use Encode qw(:fallback_all)>.
  
                       FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
   DIE_ON_ERR    0x0001             X
   WARN_ON_ERR   0x0002                               X
   RETURN_ON_ERR 0x0004                      X        X
   LEAVE_SRC     0x0008                                        X
   PERLQQ        0x0100                                        X
   HTMLCREF      0x0200
   XMLCREF       0x0400
  
  =head3 LEAVE_SRC
  
    Encode::LEAVE_SRC
  
  If the C<Encode::LEAVE_SRC> bit is I<not> set but I<CHECK> is set, then the
  source string to encode() or decode() will be overwritten in place.
  If you're not interested in this, then bitwise-OR it with the bitmask.
  
  =head2 coderef for CHECK
  
  As of C<Encode> 2.12, C<CHECK> can also be a code reference which takes the
  ordinal value of the unmapped character as an argument and returns
  octets that represent the fallback character.  For instance:
  
    $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
  
  Acts like C<FB_PERLQQ> but U+I<XXXX> is used instead of C<\x{I<XXXX>}>.
  
  Fallback for C<decode> must return decoded string (sequence of characters)
  and takes a list of ordinal values as its arguments. So for
  example if you wish to decode octets as UTF-8, and use ISO-8859-15 as
  a fallback for bytes that are not valid UTF-8, you could write
  
      $str = decode 'UTF-8', $octets, sub {
          my $tmp = join '', map chr, @_;
          return decode 'ISO-8859-15', $tmp;
      };
  
  =head1 Defining Encodings
  
  To define a new encoding, use:
  
      use Encode qw(define_encoding);
      define_encoding($object, CANONICAL_NAME [, alias...]);
  
  I<CANONICAL_NAME> will be associated with I<$object>.  The object
  should provide the interface described in L<Encode::Encoding>.
  If more than two arguments are provided, additional
  arguments are considered aliases for I<$object>.
  
  See L<Encode::Encoding> for details.
  
  =head1 The UTF8 flag
  
  Before the introduction of Unicode support in Perl, The C<eq> operator
  just compared the strings represented by two scalars. Beginning with
  Perl 5.8, C<eq> compares two strings with simultaneous consideration of
  I<the UTF8 flag>. To explain why we made it so, I quote from page 402 of
  I<Programming Perl, 3rd ed.>
  
  =over 2
  
  =item Goal #1:
  
  Old byte-oriented programs should not spontaneously break on the old
  byte-oriented data they used to work on.
  
  =item Goal #2:
  
  Old byte-oriented programs should magically start working on the new
  character-oriented data when appropriate.
  
  =item Goal #3:
  
  Programs should run just as fast in the new character-oriented mode
  as in the old byte-oriented mode.
  
  =item Goal #4:
  
  Perl should remain one language, rather than forking into a
  byte-oriented Perl and a character-oriented Perl.
  
  =back
  
  When I<Programming Perl, 3rd ed.> was written, not even Perl 5.6.0 had been
  born yet, many features documented in the book remained unimplemented for a
  long time.  Perl 5.8 corrected much of this, and the introduction of the
  UTF8 flag is one of them.  You can think of there being two fundamentally
  different kinds of strings and string-operations in Perl: one a
  byte-oriented mode  for when the internal UTF8 flag is off, and the other a
  character-oriented mode for when the internal UTF8 flag is on.
  
  This UTF8 flag is not visible in Perl scripts, exactly for the same reason
  you cannot (or rather, you I<don't have to>) see whether a scalar contains
  a string, an integer, or a floating-point number.   But you can still peek
  and poke these if you will.  See the next section.
  
  =head2 Messing with Perl's Internals
  
  The following API uses parts of Perl's internals in the current
  implementation.  As such, they are efficient but may change in a future
  release.
  
  =head3 is_utf8
  
    is_utf8(STRING [, CHECK])
  
  [INTERNAL] Tests whether the UTF8 flag is turned on in the I<STRING>.
  If I<CHECK> is true, also checks whether I<STRING> contains well-formed
  UTF-8.  Returns true if successful, false otherwise.
  
  Typically only necessary for debugging and testing.  Don't use this flag as
  a marker to distinguish character and binary data, that should be decided
  for each variable when you write your code.
  
  B<CAVEAT>: If I<STRING> has UTF8 flag set, it does B<NOT> mean that
  I<STRING> is UTF-8 encoded and vice-versa.
  
  As of Perl 5.8.1, L<utf8> also has the C<utf8::is_utf8> function.
  
  =head3 _utf8_on
  
    _utf8_on(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<on>.  The I<STRING>
  is I<not> checked for containing only well-formed UTF-8.  Do not use this
  unless you I<know with absolute certainty> that the STRING holds only
  well-formed UTF-8.  Returns the previous state of the UTF8 flag (so please
  don't treat the return value as indicating success or failure), or C<undef>
  if I<STRING> is not a string.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head3 _utf8_off
  
    _utf8_off(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<off>.  Do not use
  frivolously.  Returns the previous state of the UTF8 flag, or C<undef> if
  I<STRING> is not a string.  Do not treat the return value as indicative of
  success or failure, because that isn't what it means: it is only the
  previous setting.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head1 UTF-8 vs. utf8 vs. UTF8
  
    ....We now view strings not as sequences of bytes, but as sequences
    of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
    computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.
  
  That has historically been Perl's notion of UTF-8, as that is how UTF-8 was
  first conceived by Ken Thompson when he invented it. However, thanks to
  later revisions to the applicable standards, official UTF-8 is now rather
  stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF
  to cover only 21 bits instead of 32 or 64 bits) and some sequences
  are not allowed, like those used in surrogate pairs, the 31 non-character
  code points 0xFDD0 .. 0xFDEF, the last two code points in I<any> plane
  (0xI<XX>_FFFE and 0xI<XX>_FFFF), all non-shortest encodings, etc.
  
  The former default in which Perl would always use a loose interpretation of
  UTF-8 has now been overruled:
  
    From: Larry Wall <larry@wall.org>
    Date: December 04, 2004 11:51:58 JST
    To: perl-unicode@perl.org
    Subject: Re: Make Encode.pm support the real UTF-8
    Message-Id: <20041204025158.GA28754@wall.org>
  
    On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
    : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
    : but "UTF-8" is the name of the standard and should give the
    : corresponding behaviour.
  
    For what it's worth, that's how I've always kept them straight in my
    head.
  
    Also for what it's worth, Perl 6 will mostly default to strict but
    make it easy to switch back to lax.
  
    Larry
  
  Got that?  As of Perl 5.8.7, B<"UTF-8"> means UTF-8 in its current
  sense, which is conservative and strict and security-conscious, whereas
  B<"utf8"> means UTF-8 in its former sense, which was liberal and loose and
  lax.  C<Encode> version 2.10 or later thus groks this subtle but critically
  important distinction between C<"UTF-8"> and C<"utf8">.
  
    encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
    encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks
  
  In the C<Encode> module, C<"UTF-8"> is actually a canonical name for
  C<"utf-8-strict">.  That hyphen between the C<"UTF"> and the C<"8"> is
  critical; without it, C<Encode> goes "liberal" and (perhaps overly-)permissive:
  
    find_encoding("UTF-8")->name # is 'utf-8-strict'
    find_encoding("utf-8")->name # ditto. names are case insensitive
    find_encoding("utf_8")->name # ditto. "_" are treated as "-"
    find_encoding("UTF8")->name  # is 'utf8'.
  
  Perl's internal UTF8 flag is called "UTF8", without a hyphen. It indicates
  whether a string is internally encoded as "utf8", also without a hyphen.
  
  =head1 SEE ALSO
  
  L<Encode::Encoding>,
  L<Encode::Supported>,
  L<Encode::PerlIO>,
  L<encoding>,
  L<perlebcdic>,
  L<perlfunc/open>,
  L<perlunicode>, L<perluniintro>, L<perlunifaq>, L<perlunitut>
  L<utf8>,
  the Perl Unicode Mailing List L<http://lists.perl.org/list/perl-unicode.html>
  
  =head1 MAINTAINER
  
  This project was originated by the late Nick Ing-Simmons and later
  maintained by Dan Kogai I<< <dankogai@cpan.org> >>.  See AUTHORS
  for a full list of people involved.  For any questions, send mail to
  I<< <perl-unicode@perl.org> >> so that we can all share.
  
  While Dan Kogai retains the copyright as a maintainer, credit
  should go to all those involved.  See AUTHORS for a list of those
  who submitted code to the project.
  
  =head1 COPYRIGHT
  
  Copyright 2002-2014 Dan Kogai I<< <dankogai@cpan.org> >>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_ENCODE

$fatpacked{"x86_64-linux/Encode/Alias.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_ALIAS';
  package Encode::Alias;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.24 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  
  use Exporter 'import';
  
  # Public, encouraged API is exported by default
  
  our @EXPORT =
    qw (
    define_alias
    find_alias
  );
  
  our @Alias;    # ordered matching list
  our %Alias;    # cached known aliases
  
  sub find_alias {
      my $class = shift;
      my $find  = shift;
      unless ( exists $Alias{$find} ) {
          $Alias{$find} = undef;    # Recursion guard
          for ( my $i = 0 ; $i < @Alias ; $i += 2 ) {
              my $alias = $Alias[$i];
              my $val   = $Alias[ $i + 1 ];
              my $new;
              if ( ref($alias) eq 'Regexp' && $find =~ $alias ) {
                  DEBUG and warn "eval $val";
                  $new = eval $val;
                  DEBUG and $@ and warn "$val, $@";
              }
              elsif ( ref($alias) eq 'CODE' ) {
                  DEBUG and warn "$alias", "->", "($find)";
                  $new = $alias->($find);
              }
              elsif ( lc($find) eq lc($alias) ) {
                  $new = $val;
              }
              if ( defined($new) ) {
                  next if $new eq $find;    # avoid (direct) recursion on bugs
                  DEBUG and warn "$alias, $new";
                  my $enc =
                    ( ref($new) ) ? $new : Encode::find_encoding($new);
                  if ($enc) {
                      $Alias{$find} = $enc;
                      last;
                  }
              }
          }
  
          # case insensitive search when canonical is not in all lowercase
          # RT ticket #7835
          unless ( $Alias{$find} ) {
              my $lcfind = lc($find);
              for my $name ( keys %Encode::Encoding, keys %Encode::ExtModule )
              {
                  $lcfind eq lc($name) or next;
                  $Alias{$find} = Encode::find_encoding($name);
                  DEBUG and warn "$find => $name";
              }
          }
      }
      if (DEBUG) {
          my $name;
          if ( my $e = $Alias{$find} ) {
              $name = $e->name;
          }
          else {
              $name = "";
          }
          warn "find_alias($class, $find)->name = $name";
      }
      return $Alias{$find};
  }
  
  sub define_alias {
      while (@_) {
          my $alias = shift;
          my $name = shift;
          unshift( @Alias, $alias => $name )    # newer one has precedence
              if defined $alias;
          if ( ref($alias) ) {
  
              # clear %Alias cache to allow overrides
              my @a = keys %Alias;
              for my $k (@a) {
                  if ( ref($alias) eq 'Regexp' && $k =~ $alias ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
                  elsif ( ref($alias) eq 'CODE' && $alias->($k) ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
              }
          }
          elsif (defined $alias) {
              DEBUG and warn "delete \$Alias\{$alias\}";
              delete $Alias{$alias};
          }
          elsif (DEBUG) {
              require Carp;
              Carp::croak("undef \$alias");
          }
      }
  }
  
  # HACK: Encode must be used after define_alias is declarated as Encode calls define_alias
  use Encode ();
  
  # Allow latin-1 style names as well
  # 0  1  2  3  4  5   6   7   8   9  10
  our @Latin2iso = ( 0, 1, 2, 3, 4, 9, 10, 13, 14, 15, 16 );
  
  # Allow winlatin1 style names as well
  our %Winlatin2cp = (
      'latin1'     => 1252,
      'latin2'     => 1250,
      'cyrillic'   => 1251,
      'greek'      => 1253,
      'turkish'    => 1254,
      'hebrew'     => 1255,
      'arabic'     => 1256,
      'baltic'     => 1257,
      'vietnamese' => 1258,
  );
  
  init_aliases();
  
  sub undef_aliases {
      @Alias = ();
      %Alias = ();
  }
  
  sub init_aliases {
      undef_aliases();
  
      # Try all-lower-case version should all else fails
      define_alias( qr/^(.*)$/ => '"\L$1"' );
  
      # UTF/UCS stuff
      define_alias( qr/^(unicode-1-1-)?UTF-?7$/i     => '"UTF-7"' );
      define_alias( qr/^UCS-?2-?LE$/i => '"UCS-2LE"' );
      define_alias(
          qr/^UCS-?2-?(BE)?$/i    => '"UCS-2BE"',
          qr/^UCS-?4-?(BE|LE|)?$/i => 'uc("UTF-32$1")',
          qr/^iso-10646-1$/i      => '"UCS-2BE"'
      );
      define_alias(
          qr/^UTF-?(16|32)-?BE$/i => '"UTF-$1BE"',
          qr/^UTF-?(16|32)-?LE$/i => '"UTF-$1LE"',
          qr/^UTF-?(16|32)$/i     => '"UTF-$1"',
      );
  
      # ASCII
      define_alias( qr/^(?:US-?)ascii$/i       => '"ascii"' );
      define_alias( 'C'                        => 'ascii' );
      define_alias( qr/\b(?:ISO[-_]?)?646(?:[-_]?US)?$/i => '"ascii"' );
  
      # Allow variants of iso-8859-1 etc.
      define_alias( qr/\biso[-_]?(\d+)[-_](\d+)$/i => '"iso-$1-$2"' );
  
      # At least HP-UX has these.
      define_alias( qr/\biso8859(\d+)$/i => '"iso-8859-$1"' );
  
      # More HP stuff.
      define_alias(
          qr/\b(?:hp-)?(arabic|greek|hebrew|kana|roman|thai|turkish)8$/i =>
            '"${1}8"' );
  
      # The Official name of ASCII.
      define_alias( qr/\bANSI[-_]?X3\.4[-_]?1968$/i => '"ascii"' );
  
      # This is a font issue, not an encoding issue.
      # (The currency symbol of the Latin 1 upper half
      #  has been redefined as the euro symbol.)
      define_alias( qr/^(.+)\@euro$/i => '"$1"' );
  
      define_alias( qr/\b(?:iso[-_]?)?latin[-_]?(\d+)$/i =>
  'defined $Encode::Alias::Latin2iso[$1] ? "iso-8859-$Encode::Alias::Latin2iso[$1]" : undef'
      );
  
      define_alias(
          qr/\bwin(latin[12]|cyrillic|baltic|greek|turkish|
               hebrew|arabic|baltic|vietnamese)$/ix =>
            '"cp" . $Encode::Alias::Winlatin2cp{lc($1)}'
      );
  
      # Common names for non-latin preferred MIME names
      define_alias(
          'ascii'    => 'US-ascii',
          'cyrillic' => 'iso-8859-5',
          'arabic'   => 'iso-8859-6',
          'greek'    => 'iso-8859-7',
          'hebrew'   => 'iso-8859-8',
          'thai'     => 'iso-8859-11',
      );
      # RT #20781
      define_alias(qr/\btis-?620\b/i  => '"iso-8859-11"');
  
      # At least AIX has IBM-NNN (surprisingly...) instead of cpNNN.
      # And Microsoft has their own naming (again, surprisingly).
      # And windows-* is registered in IANA!
      define_alias(
          qr/\b(?:cp|ibm|ms|windows)[-_ ]?(\d{2,4})$/i => '"cp$1"' );
  
      # Sometimes seen with a leading zero.
      # define_alias( qr/\bcp037\b/i => '"cp37"');
  
      # Mac Mappings
      # predefined in *.ucm; unneeded
      # define_alias( qr/\bmacIcelandic$/i => '"macIceland"');
      define_alias( qr/^(?:x[_-])?mac[_-](.*)$/i => '"mac$1"' );
      # http://rt.cpan.org/Ticket/Display.html?id=36326
      define_alias( qr/^macintosh$/i => '"MacRoman"' );
      # https://rt.cpan.org/Ticket/Display.html?id=78125
      define_alias( qr/^macce$/i => '"MacCentralEurRoman"' );
      # Ououououou. gone.  They are different!
      # define_alias( qr/\bmacRomanian$/i => '"macRumanian"');
  
      # Standardize on the dashed versions.
      define_alias( qr/\bkoi8[\s\-_]*([ru])$/i => '"koi8-$1"' );
  
      unless ($Encode::ON_EBCDIC) {
  
          # for Encode::CN
          define_alias( qr/\beuc.*cn$/i => '"euc-cn"' );
          define_alias( qr/\bcn.*euc$/i => '"euc-cn"' );
  
          # define_alias( qr/\bGB[- ]?(\d+)$/i => '"euc-cn"' )
          # CP936 doesn't have vendor-addon for GBK, so they're identical.
          define_alias( qr/^gbk$/i => '"cp936"' );
  
          # This fixes gb2312 vs. euc-cn confusion, practically
          define_alias( qr/\bGB[-_ ]?2312(?!-?raw)/i => '"euc-cn"' );
  
          # for Encode::JP
          define_alias( qr/\bjis$/i         => '"7bit-jis"' );
          define_alias( qr/\beuc.*jp$/i     => '"euc-jp"' );
          define_alias( qr/\bjp.*euc$/i     => '"euc-jp"' );
          define_alias( qr/\bujis$/i        => '"euc-jp"' );
          define_alias( qr/\bshift.*jis$/i  => '"shiftjis"' );
          define_alias( qr/\bsjis$/i        => '"shiftjis"' );
          define_alias( qr/\bwindows-31j$/i => '"cp932"' );
  
          # for Encode::KR
          define_alias( qr/\beuc.*kr$/i => '"euc-kr"' );
          define_alias( qr/\bkr.*euc$/i => '"euc-kr"' );
  
          # This fixes ksc5601 vs. euc-kr confusion, practically
          define_alias( qr/(?:x-)?uhc$/i         => '"cp949"' );
          define_alias( qr/(?:x-)?windows-949$/i => '"cp949"' );
          define_alias( qr/\bks_c_5601-1987$/i   => '"cp949"' );
  
          # for Encode::TW
          define_alias( qr/\bbig-?5$/i              => '"big5-eten"' );
          define_alias( qr/\bbig5-?et(?:en)?$/i     => '"big5-eten"' );
          define_alias( qr/\btca[-_]?big5$/i        => '"big5-eten"' );
          define_alias( qr/\bbig5-?hk(?:scs)?$/i    => '"big5-hkscs"' );
          define_alias( qr/\bhk(?:scs)?[-_]?big5$/i => '"big5-hkscs"' );
      }
  
      # https://github.com/dankogai/p5-encode/issues/37
      define_alias(qr/cp65000/i => '"UTF-7"');
      define_alias(qr/cp65001/i => '"utf-8-strict"');
  
      # utf8 is blessed :)
      define_alias( qr/\bUTF-8$/i => '"utf-8-strict"' );
  
      # At last, Map white space and _ to '-'
      define_alias( qr/^([^\s_]+)[\s_]+([^\s_]*)$/i => '"$1-$2"' );
  }
  
  1;
  __END__
  
  # TODO: HP-UX '8' encodings arabic8 greek8 hebrew8 kana8 thai8 turkish8
  # TODO: HP-UX '15' encodings japanese15 korean15 roi15
  # TODO: Cyrillic encoding ISO-IR-111 (useful?)
  # TODO: Armenian encoding ARMSCII-8
  # TODO: Hebrew encoding ISO-8859-8-1
  # TODO: Thai encoding TCVN
  # TODO: Vietnamese encodings VPS
  # TODO: Mac Asian+African encodings: Arabic Armenian Bengali Burmese
  #       ChineseSimp ChineseTrad Devanagari Ethiopic ExtArabic
  #       Farsi Georgian Gujarati Gurmukhi Hebrew Japanese
  #       Kannada Khmer Korean Laotian Malayalam Mongolian
  #       Oriya Sinhalese Symbol Tamil Telugu Tibetan Vietnamese
  
  =head1 NAME
  
  Encode::Alias - alias definitions to encodings
  
  =head1 SYNOPSIS
  
    use Encode;
    use Encode::Alias;
    define_alias( "newName" => ENCODING);
    define_alias( qr/.../ => ENCODING);
    define_alias( sub { return ENCODING if ...; } );
  
  =head1 DESCRIPTION
  
  Allows newName to be used as an alias for ENCODING. ENCODING may be
  either the name of an encoding or an encoding object (as described 
  in L<Encode>).
  
  Currently the first argument to define_alias() can be specified in the
  following ways:
  
  =over 4
  
  =item As a simple string.
  
  =item As a qr// compiled regular expression, e.g.:
  
    define_alias( qr/^iso8859-(\d+)$/i => '"iso-8859-$1"' );
  
  In this case, if I<ENCODING> is not a reference, it is C<eval>-ed
  in order to allow C<$1> etc. to be substituted.  The example is one
  way to alias names as used in X11 fonts to the MIME names for the
  iso-8859-* family.  Note the double quotes inside the single quotes.
  
  (or, you don't have to do this yourself because this example is predefined)
  
  If you are using a regex here, you have to use the quotes as shown or
  it won't work.  Also note that regex handling is tricky even for the
  experienced.  Use this feature with caution.
  
  =item As a code reference, e.g.:
  
    define_alias( sub {shift =~ /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  The same effect as the example above in a different way.  The coderef
  takes the alias name as an argument and returns a canonical name on
  success or undef if not.  Note the second argument is ignored if provided.
  Use this with even more caution than the regex version.
  
  =back
  
  =head3 Changes in code reference aliasing
  
  As of Encode 1.87, the older form
  
    define_alias( sub { return  /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  no longer works. 
  
  Encode up to 1.86 internally used "local $_" to implement this older
  form.  But consider the code below;
  
    use Encode;
    $_ = "eeeee" ;
    while (/(e)/g) {
      my $utf = decode('aliased-encoding-name', $1);
      print "position:",pos,"\n";
    }
  
  Prior to Encode 1.86 this fails because of "local $_".
  
  =head2 Alias overloading
  
  You can override predefined aliases by simply applying define_alias().
  The new alias is always evaluated first, and when necessary,
  define_alias() flushes the internal cache to make the new definition
  available.
  
    # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a
    # superset of SHIFT_JIS
  
    define_alias( qr/shift.*jis$/i  => '"cp932"' );
    define_alias( qr/sjis$/i        => '"cp932"' );
  
  If you want to zap all predefined aliases, you can use
  
    Encode::Alias->undef_aliases;
  
  to do so.  And
  
    Encode::Alias->init_aliases;
  
  gets the factory settings back.
  
  Note that define_alias() will not be able to override the canonical name
  of encodings. Encodings are first looked up by canonical name before
  potential aliases are tried.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Supported>
  
  =cut
  
X86_64-LINUX_ENCODE_ALIAS

$fatpacked{"x86_64-linux/Encode/Byte.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_BYTE';
  package Encode::Byte;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Byte - Single Byte Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $greek = encode("iso-8859-7", $utf8);  # loads Encode::Byte implicitly
      $utf8  = decode("iso-8859-7", $greek); # ditto
  
  =head1 ABSTRACT
  
  This module implements various single byte encodings.  For most cases it uses
  \x80-\xff (upper half) to map non-ASCII characters.  Encodings
  supported are as follows.   
  
    Canonical      Alias		                      Description
    --------------------------------------------------------------------
    # ISO 8859 series
    (iso-8859-1	is in built-in)
    iso-8859-2	latin2					     [ISO]
    iso-8859-3	latin3					     [ISO]
    iso-8859-4	latin4					     [ISO]
    iso-8859-5						     [ISO]
    iso-8859-6						     [ISO]
    iso-8859-7						     [ISO]
    iso-8859-8						     [ISO]
    iso-8859-9	latin5					     [ISO]
    iso-8859-10	latin6					     [ISO]
    iso-8859-11
    (iso-8859-12 is nonexistent)
    iso-8859-13   latin7					     [ISO]
    iso-8859-14	latin8					     [ISO]
    iso-8859-15	latin9					     [ISO]
    iso-8859-16	latin10					     [ISO]
  
    # Cyrillic
    koi8-f					
    koi8-r        cp878					 [RFC1489]
    koi8-u						 [RFC2319]
  
    # Vietnamese
    viscii
  
    # all cp* are also available as ibm-*, ms-*, and windows-*
    # also see L<http://msdn.microsoft.com/en-us/library/aa752010%28VS.85%29.aspx>
  
    cp424  
    cp437  
    cp737  
    cp775  
    cp850  
    cp852  
    cp855  
    cp856  
    cp857  
    cp860  
    cp861  
    cp862  
    cp863  
    cp864  
    cp865  
    cp866  
    cp869  
    cp874  
    cp1006  
    cp1250	WinLatin2
    cp1251	WinCyrillic
    cp1252	WinLatin1
    cp1253	WinGreek
    cp1254	WinTurkish
    cp1255	WinHebrew
    cp1256	WinArabic
    cp1257	WinBaltic
    cp1258	WinVietnamese
  
    # Macintosh
    # Also see L<http://developer.apple.com/technotes/tn/tn1150.html>
    MacArabic  
    MacCentralEurRoman  
    MacCroatian  
    MacCyrillic  
    MacFarsi  
    MacGreek  
    MacHebrew  
    MacIcelandic  
    MacRoman  
    MacRomanian  
    MacRumanian  
    MacSami  
    MacThai  
    MacTurkish  
    MacUkrainian  
  
    # More vendor encodings
    AdobeStandardEncoding
    nextstep
    hp-roman8
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX_ENCODE_BYTE

$fatpacked{"x86_64-linux/Encode/CJKConstants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_CJKCONSTANTS';
  #
  # $Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::CJKConstants;
  
  use strict;
  use warnings;
  our $RCSID = q$Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp;
  
  require Exporter;
  our @ISA         = qw(Exporter);
  our @EXPORT      = qw();
  our @EXPORT_OK   = qw(%CHARCODE %ESC %RE);
  our %EXPORT_TAGS = ( 'all' => [ @EXPORT_OK, @EXPORT ] );
  
  my %_0208 = (
      1978 => '\e\$\@',
      1983 => '\e\$B',
      1990 => '\e&\@\e\$B',
  );
  
  our %CHARCODE = (
      UNDEF_EUC     => "\xa2\xae",    #  in EUC
      UNDEF_SJIS    => "\x81\xac",    #  in SJIS
      UNDEF_JIS     => "\xa2\xf7",    #  -- used in unicode
      UNDEF_UNICODE => "\x20\x20",    #  -- used in unicode
  );
  
  our %ESC = (
      GB_2312   => "\e\$A",
      JIS_0208  => "\e\$B",
      JIS_0212  => "\e\$(D",
      KSC_5601  => "\e\$(C",
      ASC       => "\e\(B",
      KANA      => "\e\(I",
      '2022_KR' => "\e\$)C",
  );
  
  our %RE = (
      ASCII     => '[\x00-\x7f]',
      BIN       => '[\x00-\x06\x7f\xff]',
      EUC_0212  => '\x8f[\xa1-\xfe][\xa1-\xfe]',
      EUC_C     => '[\xa1-\xfe][\xa1-\xfe]',
      EUC_KANA  => '\x8e[\xa1-\xdf]',
      JIS_0208  => "$_0208{1978}|$_0208{1983}|$_0208{1990}",
      JIS_0212  => "\e" . '\$\(D',
      ISO_ASC   => "\e" . '\([BJ]',
      JIS_KANA  => "\e" . '\(I',
      '2022_KR' => "\e" . '\$\)C',
      SJIS_C    => '[\x81-\x9f\xe0-\xfc][\x40-\x7e\x80-\xfc]',
      SJIS_KANA => '[\xa1-\xdf]',
      UTF8      => '[\xc0-\xdf][\x80-\xbf]|[\xe0-\xef][\x80-\xbf][\x80-\xbf]'
  );
  
  1;
  
  =head1 NAME
  
  Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*
  
  =cut
  
X86_64-LINUX_ENCODE_CJKCONSTANTS

$fatpacked{"x86_64-linux/Encode/CN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_CN';
  package Encode::CN;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::CN not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  # Relocated from Encode.pm
  
  use Encode::CN::HZ;
  
  # use Encode::CN::2022_CN;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN - China-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_cn = encode("euc-cn", $utf8);   # loads Encode::CN implicitly
      $utf8   = decode("euc-cn", $euc_cn); # ditto
  
  =head1 DESCRIPTION
  
  This module implements China-based Chinese charset encodings.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-cn      /\beuc.*cn$/i	EUC (Extended Unix Character)
            /\bcn.*euc$/i
                /\bGB[-_ ]?2312(?:\D.*$|$)/i (see below)
    gb2312-raw			The raw (low-bit) GB2312 character map
    gb12345-raw			Traditional chinese counterpart to 
                  GB2312 (raw)
    iso-ir-165			GB2312 + GB6345 + GB8565 + additions
    MacChineseSimp                GB2312 + Apple Additions
    cp936				Code Page 936, also known as GBK 
                  (Extended GuoBiao)
    hz				7-bit escaped GB2312 encoding
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<GB 18030> (an extension to C<GBK>) is distributed
  separately on CPAN, under the name L<Encode::HanExtra>. That module
  also contains extra Taiwan-based encodings.
  
  =head1 BUGS
  
  When you see C<charset=gb2312> on mails and web pages, they really
  mean C<euc-cn> encodings.  To fix that, C<gb2312> is aliased to C<euc-cn>.
  Use C<gb2312-raw> when you really mean it.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even though
  this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX_ENCODE_CN

$fatpacked{"x86_64-linux/Encode/CN/HZ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_CN_HZ';
  package Encode::CN::HZ;
  
  use strict;
  use warnings;
  use utf8 ();
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.10 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('hz');
  
  # HZ is a combination of ASCII and escaped GB, so we implement it
  # with the GB2312(raw) encoding here. Cf. RFCs 1842 & 1843.
  
  # not ported for EBCDIC.  Which should be used, "~" or "\x7E"?
  
  sub needs_lines { 1 }
  
  sub decode ($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness
      my $in_ascii = 1;    # default mode is ASCII.
  
      while ( length $str ) {
          if ($in_ascii) {    # ASCII mode
              if ( $str =~ s/^([\x00-\x7D\x7F]+)// ) {    # no '~' => ASCII
                  $ret .= $1;
  
                  # EBCDIC should need ascii2native, but not ported.
              }
              elsif ( $str =~ s/^\x7E\x7E// ) {           # escaped tilde
                  $ret .= '~';
              }
              elsif ( $str =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  1;                              # no-op
              }
              elsif ( $str =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              no warnings 'uninitialized';
              if ( $str =~ s/^((?:[\x21-\x77][\x21-\x7E])+)// ) {
                  my $prefix = $1;
                  $ret .= $GB->decode( $prefix, $chk );
              }
              elsif ( $str =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
              }
              else {                               # invalid
                  last;
              }
          }
      }
      $_[1] = '' if $chk;    # needs_lines guarantees no partial character
      return $ret;
  }
  
  sub cat_decode {
      my ( $obj, undef, $src, $pos, $trm, $chk ) = @_;
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1 .. 3 ];
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = '';
      my $in_ascii = 1;      # default mode is ASCII.
  
      my $ini_pos = pos($$rsrc);
  
      substr( $src, 0, $pos ) = '';
  
      my $ini_len = bytes::length($src);
  
      # $trm is the first of the pair '~~', then 2nd tilde is to be removed.
      # XXX: Is better C<$src =~ s/^\x7E// or die if ...>?
      $src =~ s/^\x7E// if $trm eq "\x7E";
  
      while ( length $src ) {
          my $now;
          if ($in_ascii) {    # ASCII mode
              if ( $src =~ s/^([\x00-\x7D\x7F])// ) {    # no '~' => ASCII
                  $now = $1;
              }
              elsif ( $src =~ s/^\x7E\x7E// ) {          # escaped tilde
                  $now = '~';
              }
              elsif ( $src =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  next;
              }
              elsif ( $src =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
                  next;
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              if ( $src =~ s/^((?:[\x21-\x77][\x21-\x7F])+)// ) {
                  $now = $GB->decode( $1, $chk );
              }
              elsif ( $src =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
                  next;
              }
              else {                               # invalid
                  last;
              }
          }
  
          next if !defined $now;
  
          $ret .= $now;
  
          if ( $now eq $trm ) {
              $$rdst .= $ret;
              $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
              pos($$rsrc) = $ini_pos;
              return 1;
          }
      }
  
      $$rdst .= $ret;
      $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
      pos($$rsrc) = $ini_pos;
      return '';    # terminator not found
  }
  
  sub encode($$;$) {
       my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness;
      my $in_ascii = 1;    # default mode is ASCII.
  
      no warnings 'utf8';  # $str may be malformed UTF8 at the end of a chunk.
  
      while ( length $str ) {
          if ( $str =~ s/^([[:ascii:]]+)// ) {
              my $tmp = $1;
              $tmp =~ s/~/~~/g;    # escapes tildes
              if ( !$in_ascii ) {
                  $ret .= "\x7E\x7D";    # '~}'
                  $in_ascii = 1;
              }
              $ret .= pack 'a*', $tmp;    # remove UTF8 flag.
          }
          elsif ( $str =~ s/(.)// ) {
              my $s = $1;
              my $tmp = $GB->encode( $s, $chk || 0 );
              last if !defined $tmp;
              if ( length $tmp == 2 ) {    # maybe a valid GB char (XXX)
                  if ($in_ascii) {
                      $ret .= "\x7E\x7B";    # '~{'
                      $in_ascii = 0;
                  }
                  $ret .= $tmp;
              }
              elsif ( length $tmp ) {        # maybe FALLBACK in ASCII (XXX)
                  if ( !$in_ascii ) {
                      $ret .= "\x7E\x7D";    # '~}'
                      $in_ascii = 1;
                  }
                  $ret .= $tmp;
              }
          }
          else {    # if $str is malformed UTF8 *and* if length $str != 0.
              last;
          }
      }
      $_[1] = $str if $chk;
  
      # The state at the end of the chunk is discarded, even if in GB mode.
      # That results in the combination of GB-OUT and GB-IN, i.e. "~}~{".
      # Parhaps it is harmless, but further investigations may be required...
  
      if ( !$in_ascii ) {
          $ret .= "\x7E\x7D";    # '~}'
          $in_ascii = 1;
      }
      utf8::encode($ret); # https://rt.cpan.org/Ticket/Display.html?id=35120
      return $ret;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN::HZ -- internally used by Encode::CN
  
  =cut
X86_64-LINUX_ENCODE_CN_HZ

$fatpacked{"x86_64-linux/Encode/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_CONFIG';
  #
  # Demand-load module list
  #
  package Encode::Config;
  our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use strict;
  use warnings;
  
  our %ExtModule = (
  
      # Encode::Byte
      #iso-8859-1 is in Encode.pm itself
      'iso-8859-2'            => 'Encode::Byte',
      'iso-8859-3'            => 'Encode::Byte',
      'iso-8859-4'            => 'Encode::Byte',
      'iso-8859-5'            => 'Encode::Byte',
      'iso-8859-6'            => 'Encode::Byte',
      'iso-8859-7'            => 'Encode::Byte',
      'iso-8859-8'            => 'Encode::Byte',
      'iso-8859-9'            => 'Encode::Byte',
      'iso-8859-10'           => 'Encode::Byte',
      'iso-8859-11'           => 'Encode::Byte',
      'iso-8859-13'           => 'Encode::Byte',
      'iso-8859-14'           => 'Encode::Byte',
      'iso-8859-15'           => 'Encode::Byte',
      'iso-8859-16'           => 'Encode::Byte',
      'koi8-f'                => 'Encode::Byte',
      'koi8-r'                => 'Encode::Byte',
      'koi8-u'                => 'Encode::Byte',
      'viscii'                => 'Encode::Byte',
      'cp424'                 => 'Encode::Byte',
      'cp437'                 => 'Encode::Byte',
      'cp737'                 => 'Encode::Byte',
      'cp775'                 => 'Encode::Byte',
      'cp850'                 => 'Encode::Byte',
      'cp852'                 => 'Encode::Byte',
      'cp855'                 => 'Encode::Byte',
      'cp856'                 => 'Encode::Byte',
      'cp857'                 => 'Encode::Byte',
      'cp858'                 => 'Encode::Byte',
      'cp860'                 => 'Encode::Byte',
      'cp861'                 => 'Encode::Byte',
      'cp862'                 => 'Encode::Byte',
      'cp863'                 => 'Encode::Byte',
      'cp864'                 => 'Encode::Byte',
      'cp865'                 => 'Encode::Byte',
      'cp866'                 => 'Encode::Byte',
      'cp869'                 => 'Encode::Byte',
      'cp874'                 => 'Encode::Byte',
      'cp1006'                => 'Encode::Byte',
      'cp1250'                => 'Encode::Byte',
      'cp1251'                => 'Encode::Byte',
      'cp1252'                => 'Encode::Byte',
      'cp1253'                => 'Encode::Byte',
      'cp1254'                => 'Encode::Byte',
      'cp1255'                => 'Encode::Byte',
      'cp1256'                => 'Encode::Byte',
      'cp1257'                => 'Encode::Byte',
      'cp1258'                => 'Encode::Byte',
      'AdobeStandardEncoding' => 'Encode::Byte',
      'MacArabic'             => 'Encode::Byte',
      'MacCentralEurRoman'    => 'Encode::Byte',
      'MacCroatian'           => 'Encode::Byte',
      'MacCyrillic'           => 'Encode::Byte',
      'MacFarsi'              => 'Encode::Byte',
      'MacGreek'              => 'Encode::Byte',
      'MacHebrew'             => 'Encode::Byte',
      'MacIcelandic'          => 'Encode::Byte',
      'MacRoman'              => 'Encode::Byte',
      'MacRomanian'           => 'Encode::Byte',
      'MacRumanian'           => 'Encode::Byte',
      'MacSami'               => 'Encode::Byte',
      'MacThai'               => 'Encode::Byte',
      'MacTurkish'            => 'Encode::Byte',
      'MacUkrainian'          => 'Encode::Byte',
      'nextstep'              => 'Encode::Byte',
      'hp-roman8'             => 'Encode::Byte',
      #'gsm0338'               => 'Encode::Byte',
      'gsm0338'               => 'Encode::GSM0338',
  
      # Encode::EBCDIC
      'cp37'     => 'Encode::EBCDIC',
      'cp500'    => 'Encode::EBCDIC',
      'cp875'    => 'Encode::EBCDIC',
      'cp1026'   => 'Encode::EBCDIC',
      'cp1047'   => 'Encode::EBCDIC',
      'posix-bc' => 'Encode::EBCDIC',
  
      # Encode::Symbol
      'dingbats'      => 'Encode::Symbol',
      'symbol'        => 'Encode::Symbol',
      'AdobeSymbol'   => 'Encode::Symbol',
      'AdobeZdingbat' => 'Encode::Symbol',
      'MacDingbats'   => 'Encode::Symbol',
      'MacSymbol'     => 'Encode::Symbol',
  
      # Encode::Unicode
      'UCS-2BE'  => 'Encode::Unicode',
      'UCS-2LE'  => 'Encode::Unicode',
      'UTF-16'   => 'Encode::Unicode',
      'UTF-16BE' => 'Encode::Unicode',
      'UTF-16LE' => 'Encode::Unicode',
      'UTF-32'   => 'Encode::Unicode',
      'UTF-32BE' => 'Encode::Unicode',
      'UTF-32LE' => 'Encode::Unicode',
      'UTF-7'    => 'Encode::Unicode::UTF7',
  );
  
  unless ( ord("A") == 193 ) {
      %ExtModule = (
          %ExtModule,
          'euc-cn'         => 'Encode::CN',
          'gb12345-raw'    => 'Encode::CN',
          'gb2312-raw'     => 'Encode::CN',
          'hz'             => 'Encode::CN',
          'iso-ir-165'     => 'Encode::CN',
          'cp936'          => 'Encode::CN',
          'MacChineseSimp' => 'Encode::CN',
  
          '7bit-jis'      => 'Encode::JP',
          'euc-jp'        => 'Encode::JP',
          'iso-2022-jp'   => 'Encode::JP',
          'iso-2022-jp-1' => 'Encode::JP',
          'jis0201-raw'   => 'Encode::JP',
          'jis0208-raw'   => 'Encode::JP',
          'jis0212-raw'   => 'Encode::JP',
          'cp932'         => 'Encode::JP',
          'MacJapanese'   => 'Encode::JP',
          'shiftjis'      => 'Encode::JP',
  
          'euc-kr'      => 'Encode::KR',
          'iso-2022-kr' => 'Encode::KR',
          'johab'       => 'Encode::KR',
          'ksc5601-raw' => 'Encode::KR',
          'cp949'       => 'Encode::KR',
          'MacKorean'   => 'Encode::KR',
  
          'big5-eten'      => 'Encode::TW',
          'big5-hkscs'     => 'Encode::TW',
          'cp950'          => 'Encode::TW',
          'MacChineseTrad' => 'Encode::TW',
  
          #'big5plus'           => 'Encode::HanExtra',
          #'euc-tw'             => 'Encode::HanExtra',
          #'gb18030'            => 'Encode::HanExtra',
  
          'MIME-Header' => 'Encode::MIME::Header',
          'MIME-B'      => 'Encode::MIME::Header',
          'MIME-Q'      => 'Encode::MIME::Header',
  
          'MIME-Header-ISO_2022_JP' => 'Encode::MIME::Header::ISO_2022_JP',
      );
  }
  
  #
  # Why not export ? to keep ConfigLocal Happy!
  #
  while ( my ( $enc, $mod ) = each %ExtModule ) {
      $Encode::ExtModule{$enc} = $mod;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Config -- internally used by Encode
  
  =cut
X86_64-LINUX_ENCODE_CONFIG

$fatpacked{"x86_64-linux/Encode/EBCDIC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_EBCDIC';
  package Encode::EBCDIC;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::EBCDIC - EBCDIC Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $posix_bc  = encode("posix-bc", $utf8); # loads Encode::EBCDIC implicitly
      $utf8 = decode("", $posix_bc);          # ditto
  
  =head1 ABSTRACT
  
  This module implements various EBCDIC-Based encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    cp37  
    cp500  
    cp875  
    cp1026  
    cp1047  
    posix-bc
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>, L<perlebcdic>
  
  =cut
X86_64-LINUX_ENCODE_EBCDIC

$fatpacked{"x86_64-linux/Encode/Encoder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_ENCODER';
  #
  # $Id: Encoder.pm,v 2.3 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::Encoder;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw ( encoder );
  
  our $AUTOLOAD;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  use Encode qw(encode decode find_encoding from_to);
  use Carp;
  
  sub new {
      my ( $class, $data, $encname ) = @_;
      unless ($encname) {
          $encname = Encode::is_utf8($data) ? 'utf8' : '';
      }
      else {
          my $obj = find_encoding($encname)
            or croak __PACKAGE__, ": unknown encoding: $encname";
          $encname = $obj->name;
      }
      my $self = {
          data     => $data,
          encoding => $encname,
      };
      bless $self => $class;
  }
  
  sub encoder { __PACKAGE__->new(@_) }
  
  sub data {
      my ( $self, $data ) = @_;
      if ( defined $data ) {
          $self->{data} = $data;
          return $data;
      }
      else {
          return $self->{data};
      }
  }
  
  sub encoding {
      my ( $self, $encname ) = @_;
      if ($encname) {
          my $obj = find_encoding($encname)
            or confess __PACKAGE__, ": unknown encoding: $encname";
          $self->{encoding} = $obj->name;
          return $self;
      }
      else {
          return $self->{encoding};
      }
  }
  
  sub bytes {
      my ( $self, $encname ) = @_;
      $encname ||= $self->{encoding};
      my $obj = find_encoding($encname)
        or confess __PACKAGE__, ": unknown encoding: $encname";
      $self->{data} = $obj->decode( $self->{data}, 1 );
      $self->{encoding} = '';
      return $self;
  }
  
  sub DESTROY {    # defined so it won't autoload.
      DEBUG and warn shift;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $type = ref($self)
        or confess "$self is not an object";
      my $myname = $AUTOLOAD;
      $myname =~ s/.*://;    # strip fully-qualified portion
      my $obj = find_encoding($myname)
        or confess __PACKAGE__, ": unknown encoding: $myname";
      DEBUG and warn $self->{encoding}, " => ", $obj->name;
      if ( $self->{encoding} ) {
          from_to( $self->{data}, $self->{encoding}, $obj->name, 1 );
      }
      else {
          $self->{data} = $obj->encode( $self->{data}, 1 );
      }
      $self->{encoding} = $obj->name;
      return $self;
  }
  
  use overload
    q("") => sub { $_[0]->{data} },
    q(0+) => sub { use bytes(); bytes::length( $_[0]->{data} ) },
    fallback => 1,
    ;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoder -- Object Oriented Encoder
  
  =head1 SYNOPSIS
  
    use Encode::Encoder;
    # Encode::encode("ISO-8859-1", $data); 
    Encode::Encoder->new($data)->iso_8859_1; # OOP way
    # shortcut
    use Encode::Encoder qw(encoder);
    encoder($data)->iso_8859_1;
    # you can stack them!
    encoder($data)->iso_8859_1->base64;  # provided base64() is defined
    # you can use it as a decoder as well
    encoder($base64)->bytes('base64')->latin1;
    # stringified
    print encoder($data)->utf8->latin1;  # prints the string in latin1
    # numified
    encoder("\x{abcd}\x{ef}g")->utf8 == 6; # true. bytes::length($data)
  
  =head1 ABSTRACT
  
  B<Encode::Encoder> allows you to use Encode in an object-oriented
  style.  This is not only more intuitive than a functional approach,
  but also handier when you want to stack encodings.  Suppose you want
  your UTF-8 string converted to Latin1 then Base64: you can simply say
  
    my $base64 = encoder($utf8)->latin1->base64;
  
  instead of
  
    my $latin1 = encode("latin1", $utf8);
    my $base64 = encode_base64($utf8);
  
  or the lazier and more convoluted
  
    my $base64 = encode_base64(encode("latin1", $utf8));
  
  =head1 Description
  
  Here is how to use this module.
  
  =over 4
  
  =item *
  
  There are at least two instance variables stored in a hash reference,
  {data} and {encoding}.
  
  =item *
  
  When there is no method, it takes the method name as the name of the
  encoding and encodes the instance I<data> with I<encoding>.  If successful,
  the instance I<encoding> is set accordingly.
  
  =item *
  
  You can retrieve the result via -E<gt>data but usually you don't have to 
  because the stringify operator ("") is overridden to do exactly that.
  
  =back
  
  =head2 Predefined Methods
  
  This module predefines the methods below:
  
  =over 4
  
  =item $e = Encode::Encoder-E<gt>new([$data, $encoding]);
  
  returns an encoder object.  Its data is initialized with $data if
  present, and its encoding is set to $encoding if present.
  
  When $encoding is omitted, it defaults to utf8 if $data is already in
  utf8 or "" (empty string) otherwise.
  
  =item encoder()
  
  is an alias of Encode::Encoder-E<gt>new().  This one is exported on demand.
  
  =item $e-E<gt>data([$data])
  
  When $data is present, sets the instance data to $data and returns the
  object itself.  Otherwise, the current instance data is returned.
  
  =item $e-E<gt>encoding([$encoding])
  
  When $encoding is present, sets the instance encoding to $encoding and
  returns the object itself.  Otherwise, the current instance encoding is
  returned.
  
  =item $e-E<gt>bytes([$encoding])
  
  decodes instance data from $encoding, or the instance encoding if
  omitted.  If the conversion is successful, the instance encoding
  will be set to "".
  
  The name I<bytes> was deliberately picked to avoid namespace tainting
  -- this module may be used as a base class so method names that appear
  in Encode::Encoding are avoided.
  
  =back
  
  =head2 Example: base64 transcoder
  
  This module is designed to work with L<Encode::Encoding>.
  To make the Base64 transcoder example above really work, you could
  write a module like this:
  
    package Encode::Base64;
    use parent 'Encode::Encoding';
    __PACKAGE__->Define('base64');
    use MIME::Base64;
    sub encode{ 
        my ($obj, $data) = @_; 
        return encode_base64($data);
    }
    sub decode{
        my ($obj, $data) = @_; 
        return decode_base64($data);
    }
    1;
    __END__
  
  And your caller module would be something like this:
  
    use Encode::Encoder;
    use Encode::Base64;
  
    # now you can really do the following
  
    encoder($data)->iso_8859_1->base64;
    encoder($base64)->bytes('base64')->latin1;
  
  =head2 Operator Overloading
  
  This module overloads two operators, stringify ("") and numify (0+).
  
  Stringify dumps the data inside the object.
  
  Numify returns the number of bytes in the instance data.
  
  They come in handy when you want to print or find the size of data.
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<Encode::Encoding>
  
  =cut
X86_64-LINUX_ENCODE_ENCODER

$fatpacked{"x86_64-linux/Encode/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_ENCODING';
  package Encode::Encoding;
  
  # Base class for classes which implement encodings
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  our @CARP_NOT = qw(Encode Encode::Encoder);
  
  use Carp ();
  use Encode ();
  use Encode::MIME::Name;
  
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  
  sub Define {
      my $obj       = shift;
      my $canonical = shift;
      $obj = bless { Name => $canonical }, $obj unless ref $obj;
  
      # warn "$canonical => $obj\n";
      Encode::define_encoding( $obj, $canonical, @_ );
  }
  
  sub name { return shift->{'Name'} }
  
  sub mime_name {
      return Encode::MIME::Name::get_mime_name(shift->name);
  }
  
  sub renew {
      my $self = shift;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller can see it
      DEBUG and warn $clone->{renewed};
      return $clone;
  }
  
  sub renewed { return $_[0]->{renewed} || 0 }
  
  *new_sequence = \&renew;
  
  sub needs_lines { 0 }
  
  sub perlio_ok {
      return eval { require PerlIO::encoding } ? 1 : 0;
  }
  
  # (Temporary|legacy) methods
  
  sub toUnicode   { shift->decode(@_) }
  sub fromUnicode { shift->encode(@_) }
  
  #
  # Needs to be overloaded or just croak
  #
  
  sub encode {
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub decode {
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub DESTROY { }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoding - Encode Implementation Base Class
  
  =head1 SYNOPSIS
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  =head1 DESCRIPTION
  
  As mentioned in L<Encode>, encodings are (in the current
  implementation at least) defined as objects. The mapping of encoding
  name to object is via the C<%Encode::Encoding> hash.  Though you can
  directly manipulate this hash, it is strongly encouraged to use this
  base class module and add encode() and decode() methods.
  
  =head2 Methods you should implement
  
  You are strongly encouraged to implement methods below, at least
  either encode() or decode().
  
  =over 4
  
  =item -E<gt>encode($string [,$check])
  
  MUST return the octet sequence representing I<$string>. 
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$string> in place to remove
  the converted part (i.e.  the whole string unless there is an error).
  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the octet sequence for the
  fragment of string that has been converted and modify $string in-place
  to remove the converted part leaving it starting with the problem
  fragment.  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<encode> MUST  make a "best effort" to
  convert the string - for example, by using a replacement character.
  
  =back
  
  =item -E<gt>decode($octets [,$check])
  
  MUST return the string that I<$octets> represents.
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$octets> in place to remove
  the converted part (i.e.  the whole sequence unless there is an
  error).  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the fragment of string that has
  been converted and modify $octets in-place to remove the converted
  part leaving it starting with the problem fragment.  If perlio_ok() is
  true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<decode> should make a "best effort" to
  convert the string - for example by using Unicode's "\x{FFFD}" as a
  replacement character.
  
  =back
  
  =back
  
  If you want your encoding to work with L<encoding> pragma, you should
  also implement the method below.
  
  =over 4
  
  =item -E<gt>cat_decode($destination, $octets, $offset, $terminator [,$check])
  
  MUST decode I<$octets> with I<$offset> and concatenate it to I<$destination>.
  Decoding will terminate when $terminator (a string) appears in output.
  I<$offset> will be modified to the last $octets position at end of decode.
  Returns true if $terminator appears output, else returns false.
  
  =back
  
  =head2 Other methods defined in Encode::Encodings
  
  You do not have to override methods shown below unless you have to.
  
  =over 4
  
  =item -E<gt>name
  
  Predefined As:
  
    sub name  { return shift->{'Name'} }
  
  MUST return the string representing the canonical name of the encoding.
  
  =item -E<gt>mime_name
  
  Predefined As:
  
    sub mime_name{
      return Encode::MIME::Name::get_mime_name(shift->name);
    }
  
  MUST return the string representing the IANA charset name of the encoding.
  
  =item -E<gt>renew
  
  Predefined As:
  
    sub renew {
      my $self = shift;
      my $clone = bless { %$self } => ref($self);
      $clone->{renewed}++;
      return $clone;
    }
  
  This method reconstructs the encoding object if necessary.  If you need
  to store the state during encoding, this is where you clone your object.
  
  PerlIO ALWAYS calls this method to make sure it has its own private
  encoding object.
  
  =item -E<gt>renewed
  
  Predefined As:
  
    sub renewed { $_[0]->{renewed} || 0 }
  
  Tells whether the object is renewed (and how many times).  Some
  modules emit C<Use of uninitialized value in null operation> warning
  unless the value is numeric so return 0 for false.
  
  =item -E<gt>perlio_ok()
  
  Predefined As:
  
    sub perlio_ok { 
      return eval { require PerlIO::encoding } ? 1 : 0;
    }
  
  If your encoding does not support PerlIO for some reasons, just;
  
   sub perlio_ok { 0 }
  
  =item -E<gt>needs_lines()
  
  Predefined As:
  
    sub needs_lines { 0 };
  
  If your encoding can work with PerlIO but needs line buffering, you
  MUST define this method so it returns true.  7bit ISO-2022 encodings
  are one example that needs this.  When this method is missing, false
  is assumed.
  
  =back
  
  =head2 Example: Encode::ROT13
  
    package Encode::ROT13;
    use strict;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define('rot13');
  
    sub encode($$;$){
        my ($obj, $str, $chk) = @_;
        $str =~ tr/A-Za-z/N-ZA-Mn-za-m/;
        $_[1] = '' if $chk; # this is what in-place edit means
        return $str;
    }
  
    # Jr pna or ynml yvxr guvf;
    *decode = \&encode;
  
    1;
  
  =head1 Why the heck Encode API is different?
  
  It should be noted that the I<$check> behaviour is different from the
  outer public API. The logic is that the "unchecked" case is useful
  when the encoding is part of a stream which may be reporting errors
  (e.g. STDERR).  In such cases, it is desirable to get everything
  through somehow without causing additional errors which obscure the
  original one. Also, the encoding is best placed to know what the
  correct replacement character is, so if that is the desired behaviour
  then letting low level code do it is the most efficient.
  
  By contrast, if I<$check> is true, the scheme above allows the
  encoding to do as much as it can and tell the layer above how much
  that was. What is lacking at present is a mechanism to report what
  went wrong. The most likely interface will be an additional method
  call to the object, or perhaps (to avoid forcing per-stream objects
  on otherwise stateless encodings) an additional parameter.
  
  It is also highly desirable that encoding classes inherit from
  C<Encode::Encoding> as a base class. This allows that class to define
  additional behaviour for all encoding objects.
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  to create an object with C<< bless {Name => ...}, $class >>, and call
  define_encoding.  They inherit their C<name> method from
  C<Encode::Encoding>.
  
  =head2 Compiled Encodings
  
  For the sake of speed and efficiency, most of the encodings are now
  supported via a I<compiled form>: XS modules generated from UCM
  files.   Encode provides the enc2xs tool to achieve that.  Please see
  L<enc2xs> for more details.
  
  =head1 SEE ALSO
  
  L<perlmod>, L<enc2xs>
  
  =begin future
  
  =over 4
  
  =item Scheme 1
  
  The fixup routine gets passed the remaining fragment of string being
  processed.  It modifies it in place to remove bytes/characters it can
  understand and returns a string used to represent them.  For example:
  
   sub fixup {
     my $ch = substr($_[0],0,1,'');
     return sprintf("\x{%02X}",ord($ch);
   }
  
  This scheme is close to how the underlying C code for Encode works,
  but gives the fixup routine very little context.
  
  =item Scheme 2
  
  The fixup routine gets passed the original string, an index into
  it of the problem area, and the output string so far.  It appends
  what it wants to the output string and returns a new index into the
  original string.  For example:
  
   sub fixup {
     # my ($s,$i,$d) = @_;
     my $ch = substr($_[0],$_[1],1);
     $_[2] .= sprintf("\x{%02X}",ord($ch);
     return $_[1]+1;
   }
  
  This scheme gives maximal control to the fixup routine but is more
  complicated to code, and may require that the internals of Encode be tweaked to
  keep the original string intact.
  
  =item Other Schemes
  
  Hybrids of the above.
  
  Multiple return values rather than in-place modifications.
  
  Index into the string could be C<pos($str)> allowing C<s/\G...//>.
  
  =back
  
  =end future
  
  =cut
X86_64-LINUX_ENCODE_ENCODING

$fatpacked{"x86_64-linux/Encode/GSM0338.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_GSM0338';
  #
  # $Id: GSM0338.pm,v 2.7 2017/06/10 17:23:50 dankogai Exp $
  #
  package Encode::GSM0338;
  
  use strict;
  use warnings;
  use Carp;
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('gsm0338');
  
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  use utf8;
  our %UNI2GSM = (
      "\x{0040}" => "\x00",        # COMMERCIAL AT
      "\x{000A}" => "\x0A",        # LINE FEED
      "\x{000C}" => "\x1B\x0A",    # FORM FEED
      "\x{000D}" => "\x0D",        # CARRIAGE RETURN
      "\x{0020}" => "\x20",        # SPACE
      "\x{0021}" => "\x21",        # EXCLAMATION MARK
      "\x{0022}" => "\x22",        # QUOTATION MARK
      "\x{0023}" => "\x23",        # NUMBER SIGN
      "\x{0024}" => "\x02",        # DOLLAR SIGN
      "\x{0025}" => "\x25",        # PERCENT SIGN
      "\x{0026}" => "\x26",        # AMPERSAND
      "\x{0027}" => "\x27",        # APOSTROPHE
      "\x{0028}" => "\x28",        # LEFT PARENTHESIS
      "\x{0029}" => "\x29",        # RIGHT PARENTHESIS
      "\x{002A}" => "\x2A",        # ASTERISK
      "\x{002B}" => "\x2B",        # PLUS SIGN
      "\x{002C}" => "\x2C",        # COMMA
      "\x{002D}" => "\x2D",        # HYPHEN-MINUS
      "\x{002E}" => "\x2E",        # FULL STOP
      "\x{002F}" => "\x2F",        # SOLIDUS
      "\x{0030}" => "\x30",        # DIGIT ZERO
      "\x{0031}" => "\x31",        # DIGIT ONE
      "\x{0032}" => "\x32",        # DIGIT TWO
      "\x{0033}" => "\x33",        # DIGIT THREE
      "\x{0034}" => "\x34",        # DIGIT FOUR
      "\x{0035}" => "\x35",        # DIGIT FIVE
      "\x{0036}" => "\x36",        # DIGIT SIX
      "\x{0037}" => "\x37",        # DIGIT SEVEN
      "\x{0038}" => "\x38",        # DIGIT EIGHT
      "\x{0039}" => "\x39",        # DIGIT NINE
      "\x{003A}" => "\x3A",        # COLON
      "\x{003B}" => "\x3B",        # SEMICOLON
      "\x{003C}" => "\x3C",        # LESS-THAN SIGN
      "\x{003D}" => "\x3D",        # EQUALS SIGN
      "\x{003E}" => "\x3E",        # GREATER-THAN SIGN
      "\x{003F}" => "\x3F",        # QUESTION MARK
      "\x{0041}" => "\x41",        # LATIN CAPITAL LETTER A
      "\x{0042}" => "\x42",        # LATIN CAPITAL LETTER B
      "\x{0043}" => "\x43",        # LATIN CAPITAL LETTER C
      "\x{0044}" => "\x44",        # LATIN CAPITAL LETTER D
      "\x{0045}" => "\x45",        # LATIN CAPITAL LETTER E
      "\x{0046}" => "\x46",        # LATIN CAPITAL LETTER F
      "\x{0047}" => "\x47",        # LATIN CAPITAL LETTER G
      "\x{0048}" => "\x48",        # LATIN CAPITAL LETTER H
      "\x{0049}" => "\x49",        # LATIN CAPITAL LETTER I
      "\x{004A}" => "\x4A",        # LATIN CAPITAL LETTER J
      "\x{004B}" => "\x4B",        # LATIN CAPITAL LETTER K
      "\x{004C}" => "\x4C",        # LATIN CAPITAL LETTER L
      "\x{004D}" => "\x4D",        # LATIN CAPITAL LETTER M
      "\x{004E}" => "\x4E",        # LATIN CAPITAL LETTER N
      "\x{004F}" => "\x4F",        # LATIN CAPITAL LETTER O
      "\x{0050}" => "\x50",        # LATIN CAPITAL LETTER P
      "\x{0051}" => "\x51",        # LATIN CAPITAL LETTER Q
      "\x{0052}" => "\x52",        # LATIN CAPITAL LETTER R
      "\x{0053}" => "\x53",        # LATIN CAPITAL LETTER S
      "\x{0054}" => "\x54",        # LATIN CAPITAL LETTER T
      "\x{0055}" => "\x55",        # LATIN CAPITAL LETTER U
      "\x{0056}" => "\x56",        # LATIN CAPITAL LETTER V
      "\x{0057}" => "\x57",        # LATIN CAPITAL LETTER W
      "\x{0058}" => "\x58",        # LATIN CAPITAL LETTER X
      "\x{0059}" => "\x59",        # LATIN CAPITAL LETTER Y
      "\x{005A}" => "\x5A",        # LATIN CAPITAL LETTER Z
      "\x{005F}" => "\x11",        # LOW LINE
      "\x{0061}" => "\x61",        # LATIN SMALL LETTER A
      "\x{0062}" => "\x62",        # LATIN SMALL LETTER B
      "\x{0063}" => "\x63",        # LATIN SMALL LETTER C
      "\x{0064}" => "\x64",        # LATIN SMALL LETTER D
      "\x{0065}" => "\x65",        # LATIN SMALL LETTER E
      "\x{0066}" => "\x66",        # LATIN SMALL LETTER F
      "\x{0067}" => "\x67",        # LATIN SMALL LETTER G
      "\x{0068}" => "\x68",        # LATIN SMALL LETTER H
      "\x{0069}" => "\x69",        # LATIN SMALL LETTER I
      "\x{006A}" => "\x6A",        # LATIN SMALL LETTER J
      "\x{006B}" => "\x6B",        # LATIN SMALL LETTER K
      "\x{006C}" => "\x6C",        # LATIN SMALL LETTER L
      "\x{006D}" => "\x6D",        # LATIN SMALL LETTER M
      "\x{006E}" => "\x6E",        # LATIN SMALL LETTER N
      "\x{006F}" => "\x6F",        # LATIN SMALL LETTER O
      "\x{0070}" => "\x70",        # LATIN SMALL LETTER P
      "\x{0071}" => "\x71",        # LATIN SMALL LETTER Q
      "\x{0072}" => "\x72",        # LATIN SMALL LETTER R
      "\x{0073}" => "\x73",        # LATIN SMALL LETTER S
      "\x{0074}" => "\x74",        # LATIN SMALL LETTER T
      "\x{0075}" => "\x75",        # LATIN SMALL LETTER U
      "\x{0076}" => "\x76",        # LATIN SMALL LETTER V
      "\x{0077}" => "\x77",        # LATIN SMALL LETTER W
      "\x{0078}" => "\x78",        # LATIN SMALL LETTER X
      "\x{0079}" => "\x79",        # LATIN SMALL LETTER Y
      "\x{007A}" => "\x7A",        # LATIN SMALL LETTER Z
      "\x{000C}" => "\x1B\x0A",    # FORM FEED
      "\x{005B}" => "\x1B\x3C",    # LEFT SQUARE BRACKET
      "\x{005C}" => "\x1B\x2F",    # REVERSE SOLIDUS
      "\x{005D}" => "\x1B\x3E",    # RIGHT SQUARE BRACKET
      "\x{005E}" => "\x1B\x14",    # CIRCUMFLEX ACCENT
      "\x{007B}" => "\x1B\x28",    # LEFT CURLY BRACKET
      "\x{007C}" => "\x1B\x40",    # VERTICAL LINE
      "\x{007D}" => "\x1B\x29",    # RIGHT CURLY BRACKET
      "\x{007E}" => "\x1B\x3D",    # TILDE
      "\x{00A0}" => "\x1B",        # NO-BREAK SPACE
      "\x{00A1}" => "\x40",        # INVERTED EXCLAMATION MARK
      "\x{00A3}" => "\x01",        # POUND SIGN
      "\x{00A4}" => "\x24",        # CURRENCY SIGN
      "\x{00A5}" => "\x03",        # YEN SIGN
      "\x{00A7}" => "\x5F",        # SECTION SIGN
      "\x{00BF}" => "\x60",        # INVERTED QUESTION MARK
      "\x{00C4}" => "\x5B",        # LATIN CAPITAL LETTER A WITH DIAERESIS
      "\x{00C5}" => "\x0E",        # LATIN CAPITAL LETTER A WITH RING ABOVE
      "\x{00C6}" => "\x1C",        # LATIN CAPITAL LETTER AE
      "\x{00C9}" => "\x1F",        # LATIN CAPITAL LETTER E WITH ACUTE
      "\x{00D1}" => "\x5D",        # LATIN CAPITAL LETTER N WITH TILDE
      "\x{00D6}" => "\x5C",        # LATIN CAPITAL LETTER O WITH DIAERESIS
      "\x{00D8}" => "\x0B",        # LATIN CAPITAL LETTER O WITH STROKE
      "\x{00DC}" => "\x5E",        # LATIN CAPITAL LETTER U WITH DIAERESIS
      "\x{00DF}" => "\x1E",        # LATIN SMALL LETTER SHARP S
      "\x{00E0}" => "\x7F",        # LATIN SMALL LETTER A WITH GRAVE
      "\x{00E4}" => "\x7B",        # LATIN SMALL LETTER A WITH DIAERESIS
      "\x{00E5}" => "\x0F",        # LATIN SMALL LETTER A WITH RING ABOVE
      "\x{00E6}" => "\x1D",        # LATIN SMALL LETTER AE
      #"\x{00E7}" => "\x09",        # LATIN SMALL LETTER C WITH CEDILLA
      "\x{00C7}" => "\x09",        # LATIN CAPITAL LETTER C WITH CEDILLA
      "\x{00E8}" => "\x04",        # LATIN SMALL LETTER E WITH GRAVE
      "\x{00E9}" => "\x05",        # LATIN SMALL LETTER E WITH ACUTE
      "\x{00EC}" => "\x07",        # LATIN SMALL LETTER I WITH GRAVE
      "\x{00F1}" => "\x7D",        # LATIN SMALL LETTER N WITH TILDE
      "\x{00F2}" => "\x08",        # LATIN SMALL LETTER O WITH GRAVE
      "\x{00F6}" => "\x7C",        # LATIN SMALL LETTER O WITH DIAERESIS
      "\x{00F8}" => "\x0C",        # LATIN SMALL LETTER O WITH STROKE
      "\x{00F9}" => "\x06",        # LATIN SMALL LETTER U WITH GRAVE
      "\x{00FC}" => "\x7E",        # LATIN SMALL LETTER U WITH DIAERESIS
      "\x{0393}" => "\x13",        # GREEK CAPITAL LETTER GAMMA
      "\x{0394}" => "\x10",        # GREEK CAPITAL LETTER DELTA
      "\x{0398}" => "\x19",        # GREEK CAPITAL LETTER THETA
      "\x{039B}" => "\x14",        # GREEK CAPITAL LETTER LAMDA
      "\x{039E}" => "\x1A",        # GREEK CAPITAL LETTER XI
      "\x{03A0}" => "\x16",        # GREEK CAPITAL LETTER PI
      "\x{03A3}" => "\x18",        # GREEK CAPITAL LETTER SIGMA
      "\x{03A6}" => "\x12",        # GREEK CAPITAL LETTER PHI
      "\x{03A8}" => "\x17",        # GREEK CAPITAL LETTER PSI
      "\x{03A9}" => "\x15",        # GREEK CAPITAL LETTER OMEGA
      "\x{20AC}" => "\x1B\x65",    # EURO SIGN
  );
  our %GSM2UNI = reverse %UNI2GSM;
  our $ESC    = "\x1b";
  our $ATMARK = "\x40";
  our $FBCHAR = "\x3F";
  our $NBSP   = "\x{00A0}";
  
  #define ERR_DECODE_NOMAP "%s \"\\x%02" UVXf "\" does not map to Unicode"
  
  sub decode ($$;$) {
      my ( $obj, $bytes, $chk ) = @_;
      return undef unless defined $bytes;
      my $str = substr($bytes, 0, 0); # to propagate taintedness;
      while ( length $bytes ) {
          my $c = substr( $bytes, 0, 1, '' );
          my $u;
          if ( $c eq "\x00" ) {
              my $c2 = substr( $bytes, 0, 1, '' );
              $u =
                  !length $c2 ? $ATMARK
                : $c2 eq "\x00" ? "\x{0000}"
                : exists $GSM2UNI{$c2} ? $ATMARK . $GSM2UNI{$c2}
                : $chk
                ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
  			       ord($c), ord($c2) )
                : $ATMARK . $FBCHAR;
  
          }
          elsif ( $c eq $ESC ) {
              my $c2 = substr( $bytes, 0, 1, '' );
              $u =
                  exists $GSM2UNI{ $c . $c2 } ? $GSM2UNI{ $c . $c2 }
                : exists $GSM2UNI{$c2}        ? $NBSP . $GSM2UNI{$c2}
                : $chk
                ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
  			       ord($c), ord($c2) )
                : $NBSP . $FBCHAR;
          }
          else {
              $u =
                exists $GSM2UNI{$c}
                ? $GSM2UNI{$c}
                : $chk ? ref $chk eq 'CODE'
                    ? $chk->( ord $c )
                    : croak sprintf( "\\x%02X does not map to Unicode", ord($c) )
                : $FBCHAR;
          }
          $str .= $u;
      }
      $_[1] = $bytes if $chk;
      return $str;
  }
  
  #define ERR_ENCODE_NOMAP "\"\\x{%04" UVxf "}\" does not map to %s"
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $bytes = substr($str, 0, 0); # to propagate taintedness
      while ( length $str ) {
          my $u = substr( $str, 0, 1, '' );
          my $c;
          $bytes .=
            exists $UNI2GSM{$u}
            ? $UNI2GSM{$u}
            : $chk ? ref $chk eq 'CODE'
                ? $chk->( ord($u) )
                : croak sprintf( "\\x{%04x} does not map to %s", 
  			       ord($u), $obj->name )
            : $FBCHAR;
      }
      $_[1] = $str if $chk;
      return $bytes;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::GSM0338 -- ESTI GSM 03.38 Encoding
  
  =head1 SYNOPSIS
  
    use Encode qw/encode decode/; 
    $gsm0338 = encode("gsm0338", $utf8);    # loads Encode::GSM0338 implicitly
    $utf8    = decode("gsm0338", $gsm0338); # ditto
  
  =head1 DESCRIPTION
  
  GSM0338 is for GSM handsets. Though it shares alphanumerals with ASCII,
  control character ranges and other parts are mapped very differently,
  mainly to store Greek characters.  There are also escape sequences
  (starting with 0x1B) to cover e.g. the Euro sign.
  
  This was once handled by L<Encode::Bytes> but because of all those
  unusual specifications, Encode 2.20 has relocated the support to
  this module.
  
  =head1 NOTES
  
  Unlike most other encodings,  the following always croaks on error
  for any $chk that evaluates to true.
  
    $gsm0338 = encode("gsm0338", $utf8      $chk);
    $utf8    = decode("gsm0338", $gsm0338,  $chk);
  
  So if you want to check the validity of the encoding, surround the
  expression with C<eval {}> block as follows;
  
    eval {
      $utf8    = decode("gsm0338", $gsm0338,  $chk);
    } or do {
      # handle exception here
    };
  
  =head1 BUGS
  
  ESTI GSM 03.38 Encoding itself.
  
  Mapping \x00 to '@' causes too much pain everywhere.
  
  Its use of \x1b (escape) is also very questionable.  
  
  Because of those two, the code paging approach used use in ucm-based
  Encoding SOMETIMES fails so this module was written.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX_ENCODE_GSM0338

$fatpacked{"x86_64-linux/Encode/Guess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_GUESS';
  package Encode::Guess;
  use strict;
  use warnings;
  use Encode qw(:fallbacks find_encoding);
  our $VERSION = do { my @r = ( q$Revision: 2.7 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  my $Canon = 'Guess';
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  our %DEF_SUSPECTS = map { $_ => find_encoding($_) } qw(ascii utf8);
  my $obj = bless {
      Name     => $Canon,
      Suspects => {%DEF_SUSPECTS},
  } => __PACKAGE__;
  Encode::define_encoding($obj, $Canon);
  
  use parent qw(Encode::Encoding);
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  our @EXPORT         = qw(guess_encoding);
  our $NoUTFAutoGuess = 0;
  our $UTF8_BOM       = pack( "C3", 0xef, 0xbb, 0xbf );
  
  sub import {    # Exporter not used so we do it on our own
      my $callpkg = caller;
      for my $item (@EXPORT) {
          no strict 'refs';
          *{"$callpkg\::$item"} = \&{"$item"};
      }
      set_suspects(@_);
  }
  
  sub set_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      $self->{Suspects} = {%DEF_SUSPECTS};
      $self->add_suspects(@_);
  }
  
  sub add_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $self->{Suspects}{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
  }
  
  sub decode($$;$) {
      my ( $obj, $octet, $chk ) = @_;
      my $guessed = guess( $obj, $octet );
      unless ( ref($guessed) ) {
          require Carp;
          Carp::croak($guessed);
      }
      my $utf8 = $guessed->decode( $octet, $chk || 0 );
      $_[1] = $octet if $chk;
      return $utf8;
  }
  
  sub guess_encoding {
      guess( $Encode::Encoding{$Canon}, @_ );
  }
  
  sub guess {
      my $class = shift;
      my $obj   = ref($class) ? $class : $Encode::Encoding{$Canon};
      my $octet = shift;
  
      # sanity check
      return "Empty string, empty guess" unless defined $octet and length $octet;
  
      # cheat 0: utf8 flag;
      if ( Encode::is_utf8($octet) ) {
          return find_encoding('utf8') unless $NoUTFAutoGuess;
          Encode::_utf8_off($octet);
      }
  
      # cheat 1: BOM
      use Encode::Unicode;
      unless ($NoUTFAutoGuess) {
          my $BOM = pack( 'C3', unpack( "C3", $octet ) );
          return find_encoding('utf8')
            if ( defined $BOM and $BOM eq $UTF8_BOM );
          $BOM = unpack( 'N', $octet );
          return find_encoding('UTF-32')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe0000 ) );
          $BOM = unpack( 'n', $octet );
          return find_encoding('UTF-16')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe ) );
          if ( $octet =~ /\x00/o )
          {    # if \x00 found, we assume UTF-(16|32)(BE|LE)
              my $utf;
              my ( $be, $le ) = ( 0, 0 );
              if ( $octet =~ /\x00\x00/o ) {    # UTF-32(BE|LE) assumed
                  $utf = "UTF-32";
                  for my $char ( unpack( 'N*', $octet ) ) {
                      $char & 0x0000ffff and $be++;
                      $char & 0xffff0000 and $le++;
                  }
              }
              else {                            # UTF-16(BE|LE) assumed
                  $utf = "UTF-16";
                  for my $char ( unpack( 'n*', $octet ) ) {
                      $char & 0x00ff and $be++;
                      $char & 0xff00 and $le++;
                  }
              }
              DEBUG and warn "$utf, be == $be, le == $le";
              $be == $le
                and return
                "Encodings ambiguous between $utf BE and LE ($be, $le)";
              $utf .= ( $be > $le ) ? 'BE' : 'LE';
              return find_encoding($utf);
          }
      }
      my %try = %{ $obj->{Suspects} };
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $try{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
      my $nline = 1;
      for my $line ( split /\r\n?|\n/, $octet ) {
  
          # cheat 2 -- \e in the string
          if ( $line =~ /\e/o ) {
              my @keys = keys %try;
              delete @try{qw/utf8 ascii/};
              for my $k (@keys) {
                  ref( $try{$k} ) eq 'Encode::XS' and delete $try{$k};
              }
          }
          my %ok = %try;
  
          # warn join(",", keys %try);
          for my $k ( keys %try ) {
              my $scratch = $line;
              $try{$k}->decode( $scratch, FB_QUIET );
              if ( $scratch eq '' ) {
                  DEBUG and warn sprintf( "%4d:%-24s ok\n", $nline, $k );
              }
              else {
                  use bytes ();
                  DEBUG
                    and warn sprintf( "%4d:%-24s not ok; %d bytes left\n",
                      $nline, $k, bytes::length($scratch) );
                  delete $ok{$k};
              }
          }
          %ok or return "No appropriate encodings found!";
          if ( scalar( keys(%ok) ) == 1 ) {
              my ($retval) = values(%ok);
              return $retval;
          }
          %try = %ok;
          $nline++;
      }
      $try{ascii}
        or return "Encodings too ambiguous: ", join( " or ", keys %try );
      return $try{ascii};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Guess -- Guesses encoding from data
  
  =head1 SYNOPSIS
  
    # if you are sure $data won't contain anything bogus
  
    use Encode;
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
    my $utf8 = decode("Guess", $data);
    my $data = encode("Guess", $utf8);   # this doesn't work!
  
    # more elaborate way
    use Encode::Guess;
    my $enc = guess_encoding($data, qw/euc-jp shiftjis 7bit-jis/);
    ref($enc) or die "Can't guess: $enc"; # trap error this way
    $utf8 = $enc->decode($data);
    # or
    $utf8 = decode($enc->name, $data)
  
  =head1 ABSTRACT
  
  Encode::Guess enables you to guess in what encoding a given data is
  encoded, or at least tries to.  
  
  =head1 DESCRIPTION
  
  By default, it checks only ascii, utf8 and UTF-16/32 with BOM.
  
    use Encode::Guess; # ascii/utf8/BOMed UTF
  
  To use it more practically, you have to give the names of encodings to
  check (I<suspects> as follows).  The name of suspects can either be
  canonical names or aliases.
  
  CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.
  
   # tries all major Japanese Encodings as well
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
  
  If the C<$Encode::Guess::NoUTFAutoGuess> variable is set to a true
  value, no heuristics will be applied to UTF8/16/32, and the result
  will be limited to the suspects and C<ascii>.
  
  =over 4
  
  =item Encode::Guess->set_suspects
  
  You can also change the internal suspects list via C<set_suspects>
  method. 
  
    use Encode::Guess;
    Encode::Guess->set_suspects(qw/euc-jp shiftjis 7bit-jis/);
  
  =item Encode::Guess->add_suspects
  
  Or you can use C<add_suspects> method.  The difference is that
  C<set_suspects> flushes the current suspects list while
  C<add_suspects> adds.
  
    use Encode::Guess;
    Encode::Guess->add_suspects(qw/euc-jp shiftjis 7bit-jis/);
    # now the suspects are euc-jp,shiftjis,7bit-jis, AND
    # euc-kr,euc-cn, and big5-eten
    Encode::Guess->add_suspects(qw/euc-kr euc-cn big5-eten/);
  
  =item Encode::decode("Guess" ...)
  
  When you are content with suspects list, you can now
  
    my $utf8 = Encode::decode("Guess", $data);
  
  =item Encode::Guess->guess($data)
  
  But it will croak if:
  
  =over
  
  =item *
  
  Two or more suspects remain
  
  =item *
  
  No suspects left
  
  =back
  
  So you should instead try this;
  
    my $decoder = Encode::Guess->guess($data);
  
  On success, $decoder is an object that is documented in
  L<Encode::Encoding>.  So you can now do this;
  
    my $utf8 = $decoder->decode($data);
  
  On failure, $decoder now contains an error message so the whole thing
  would be as follows;
  
    my $decoder = Encode::Guess->guess($data);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
  
  =item guess_encoding($data, [, I<list of suspects>])
  
  You can also try C<guess_encoding> function which is exported by
  default.  It takes $data to check and it also takes the list of
  suspects by option.  The optional suspect list is I<not reflected> to
  the internal suspects list.
  
    my $decoder = guess_encoding($data, qw/euc-jp euc-kr euc-cn/);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
    # check only ascii, utf8 and UTF-(16|32) with BOM
    my $decoder = guess_encoding($data);
  
  =back
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  Because of the algorithm used, ISO-8859 series and other single-byte
  encodings do not work well unless either one of ISO-8859 is the only
  one suspect (besides ascii and utf8).
  
    use Encode::Guess;
    # perhaps ok
    my $decoder = guess_encoding($data, 'latin1');
    # definitely NOT ok
    my $decoder = guess_encoding($data, qw/latin1 greek/);
  
  The reason is that Encode::Guess guesses encoding by trial and error.
  It first splits $data into lines and tries to decode the line for each
  suspect.  It keeps it going until all but one encoding is eliminated
  out of suspects list.  ISO-8859 series is just too successful for most
  cases (because it fills almost all code points in \x00-\xff).
  
  =item *
  
  Do not mix national standard encodings and the corresponding vendor
  encodings.
  
    # a very bad idea
    my $decoder
       = guess_encoding($data, qw/shiftjis MacJapanese cp932/);
  
  The reason is that vendor encoding is usually a superset of national
  standard so it becomes too ambiguous for most cases.
  
  =item *
  
  On the other hand, mixing various national standard encodings
  automagically works unless $data is too short to allow for guessing.
  
   # This is ok if $data is long enough
   my $decoder =  
    guess_encoding($data, qw/euc-cn
                             euc-jp shiftjis 7bit-jis
                             euc-kr
                             big5-eten/);
  
  =item *
  
  DO NOT PUT TOO MANY SUSPECTS!  Don't you try something like this!
  
    my $decoder = guess_encoding($data, 
                                 Encode->encodings(":all"));
  
  =back
  
  It is, after all, just a guess.  You should alway be explicit when it
  comes to encodings.  But there are some, especially Japanese,
  environment that guess-coding is a must.  Use this module with care. 
  
  =head1 TO DO
  
  Encode::Guess does not work on EBCDIC platforms.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Encoding>
  
  =cut
  
X86_64-LINUX_ENCODE_GUESS

$fatpacked{"x86_64-linux/Encode/JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_JP';
  package Encode::JP;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::JP not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::JP::JIS7;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::JP - Japanese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_jp = encode("euc-jp", $utf8);   # loads Encode::JP implicitly
      $utf8   = decode("euc-jp", $euc_jp); # ditto
  
  =head1 ABSTRACT
  
  This module implements Japanese charset encodings.  Encodings
  supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-jp      /\beuc.*jp$/i	EUC (Extended Unix Character)
                /\bjp.*euc/i   
            /\bujis$/i
    shiftjis    /\bshift.*jis$/i	Shift JIS (aka MS Kanji)
            /\bsjis$/i
    7bit-jis    /\bjis$/i		7bit JIS
    iso-2022-jp			ISO-2022-JP                  [RFC1468]
                  = 7bit JIS with all Halfwidth Kana 
                    converted to Fullwidth
    iso-2022-jp-1			ISO-2022-JP-1                [RFC2237]
                                  = ISO-2022-JP with JIS X 0212-1990
                    support.  See below
    MacJapanese	                Shift JIS + Apple vendor mappings
    cp932       /\bwindows-31j$/i Code Page 932
                                  = Shift JIS + MS/IBM vendor mappings
    jis0201-raw                   JIS0201, raw format
    jis0208-raw                   JIS0201, raw format
    jis0212-raw                   JIS0201, raw format
    --------------------------------------------------------------------
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 Note on ISO-2022-JP(-1)?
  
  ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which
  adds support for JIS X 0212-1990.  That means you can use the same
  code to decode to utf8 but not vice versa.
  
    $utf8 = decode('iso-2022-jp-1', $stream);
  
  and
  
    $utf8 = decode('iso-2022-jp',   $stream);
  
  yield the same result but
  
    $with_0212 = encode('iso-2022-jp-1', $utf8);
  
  is now different from
  
    $without_0212 = encode('iso-2022-jp', $utf8 );
  
  In the latter case, characters that map to 0212 are first converted
  to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or
  'geta mark') then fed to the decoding engine.  U+FFFD is not used,
  in order to preserve text layout as much as possible.
  
  =head1 BUGS
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX_ENCODE_JP

$fatpacked{"x86_64-linux/Encode/JP/H2Z.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_JP_H2Z';
  #
  # $Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::JP::H2Z;
  
  use strict;
  use warnings;
  
  our $RCSID = q$Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode::CJKConstants qw(:all);
  
  use vars qw(%_D2Z  $_PAT_D2Z
    %_Z2D  $_PAT_Z2D
    %_H2Z  $_PAT_H2Z
    %_Z2H  $_PAT_Z2H);
  
  %_H2Z = (
      "\x8e\xa1" => "\xa1\xa3",    #
      "\x8e\xa2" => "\xa1\xd6",    #
      "\x8e\xa3" => "\xa1\xd7",    #
      "\x8e\xa4" => "\xa1\xa2",    #
      "\x8e\xa5" => "\xa1\xa6",    #
      "\x8e\xa6" => "\xa5\xf2",    #
      "\x8e\xa7" => "\xa5\xa1",    #
      "\x8e\xa8" => "\xa5\xa3",    #
      "\x8e\xa9" => "\xa5\xa5",    #
      "\x8e\xaa" => "\xa5\xa7",    #
      "\x8e\xab" => "\xa5\xa9",    #
      "\x8e\xac" => "\xa5\xe3",    #
      "\x8e\xad" => "\xa5\xe5",    #
      "\x8e\xae" => "\xa5\xe7",    #
      "\x8e\xaf" => "\xa5\xc3",    #
      "\x8e\xb0" => "\xa1\xbc",    #
      "\x8e\xb1" => "\xa5\xa2",    #
      "\x8e\xb2" => "\xa5\xa4",    #
      "\x8e\xb3" => "\xa5\xa6",    #
      "\x8e\xb4" => "\xa5\xa8",    #
      "\x8e\xb5" => "\xa5\xaa",    #
      "\x8e\xb6" => "\xa5\xab",    #
      "\x8e\xb7" => "\xa5\xad",    #
      "\x8e\xb8" => "\xa5\xaf",    #
      "\x8e\xb9" => "\xa5\xb1",    #
      "\x8e\xba" => "\xa5\xb3",    #
      "\x8e\xbb" => "\xa5\xb5",    #
      "\x8e\xbc" => "\xa5\xb7",    #
      "\x8e\xbd" => "\xa5\xb9",    #
      "\x8e\xbe" => "\xa5\xbb",    #
      "\x8e\xbf" => "\xa5\xbd",    #
      "\x8e\xc0" => "\xa5\xbf",    #
      "\x8e\xc1" => "\xa5\xc1",    #
      "\x8e\xc2" => "\xa5\xc4",    #
      "\x8e\xc3" => "\xa5\xc6",    #
      "\x8e\xc4" => "\xa5\xc8",    #
      "\x8e\xc5" => "\xa5\xca",    #
      "\x8e\xc6" => "\xa5\xcb",    #
      "\x8e\xc7" => "\xa5\xcc",    #
      "\x8e\xc8" => "\xa5\xcd",    #
      "\x8e\xc9" => "\xa5\xce",    #
      "\x8e\xca" => "\xa5\xcf",    #
      "\x8e\xcb" => "\xa5\xd2",    #
      "\x8e\xcc" => "\xa5\xd5",    #
      "\x8e\xcd" => "\xa5\xd8",    #
      "\x8e\xce" => "\xa5\xdb",    #
      "\x8e\xcf" => "\xa5\xde",    #
      "\x8e\xd0" => "\xa5\xdf",    #
      "\x8e\xd1" => "\xa5\xe0",    #
      "\x8e\xd2" => "\xa5\xe1",    #
      "\x8e\xd3" => "\xa5\xe2",    #
      "\x8e\xd4" => "\xa5\xe4",    #
      "\x8e\xd5" => "\xa5\xe6",    #
      "\x8e\xd6" => "\xa5\xe8",    #
      "\x8e\xd7" => "\xa5\xe9",    #
      "\x8e\xd8" => "\xa5\xea",    #
      "\x8e\xd9" => "\xa5\xeb",    #
      "\x8e\xda" => "\xa5\xec",    #
      "\x8e\xdb" => "\xa5\xed",    #
      "\x8e\xdc" => "\xa5\xef",    #
      "\x8e\xdd" => "\xa5\xf3",    #
      "\x8e\xde" => "\xa1\xab",    #
      "\x8e\xdf" => "\xa1\xac",    #
  );
  
  %_D2Z = (
      "\x8e\xb6\x8e\xde" => "\xa5\xac",    #
      "\x8e\xb7\x8e\xde" => "\xa5\xae",    #
      "\x8e\xb8\x8e\xde" => "\xa5\xb0",    #
      "\x8e\xb9\x8e\xde" => "\xa5\xb2",    #
      "\x8e\xba\x8e\xde" => "\xa5\xb4",    #
      "\x8e\xbb\x8e\xde" => "\xa5\xb6",    #
      "\x8e\xbc\x8e\xde" => "\xa5\xb8",    #
      "\x8e\xbd\x8e\xde" => "\xa5\xba",    #
      "\x8e\xbe\x8e\xde" => "\xa5\xbc",    #
      "\x8e\xbf\x8e\xde" => "\xa5\xbe",    #
      "\x8e\xc0\x8e\xde" => "\xa5\xc0",    #
      "\x8e\xc1\x8e\xde" => "\xa5\xc2",    #
      "\x8e\xc2\x8e\xde" => "\xa5\xc5",    #
      "\x8e\xc3\x8e\xde" => "\xa5\xc7",    #
      "\x8e\xc4\x8e\xde" => "\xa5\xc9",    #
      "\x8e\xca\x8e\xde" => "\xa5\xd0",    #
      "\x8e\xcb\x8e\xde" => "\xa5\xd3",    #
      "\x8e\xcc\x8e\xde" => "\xa5\xd6",    #
      "\x8e\xcd\x8e\xde" => "\xa5\xd9",    #
      "\x8e\xce\x8e\xde" => "\xa5\xdc",    #
      "\x8e\xca\x8e\xdf" => "\xa5\xd1",    #
      "\x8e\xcb\x8e\xdf" => "\xa5\xd4",    #
      "\x8e\xcc\x8e\xdf" => "\xa5\xd7",    #
      "\x8e\xcd\x8e\xdf" => "\xa5\xda",    #
      "\x8e\xce\x8e\xdf" => "\xa5\xdd",    #
      "\x8e\xb3\x8e\xde" => "\xa5\xf4",    #
  );
  
  # init only once;
  
  #$_PAT_D2Z = join("|", keys %_D2Z);
  #$_PAT_H2Z = join("|", keys %_H2Z);
  
  %_Z2H = reverse %_H2Z;
  %_Z2D = reverse %_D2Z;
  
  #$_PAT_Z2H    = join("|", keys %_Z2H);
  #$_PAT_Z2D    = join("|", keys %_Z2D);
  
  sub h2z {
      no warnings qw(uninitialized);
      my $r_str          = shift;
      my ($keep_dakuten) = @_;
      my $n              = 0;
      unless ($keep_dakuten) {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA}
                  (?:\x8e[\xde\xdf])?)
                 ){
            my $str = $1;
            $_D2Z{$str} || $_H2Z{$str} || 
                # in case dakuten and handakuten are side-by-side!
                $_H2Z{substr($str,0,2)} . $_H2Z{substr($str,2,2)};
            }eogx
          );
      }
      else {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA})
                 ){
            $_H2Z{$1};
            }eogx
          );
      }
      $n;
  }
  
  sub z2h {
      my $r_str = shift;
      my $n     = (
          $$r_str =~ s(
                ($RE{EUC_C}|$RE{EUC_0212}|$RE{EUC_KANA})
                ){
           $_Z2D{$1} || $_Z2H{$1} || $1;
           }eogx
      );
      $n;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*
  
  =cut
X86_64-LINUX_ENCODE_JP_H2Z

$fatpacked{"x86_64-linux/Encode/JP/JIS7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_JP_JIS7';
  package Encode::JP::JIS7;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  for my $name ( '7bit-jis', 'iso-2022-jp', 'iso-2022-jp-1' ) {
      my $h2z     = ( $name eq '7bit-jis' )    ? 0 : 1;
      my $jis0212 = ( $name eq 'iso-2022-jp' ) ? 0 : 1;
  
      my $obj = bless {
          Name    => $name,
          h2z     => $h2z,
          jis0212 => $jis0212,
      } => __PACKAGE__;
      Encode::define_encoding($obj, $name);
  }
  
  use parent qw(Encode::Encoding);
  
  # we override this to 1 so PerlIO works
  sub needs_lines { 1 }
  
  use Encode::CJKConstants qw(:all);
  
  #
  # decode is identical for all 2022 variants
  #
  
  sub decode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $residue = '';
      if ($chk) {
          $str =~ s/([^\x00-\x7f].*)$//so and $residue = $1;
      }
      $residue .= jis_euc( \$str );
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-jp', $str, FB_PERLQQ );
  }
  
  #
  # encode is different
  #
  
  sub encode($$;$) {
      require Encode::JP::H2Z;
      my ( $obj, $utf8, $chk ) = @_;
      return undef unless defined $utf8;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my ( $h2z, $jis0212 ) = @$obj{qw(h2z jis0212)};
      my $octet = Encode::encode( 'euc-jp', $utf8, $chk || 0 );
      $h2z and &Encode::JP::H2Z::h2z( \$octet );
      euc_jis( \$octet, $jis0212 );
      return $octet;
  }
  
  #
  # cat_decode
  #
  my $re_scan_jis_g = qr{
     \G ( ($RE{JIS_0212}) |  $RE{JIS_0208}  |
          ($RE{ISO_ASC})  | ($RE{JIS_KANA}) | )
        ([^\e]*)
  }x;
  
  sub cat_decode {    # ($obj, $dst, $src, $pos, $trm, $chk)
      my ( $obj, undef, undef, $pos, $trm ) = @_;    # currently ignores $chk
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
      local ${^ENCODING};
      use bytes;
      my $opos = pos($$rsrc);
      pos($$rsrc) = $pos;
      while ( $$rsrc =~ /$re_scan_jis_g/gc ) {
          my ( $esc, $esc_0212, $esc_asc, $esc_kana, $chunk ) =
            ( $1, $2, $3, $4, $5 );
  
          unless ($chunk) { $esc or last; next; }
  
          if ( $esc && !$esc_asc ) {
              $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
              if ($esc_kana) {
                  $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
              }
              elsif ($esc_0212) {
                  $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
              }
              $chunk = Encode::decode( 'euc-jp', $chunk, 0 );
          }
          elsif ( ( my $npos = index( $chunk, $trm ) ) >= 0 ) {
              $$rdst .= substr( $chunk, 0, $npos + length($trm) );
              $$rpos += length($esc) + $npos + length($trm);
              pos($$rsrc) = $opos;
              return 1;
          }
          $$rdst .= $chunk;
          $$rpos = pos($$rsrc);
      }
      $$rpos = pos($$rsrc);
      pos($$rsrc) = $opos;
      return '';
  }
  
  # JIS<->EUC
  my $re_scan_jis = qr{
     (?:($RE{JIS_0212})|$RE{JIS_0208}|($RE{ISO_ASC})|($RE{JIS_KANA}))([^\e]*)
  }x;
  
  sub jis_euc {
      local ${^ENCODING};
      my $r_str = shift;
      $$r_str =~ s($re_scan_jis)
      {
      my ($esc_0212, $esc_asc, $esc_kana, $chunk) =
         ($1, $2, $3, $4);
      if (!$esc_asc) {
          $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
          if ($esc_kana) {
          $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
          }
          elsif ($esc_0212) {
          $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
          }
      }
      $chunk;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_jis {
      no warnings qw(uninitialized);
      local ${^ENCODING};
      my $r_str   = shift;
      my $jis0212 = shift;
      $$r_str =~ s{
      ((?:$RE{EUC_C})+|(?:$RE{EUC_KANA})+|(?:$RE{EUC_0212})+)
      }{
          my $chunk = $1;
          my $esc =
          ( $chunk =~ tr/\x8E//d ) ? $ESC{KANA} :
              ( $chunk =~ tr/\x8F//d ) ? $ESC{JIS_0212} :
              $ESC{JIS_0208};
          if ($esc eq $ESC{JIS_0212} && !$jis0212){
          # fallback to '?'
          $chunk =~ tr/\xA1-\xFE/\x3F/;
          }else{
          $chunk =~ tr/\xA1-\xFE/\x21-\x7E/;
          }
          $esc . $chunk . $ESC{ASC};
      }geox;
      $$r_str =~ s/\Q$ESC{ASC}\E
          (\Q$ESC{KANA}\E|\Q$ESC{JIS_0212}\E|\Q$ESC{JIS_0208}\E)/$1/gox;
      $$r_str;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::JIS7 -- internally used by Encode::JP
  
  =cut
X86_64-LINUX_ENCODE_JP_JIS7

$fatpacked{"x86_64-linux/Encode/KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_KR';
  package Encode::KR;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::KR not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::KR::2022_KR;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR - Korean Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_kr = encode("euc-kr", $utf8);   # loads Encode::KR implicitly
      $utf8   = decode("euc-kr", $euc_kr); # ditto
  
  =head1 DESCRIPTION
  
  This module implements Korean charset encodings.  Encodings supported
  are as follows.
  
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-kr      /\beuc.*kr$/i	EUC (Extended Unix Character)
            /\bkr.*euc$/i
    ksc5601-raw			Korean standard code set (as is)
    cp949	      /(?:x-)?uhc$/i
                /(?:x-)?windows-949$/i
                /\bks_c_5601-1987$/i
                                  Code Page 949 (EUC-KR + 8,822 
                                  (additional Hangul syllables)
    MacKorean			EUC-KR + Apple Vendor Mappings
    johab       JOHAB             A supplementary encoding defined in 
                                               Annex 3 of KS X 1001:1998
    iso-2022-kr                   iso-2022-kr                  [RFC1557]
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 BUGS
  
  When you see C<charset=ks_c_5601-1987> on mails and web pages, they really
  mean "cp949" encodings.  To fix that, the following aliases are set;
  
    qr/(?:x-)?uhc$/i         => '"cp949"'
    qr/(?:x-)?windows-949$/i => '"cp949"'
    qr/ks_c_5601-1987$/i     => '"cp949"'
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX_ENCODE_KR

$fatpacked{"x86_64-linux/Encode/KR/2022_KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_KR_2022_KR';
  package Encode::KR::2022_KR;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('iso-2022-kr');
  
  sub needs_lines { 1 }
  
  sub perlio_ok {
      return 0;    # for the time being
  }
  
  sub decode {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $res     = $str;
      my $residue = iso_euc( \$res );
  
      # This is for PerlIO
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-kr', $res, FB_PERLQQ );
  }
  
  sub encode {
      my ( $obj, $utf8, $chk ) = @_;
      return undef unless defined $utf8;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my $octet = Encode::encode( 'euc-kr', $utf8, FB_PERLQQ );
      euc_iso( \$octet );
      return $octet;
  }
  
  use Encode::CJKConstants qw(:all);
  
  # ISO<->EUC
  
  sub iso_euc {
      my $r_str = shift;
      $$r_str =~ s/$RE{'2022_KR'}//gox;    # remove the designator
      $$r_str =~ s{                      # replace characters in GL
       \x0e                              # between SO(\x0e) and SI(\x0f)
       ([^\x0f]*)                        # with characters in GR
       \x0f
          }
      {
                          my $out= $1;
        $out =~ tr/\x21-\x7e/\xa1-\xfe/;
        $out;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_iso {
      no warnings qw(uninitialized);
      my $r_str = shift;
      substr( $$r_str, 0, 0 ) =
        $ESC{'2022_KR'};    # put the designator at the beg.
      $$r_str =~
        s{                         # move KS X 1001 characters in GR to GL
          ($RE{EUC_C}+)                     # and enclose them with SO and SI
          }{
              my $str = $1;
              $str =~ tr/\xA1-\xFE/\x21-\x7E/;
              "\x0e" . $str . "\x0f";
          }geox;
      $$r_str;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR::2022_KR -- internally used by Encode::KR
  
  =cut
X86_64-LINUX_ENCODE_KR_2022_KR

$fatpacked{"x86_64-linux/Encode/MIME/Header.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_MIME_HEADER';
  package Encode::MIME::Header;
  use strict;
  use warnings;
  
  our $VERSION = do { my @r = ( q$Revision: 2.28 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp ();
  use Encode ();
  use MIME::Base64 ();
  
  my %seed = (
      decode_b => 1,       # decodes 'B' encoding ?
      decode_q => 1,       # decodes 'Q' encoding ?
      encode   => 'B',     # encode with 'B' or 'Q' ?
      charset  => 'UTF-8', # encode charset
      bpl      => 75,      # bytes per line
  );
  
  my @objs;
  
  push @objs, bless {
      %seed,
      Name     => 'MIME-Header',
  } => __PACKAGE__;
  
  push @objs, bless {
      %seed,
      decode_q => 0,
      Name     => 'MIME-B',
  } => __PACKAGE__;
  
  push @objs, bless {
      %seed,
      decode_b => 0,
      encode   => 'Q',
      Name     => 'MIME-Q',
  } => __PACKAGE__;
  
  Encode::define_encoding($_, $_->{Name}) foreach @objs;
  
  use parent qw(Encode::Encoding);
  
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  # RFC 2047 and RFC 2231 grammar
  my $re_charset = qr/[!"#\$%&'+\-0-9A-Z\\\^_`a-z\{\|\}~]+/;
  my $re_language = qr/[A-Za-z]{1,8}(?:-[0-9A-Za-z]{1,8})*/;
  my $re_encoding = qr/[QqBb]/;
  my $re_encoded_text = qr/[^\?]*/;
  my $re_encoded_word = qr/=\?$re_charset(?:\*$re_language)?\?$re_encoding\?$re_encoded_text\?=/;
  my $re_capture_encoded_word = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding\?$re_encoded_text)\?=/;
  my $re_capture_encoded_word_split = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding)\?($re_encoded_text)\?=/;
  
  # in strict mode check also for valid base64 characters and also for valid quoted printable codes
  my $re_encoding_strict_b = qr/[Bb]/;
  my $re_encoding_strict_q = qr/[Qq]/;
  my $re_encoded_text_strict_b = qr/[0-9A-Za-z\+\/]*={0,2}/;
  my $re_encoded_text_strict_q = qr/(?:[\x21-\x3C\x3E\x40-\x7E]|=[0-9A-Fa-f]{2})*/; # NOTE: first part are printable US-ASCII except ?, =, SPACE and TAB
  my $re_encoded_word_strict = qr/=\?$re_charset(?:\*$re_language)?\?(?:$re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  my $re_capture_encoded_word_strict = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  
  my $re_newline = qr/(?:\r\n|[\r\n])/;
  
  # in strict mode encoded words must be always separated by spaces or tabs (or folded newline)
  # except in comments when separator between words and comment round brackets can be omitted
  my $re_word_begin_strict = qr/(?:(?:[ \t]|\A)\(?|(?:[^\\]|\A)\)\()/;
  my $re_word_sep_strict = qr/(?:$re_newline?[ \t])+/;
  my $re_word_end_strict = qr/(?:\)\(|\)?(?:$re_newline?[ \t]|\z))/;
  
  my $re_match = qr/()((?:$re_encoded_word\s*)*$re_encoded_word)()/;
  my $re_match_strict = qr/($re_word_begin_strict)((?:$re_encoded_word_strict$re_word_sep_strict)*$re_encoded_word_strict)(?=$re_word_end_strict)/;
  
  my $re_capture = qr/$re_capture_encoded_word(?:\s*)?/;
  my $re_capture_strict = qr/$re_capture_encoded_word_strict$re_word_sep_strict?/;
  
  our $STRICT_DECODE = 0;
  
  sub decode($$;$) {
      my ($obj, $str, $chk) = @_;
      return undef unless defined $str;
  
      my $re_match_decode = $STRICT_DECODE ? $re_match_strict : $re_match;
      my $re_capture_decode = $STRICT_DECODE ? $re_capture_strict : $re_capture;
  
      my $stop = 0;
      my $output = substr($str, 0, 0); # to propagate taintedness
  
      # decode each line separately, match whole continuous folded line at one call
      1 while not $stop and $str =~ s{^((?:[^\r\n]*(?:$re_newline[ \t])?)*)($re_newline)?}{
  
          my $line = $1;
          my $sep = defined $2 ? $2 : '';
  
          $stop = 1 unless length($line) or length($sep);
  
          # NOTE: this code partially could break $chk support
          # in non strict mode concat consecutive encoded mime words with same charset, language and encoding
          # fixes breaking inside multi-byte characters
          1 while not $STRICT_DECODE and $line =~ s/$re_capture_encoded_word_split\s*=\?\1\2\?\3\?($re_encoded_text)\?=/=\?$1$2\?$3\?$4$5\?=/so;
  
          # process sequence of encoded MIME words at once
          1 while not $stop and $line =~ s{^(.*?)$re_match_decode}{
  
              my $begin = $1 . $2;
              my $words = $3;
  
              $begin =~ tr/\r\n//d;
              $output .= $begin;
  
              # decode one MIME word
              1 while not $stop and $words =~ s{^(.*?)($re_capture_decode)}{
  
                  $output .= $1;
                  my $orig = $2;
                  my $charset = $3;
                  my ($mime_enc, $text) = split /\?/, $5;
  
                  $text =~ tr/\r\n//d;
  
                  my $enc = Encode::find_mime_encoding($charset);
  
                  # in non strict mode allow also perl encoding aliases
                  if ( not defined $enc and not $STRICT_DECODE ) {
                      # make sure that decoded string will be always strict UTF-8
                      $charset = 'UTF-8' if lc($charset) eq 'utf8';
                      $enc = Encode::find_encoding($charset);
                  }
  
                  if ( not defined $enc ) {
                      Carp::croak qq(Unknown charset "$charset") if not ref $chk and $chk and $chk & Encode::DIE_ON_ERR;
                      Carp::carp qq(Unknown charset "$charset") if not ref $chk and $chk and $chk & Encode::WARN_ON_ERR;
                      $stop = 1 if not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                      $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                      $stop ? $orig : '';
                  } else {
                      if ( uc($mime_enc) eq 'B' and $obj->{decode_b} ) {
                          my $decoded = _decode_b($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } elsif ( uc($mime_enc) eq 'Q' and $obj->{decode_q} ) {
                          my $decoded = _decode_q($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } else {
                          Carp::croak qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk and $chk & Encode::DIE_ON_ERR;
                          Carp::carp qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk and $chk & Encode::WARN_ON_ERR;
                          $stop = 1 if not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                          $stop ? $orig : '';
                      }
                  }
  
              }se;
  
              if ( not $stop ) {
                  $output .= $words;
                  $words = '';
              }
  
              $words;
  
          }se;
  
          if ( not $stop ) {
              $line =~ tr/\r\n//d;
              $output .= $line . $sep;
              $line = '';
              $sep = '';
          }
  
          $line . $sep;
  
      }se;
  
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output;
  }
  
  sub _decode_b {
      my ($enc, $text, $chk) = @_;
      # MIME::Base64::decode ignores everything after a '=' padding character
      # in non strict mode split string after each sequence of padding characters and decode each substring
      my $octets = $STRICT_DECODE ?
          MIME::Base64::decode($text) :
          join('', map { MIME::Base64::decode($_) } split /(?<==)(?=[^=])/, $text);
      return _decode_octets($enc, $octets, $chk);
  }
  
  sub _decode_q {
      my ($enc, $text, $chk) = @_;
      $text =~ s/_/ /go;
      $text =~ s/=([0-9A-Fa-f]{2})/pack('C', hex($1))/ego;
      return _decode_octets($enc, $text, $chk);
  }
  
  sub _decode_octets {
      my ($enc, $octets, $chk) = @_;
      $chk = 0 unless defined $chk;
      $chk &= ~Encode::LEAVE_SRC if not ref $chk and $chk;
      my $output = $enc->decode($octets, $chk);
      return undef if not ref $chk and $chk and $octets ne '';
      return $output;
  }
  
  sub encode($$;$) {
      my ($obj, $str, $chk) = @_;
      return undef unless defined $str;
      my $output = $obj->_fold_line($obj->_encode_string($str, $chk));
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output . substr($str, 0, 0); # to propagate taintedness
  }
  
  sub _fold_line {
      my ($obj, $line) = @_;
      my $bpl = $obj->{bpl};
      my $output = '';
  
      while ( length($line) ) {
          if ( $line =~ s/^(.{0,$bpl})(\s|\z)// ) {
              $output .= $1;
              $output .= "\r\n" . $2 if length($line);
          } elsif ( $line =~ s/(\s)(.*)$// ) {
              $output .= $line;
              $line = $2;
              $output .= "\r\n" . $1 if length($line);
          } else {
              $output .= $line;
              last;
          }
      }
  
      return $output;
  }
  
  sub _encode_string {
      my ($obj, $str, $chk) = @_;
      my $wordlen = $obj->{bpl} > 76 ? 76 : $obj->{bpl};
      my $enc = Encode::find_mime_encoding($obj->{charset});
      my $enc_chk = $chk;
      $enc_chk = 0 unless defined $enc_chk;
      $enc_chk |= Encode::LEAVE_SRC if not ref $enc_chk and $enc_chk;
      my @result = ();
      my $octets = '';
      while ( length( my $chr = substr($str, 0, 1, '') ) ) {
          my $seq = $enc->encode($chr, $enc_chk);
          if ( not length($seq) ) {
              substr($str, 0, 0, $chr);
              last;
          }
          if ( $obj->_encoded_word_len($octets . $seq) > $wordlen ) {
              push @result, $obj->_encode_word($octets);
              $octets = '';
          }
          $octets .= $seq;
      }
      length($octets) and push @result, $obj->_encode_word($octets);
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return join(' ', @result);
  }
  
  sub _encode_word {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text = $encode eq 'B' ? _encode_b($octets) : _encode_q($octets);
      return "=?$charset?$encode?$text?=";
  }
  
  sub _encoded_word_len {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text_len = $encode eq 'B' ? _encoded_b_len($octets) : _encoded_q_len($octets);
      return length("=?$charset?$encode??=") + $text_len;
  }
  
  sub _encode_b {
      my ($octets) = @_;
      return MIME::Base64::encode($octets, '');
  }
  
  sub _encoded_b_len {
      my ($octets) = @_;
      return ( length($octets) + 2 ) / 3 * 4;
  }
  
  my $re_invalid_q_char = qr/[^0-9A-Za-z !*+\-\/]/;
  
  sub _encode_q {
      my ($octets) = @_;
      $octets =~ s{($re_invalid_q_char)}{
          join('', map { sprintf('=%02X', $_) } unpack('C*', $1))
      }egox;
      $octets =~ s/ /_/go;
      return $octets;
  }
  
  sub _encoded_q_len {
      my ($octets) = @_;
      my $invalid_count = () = $octets =~ /$re_invalid_q_char/sgo;
      return ( $invalid_count * 3 ) + ( length($octets) - $invalid_count );
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::Header -- MIME encoding for an unstructured email header
  
  =head1 SYNOPSIS
  
      use Encode qw(encode decode);
  
      my $mime_str = encode("MIME-Header", "Sample:Text \N{U+263A}");
      # $mime_str is "=?UTF-8?B?U2FtcGxlOlRleHQg4pi6?="
  
      my $mime_q_str = encode("MIME-Q", "Sample:Text \N{U+263A}");
      # $mime_q_str is "=?UTF-8?Q?Sample=3AText_=E2=98=BA?="
  
      my $str = decode("MIME-Header",
          "=?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=\r\n " .
          "=?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?="
      );
      # $str is "If you can read this you understand the example."
  
      use Encode qw(decode :fallbacks);
      use Encode::MIME::Header;
      local $Encode::MIME::Header::STRICT_DECODE = 1;
      my $strict_string = decode("MIME-Header", $mime_string, FB_CROAK);
      # use strict decoding and croak on errors
  
  =head1 ABSTRACT
  
  This module implements L<RFC 2047|https://tools.ietf.org/html/rfc2047> MIME
  encoding for an unstructured field body of the email header.  It can also be
  used for L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token.  However,
  it cannot be used directly for the whole header with the field name or for the
  structured header fields like From, To, Cc, Message-Id, etc...  There are 3
  encoding names supported by this module: C<MIME-Header>, C<MIME-B> and
  C<MIME-Q>.
  
  =head1 DESCRIPTION
  
  Decode method takes an unstructured field body of the email header (or
  L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token) as its input and
  decodes each MIME encoded-word from input string to a sequence of bytes
  according to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Subsequently, each sequence
  of bytes with the corresponding MIME charset is decoded with
  L<the Encode module|Encode> and finally, one output string is returned.  Text
  parts of the input string which do not contain MIME encoded-word stay
  unmodified in the output string.  Folded newlines between two consecutive MIME
  encoded-words are discarded, others are preserved in the output string.
  C<MIME-B> can decode Base64 variant, C<MIME-Q> can decode Quoted-Printable
  variant and C<MIME-Header> can decode both of them.  If L<Encode module|Encode>
  does not support particular MIME charset or chosen variant then an action based
  on L<CHECK flags|Encode/Handling Malformed Data> is performed (by default, the
  MIME encoded-word is not decoded).
  
  Encode method takes a scalar string as its input and uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for encoding it to UTF-8
  bytes.  Then a sequence of UTF-8 bytes is encoded into MIME encoded-words
  (C<MIME-Header> and C<MIME-B> use a Base64 variant while C<MIME-Q> uses a
  Quoted-Printable variant) where each MIME encoded-word is limited to 75
  characters.  MIME encoded-words are separated by C<CRLF SPACE> and joined to
  one output string.  Output string is suitable for unstructured field body of
  the email header.
  
  Both encode and decode methods propagate
  L<CHECK flags|Encode/Handling Malformed Data> when encoding and decoding the
  MIME charset.
  
  =head1 BUGS
  
  Versions prior to 2.22 (part of Encode 2.83) have a malfunctioning decoder
  and encoder.  The MIME encoder infamously inserted additional spaces or
  discarded white spaces between consecutive MIME encoded-words, which led to
  invalid MIME headers produced by this module.  The MIME decoder had a tendency
  to discard white spaces, incorrectly interpret data or attempt to decode Base64
  MIME encoded-words as Quoted-Printable.  These problems were fixed in version
  2.22.  It is highly recommended not to use any version prior 2.22!
  
  Versions prior to 2.24 (part of Encode 2.87) ignored
  L<CHECK flags|Encode/Handling Malformed Data>.  The MIME encoder used
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for input Unicode
  strings which could lead to invalid UTF-8 sequences.  MIME decoder used also
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> decoder and additionally
  called the decode method with a C<Encode::FB_PERLQQ> flag (thus user-specified
  L<CHECK flags|Encode/Handling Malformed Data> were ignored).  Moreover, it
  automatically croaked when a MIME encoded-word contained unknown encoding.
  Since version 2.24, this module uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder and decoder.  And
  L<CHECK flags|Encode/Handling Malformed Data> are correctly propagated.
  
  Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully
  compliant to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Due to the aforementioned
  bugs in previous versions of the MIME encoder, there is a I<less strict>
  compatible mode for the MIME decoder which is used by default.  It should be
  able to decode MIME encoded-words encoded by pre 2.22 versions of this module.
  However, note that this is not correct according to
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>.
  
  In default I<not strict> mode the MIME decoder attempts to decode every substring
  which looks like a MIME encoded-word.  Therefore, the MIME encoded-words do not
  need to be separated by white space.  To enforce a correct I<strict> mode, set
  variable C<$Encode::MIME::Header::STRICT_DECODE> to 1 e.g. by localizing:
  
    use Encode::MIME::Header;
    local $Encode::MIME::Header::STRICT_DECODE = 1;
  
  =head1 AUTHORS
  
  Pali E<lt>pali@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<RFC 822|https://tools.ietf.org/html/rfc822>,
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>,
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>
  
  =cut
X86_64-LINUX_ENCODE_MIME_HEADER

$fatpacked{"x86_64-linux/Encode/MIME/Header/ISO_2022_JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_MIME_HEADER_ISO_2022_JP';
  package Encode::MIME::Header::ISO_2022_JP;
  
  use strict;
  use warnings;
  
  use parent qw(Encode::MIME::Header);
  
  my $obj =
    bless { decode_b => '1', decode_q => '1', encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
    __PACKAGE__;
  Encode::define_encoding($obj, 'MIME-Header-ISO_2022_JP');
  
  use constant HEAD => '=?ISO-2022-JP?B?';
  use constant TAIL => '?=';
  
  use Encode::CJKConstants qw(%RE);
  
  our $VERSION = do { my @r = ( q$Revision: 1.9 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # I owe the below codes totally to
  #   Jcode by Dan Kogai & http://www.din.or.jp/~ohzaki/perl.htm#JP_Base64
  
  sub encode {
      my $self = shift;
      my $str  = shift;
      return undef unless defined $str;
  
      utf8::encode($str) if ( Encode::is_utf8($str) );
      Encode::from_to( $str, 'utf8', 'euc-jp' );
  
      my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );
  
      $str = _mime_unstructured_header( $str, $self->{bpl} );
  
      not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;
  
      return $str;
  }
  
  sub _mime_unstructured_header {
      my ( $oldheader, $bpl ) = @_;
      my $crlf = $oldheader =~ /\n$/;
      my ( $header, @words, @wordstmp, $i ) = ('');
  
      $oldheader =~ s/\s+$//;
  
      @wordstmp = split /\s+/, $oldheader;
  
      for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
          if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
              and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
          {
              $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
          }
          else {
              push( @words, $wordstmp[$i] );
          }
      }
  
      push( @words, $wordstmp[-1] );
  
      for my $word (@words) {
          if ( $word =~ /^[\x21-\x7E]+$/ ) {
              $header =~ /(?:.*\n)*(.*)/;
              if ( length($1) + length($word) > $bpl ) {
                  $header .= "\n $word";
              }
              else {
                  $header .= $word;
              }
          }
          else {
              $header = _add_encoded_word( $word, $header, $bpl );
          }
  
          $header =~ /(?:.*\n)*(.*)/;
  
          if ( length($1) == $bpl ) {
              $header .= "\n ";
          }
          else {
              $header .= ' ';
          }
      }
  
      $header =~ s/\n? $//mg;
  
      $crlf ? "$header\n" : $header;
  }
  
  sub _add_encoded_word {
      my ( $str, $line, $bpl ) = @_;
      my $result = '';
  
      while ( length($str) ) {
          my $target = $str;
          $str = '';
  
          if (
              length($line) + 22 +
              ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
          {
              $line =~ s/[ \t\n\r]*$/\n/;
              $result .= $line;
              $line = ' ';
          }
  
          while (1) {
              my $iso_2022_jp = $target;
              Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );
  
              my $encoded =
                HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;
  
              if ( length($encoded) + length($line) > $bpl ) {
                  $target =~
                    s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                  $str = $1 . $str;
              }
              else {
                  $line .= $encoded;
                  last;
              }
          }
  
      }
  
      $result . $line;
  }
  
  1;
  __END__
  
X86_64-LINUX_ENCODE_MIME_HEADER_ISO_2022_JP

$fatpacked{"x86_64-linux/Encode/MIME/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_MIME_NAME';
  package Encode::MIME::Name;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 1.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # NOTE: This table must be 1:1 mapping
  our %MIME_NAME_OF = (
      'AdobeStandardEncoding' => 'Adobe-Standard-Encoding',
      'AdobeSymbol'           => 'Adobe-Symbol-Encoding',
      'ascii'                 => 'US-ASCII',
      'big5-hkscs'            => 'Big5-HKSCS',
      'cp1026'                => 'IBM1026',
      'cp1047'                => 'IBM1047',
      'cp1250'                => 'windows-1250',
      'cp1251'                => 'windows-1251',
      'cp1252'                => 'windows-1252',
      'cp1253'                => 'windows-1253',
      'cp1254'                => 'windows-1254',
      'cp1255'                => 'windows-1255',
      'cp1256'                => 'windows-1256',
      'cp1257'                => 'windows-1257',
      'cp1258'                => 'windows-1258',
      'cp37'                  => 'IBM037',
      'cp424'                 => 'IBM424',
      'cp437'                 => 'IBM437',
      'cp500'                 => 'IBM500',
      'cp775'                 => 'IBM775',
      'cp850'                 => 'IBM850',
      'cp852'                 => 'IBM852',
      'cp855'                 => 'IBM855',
      'cp857'                 => 'IBM857',
      'cp860'                 => 'IBM860',
      'cp861'                 => 'IBM861',
      'cp862'                 => 'IBM862',
      'cp863'                 => 'IBM863',
      'cp864'                 => 'IBM864',
      'cp865'                 => 'IBM865',
      'cp866'                 => 'IBM866',
      'cp869'                 => 'IBM869',
      'cp936'                 => 'GBK',
      'euc-cn'                => 'EUC-CN',
      'euc-jp'                => 'EUC-JP',
      'euc-kr'                => 'EUC-KR',
      #'gb2312-raw'            => 'GB2312', # no, you're wrong, I18N::Charset
      'hp-roman8'             => 'hp-roman8',
      'hz'                    => 'HZ-GB-2312',
      'iso-2022-jp'           => 'ISO-2022-JP',
      'iso-2022-jp-1'         => 'ISO-2022-JP-1',
      'iso-2022-kr'           => 'ISO-2022-KR',
      'iso-8859-1'            => 'ISO-8859-1',
      'iso-8859-10'           => 'ISO-8859-10',
      'iso-8859-13'           => 'ISO-8859-13',
      'iso-8859-14'           => 'ISO-8859-14',
      'iso-8859-15'           => 'ISO-8859-15',
      'iso-8859-16'           => 'ISO-8859-16',
      'iso-8859-2'            => 'ISO-8859-2',
      'iso-8859-3'            => 'ISO-8859-3',
      'iso-8859-4'            => 'ISO-8859-4',
      'iso-8859-5'            => 'ISO-8859-5',
      'iso-8859-6'            => 'ISO-8859-6',
      'iso-8859-7'            => 'ISO-8859-7',
      'iso-8859-8'            => 'ISO-8859-8',
      'iso-8859-9'            => 'ISO-8859-9',
      #'jis0201-raw'           => 'JIS_X0201',
      #'jis0208-raw'           => 'JIS_C6226-1983',
      #'jis0212-raw'           => 'JIS_X0212-1990',
      'koi8-r'                => 'KOI8-R',
      'koi8-u'                => 'KOI8-U',
      #'ksc5601-raw'           => 'KS_C_5601-1987',
      'shiftjis'              => 'Shift_JIS',
      'UTF-16'                => 'UTF-16',
      'UTF-16BE'              => 'UTF-16BE',
      'UTF-16LE'              => 'UTF-16LE',
      'UTF-32'                => 'UTF-32',
      'UTF-32BE'              => 'UTF-32BE',
      'UTF-32LE'              => 'UTF-32LE',
      'UTF-7'                 => 'UTF-7',
      'utf-8-strict'          => 'UTF-8',
      'viscii'                => 'VISCII',
  );
  
  # NOTE: %MIME_NAME_OF is still 1:1 mapping
  our %ENCODE_NAME_OF = map { uc $MIME_NAME_OF{$_} => $_ } keys %MIME_NAME_OF;
  
  # Add additional 1:N mapping
  $MIME_NAME_OF{'utf8'} = 'UTF-8';
  
  sub get_mime_name($) { $MIME_NAME_OF{$_[0]} };
  
  sub get_encode_name($) { $ENCODE_NAME_OF{uc $_[0]} };
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::NAME -- internally used by Encode
  
  =head1 SEE ALSO
  
  L<I18N::Charset>
  
  =cut
X86_64-LINUX_ENCODE_MIME_NAME

$fatpacked{"x86_64-linux/Encode/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_SYMBOL';
  package Encode::Symbol;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Symbol - Symbol Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $symbol  = encode("symbol", $utf8); # loads Encode::Symbol implicitly
      $utf8 = decode("", $symbol);        # ditto
  
  =head1 ABSTRACT
  
  This module implements symbol and dingbats encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    symbol
    dingbats
    AdobeZDingbat
    AdobeSymbol
    MacDingbats
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX_ENCODE_SYMBOL

$fatpacked{"x86_64-linux/Encode/TW.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_TW';
  package Encode::TW;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::TW not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::TW - Taiwan-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $big5 = encode("big5", $utf8); # loads Encode::TW implicitly
      $utf8 = decode("big5", $big5); # ditto
  
  =head1 DESCRIPTION
  
  This module implements tradition Chinese charset encodings as used
  in Taiwan and Hong Kong.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    big5-eten   /\bbig-?5$/i	Big5 encoding (with ETen extensions)
            /\bbig5-?et(en)?$/i
            /\btca-?big5$/i
    big5-hkscs  /\bbig5-?hk(scs)?$/i
                /\bhk(scs)?-?big5$/i
                                  Big5 + Cantonese characters in Hong Kong
    MacChineseTrad		Big5 + Apple Vendor Mappings
    cp950		                Code Page 950 
                                  = Big5 + Microsoft vendor mappings
    --------------------------------------------------------------------
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<EUC-TW> (Extended Unix Character), C<CCCII>
  (Chinese Character Code for Information Interchange), C<BIG5PLUS>
  (CMEX's Big5+) and C<BIG5EXT> (CMEX's Big5e) are distributed separately
  on CPAN, under the name L<Encode::HanExtra>. That module also contains
  extra China-based encodings.
  
  =head1 BUGS
  
  Since the original C<big5> encoding (1984) is not supported anywhere
  (glibc and DOS-based systems uses C<big5> to mean C<big5-eten>; Microsoft
  uses C<big5> to mean C<cp950>), a conscious decision was made to alias
  C<big5> to C<big5-eten>, which is the de facto superset of the original
  big5.
  
  The C<CNS11643> encoding files are not complete. For common C<CNS11643>
  manipulation, please use C<EUC-TW> in L<Encode::HanExtra>, which contains
  planes 1-7.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX_ENCODE_TW

$fatpacked{"x86_64-linux/Encode/Unicode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_UNICODE';
  package Encode::Unicode;
  
  use strict;
  use warnings;
  
  our $VERSION = do { my @r = ( q$Revision: 2.18 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  #
  # Object Generator 8 transcoders all at once!
  #
  
  use Encode ();
  
  our %BOM_Unknown = map { $_ => 1 } qw(UTF-16 UTF-32);
  
  for my $name (
      qw(UTF-16 UTF-16BE UTF-16LE
      UTF-32 UTF-32BE UTF-32LE
      UCS-2BE  UCS-2LE)
    )
  {
      my ( $size, $endian, $ucs2, $mask );
      $name =~ /^(\w+)-(\d+)(\w*)$/o;
      if ( $ucs2 = ( $1 eq 'UCS' ) ) {
          $size = 2;
      }
      else {
          $size = $2 / 8;
      }
      $endian = ( $3 eq 'BE' ) ? 'n' : ( $3 eq 'LE' ) ? 'v' : '';
      $size == 4 and $endian = uc($endian);
  
      my $obj = bless {
          Name   => $name,
          size   => $size,
          endian => $endian,
          ucs2   => $ucs2,
      } => __PACKAGE__;
      Encode::define_encoding($obj, $name);
  }
  
  use parent qw(Encode::Encoding);
  
  sub renew {
      my $self = shift;
      $BOM_Unknown{ $self->name } or return $self;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller knows it is renewed.
      return $clone;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode -- Various Unicode Transformation Formats
  
  =cut
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/;
      $ucs2 = encode("UCS-2BE", $utf8);
      $utf8 = decode("UCS-2BE", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements all Character Encoding Schemes of Unicode that
  are officially documented by Unicode Consortium (except, of course,
  for UTF-8, which is a native format in perl).
  
  =over 4
  
  =item L<http://www.unicode.org/glossary/> says:
  
  I<Character Encoding Scheme> A character encoding form plus byte
  serialization. There are Seven character encoding schemes in Unicode:
  UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and
  UTF-32LE (UCS-4LE), and UTF-7.
  
  Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of
  Unicode's Character Encoding Scheme.  It is separately implemented in
  Encode::Unicode::UTF7.  For details see L<Encode::Unicode::UTF7>.
  
  =item Quick Reference
  
                  Decodes from ord(N)           Encodes chr(N) to...
         octet/char BOM S.P d800-dfff  ord > 0xffff     \x{1abcd} ==
    ---------------+-----------------+------------------------------
    UCS-2BE       2   N   N  is bogus                  Not Available
    UCS-2LE       2   N   N     bogus                  Not Available
    UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE
    UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
    UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
    UTF-32        4   Y   -  is bogus         As is            BE/LE
    UTF-32BE      4   N   -     bogus         As is       0x0001abcd
    UTF-32LE      4   N   -     bogus         As is       0xcdab0100
    UTF-8       1-4   -   -     bogus   >= 4 octets   \xf0\x9a\af\8d
    ---------------+-----------------+------------------------------
  
  =back
  
  =head1 Size, Endianness, and BOM
  
  You can categorize these CES by 3 criteria:  size of each character,
  endianness, and Byte Order Mark.
  
  =head2 by size
  
  UCS-2 is a fixed-length encoding with each character taking 16 bits.
  It B<does not> support I<surrogate pairs>.  When a surrogate pair
  is encountered during decode(), its place is filled with \x{FFFD}
  if I<CHECK> is 0, or the routine croaks if I<CHECK> is 1.  When a
  character whose ord value is larger than 0xFFFF is encountered,
  its place is filled with \x{FFFD} if I<CHECK> is 0, or the routine
  croaks if I<CHECK> is 1.
  
  UTF-16 is almost the same as UCS-2 but it supports I<surrogate pairs>.
  When it encounters a high surrogate (0xD800-0xDBFF), it fetches the
  following low surrogate (0xDC00-0xDFFF) and C<desurrogate>s them to
  form a character.  Bogus surrogates result in death.  When \x{10000}
  or above is encountered during encode(), it C<ensurrogate>s them and
  pushes the surrogate pair to the output stream.
  
  UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits.
  Since it is 32-bit, there is no need for I<surrogate pairs>.
  
  =head2 by endianness
  
  The first (and now failed) goal of Unicode was to map all character
  repertoires into a fixed-length integer so that programmers are happy.
  Since each character is either a I<short> or I<long> in C, you have to
  pay attention to the endianness of each platform when you pass data
  to one another.
  
  Anything marked as BE is Big Endian (or network byte order) and LE is
  Little Endian (aka VAX byte order).  For anything not marked either
  BE or LE, a character called Byte Order Mark (BOM) indicating the
  endianness is prepended to the string.
  
  CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless
  and as of this writing Encode suite just leave it as is (\x{FeFF}).
  
  =over 4
  
  =item BOM as integer when fetched in network byte order
  
                16         32 bits/char
    -------------------------
    BE      0xFeFF 0x0000FeFF
    LE      0xFFFe 0xFFFe0000
    -------------------------
  
  =back
  
  This modules handles the BOM as follows.
  
  =over 4
  
  =item *
  
  When BE or LE is explicitly stated as the name of encoding, BOM is
  simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).
  
  =item *
  
  When BE or LE is omitted during decode(), it checks if BOM is at the
  beginning of the string; if one is found, the endianness is set to
  what the BOM says.  
  
  =item *
  
  Default Byte Order
  
  When no BOM is found, Encode 2.76 and blow croaked.  Since Encode
  2.77, it falls back to BE accordingly to RFC2781 and the Unicode
  Standard version 8.0
  
  =item *
  
  When BE or LE is omitted during encode(), it returns a BE-encoded
  string with BOM prepended.  So when you want to encode a whole text
  file, make sure you encode() the whole text at once, not line by line
  or each line, not file, will have a BOM prepended.
  
  =item *
  
  C<UCS-2> is an exception.  Unlike others, this is an alias of UCS-2BE.
  UCS-2 is already registered by IANA and others that way.
  
  =back
  
  =head1 Surrogate Pairs
  
  To say the least, surrogate pairs were the biggest mistake of the
  Unicode Consortium.  But according to the late Douglas Adams in I<The
  Hitchhiker's Guide to the Galaxy> Trilogy, C<In the beginning the
  Universe was created. This has made a lot of people very angry and
  been widely regarded as a bad move>.  Their mistake was not of this
  magnitude so let's forgive them.
  
  (I don't dare make any comparison with Unicode Consortium and the
  Vogons here ;)  Or, comparing Encode to Babel Fish is completely
  appropriate -- if you can only stick this into your ear :)
  
  Surrogate pairs were born when the Unicode Consortium finally
  admitted that 16 bits were not big enough to hold all the world's
  character repertoires.  But they already made UCS-2 16-bit.  What
  do we do?
  
  Back then, the range 0xD800-0xDFFF was not allocated.  Let's split
  that range in half and use the first half to represent the C<upper
  half of a character> and the second half to represent the C<lower
  half of a character>.  That way, you can represent 1024 * 1024 =
  1048576 more characters.  Now we can store character ranges up to
  \x{10ffff} even with 16-bit encodings.  This pair of half-character is
  now called a I<surrogate pair> and UTF-16 is the name of the encoding
  that embraces them.
  
  Here is a formula to ensurrogate a Unicode character \x{10000} and
  above;
  
    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
  
  And to desurrogate;
  
   $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
  
  Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but
  perl does not prohibit the use of characters within this range.  To perl,
  every one of \x{0000_0000} up to \x{ffff_ffff} (*) is I<a character>.
  
    (*) or \x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit
    integer support!
  
  =head1 Error Checking
  
  Unlike most encodings which accept various ways to handle errors,
  Unicode encodings simply croaks.
  
    % perl -MEncode -e'$_ = "\xfe\xff\xd8\xd9\xda\xdb\0\n"' \
           -e'Encode::from_to($_, "utf16","shift_jis", 0); print'
    UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
    % perl -MEncode -e'$a = "BOM missing"' \
           -e' Encode::from_to($a, "utf16", "shift_jis", 0); print'
    UTF-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.
  
  Unlike other encodings where mappings are not one-to-one against
  Unicode, UTFs are supposed to map 100% against one another.  So Encode
  is more strict on UTFs.
  
  Consider that "division by zero" of Encode :)
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode::UTF7>, L<http://www.unicode.org/glossary/>,
  L<http://www.unicode.org/unicode/faq/utf_bom.html>,
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2781.txt>,
  
  The whole Unicode standard L<http://www.unicode.org/unicode/uni2book/u2.html>
  
  Ch. 15, pp. 403 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
X86_64-LINUX_ENCODE_UNICODE

$fatpacked{"x86_64-linux/Encode/Unicode/UTF7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODE_UNICODE_UTF7';
  #
  # $Id: UTF7.pm,v 2.10 2017/06/10 17:23:50 dankogai Exp $
  #
  package Encode::Unicode::UTF7;
  use strict;
  use warnings;
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('UTF-7');
  our $VERSION = do { my @r = ( q$Revision: 2.10 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use MIME::Base64;
  use Encode qw(find_encoding);
  
  #
  # Algorithms taken from Unicode::String by Gisle Aas
  #
  
  our $OPTIONAL_DIRECT_CHARS = 1;
  my $specials = quotemeta "\'(),-./:?";
  $OPTIONAL_DIRECT_CHARS
    and $specials .= quotemeta "!\"#$%&*;<=>@[]^_`{|}";
  
  # \s will not work because it matches U+3000 DEOGRAPHIC SPACE
  # We use qr/[\n\r\t\ ] instead
  my $re_asis    = qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
  my $re_encoded = qr/(?:[^\n\r\t\ A-Za-z0-9$specials])/;
  my $e_utf16    = find_encoding("UTF-16BE");
  
  sub needs_lines { 1 }
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $len = length($str);
      pos($str) = 0;
      my $bytes = substr($str, 0, 0); # to propagate taintedness
      while ( pos($str) < $len ) {
          if ( $str =~ /\G($re_asis+)/ogc ) {
  	    my $octets = $1;
  	    utf8::downgrade($octets);
  	    $bytes .= $octets;
          }
          elsif ( $str =~ /\G($re_encoded+)/ogsc ) {
              if ( $1 eq "+" ) {
                  $bytes .= "+-";
              }
              else {
                  my $s = $1;
                  my $base64 = encode_base64( $e_utf16->encode($s), '' );
                  $base64 =~ s/=+$//;
                  $bytes .= "+$base64-";
              }
          }
          else {
              die "This should not happen! (pos=" . pos($str) . ")";
          }
      }
      $_[1] = '' if $chk;
      return $bytes;
  }
  
  sub decode($$;$) {
      use re 'taint';
      my ( $obj, $bytes, $chk ) = @_;
      return undef unless defined $bytes;
      my $len = length($bytes);
      my $str = substr($bytes, 0, 0); # to propagate taintedness;
      pos($bytes) = 0;
      no warnings 'uninitialized';
      while ( pos($bytes) < $len ) {
          if ( $bytes =~ /\G([^+]+)/ogc ) {
              $str .= $1;
          }
          elsif ( $bytes =~ /\G\+-/ogc ) {
              $str .= "+";
          }
          elsif ( $bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc ) {
              my $base64 = $1;
              my $pad    = length($base64) % 4;
              $base64 .= "=" x ( 4 - $pad ) if $pad;
              $str .= $e_utf16->decode( decode_base64($base64) );
          }
          elsif ( $bytes =~ /\G\+/ogc ) {
              $^W and warn "Bad UTF7 data escape";
              $str .= "+";
          }
          else {
              die "This should not happen " . pos($bytes);
          }
      }
      $_[1] = '' if $chk;
      return $str;
  }
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode::UTF7 -- UTF-7 encoding
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $utf7 = encode("UTF-7", $utf8);
      $utf8 = decode("UTF-7", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements UTF-7 encoding documented in RFC 2152.  UTF-7,
  as its name suggests, is a 7-bit re-encoded version of UTF-16BE.  It
  is designed to be MTA-safe and expected to be a standard way to
  exchange Unicoded mails via mails.  But with the advent of UTF-8 and
  8-bit compliant MTAs, UTF-7 is hardly ever used.
  
  UTF-7 was not supported by Encode until version 1.95 because of that.
  But Unicode::String, a module by Gisle Aas which adds Unicode supports
  to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added
  so Encode can supersede Unicode::String 100%.
  
  =head1 In Practice
  
  When you want to encode Unicode for mails and web pages, however, do
  not use UTF-7 unless you are sure your recipients and readers can
  handle it.  Very few MUAs and WWW Browsers support these days (only
  Mozilla seems to support one).  For general cases, use UTF-8 for
  message body and MIME-Header for header instead.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode>, L<Unicode::String>
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2152.txt>
  
  =cut
X86_64-LINUX_ENCODE_UNICODE_UTF7

$fatpacked{"x86_64-linux/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC';
  package File::Spec;
  
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  my %module = (
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  our @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of files in a directory (such as from C<readdir()>),
  strip out C<'.'> and C<'..'>.
  
  B<SECURITY NOTE:> This does NOT filter paths containing C<'..'>, like
  C<'../../../../etc/passwd'>, only literal matches to C<'.'> and C<'..'>.
  
      @paths = File::Spec->no_upwards( readdir $dirhandle );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_FILE_SPEC

$fatpacked{"x86_64-linux/File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec
                                # if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_AMIGAOS

$fatpacked{"x86_64-linux/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval {
        local @INC = @INC;
        pop @INC if $INC[-1] eq '.';
        require Win32API::File;
    } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_CYGWIN

$fatpacked{"x86_64-linux/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_EPOC

$fatpacked{"x86_64-linux/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  our @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  our %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
X86_64-LINUX_FILE_SPEC_FUNCTIONS

$fatpacked{"x86_64-linux/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  L<File::Spec::Unix/canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see L<File::Spec::Unix/canonpath()>. If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns the empty string.  Mac OS has no real root directory.
  
  =cut
  
  sub rootdir { '' }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_MAC

$fatpacked{"x86_64-linux/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_FILE_SPEC_OS2

$fatpacked{"x86_64-linux/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use Cwd ();
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { !defined($_) || eval { eval('1'.substr $_,0,0) } }
  			@dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath(Cwd::getcwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
X86_64-LINUX_FILE_SPEC_UNIX

$fatpacked{"x86_64-linux/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__};
                 local @INC = @INC;
                 pop @INC if $INC[-1] eq '.';
                 require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])(?:\^.|[^\]\.])+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $self->canonpath( $path ) unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
X86_64-LINUX_FILE_SPEC_VMS

$fatpacked{"x86_64-linux/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval {
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Win32API::File;
    } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( Cwd::getcwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = Cwd::getcwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
X86_64-LINUX_FILE_SPEC_WIN32

$fatpacked{"x86_64-linux/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO';
  #
  
  package IO;
  
  use XSLoader ();
  use Carp;
  use strict;
  use warnings;
  
  our $VERSION = "1.39";
  XSLoader::load 'IO', $VERSION;
  
  sub import {
      shift;
  
      warnings::warnif('deprecated', qq{Parameterless "use IO" deprecated})
          if @_ == 0 ;
      
      my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);
  
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      eval join("", map { "require IO::" . (/(\w+)/)[0] . ";\n" } @l)
  	or croak $@;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO - load various IO modules
  
  =head1 SYNOPSIS
  
     use IO qw(Handle File); # loads IO modules, here IO::Handle, IO::File
     use IO;                 # DEPRECATED
  
  =head1 DESCRIPTION
  
  C<IO> provides a simple mechanism to load several of the IO modules
  in one go.  The IO modules belonging to the core are:
  
        IO::Handle
        IO::Seekable
        IO::File
        IO::Pipe
        IO::Socket
        IO::Dir
        IO::Select
        IO::Poll
  
  Some other IO modules don't belong to the perl core but can be loaded
  as well if they have been installed from CPAN.  You can discover which
  ones exist by searching for "^IO::" on http://search.cpan.org.
  
  For more information on any of these modules, please see its respective
  documentation.
  
  =head1 DEPRECATED
  
      use IO;                # loads all the modules listed below
  
  The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe,
  IO::Socket, IO::Dir.  You should instead explicitly import the IO
  modules you want.
  
  =cut
  
X86_64-LINUX_IO

$fatpacked{"x86_64-linux/IO/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_DIR';
  # IO::Dir.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Dir;
  
  use 5.008_001;
  
  use strict;
  use Carp;
  use Symbol;
  use Exporter;
  use IO::File;
  use Tie::Hash;
  use File::stat;
  use File::Spec;
  
  our @ISA = qw(Tie::Hash Exporter);
  our $VERSION = "1.39";
  
  our @EXPORT_OK = qw(DIR_UNLINK);
  
  sub DIR_UNLINK () { 1 }
  
  sub new {
      @_ >= 1 && @_ <= 2 or croak 'usage: IO::Dir->new([DIRNAME])';
      my $class = shift;
      my $dh = gensym;
      if (@_) {
  	IO::Dir::open($dh, $_[0])
  	    or return undef;
      }
      bless $dh, $class;
  }
  
  sub DESTROY {
      my ($dh) = @_;
      local($., $@, $!, $^E, $?);
      no warnings 'io';
      closedir($dh);
  }
  
  sub open {
      @_ == 2 or croak 'usage: $dh->open(DIRNAME)';
      my ($dh, $dirname) = @_;
      return undef
  	unless opendir($dh, $dirname);
      # a dir name should always have a ":" in it; assume dirname is
      # in current directory
      $dirname = ':' .  $dirname if ( ($^O eq 'MacOS') && ($dirname !~ /:/) );
      ${*$dh}{io_dir_path} = $dirname;
      1;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $dh->close()';
      my ($dh) = @_;
      closedir($dh);
  }
  
  sub read {
      @_ == 1 or croak 'usage: $dh->read()';
      my ($dh) = @_;
      readdir($dh);
  }
  
  sub seek {
      @_ == 2 or croak 'usage: $dh->seek(POS)';
      my ($dh,$pos) = @_;
      seekdir($dh,$pos);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $dh->tell()';
      my ($dh) = @_;
      telldir($dh);
  }
  
  sub rewind {
      @_ == 1 or croak 'usage: $dh->rewind()';
      my ($dh) = @_;
      rewinddir($dh);
  }
  
  sub TIEHASH {
      my($class,$dir,$options) = @_;
  
      my $dh = $class->new($dir)
  	or return undef;
  
      $options ||= 0;
  
      ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;
      $dh;
  }
  
  sub FIRSTKEY {
      my($dh) = @_;
      $dh->rewind;
      scalar $dh->read;
  }
  
  sub NEXTKEY {
      my($dh) = @_;
      scalar $dh->read;
  }
  
  sub EXISTS {
      my($dh,$key) = @_;
      -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  }
  
  sub FETCH {
      my($dh,$key) = @_;
      &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));
  }
  
  sub STORE {
      my($dh,$key,$data) = @_;
      my($atime,$mtime) = ref($data) ? @$data : ($data,$data);
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
      unless(-e $file) {
  	my $io = IO::File->new($file,O_CREAT | O_RDWR);
  	$io->close if $io;
      }
      utime($atime,$mtime, $file);
  }
  
  sub DELETE {
      my($dh,$key) = @_;
  
      # Only unlink if unlink-ing is enabled
      return 0
  	unless ${*$dh}{io_dir_unlink};
  
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  
      -d $file
  	? rmdir($file)
  	: unlink($file);
  }
  
  1;
  
  __END__
  
  =head1 NAME 
  
  IO::Dir - supply object methods for directory handles
  
  =head1 SYNOPSIS
  
      use IO::Dir;
      $d = IO::Dir->new(".");
      if (defined $d) {
          while (defined($_ = $d->read)) { something($_); }
          $d->rewind;
          while (defined($_ = $d->read)) { something_else($_); }
          undef $d;
      }
  
      tie %dir, 'IO::Dir', ".";
      foreach (keys %dir) {
  	print $_, " " , $dir{$_}->size,"\n";
      }
  
  =head1 DESCRIPTION
  
  The C<IO::Dir> package provides two interfaces to perl's directory reading
  routines.
  
  The first interface is an object approach. C<IO::Dir> provides an object
  constructor and methods, which are just wrappers around perl's built in
  directory reading routines.
  
  =over 4
  
  =item new ( [ DIRNAME ] )
  
  C<new> is the constructor for C<IO::Dir> objects. It accepts one optional
  argument which,  if given, C<new> will pass to C<open>
  
  =back
  
  The following methods are wrappers for the directory related functions built
  into perl (the trailing 'dir' has been removed from the names). See L<perlfunc>
  for details of these functions.
  
  =over 4
  
  =item open ( DIRNAME )
  
  =item read ()
  
  =item seek ( POS )
  
  =item tell ()
  
  =item rewind ()
  
  =item close ()
  
  =back
  
  C<IO::Dir> also provides an interface to reading directories via a tied
  hash. The tied hash extends the interface beyond just the directory
  reading routines by the use of C<lstat>, from the C<File::stat> package,
  C<unlink>, C<rmdir> and C<utime>.
  
  =over 4
  
  =item tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]
  
  =back
  
  The keys of the hash will be the names of the entries in the directory. 
  Reading a value from the hash will be the result of calling
  C<File::stat::lstat>.  Deleting an element from the hash will 
  delete the corresponding file or subdirectory,
  provided that C<DIR_UNLINK> is included in the C<OPTIONS>.
  
  Assigning to an entry in the hash will cause the time stamps of the file
  to be modified. If the file does not exist then it will be created. Assigning
  a single integer to a hash element will cause both the access and 
  modification times to be changed to that value. Alternatively a reference to
  an array of two values can be passed. The first array element will be used to
  set the access time and the second element will be used to set the modification
  time.
  
  =head1 SEE ALSO
  
  L<File::stat>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs to <perlbug@perl.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2003 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_IO_DIR

$fatpacked{"x86_64-linux/IO/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_FILE';
  #
  
  package IO::File;
  
  =head1 NAME
  
  IO::File - supply object methods for filehandles
  
  =head1 SYNOPSIS
  
      use IO::File;
  
      $fh = IO::File->new();
      if ($fh->open("< file")) {
          print <$fh>;
          $fh->close;
      }
  
      $fh = IO::File->new("> file");
      if (defined $fh) {
          print $fh "bar\n";
          $fh->close;
      }
  
      $fh = IO::File->new("file", "r");
      if (defined $fh) {
          print <$fh>;
          undef $fh;       # automatically closes the file
      }
  
      $fh = IO::File->new("file", O_WRONLY|O_APPEND);
      if (defined $fh) {
          print $fh "corge\n";
  
          $pos = $fh->getpos;
          $fh->setpos($pos);
  
          undef $fh;       # automatically closes the file
      }
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::File> inherits from C<IO::Handle> and C<IO::Seekable>. It extends
  these classes with methods that are specific to file handles.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( FILENAME [,MODE [,PERMS]] )
  
  Creates an C<IO::File>.  If it receives any parameters, they are passed to
  the method C<open>; if the open fails, the object is destroyed.  Otherwise,
  it is returned to the caller.
  
  =item new_tmpfile
  
  Creates an C<IO::File> opened for read/write on a newly created temporary
  file.  On systems where this is possible, the temporary file is anonymous
  (i.e. it is unlinked after creation, but held open).  If the temporary
  file cannot be created or opened, the C<IO::File> object is destroyed.
  Otherwise, it is returned to the caller.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item open( FILENAME [,MODE [,PERMS]] )
  
  =item open( FILENAME, IOLAYERS )
  
  C<open> accepts one, two or three parameters.  With one parameter,
  it is just a front end for the built-in C<open> function.  With two or three
  parameters, the first parameter is a filename that may include
  whitespace or other special characters, and the second parameter is
  the open mode, optionally followed by a file permission value.
  
  If C<IO::File::open> receives a Perl mode string ("E<gt>", "+E<lt>", etc.)
  or an ANSI C fopen() mode string ("w", "r+", etc.), it uses the basic
  Perl C<open> operator (but protects any special characters).
  
  If C<IO::File::open> is given a numeric mode, it passes that mode
  and the optional permissions value to the Perl C<sysopen> operator.
  The permissions default to 0666.
  
  If C<IO::File::open> is given a mode that includes the C<:> character,
  it passes all the three arguments to the three-argument C<open> operator.
  
  For convenience, C<IO::File> exports the O_XXX constants from the
  Fcntl module, if this module is available.
  
  =item binmode( [LAYER] )
  
  C<binmode> sets C<binmode> on the underlying C<IO> object, as documented
  in C<perldoc -f binmode>.
  
  C<binmode> accepts one optional parameter, which is the layer to be
  passed on to the C<binmode> call.
  
  =back
  
  =head1 NOTE
  
  Some operating systems may perform  C<IO::File::new()> or C<IO::File::open()>
  on a directory without errors.  This behavior is not portable and not
  suggested for use.  Using C<opendir()> and C<readdir()> or C<IO::Dir> are
  suggested instead.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>,
  L<IO::Seekable>,
  L<IO::Dir>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>.
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO::Seekable;
  
  require Exporter;
  
  our @ISA = qw(IO::Handle IO::Seekable Exporter);
  
  our $VERSION = "1.39";
  
  our @EXPORT = @IO::Seekable::EXPORT;
  
  eval {
      # Make all Fcntl O_XXX constants available for importing
      require Fcntl;
      my @O = grep /^O_/, @Fcntl::EXPORT;
      Fcntl->import(@O);  # first we import what we want to export
      push(@EXPORT, @O);
  };
  
  ################################################
  ## Constructor
  ##
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::File";
      @_ >= 0 && @_ <= 3
  	or croak "usage: $class->new([FILENAME [,MODE [,PERMS]]])";
      my $fh = $class->SUPER::new();
      if (@_) {
  	$fh->open(@_)
  	    or return undef;
      }
      $fh;
  }
  
  ################################################
  ## Open
  ##
  
  sub open {
      @_ >= 2 && @_ <= 4 or croak 'usage: $fh->open(FILENAME [,MODE [,PERMS]])';
      my ($fh, $file) = @_;
      if (@_ > 2) {
  	my ($mode, $perms) = @_[2, 3];
  	if ($mode =~ /^\d+$/) {
  	    defined $perms or $perms = 0666;
  	    return sysopen($fh, $file, $mode, $perms);
  	} elsif ($mode =~ /:/) {
  	    return open($fh, $mode, $file) if @_ == 3;
  	    croak 'usage: $fh->open(FILENAME, IOLAYERS)';
  	} else {
              return open($fh, IO::Handle::_open_mode_string($mode), $file);
          }
      }
      open($fh, $file);
  }
  
  ################################################
  ## Binmode
  ##
  
  sub binmode {
      ( @_ == 1 or @_ == 2 ) or croak 'usage $fh->binmode([LAYER])';
  
      my($fh, $layer) = @_;
  
      return binmode $$fh unless $layer;
      return binmode $$fh, $layer;
  }
  
  1;
X86_64-LINUX_IO_FILE

$fatpacked{"x86_64-linux/IO/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_HANDLE';
  package IO::Handle;
  
  =head1 NAME
  
  IO::Handle - supply object methods for I/O handles
  
  =head1 SYNOPSIS
  
      use IO::Handle;
  
      $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDIN),"r")) {
          print $io->getline;
          $io->close;
      }
  
      $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDOUT),"w")) {
          $io->print("Some text\n");
      }
  
      # setvbuf is not available by default on Perls 5.8.0 and later.
      use IO::Handle '_IOLBF';
      $io->setvbuf($buffer_var, _IOLBF, 1024);
  
      undef $io;       # automatically closes the file if it's open
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::Handle> is the base class for all other IO handle classes. It is
  not intended that objects of C<IO::Handle> would be created directly,
  but instead C<IO::Handle> is inherited from by several other classes
  in the IO hierarchy.
  
  If you are reading this documentation, looking for a replacement for
  the C<FileHandle> package, then I suggest you read the documentation
  for C<IO::File> too.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ()
  
  Creates a new C<IO::Handle> object.
  
  =item new_from_fd ( FD, MODE )
  
  Creates an C<IO::Handle> like C<new> does.
  It requires two parameters, which are passed to the method C<fdopen>;
  if the fdopen fails, the object is destroyed. Otherwise, it is returned
  to the caller.
  
  =back
  
  =head1 METHODS
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Handle> methods, which are just front ends for the
  corresponding built-in functions:
  
      $io->close
      $io->eof
      $io->fcntl( FUNCTION, SCALAR )
      $io->fileno
      $io->format_write( [FORMAT_NAME] )
      $io->getc
      $io->ioctl( FUNCTION, SCALAR )
      $io->read ( BUF, LEN, [OFFSET] )
      $io->print ( ARGS )
      $io->printf ( FMT, [ARGS] )
      $io->say ( ARGS )
      $io->stat
      $io->sysread ( BUF, LEN, [OFFSET] )
      $io->syswrite ( BUF, [LEN, [OFFSET]] )
      $io->truncate ( LEN )
  
  See L<perlvar> for complete descriptions of each of the following
  supported C<IO::Handle> methods.  All of them return the previous
  value of the attribute and takes an optional single argument that when
  given will set the value.  If no argument is given the previous value
  is unchanged (except for $io->autoflush will actually turn ON
  autoflush by default).
  
      $io->autoflush ( [BOOL] )                         $|
      $io->format_page_number( [NUM] )                  $%
      $io->format_lines_per_page( [NUM] )               $=
      $io->format_lines_left( [NUM] )                   $-
      $io->format_name( [STR] )                         $~
      $io->format_top_name( [STR] )                     $^
      $io->input_line_number( [NUM])                    $.
  
  The following methods are not supported on a per-filehandle basis.
  
      IO::Handle->format_line_break_characters( [STR] ) $:
      IO::Handle->format_formfeed( [STR])               $^L
      IO::Handle->output_field_separator( [STR] )       $,
      IO::Handle->output_record_separator( [STR] )      $\
  
      IO::Handle->input_record_separator( [STR] )       $/
  
  Furthermore, for doing normal I/O you might need these:
  
  =over 4
  
  =item $io->fdopen ( FD, MODE )
  
  C<fdopen> is like an ordinary C<open> except that its first parameter
  is not a filename but rather a file handle name, an IO::Handle object,
  or a file descriptor number.  (For the documentation of the C<open>
  method, see L<IO::File>.)
  
  =item $io->opened
  
  Returns true if the object is currently a valid file descriptor, false
  otherwise.
  
  =item $io->getline
  
  This works like <$io> described in L<perlop/"I/O Operators">
  except that it's more readable and can be safely called in a
  list context but still returns just one line.  If used as the conditional
  within a C<while> or C-style C<for> loop, however, you will need to
  emulate the functionality of <$io> with C<< defined($_ = $io->getline) >>.
  
  =item $io->getlines
  
  This works like <$io> when called in a list context to read all
  the remaining lines in a file, except that it's more readable.
  It will also croak() if accidentally called in a scalar context.
  
  =item $io->ungetc ( ORD )
  
  Pushes a character with the given ordinal value back onto the given
  handle's input stream.  Only one character of pushback per handle is
  guaranteed.
  
  =item $io->write ( BUF, LEN [, OFFSET ] )
  
  This C<write> is somewhat like C<write> found in C, in that it is the
  opposite of read. The wrapper for the perl C<write> function is
  called C<format_write>. However, whilst the C C<write> function returns
  the number of bytes written, this C<write> function simply returns true
  if successful (like C<print>). A more C-like C<write> is C<syswrite>
  (see above).
  
  =item $io->error
  
  Returns a true value if the given handle has experienced any errors
  since it was opened or since the last call to C<clearerr>, or if the
  handle is invalid. It only returns false for a valid handle with no
  outstanding errors.
  
  =item $io->clearerr
  
  Clear the given handle's error indicator. Returns -1 if the handle is
  invalid, 0 otherwise.
  
  =item $io->sync
  
  C<sync> synchronizes a file's in-memory state  with  that  on the
  physical medium. C<sync> does not operate at the perlio api level, but
  operates on the file descriptor (similar to sysread, sysseek and
  systell). This means that any data held at the perlio api level will not
  be synchronized. To synchronize data that is buffered at the perlio api
  level you must use the flush method. C<sync> is not implemented on all
  platforms. Returns "0 but true" on success, C<undef> on error, C<undef>
  for an invalid handle. See L<fsync(3c)>.
  
  =item $io->flush
  
  C<flush> causes perl to flush any buffered data at the perlio api level.
  Any unread data in the buffer will be discarded, and any unwritten data
  will be written to the underlying file descriptor. Returns "0 but true"
  on success, C<undef> on error.
  
  =item $io->printflush ( ARGS )
  
  Turns on autoflush, print ARGS and then restores the autoflush status of the
  C<IO::Handle> object. Returns the return value from print.
  
  =item $io->blocking ( [ BOOL ] )
  
  If called with an argument C<blocking> will turn on non-blocking IO if
  C<BOOL> is false, and turn it off if C<BOOL> is true.
  
  C<blocking> will return the value of the previous setting, or the
  current setting if C<BOOL> is not given. 
  
  If an error occurs C<blocking> will return undef and C<$!> will be set.
  
  =back
  
  
  If the C functions setbuf() and/or setvbuf() are available, then
  C<IO::Handle::setbuf> and C<IO::Handle::setvbuf> set the buffering
  policy for an IO::Handle.  The calling sequences for the Perl functions
  are the same as their C counterparts--including the constants C<_IOFBF>,
  C<_IOLBF>, and C<_IONBF> for setvbuf()--except that the buffer parameter
  specifies a scalar variable to use as a buffer. You should only
  change the buffer before any I/O, or immediately after calling flush.
  
  WARNING: The IO::Handle::setvbuf() is not available by default on
  Perls 5.8.0 and later because setvbuf() is rather specific to using
  the stdio library, while Perl prefers the new perlio subsystem instead.
  
  WARNING: A variable used as a buffer by C<setbuf> or C<setvbuf> B<must not
  be modified> in any way until the IO::Handle is closed or C<setbuf> or
  C<setvbuf> is called again, or memory corruption may result! Remember that
  the order of global destruction is undefined, so even if your buffer
  variable remains in scope until program termination, it may be undefined
  before the file IO::Handle is closed. Note that you need to import the
  constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly. Like C, setbuf
  returns nothing. setvbuf returns "0 but true", on success, C<undef> on
  failure.
  
  Lastly, there is a special method for working under B<-T> and setuid/gid
  scripts:
  
  =over 4
  
  =item $io->untaint
  
  Marks the object as taint-clean, and as such data read from it will also
  be considered taint-clean. Note that this is a very trusting action to
  take, and appropriate consideration for the data source and potential
  vulnerability should be kept in mind. Returns 0 on success, -1 if setting
  the taint-clean flag failed. (eg invalid handle)
  
  =back
  
  =head1 NOTE
  
  An C<IO::Handle> object is a reference to a symbol/GLOB reference (see
  the C<Symbol> package).  Some modules that
  inherit from C<IO::Handle> may want to keep object related variables
  in the hash table part of the GLOB. In an attempt to prevent modules
  trampling on each other I propose the that any such module should prefix
  its variables with its own name separated by _'s. For example the IO::Socket
  module keeps a C<timeout> variable in 'io_socket_timeout'.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::File>
  
  =head1 BUGS
  
  Due to backwards compatibility, all filehandles resemble objects
  of class C<IO::Handle>, or actually classes derived from that class.
  They actually aren't.  Which means you can't derive your own 
  class from C<IO::Handle> and inherit those methods.
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO ();	# Load the XS module
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.39";
  
  our @EXPORT_OK = qw(
      autoflush
      output_field_separator
      output_record_separator
      input_record_separator
      input_line_number
      format_page_number
      format_lines_per_page
      format_lines_left
      format_name
      format_top_name
      format_line_break_characters
      format_formfeed
      format_write
  
      print
      printf
      say
      getline
      getlines
  
      printflush
      flush
  
      SEEK_SET
      SEEK_CUR
      SEEK_END
      _IOFBF
      _IOLBF
      _IONBF
  );
  
  ################################################
  ## Constructors, destructors.
  ##
  
  sub new {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      if (@_ != 1) {
  	# Since perl will automatically require IO::File if needed, but
  	# also initialises IO::File's @ISA as part of the core we must
  	# ensure IO::File is loaded if IO::Handle is. This avoids effect-
  	# ively "half-loading" IO::File.
  	if ($] > 5.013 && $class eq 'IO::File' && !$INC{"IO/File.pm"}) {
  	    require IO::File;
  	    shift;
  	    return IO::File::->new(@_);
  	}
  	croak "usage: $class->new()";
      }
      my $io = gensym;
      bless $io, $class;
  }
  
  sub new_from_fd {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      @_ == 3 or croak "usage: $class->new_from_fd(FD, MODE)";
      my $io = gensym;
      shift;
      IO::Handle::fdopen($io, @_)
  	or return undef;
      bless $io, $class;
  }
  
  #
  # There is no need for DESTROY to do anything, because when the
  # last reference to an IO object is gone, Perl automatically
  # closes its associated files (if any).  However, to avoid any
  # attempts to autoload DESTROY, we here define it to do nothing.
  #
  sub DESTROY {}
  
  
  ################################################
  ## Open and close.
  ##
  
  sub _open_mode_string {
      my ($mode) = @_;
      $mode =~ /^\+?(<|>>?)$/
        or $mode =~ s/^r(\+?)$/$1</
        or $mode =~ s/^w(\+?)$/$1>/
        or $mode =~ s/^a(\+?)$/$1>>/
        or croak "IO::Handle: bad open mode: $mode";
      $mode;
  }
  
  sub fdopen {
      @_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
      my ($io, $fd, $mode) = @_;
      local(*GLOB);
  
      if (ref($fd) && "$fd" =~ /GLOB\(/o) {
  	# It's a glob reference; Alias it as we cannot get name of anon GLOBs
  	my $n = qualify(*GLOB);
  	*GLOB = *{*$fd};
  	$fd =  $n;
      } elsif ($fd =~ m#^\d+$#) {
  	# It's an FD number; prefix with "=".
  	$fd = "=$fd";
      }
  
      open($io, _open_mode_string($mode) . '&' . $fd)
  	? $io : undef;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $io->close()';
      my($io) = @_;
  
      close($io);
  }
  
  ################################################
  ## Normal I/O functions.
  ##
  
  # flock
  # select
  
  sub opened {
      @_ == 1 or croak 'usage: $io->opened()';
      defined fileno($_[0]);
  }
  
  sub fileno {
      @_ == 1 or croak 'usage: $io->fileno()';
      fileno($_[0]);
  }
  
  sub getc {
      @_ == 1 or croak 'usage: $io->getc()';
      getc($_[0]);
  }
  
  sub eof {
      @_ == 1 or croak 'usage: $io->eof()';
      eof($_[0]);
  }
  
  sub print {
      @_ or croak 'usage: $io->print(ARGS)';
      my $this = shift;
      print $this @_;
  }
  
  sub printf {
      @_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
      my $this = shift;
      printf $this @_;
  }
  
  sub say {
      @_ or croak 'usage: $io->say(ARGS)';
      my $this = shift;
      local $\ = "\n";
      print $this @_;
  }
  
  # Special XS wrapper to make them inherit lexical hints from the caller.
  _create_getline_subs( <<'END' ) or die $@;
  sub getline {
      @_ == 1 or croak 'usage: $io->getline()';
      my $this = shift;
      return scalar <$this>;
  } 
  
  sub getlines {
      @_ == 1 or croak 'usage: $io->getlines()';
      wantarray or
  	croak 'Can\'t call $io->getlines in a scalar context, use $io->getline';
      my $this = shift;
      return <$this>;
  }
  1; # return true for error checking
  END
  
  *gets = \&getline;  # deprecated
  
  sub truncate {
      @_ == 2 or croak 'usage: $io->truncate(LEN)';
      truncate($_[0], $_[1]);
  }
  
  sub read {
      @_ == 3 || @_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
      read($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub sysread {
      @_ == 3 || @_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
      sysread($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub write {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
      local($\) = "";
      $_[2] = length($_[1]) unless defined $_[2];
      print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);
  }
  
  sub syswrite {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
      if (defined($_[2])) {
  	syswrite($_[0], $_[1], $_[2], $_[3] || 0);
      } else {
  	syswrite($_[0], $_[1]);
      }
  }
  
  sub stat {
      @_ == 1 or croak 'usage: $io->stat()';
      stat($_[0]);
  }
  
  ################################################
  ## State modification functions.
  ##
  
  sub autoflush {
      my $old = SelectSaver->new(qualify($_[0], caller));
      my $prev = $|;
      $| = @_ > 1 ? $_[1] : 1;
      $prev;
  }
  
  sub output_field_separator {
      carp "output_field_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $,;
      $, = $_[1] if @_ > 1;
      $prev;
  }
  
  sub output_record_separator {
      carp "output_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $\;
      $\ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_record_separator {
      carp "input_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $/;
      $/ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_line_number {
      local $.;
      () = tell qualify($_[0], caller) if ref($_[0]);
      my $prev = $.;
      $. = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_page_number {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $%;
      $% = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_per_page {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $=;
      $= = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_left {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $-;
      $- = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $~;
      $~ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_top_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $^;
      $^ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_line_break_characters {
      carp "format_line_break_characters is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $:;
      $: = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_formfeed {
      carp "format_formfeed is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $^L;
      $^L = $_[1] if @_ > 1;
      $prev;
  }
  
  sub formline {
      my $io = shift;
      my $picture = shift;
      local($^A) = $^A;
      local($\) = "";
      formline($picture, @_);
      print $io $^A;
  }
  
  sub format_write {
      @_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
      if (@_ == 2) {
  	my ($io, $fmt) = @_;
  	my $oldfmt = $io->format_name(qualify($fmt,caller));
  	CORE::write($io);
  	$io->format_name($oldfmt);
      } else {
  	CORE::write($_[0]);
      }
  }
  
  sub fcntl {
      @_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
      my ($io, $op) = @_;
      return fcntl($io, $op, $_[2]);
  }
  
  sub ioctl {
      @_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
      my ($io, $op) = @_;
      return ioctl($io, $op, $_[2]);
  }
  
  # this sub is for compatibility with older releases of IO that used
  # a sub called constant to determine if a constant existed -- GMB
  #
  # The SEEK_* and _IO?BF constants were the only constants at that time
  # any new code should just check defined(&CONSTANT_NAME)
  
  sub constant {
      no strict 'refs';
      my $name = shift;
      (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
  	? &{$name}() : undef;
  }
  
  
  # so that flush.pl can be deprecated
  
  sub printflush {
      my $io = shift;
      my $old;
      $old = SelectSaver->new(qualify($io, caller)) if ref($io);
      local $| = 1;
      if(ref($io)) {
          print $io @_;
      }
      else {
  	print @_;
      }
  }
  
  1;
X86_64-LINUX_IO_HANDLE

$fatpacked{"x86_64-linux/IO/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_PIPE';
  # IO::Pipe.pm
  #
  # Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Pipe;
  
  use 5.008_001;
  
  use IO::Handle;
  use strict;
  use Carp;
  use Symbol;
  
  our $VERSION = "1.39";
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::Pipe";
      @_ == 0 || @_ == 2 or croak "usage: $class->([READFH, WRITEFH])";
  
      my $me = bless gensym(), $class;
  
      my($readfh,$writefh) = @_ ? @_ : $me->handles;
  
      pipe($readfh, $writefh)
  	or return undef;
  
      @{*$me} = ($readfh, $writefh);
  
      $me;
  }
  
  sub handles {
      @_ == 1 or croak 'usage: $pipe->handles()';
      (IO::Pipe::End->new(), IO::Pipe::End->new());
  }
  
  my $do_spawn = $^O eq 'os2' || $^O eq 'MSWin32';
  
  sub _doit {
      my $me = shift;
      my $rw = shift;
  
      my $pid = $do_spawn ? 0 : fork();
  
      if($pid) { # Parent
          return $pid;
      }
      elsif(defined $pid) { # Child or spawn
          my $fh;
          my $io = $rw ? \*STDIN : \*STDOUT;
          my ($mode, $save) = $rw ? "r" : "w";
          if ($do_spawn) {
            require Fcntl;
            $save = IO::Handle->new_from_fd($io, $mode);
  	  my $handle = shift;
            # Close in child:
  	  unless ($^O eq 'MSWin32') {
              fcntl($handle, Fcntl::F_SETFD(), 1) or croak "fcntl: $!";
  	  }
            $fh = $rw ? ${*$me}[0] : ${*$me}[1];
          } else {
            shift;
            $fh = $rw ? $me->reader() : $me->writer(); # close the other end
          }
          bless $io, "IO::Handle";
          $io->fdopen($fh, $mode);
  	$fh->close;
  
          if ($do_spawn) {
            $pid = eval { system 1, @_ }; # 1 == P_NOWAIT
            my $err = $!;
      
            $io->fdopen($save, $mode);
            $save->close or croak "Cannot close $!";
            croak "IO::Pipe: Cannot spawn-NOWAIT: $err" if not $pid or $pid < 0;
            return $pid;
          } else {
            exec @_ or
              croak "IO::Pipe: Cannot exec: $!";
          }
      }
      else {
          croak "IO::Pipe: Cannot fork: $!";
      }
  
      # NOT Reached
  }
  
  sub reader {
      @_ >= 1 or croak 'usage: $pipe->reader( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[0];
      my $pid;
      $pid = $me->_doit(0, $fh, @_)
          if(@_);
  
      close ${*$me}[1];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"r")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  sub writer {
      @_ >= 1 or croak 'usage: $pipe->writer( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[1];
      my $pid;
      $pid = $me->_doit(1, $fh, @_)
          if(@_);
  
      close ${*$me}[0];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"w")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  package IO::Pipe::End;
  
  our(@ISA);
  
  @ISA = qw(IO::Handle);
  
  sub close {
      my $fh = shift;
      my $r = $fh->SUPER::close(@_);
  
      waitpid(${*$fh}{'io_pipe_pid'},0)
  	if(defined ${*$fh}{'io_pipe_pid'});
  
      $r;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Pipe - supply object methods for pipes
  
  =head1 SYNOPSIS
  
  	use IO::Pipe;
  
  	$pipe = IO::Pipe->new();
  
  	if($pid = fork()) { # Parent
  	    $pipe->reader();
  
  	    while(<$pipe>) {
  		...
  	    }
  
  	}
  	elsif(defined $pid) { # Child
  	    $pipe->writer();
  
  	    print $pipe ...
  	}
  
  	or
  
  	$pipe = IO::Pipe->new();
  
  	$pipe->reader(qw(ls -l));
  
  	while(<$pipe>) {
  	    ...
  	}
  
  =head1 DESCRIPTION
  
  C<IO::Pipe> provides an interface to creating pipes between
  processes.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [READER, WRITER] )
  
  Creates an C<IO::Pipe>, which is a reference to a newly created symbol
  (see the C<Symbol> package). C<IO::Pipe::new> optionally takes two
  arguments, which should be objects blessed into C<IO::Handle>, or a
  subclass thereof. These two objects will be used for the system call
  to C<pipe>. If no arguments are given then method C<handles> is called
  on the new C<IO::Pipe> object.
  
  These two handles are held in the array part of the GLOB until either
  C<reader> or C<writer> is called.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item reader ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the reading end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item writer ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the writing end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item handles ()
  
  This method is called during construction by C<IO::Pipe::new>
  on the newly created C<IO::Pipe> object. It returns an array of two objects
  blessed into C<IO::Pipe::End>, or a subclass thereof.
  
  =back
  
  =head1 SEE ALSO
  
  L<IO::Handle>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs to <perlbug@perl.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_IO_PIPE

$fatpacked{"x86_64-linux/IO/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_POLL';
  
  # IO::Poll.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Poll;
  
  use strict;
  use IO::Handle;
  use Exporter ();
  
  our @ISA = qw(Exporter);
  our $VERSION = "1.39";
  
  our @EXPORT = qw( POLLIN
  	      POLLOUT
  	      POLLERR
  	      POLLHUP
  	      POLLNVAL
  	    );
  
  our @EXPORT_OK = qw(
   POLLPRI
   POLLRDNORM
   POLLWRNORM
   POLLRDBAND
   POLLWRBAND
   POLLNORM
  	       );
  
  # [0] maps fd's to requested masks
  # [1] maps fd's to returned  masks
  # [2] maps fd's to handles
  sub new {
      my $class = shift;
  
      my $self = bless [{},{},{}], $class;
  
      $self;
  }
  
  sub mask {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      return unless defined $fd;
      if (@_) {
  	my $mask = shift;
  	if($mask) {
  	  $self->[0]{$fd}{$io} = $mask; # the error events are always returned
  	  $self->[1]{$fd}      = 0;     # output mask
  	  $self->[2]{$io}      = $io;   # remember handle
  	} else {
            delete $self->[0]{$fd}{$io};
            unless(%{$self->[0]{$fd}}) {
              # We no longer have any handles for this FD
              delete $self->[1]{$fd};
              delete $self->[0]{$fd};
            }
            delete $self->[2]{$io};
  	}
      }
      
      return unless exists $self->[0]{$fd} and exists $self->[0]{$fd}{$io};
  	return $self->[0]{$fd}{$io};
  }
  
  
  sub poll {
      my($self,$timeout) = @_;
  
      $self->[1] = {};
  
      my($fd,$mask,$iom);
      my @poll = ();
  
      while(($fd,$iom) = each %{$self->[0]}) {
  	$mask   = 0;
  	$mask  |= $_ for values(%$iom);
  	push(@poll,$fd => $mask);
      }
  
      my $ret = _poll(defined($timeout) ? $timeout * 1000 : -1,@poll);
  
      return $ret
  	unless $ret > 0;
  
      while(@poll) {
  	my($fd,$got) = splice(@poll,0,2);
  	$self->[1]{$fd} = $got if $got;
      }
  
      return $ret;  
  }
  
  sub events {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      exists $self->[1]{$fd} and exists $self->[0]{$fd}{$io} 
                  ? $self->[1]{$fd} & ($self->[0]{$fd}{$io}|POLLHUP|POLLERR|POLLNVAL)
  	: 0;
  }
  
  sub remove {
      my $self = shift;
      my $io = shift;
      $self->mask($io,0);
  }
  
  sub handles {
      my $self = shift;
      return values %{$self->[2]} unless @_;
  
      my $events = shift || 0;
      my($fd,$ev,$io,$mask);
      my @handles = ();
  
      while(($fd,$ev) = each %{$self->[1]}) {
  	while (($io,$mask) = each %{$self->[0]{$fd}}) {
  	    $mask |= POLLHUP|POLLERR|POLLNVAL;  # must allow these
  	    push @handles,$self->[2]{$io} if ($ev & $mask) & $events;
  	}
      }
      return @handles;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Poll - Object interface to system poll call
  
  =head1 SYNOPSIS
  
      use IO::Poll qw(POLLRDNORM POLLWRNORM POLLIN POLLHUP);
  
      $poll = IO::Poll->new();
  
      $poll->mask($input_handle => POLLIN);
      $poll->mask($output_handle => POLLOUT);
  
      $poll->poll($timeout);
  
      $ev = $poll->events($input);
  
  =head1 DESCRIPTION
  
  C<IO::Poll> is a simple interface to the system level poll routine.
  
  =head1 METHODS
  
  =over 4
  
  =item mask ( IO [, EVENT_MASK ] )
  
  If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the
  list of file descriptors and the next call to poll will check for
  any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be
  removed from the list of file descriptors.
  
  If EVENT_MASK is not given then the return value will be the current
  event mask value for IO.
  
  =item poll ( [ TIMEOUT ] )
  
  Call the system level poll routine. If TIMEOUT is not specified then the
  call will block. Returns the number of handles which had events
  happen, or -1 on error.
  
  =item events ( IO )
  
  Returns the event mask which represents the events that happened on IO
  during the last call to C<poll>.
  
  =item remove ( IO )
  
  Remove IO from the list of file descriptors for the next poll.
  
  =item handles( [ EVENT_MASK ] )
  
  Returns a list of handles. If EVENT_MASK is not given then a list of all
  handles known will be returned. If EVENT_MASK is given then a list
  of handles will be returned which had one of the events specified by
  EVENT_MASK happen during the last call ti C<poll>
  
  =back
  
  =head1 SEE ALSO
  
  L<poll(2)>, L<IO::Handle>, L<IO::Select>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs to <perlbug@perl.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_IO_POLL

$fatpacked{"x86_64-linux/IO/Seekable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_SEEKABLE';
  #
  
  package IO::Seekable;
  
  =head1 NAME
  
  IO::Seekable - supply seek based methods for I/O objects
  
  =head1 SYNOPSIS
  
      use IO::Seekable;
      package IO::Something;
      @ISA = qw(IO::Seekable);
  
  =head1 DESCRIPTION
  
  C<IO::Seekable> does not have a constructor of its own as it is intended to
  be inherited by other C<IO::Handle> based objects. It provides methods
  which allow seeking of the file descriptors.
  
  =over 4
  
  =item $io->getpos
  
  Returns an opaque value that represents the current position of the
  IO::File, or C<undef> if this is not possible (eg an unseekable stream such
  as a terminal, pipe or socket). If the fgetpos() function is available in
  your C library it is used to implements getpos, else perl emulates getpos
  using C's ftell() function.
  
  =item $io->setpos
  
  Uses the value of a previous getpos call to return to a previously visited
  position. Returns "0 but true" on success, C<undef> on failure.
  
  =back
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Seekable> methods, which are just front ends for the
  corresponding built-in functions:
  
  =over 4
  
  =item $io->seek ( POS, WHENCE )
  
  Seek the IO::File to position POS, relative to WHENCE:
  
  =over 8
  
  =item WHENCE=0 (SEEK_SET)
  
  POS is absolute position. (Seek relative to the start of the file)
  
  =item WHENCE=1 (SEEK_CUR)
  
  POS is an offset from the current position. (Seek relative to current)
  
  =item WHENCE=2 (SEEK_END)
  
  POS is an offset from the end of the file. (Seek relative to end)
  
  =back
  
  The SEEK_* constants can be imported from the C<Fcntl> module if you
  don't wish to use the numbers C<0> C<1> or C<2> in your code.
  
  Returns C<1> upon success, C<0> otherwise.
  
  =item $io->sysseek( POS, WHENCE )
  
  Similar to $io->seek, but sets the IO::File's position using the system
  call lseek(2) directly, so will confuse most perl IO operators except
  sysread and syswrite (see L<perlfunc> for full details)
  
  Returns the new position, or C<undef> on failure.  A position
  of zero is returned as the string C<"0 but true">
  
  =item $io->tell
  
  Returns the IO::File's current position, or -1 on error.
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>
  L<IO::File>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>gbarr@pobox.comE<gt>
  
  =cut
  
  use 5.008_001;
  use Carp;
  use strict;
  use IO::Handle ();
  # XXX we can't get these from IO::Handle or we'll get prototype
  # mismatch warnings on C<use POSIX; use IO::File;> :-(
  use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
  require Exporter;
  
  our @EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.39";
  
  sub seek {
      @_ == 3 or croak 'usage: $io->seek(POS, WHENCE)';
      seek($_[0], $_[1], $_[2]);
  }
  
  sub sysseek {
      @_ == 3 or croak 'usage: $io->sysseek(POS, WHENCE)';
      sysseek($_[0], $_[1], $_[2]);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $io->tell()';
      tell($_[0]);
  }
  
  1;
X86_64-LINUX_IO_SEEKABLE

$fatpacked{"x86_64-linux/IO/Select.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_SELECT';
  # IO::Select.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Select;
  
  use     strict;
  use warnings::register;
  require Exporter;
  
  our $VERSION = "1.39";
  
  our @ISA = qw(Exporter); # This is only so we can do version checking
  
  sub VEC_BITS () {0}
  sub FD_COUNT () {1}
  sub FIRST_FD () {2}
  
  sub new
  {
   my $self = shift;
   my $type = ref($self) || $self;
  
   my $vec = bless [undef,0], $type;
  
   $vec->add(@_)
      if @_;
  
   $vec;
  }
  
  sub add
  {
   shift->_update('add', @_);
  }
  
  
  sub remove
  {
   shift->_update('remove', @_);
  }
  
  
  sub exists
  {
   my $vec = shift;
   my $fno = $vec->_fileno(shift);
   return undef unless defined $fno;
   $vec->[$fno + FIRST_FD];
  }
  
  
  sub _fileno
  {
   my($self, $f) = @_;
   return unless defined $f;
   $f = $f->[0] if ref($f) eq 'ARRAY';
   ($f =~ /^\d+$/) ? $f : fileno($f);
  }
  
  sub _update
  {
   my $vec = shift;
   my $add = shift eq 'add';
  
   my $bits = $vec->[VEC_BITS];
   $bits = '' unless defined $bits;
  
   my $count = 0;
   my $f;
   foreach $f (@_)
    {
     my $fn = $vec->_fileno($f);
     if ($add) {
       next unless defined $fn;
       my $i = $fn + FIRST_FD;
       if (defined $vec->[$i]) {
  	 $vec->[$i] = $f;  # if array rest might be different, so we update
  	 next;
       }
       $vec->[FD_COUNT]++;
       vec($bits, $fn, 1) = 1;
       $vec->[$i] = $f;
     } else {      # remove
       if ( ! defined $fn ) { # remove if fileno undef'd
         $fn = 0;
         for my $fe (@{$vec}[FIRST_FD .. $#$vec]) {
           if (defined($fe) && $fe == $f) {
  	   $vec->[FD_COUNT]--;
  	   $fe = undef;
  	   vec($bits, $fn, 1) = 0;
  	   last;
  	 }
  	 ++$fn;
         }
       }
       else {
         my $i = $fn + FIRST_FD;
         next unless defined $vec->[$i];
         $vec->[FD_COUNT]--;
         vec($bits, $fn, 1) = 0;
         $vec->[$i] = undef;
       }
     }
     $count++;
    }
   $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;
   $count;
  }
  
  sub can_read
  {
   my $vec = shift;
   my $timeout = shift;
   my $r = $vec->[VEC_BITS];
  
   defined($r) && (select($r,undef,undef,$timeout) > 0)
      ? handles($vec, $r)
      : ();
  }
  
  sub can_write
  {
   my $vec = shift;
   my $timeout = shift;
   my $w = $vec->[VEC_BITS];
  
   defined($w) && (select(undef,$w,undef,$timeout) > 0)
      ? handles($vec, $w)
      : ();
  }
  
  sub has_exception
  {
   my $vec = shift;
   my $timeout = shift;
   my $e = $vec->[VEC_BITS];
  
   defined($e) && (select(undef,undef,$e,$timeout) > 0)
      ? handles($vec, $e)
      : ();
  }
  
  sub has_error
  {
   warnings::warn("Call to deprecated method 'has_error', use 'has_exception'")
  	if warnings::enabled();
   goto &has_exception;
  }
  
  sub count
  {
   my $vec = shift;
   $vec->[FD_COUNT];
  }
  
  sub bits
  {
   my $vec = shift;
   $vec->[VEC_BITS];
  }
  
  sub as_string  # for debugging
  {
   my $vec = shift;
   my $str = ref($vec) . ": ";
   my $bits = $vec->bits;
   my $count = $vec->count;
   $str .= defined($bits) ? unpack("b*", $bits) : "undef";
   $str .= " $count";
   my @handles = @$vec;
   splice(@handles, 0, FIRST_FD);
   for (@handles) {
       $str .= " " . (defined($_) ? "$_" : "-");
   }
   $str;
  }
  
  sub _max
  {
   my($a,$b,$c) = @_;
   $a > $b
      ? $a > $c
          ? $a
          : $c
      : $b > $c
          ? $b
          : $c;
  }
  
  sub select
  {
   shift
     if defined $_[0] && !ref($_[0]);
  
   my($r,$w,$e,$t) = @_;
   my @result = ();
  
   my $rb = defined $r ? $r->[VEC_BITS] : undef;
   my $wb = defined $w ? $w->[VEC_BITS] : undef;
   my $eb = defined $e ? $e->[VEC_BITS] : undef;
  
   if(select($rb,$wb,$eb,$t) > 0)
    {
     my @r = ();
     my @w = ();
     my @e = ();
     my $i = _max(defined $r ? scalar(@$r)-1 : 0,
                  defined $w ? scalar(@$w)-1 : 0,
                  defined $e ? scalar(@$e)-1 : 0);
  
     for( ; $i >= FIRST_FD ; $i--)
      {
       my $j = $i - FIRST_FD;
       push(@r, $r->[$i])
          if defined $rb && defined $r->[$i] && vec($rb, $j, 1);
       push(@w, $w->[$i])
          if defined $wb && defined $w->[$i] && vec($wb, $j, 1);
       push(@e, $e->[$i])
          if defined $eb && defined $e->[$i] && vec($eb, $j, 1);
      }
  
     @result = (\@r, \@w, \@e);
    }
   @result;
  }
  
  
  sub handles
  {
   my $vec = shift;
   my $bits = shift;
   my @h = ();
   my $i;
   my $max = scalar(@$vec) - 1;
  
   for ($i = FIRST_FD; $i <= $max; $i++)
    {
     next unless defined $vec->[$i];
     push(@h, $vec->[$i])
        if !defined($bits) || vec($bits, $i - FIRST_FD, 1);
    }
   
   @h;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IO::Select - OO interface to the select system call
  
  =head1 SYNOPSIS
  
      use IO::Select;
  
      $s = IO::Select->new();
  
      $s->add(\*STDIN);
      $s->add($some_handle);
  
      @ready = $s->can_read($timeout);
  
      @ready = IO::Select->new(@handles)->can_read(0);
  
  =head1 DESCRIPTION
  
  The C<IO::Select> package implements an object approach to the system C<select>
  function call. It allows the user to see what IO handles, see L<IO::Handle>,
  are ready for reading, writing or have an exception pending.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ HANDLES ] )
  
  The constructor creates a new object and optionally initialises it with a set
  of handles.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item add ( HANDLES )
  
  Add the list of handles to the C<IO::Select> object. It is these values that
  will be returned when an event occurs. C<IO::Select> keeps these values in a
  cache which is indexed by the C<fileno> of the handle, so if more than one
  handle with the same C<fileno> is specified then only the last one is cached.
  
  Each handle can be an C<IO::Handle> object, an integer or an array
  reference where the first element is an C<IO::Handle> or an integer.
  
  =item remove ( HANDLES )
  
  Remove all the given handles from the object. This method also works
  by the C<fileno> of the handles. So the exact handles that were added
  need not be passed, just handles that have an equivalent C<fileno>
  
  =item exists ( HANDLE )
  
  Returns a true value (actually the handle itself) if it is present.
  Returns undef otherwise.
  
  =item handles
  
  Return an array of all registered handles.
  
  =item can_read ( [ TIMEOUT ] )
  
  Return an array of handles that are ready for reading.  C<TIMEOUT> is the
  maximum amount of time to wait before returning an empty list (with C<$!>
  unchanged), in seconds, possibly fractional.  If C<TIMEOUT> is not given
  and any handles are registered then the call will block indefinitely.
  Upon error, an empty list is returned, with C<$!> set to indicate the
  error.  To distinguish between timeout and error, set C<$!> to zero
  before calling this method, and check it after an empty list is returned.
  
  =item can_write ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that can be written to.
  
  =item has_exception ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that have an exception
  condition, for example pending out-of-band data.
  
  =item count ()
  
  Returns the number of handles that the object will check for when
  one of the C<can_> methods is called or the object is passed to
  the C<select> static method.
  
  =item bits()
  
  Return the bit string suitable as argument to the core select() call.
  
  =item select ( READ, WRITE, EXCEPTION [, TIMEOUT ] )
  
  C<select> is a static method, that is you call it with the package name
  like C<new>. C<READ>, C<WRITE> and C<EXCEPTION> are either C<undef> or
  C<IO::Select> objects. C<TIMEOUT> is optional and has the same effect as
  for the core select call.
  
  If at least one handle is ready for the specified kind of operation,
  the result will be an array of 3 elements, each a reference to an array
  which will hold the handles that are ready for reading, writing and
  have exceptions respectively.  Upon timeout, an empty list is returned,
  with C<$!> unchanged.  Upon error, an empty list is returned, with C<$!>
  set to indicate the error.  To distinguish between timeout and error,
  set C<$!> to zero before calling this method, and check it after an
  empty list is returned.
  
  =back
  
  =head1 EXAMPLE
  
  Here is a short example which shows how C<IO::Select> could be used
  to write a server which communicates with several sockets while also
  listening for more connections on a listen socket
  
      use IO::Select;
      use IO::Socket;
  
      $lsn = IO::Socket::INET->new(Listen => 1, LocalPort => 8080);
      $sel = IO::Select->new( $lsn );
  
      while(@ready = $sel->can_read) {
          foreach $fh (@ready) {
              if($fh == $lsn) {
                  # Create a new socket
                  $new = $lsn->accept;
                  $sel->add($new);
              }
              else {
                  # Process socket
  
                  # Maybe we have finished with the socket
                  $sel->remove($fh);
                  $fh->close;
              }
          }
      }
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs to <perlbug@perl.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
X86_64-LINUX_IO_SELECT

$fatpacked{"x86_64-linux/IO/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_SOCKET';
  
  # IO::Socket.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket;
  
  use 5.008_001;
  
  use IO::Handle;
  use Socket 1.3;
  use Carp;
  use strict;
  use Exporter;
  use Errno;
  
  # legacy
  
  require IO::Socket::INET;
  require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');
  
  our @ISA = qw(IO::Handle);
  
  our $VERSION = "1.39";
  
  our @EXPORT_OK = qw(sockatmark);
  
  sub import {
      my $pkg = shift;
      if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
  	Exporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');
      } else {
  	my $callpkg = caller;
  	Exporter::export 'Socket', $callpkg, @_;
      }
  }
  
  sub new {
      my($class,%arg) = @_;
      my $sock = $class->SUPER::new();
  
      $sock->autoflush(1);
  
      ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
  
      return scalar(%arg) ? $sock->configure(\%arg)
  			: $sock;
  }
  
  my @domain2pkg;
  
  sub register_domain {
      my($p,$d) = @_;
      $domain2pkg[$d] = $p;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my $domain = delete $arg->{Domain};
  
      croak 'IO::Socket: Cannot configure a generic socket'
  	unless defined $domain;
  
      croak "IO::Socket: Unsupported socket domain"
  	unless defined $domain2pkg[$domain];
  
      croak "IO::Socket: Cannot configure socket in domain '$domain'"
  	unless ref($sock) eq "IO::Socket";
  
      bless($sock, $domain2pkg[$domain]);
      $sock->configure($arg);
  }
  
  sub socket {
      @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
      my($sock,$domain,$type,$protocol) = @_;
  
      socket($sock,$domain,$type,$protocol) or
      	return undef;
  
      ${*$sock}{'io_socket_domain'} = $domain;
      ${*$sock}{'io_socket_type'}   = $type;
      ${*$sock}{'io_socket_proto'}  = $protocol;
  
      $sock;
  }
  
  sub socketpair {
      @_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';
      my($class,$domain,$type,$protocol) = @_;
      my $sock1 = $class->new();
      my $sock2 = $class->new();
  
      socketpair($sock1,$sock2,$domain,$type,$protocol) or
      	return ();
  
      ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;
      ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;
  
      ($sock1,$sock2);
  }
  
  sub connect {
      @_ == 2 or croak 'usage: $sock->connect(NAME)';
      my $sock = shift;
      my $addr = shift;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $err;
      my $blocking;
  
      $blocking = $sock->blocking(0) if $timeout;
      if (!connect($sock, $addr)) {
  	if (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {
  	    require IO::Select;
  
  	    my $sel = new IO::Select $sock;
  
  	    undef $!;
  	    my($r,$w,$e) = IO::Select::select(undef,$sel,$sel,$timeout);
  	    if(@$e[0]) {
  		# Windows return from select after the timeout in case of
  		# WSAECONNREFUSED(10061) if exception set is not used.
  		# This behavior is different from Linux.
  		# Using the exception
  		# set we now emulate the behavior in Linux
  		#    - Karthik Rajagopalan
  		$err = $sock->getsockopt(SOL_SOCKET,SO_ERROR);
  		$@ = "connect: $err";
  	    }
  	    elsif(!@$w[0]) {
  		$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  		$@ = "connect: timeout";
  	    }
  	    elsif (!connect($sock,$addr) &&
                  not ($!{EISCONN} || ($^O eq 'MSWin32' &&
                  ($! == (($] < 5.019004) ? 10022 : Errno::EINVAL))))
              ) {
  		# Some systems refuse to re-connect() to
  		# an already open socket and set errno to EISCONN.
  		# Windows sets errno to WSAEINVAL (10022) (pre-5.19.4) or
  		# EINVAL (22) (5.19.4 onwards).
  		$err = $!;
  		$@ = "connect: $!";
  	    }
  	}
          elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {
  	    $err = $!;
  	    $@ = "connect: $!";
  	}
      }
  
      $sock->blocking(1) if $blocking;
  
      $! = $err if $err;
  
      $err ? undef : $sock;
  }
  
  # Enable/disable blocking IO on sockets.
  # Without args return the current status of blocking,
  # with args change the mode as appropriate, returning the
  # old setting, or in case of error during the mode change
  # undef.
  
  sub blocking {
      my $sock = shift;
  
      return $sock->SUPER::blocking(@_)
          if $^O ne 'MSWin32' && $^O ne 'VMS';
  
      # Windows handles blocking differently
      #
      # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f
      # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp
      #
      # 0x8004667e is FIONBIO
      #
      # which is used to set blocking behaviour.
  
      # NOTE: 
      # This is a little confusing, the perl keyword for this is
      # 'blocking' but the OS level behaviour is 'non-blocking', probably
      # because sockets are blocking by default.
      # Therefore internally we have to reverse the semantics.
  
      my $orig= !${*$sock}{io_sock_nonblocking};
          
      return $orig unless @_;
  
      my $block = shift;
      
      if ( !$block != !$orig ) {
          ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;
          ioctl($sock, 0x8004667e, pack("L!",${*$sock}{io_sock_nonblocking}))
              or return undef;
      }
      
      return $orig;        
  }
  
  
  sub close {
      @_ == 1 or croak 'usage: $sock->close()';
      my $sock = shift;
      ${*$sock}{'io_socket_peername'} = undef;
      $sock->SUPER::close();
  }
  
  sub bind {
      @_ == 2 or croak 'usage: $sock->bind(NAME)';
      my $sock = shift;
      my $addr = shift;
  
      return bind($sock, $addr) ? $sock
  			      : undef;
  }
  
  sub listen {
      @_ >= 1 && @_ <= 2 or croak 'usage: $sock->listen([QUEUE])';
      my($sock,$queue) = @_;
      $queue = 5
  	unless $queue && $queue > 0;
  
      return listen($sock, $queue) ? $sock
  				 : undef;
  }
  
  sub accept {
      @_ == 1 || @_ == 2 or croak 'usage $sock->accept([PKG])';
      my $sock = shift;
      my $pkg = shift || $sock;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $new = $pkg->new(Timeout => $timeout);
      my $peer = undef;
  
      if(defined $timeout) {
  	require IO::Select;
  
  	my $sel = new IO::Select $sock;
  
  	unless ($sel->can_read($timeout)) {
  	    $@ = 'accept: timeout';
  	    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  	    return;
  	}
      }
  
      $peer = accept($new,$sock)
  	or return;
  
      ${*$new}{$_} = ${*$sock}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
      return wantarray ? ($new, $peer)
      	      	     : $new;
  }
  
  sub sockname {
      @_ == 1 or croak 'usage: $sock->sockname()';
      getsockname($_[0]);
  }
  
  sub peername {
      @_ == 1 or croak 'usage: $sock->peername()';
      my($sock) = @_;
      ${*$sock}{'io_socket_peername'} ||= getpeername($sock);
  }
  
  sub connected {
      @_ == 1 or croak 'usage: $sock->connected()';
      my($sock) = @_;
      getpeername($sock);
  }
  
  sub send {
      @_ >= 2 && @_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
      my $sock  = $_[0];
      my $flags = $_[2] || 0;
      my $peer  = $_[3] || $sock->peername;
  
      croak 'send: Cannot determine peer address'
  	 unless(defined $peer);
  
      my $r = defined(getpeername($sock))
  	? send($sock, $_[1], $flags)
  	: send($sock, $_[1], $flags, $peer);
  
      # remember who we send to, if it was successful
      ${*$sock}{'io_socket_peername'} = $peer
  	if(@_ == 4 && defined $r);
  
      $r;
  }
  
  sub recv {
      @_ == 3 || @_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
      my $sock  = $_[0];
      my $len   = $_[2];
      my $flags = $_[3] || 0;
  
      # remember who we recv'd from
      ${*$sock}{'io_socket_peername'} = recv($sock, $_[1]='', $len, $flags);
  }
  
  sub shutdown {
      @_ == 2 or croak 'usage: $sock->shutdown(HOW)';
      my($sock, $how) = @_;
      ${*$sock}{'io_socket_peername'} = undef;
      shutdown($sock, $how);
  }
  
  sub setsockopt {
      @_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
      setsockopt($_[0],$_[1],$_[2],$_[3]);
  }
  
  my $intsize = length(pack("i",0));
  
  sub getsockopt {
      @_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
      my $r = getsockopt($_[0],$_[1],$_[2]);
      # Just a guess
      $r = unpack("i", $r)
  	if(defined $r && length($r) == $intsize);
      $r;
  }
  
  sub sockopt {
      my $sock = shift;
      @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)
  	    : $sock->setsockopt(SOL_SOCKET,@_);
  }
  
  sub atmark {
      @_ == 1 or croak 'usage: $sock->atmark()';
      my($sock) = @_;
      sockatmark($sock);
  }
  
  sub timeout {
      @_ == 1 || @_ == 2 or croak 'usage: $sock->timeout([VALUE])';
      my($sock,$val) = @_;
      my $r = ${*$sock}{'io_socket_timeout'};
  
      ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val
  	if(@_ == 2);
  
      $r;
  }
  
  sub sockdomain {
      @_ == 1 or croak 'usage: $sock->sockdomain()';
      my $sock = shift;
      if (!defined(${*$sock}{'io_socket_domain'})) {
  	my $addr = $sock->sockname();
  	${*$sock}{'io_socket_domain'} = sockaddr_family($addr)
  	    if (defined($addr));
      }
      ${*$sock}{'io_socket_domain'};
  }
  
  sub socktype {
      @_ == 1 or croak 'usage: $sock->socktype()';
      my $sock = shift;
      ${*$sock}{'io_socket_type'} = $sock->sockopt(Socket::SO_TYPE)
  	if (!defined(${*$sock}{'io_socket_type'}) && defined(eval{Socket::SO_TYPE}));
      ${*$sock}{'io_socket_type'}
  }
  
  sub protocol {
      @_ == 1 or croak 'usage: $sock->protocol()';
      my($sock) = @_;
      ${*$sock}{'io_socket_proto'} = $sock->sockopt(Socket::SO_PROTOCOL)
  	if (!defined(${*$sock}{'io_socket_proto'}) && defined(eval{Socket::SO_PROTOCOL}));
      ${*$sock}{'io_socket_proto'};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket - Object interface to socket communications
  
  =head1 SYNOPSIS
  
      use IO::Socket;
  
  =head1 DESCRIPTION
  
  C<IO::Socket> provides an object interface to creating and using sockets. It
  is built upon the L<IO::Handle> interface and inherits all the methods defined
  by L<IO::Handle>.
  
  C<IO::Socket> only defines methods for those operations which are common to all
  types of socket. Operations which are specified to a socket in a particular 
  domain have methods defined in sub classes of C<IO::Socket>
  
  C<IO::Socket> will export all functions (and constants) defined by L<Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket>, which is a reference to a
  newly created symbol (see the C<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  C<new> only looks for one key C<Domain> which tells new which domain
  the socket will be in. All other arguments will be passed to the
  configuration method of the package for that domain, See below.
  
   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
  
  As of VERSION 1.18 all IO::Socket objects have autoflush turned on
  by default. This was not the case with earlier releases.
  
   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
  
  =back
  
  =head1 METHODS
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Socket> methods, which are just front ends for the
  corresponding built-in functions:
  
      socket
      socketpair
      bind
      listen
      accept
      send
      recv
      peername (getpeername)
      sockname (getsockname)
      shutdown
  
  Some methods take slightly different arguments to those defined in L<perlfunc>
  in attempt to make the interface more flexible. These are
  
  =over 4
  
  =item accept([PKG])
  
  perform the system call C<accept> on the socket and return a new
  object. The new object will be created in the same class as the listen
  socket, unless C<PKG> is specified. This object can be used to
  communicate with the client that was trying to connect.
  
  In a scalar context the new socket is returned, or undef upon
  failure. In a list context a two-element array is returned containing
  the new socket and the peer address; the list will be empty upon
  failure.
  
  The timeout in the [PKG] can be specified as zero to effect a "poll",
  but you shouldn't do that because a new IO::Select object will be
  created behind the scenes just to do the single poll.  This is
  horrendously inefficient.  Use rather true select() with a zero
  timeout on the handle, or non-blocking IO.
  
  =item socketpair(DOMAIN, TYPE, PROTOCOL)
  
  Call C<socketpair> and return a list of two sockets created, or an
  empty list on failure.
  
  =back
  
  Additional methods that are provided are:
  
  =over 4
  
  =item atmark
  
  True if the socket is currently positioned at the urgent data mark,
  false otherwise.
  
      use IO::Socket;
  
      my $sock = IO::Socket::INET->new('some_server');
      $sock->read($data, 1024) until $sock->atmark;
  
  Note: this is a reasonably new addition to the family of socket
  functions, so all systems may not support this yet.  If it is
  unsupported by the system, an attempt to use this method will
  abort the program.
  
  The atmark() functionality is also exportable as sockatmark() function:
  
  	use IO::Socket 'sockatmark';
  
  This allows for a more traditional use of sockatmark() as a procedural
  socket function.  If your system does not support sockatmark(), the
  C<use> declaration will fail at compile time.
  
  =item connected
  
  If the socket is in a connected state, the peer address is returned. If the
  socket is not in a connected state, undef is returned.
  
  Note that connected() considers a half-open TCP socket to be "in a connected
  state".  Specifically, connected() does not distinguish between the
  B<ESTABLISHED> and B<CLOSE-WAIT> TCP states; it returns the peer address,
  rather than undef, in either case.  Thus, in general, connected() cannot
  be used to reliably learn whether the peer has initiated a graceful shutdown
  because in most cases (see below) the local TCP state machine remains in
  B<CLOSE-WAIT> until the local application calls shutdown() or close();
  only at that point does connected() return undef.
  
  The "in most cases" hedge is because local TCP state machine behavior may
  depend on the peer's socket options. In particular, if the peer socket has
  SO_LINGER enabled with a zero timeout, then the peer's close() will generate
  a RST segment, upon receipt of which the local TCP transitions immediately to
  B<CLOSED>, and in that state, connected() I<will> return undef.
  
  =item protocol
  
  Returns the numerical number for the protocol being used on the socket, if
  known. If the protocol is unknown, as with an AF_UNIX socket, zero
  is returned.
  
  =item sockdomain
  
  Returns the numerical number for the socket domain type. For example, for
  an AF_INET socket the value of &AF_INET will be returned.
  
  =item sockopt(OPT [, VAL])
  
  Unified method to both set and get options in the SOL_SOCKET level. If called
  with one argument then getsockopt is called, otherwise setsockopt is called.
  
  =item getsockopt(LEVEL, OPT)
  
  Get option associated with the socket. Other levels than SOL_SOCKET
  may be specified here.
  
  =item setsockopt(LEVEL, OPT, VAL)
  
  Set option associated with the socket. Other levels than SOL_SOCKET
  may be specified here.
  
  =item socktype
  
  Returns the numerical number for the socket type. For example, for
  a SOCK_STREAM socket the value of &SOCK_STREAM will be returned.
  
  =item timeout([VAL])
  
  Set or get the timeout value (in seconds) associated with this socket.
  If called without any arguments then the current setting is returned. If
  called with an argument the current setting is changed and the previous
  value returned.
  
  =back
  
  =head1 LIMITATIONS
  
  On some systems, for an IO::Socket object created with new_from_fd(),
  or created with accept() from such an object, the protocol(),
  sockdomain() and socktype() methods may return undef.
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Handle>, L<IO::Socket::INET>, L<IO::Socket::UNIX>
  
  =head1 AUTHOR
  
  Graham Barr.  atmark() by Lincoln Stein.  Currently maintained by the
  Perl Porters.  Please report all bugs to <perlbug@perl.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  The atmark() implementation: Copyright 2001, Lincoln Stein <lstein@cshl.org>.
  This module is distributed under the same terms as Perl itself.
  Feel free to use, modify and redistribute it as long as you retain
  the correct attribution.
  
  =cut
X86_64-LINUX_IO_SOCKET

$fatpacked{"x86_64-linux/IO/Socket/INET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_SOCKET_INET';
  # IO::Socket::INET.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::INET;
  
  use strict;
  use IO::Socket;
  use Socket;
  use Carp;
  use Exporter;
  use Errno;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.39";
  
  my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;
  
  IO::Socket::INET->register_domain( AF_INET );
  
  my %socket_type = ( tcp  => SOCK_STREAM,
  		    udp  => SOCK_DGRAM,
  		    icmp => SOCK_RAW
  		  );
  my %proto_number;
  $proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;
  $proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
  $proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  my %proto_name = reverse %proto_number;
  
  sub new {
      my $class = shift;
      unshift(@_, "PeerAddr") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub _cache_proto {
      my @proto = @_;
      for (map lc($_), $proto[0], split(' ', $proto[1])) {
  	$proto_number{$_} = $proto[2];
      }
      $proto_name{$proto[2]} = $proto[0];
  }
  
  sub _get_proto_number {
      my $name = lc(shift);
      return undef unless defined $name;
      return $proto_number{$name} if exists $proto_number{$name};
  
      my @proto = eval { getprotobyname($name) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[2];
  }
  
  sub _get_proto_name {
      my $num = shift;
      return undef unless defined $num;
      return $proto_name{$num} if exists $proto_name{$num};
  
      my @proto = eval { getprotobynumber($num) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[0];
  }
  
  sub _sock_info {
    my($addr,$port,$proto) = @_;
    my $origport = $port;
    my @serv = ();
  
    $port = $1
  	if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
  
    if(defined $proto  && $proto =~ /\D/) {
      my $num = _get_proto_number($proto);
      unless (defined $num) {
        $@ = "Bad protocol '$proto'";
        return;
      }
      $proto = $num;
    }
  
    if(defined $port) {
      my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
      my $pnum = ($port =~ m,^(\d+)$,)[0];
  
      @serv = getservbyname($port, _get_proto_name($proto) || "")
  	if ($port =~ m,\D,);
  
      $port = $serv[2] || $defport || $pnum;
      unless (defined $port) {
  	$@ = "Bad service '$origport'";
  	return;
      }
  
      $proto = _get_proto_number($serv[3]) if @serv && !$proto;
    }
  
   return ($addr || undef,
  	 $port || undef,
  	 $proto || undef
  	);
  }
  
  sub _error {
      my $sock = shift;
      my $err = shift;
      {
        local($!);
        my $title = ref($sock).": ";
        $@ = join("", $_[0] =~ /^$title/ ? "" : $title, @_);
        $sock->close()
  	if(defined fileno($sock));
      }
      $! = $err;
      return undef;
  }
  
  sub _get_addr {
      my($sock,$addr_str, $multi) = @_;
      my @addr;
      if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
  	(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);
      } else {
  	my $h = inet_aton($addr_str);
  	push(@addr, $h) if defined $h;
      }
      @addr;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($lport,$rport,$laddr,$raddr,$proto,$type);
  
  
      $arg->{LocalAddr} = $arg->{LocalHost}
  	if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};
  
      ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
  					$arg->{LocalPort},
  					$arg->{Proto})
  			or return _error($sock, $!, $@);
  
      $laddr = defined $laddr ? inet_aton($laddr)
  			    : INADDR_ANY;
  
      return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
  	unless(defined $laddr);
  
      $arg->{PeerAddr} = $arg->{PeerHost}
  	if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};
  
      unless(exists $arg->{Listen}) {
  	($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
  					    $arg->{PeerPort},
  					    $proto)
  			or return _error($sock, $!, $@);
      }
  
      $proto ||= _get_proto_number('tcp');
  
      $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};
  
      my @raddr = ();
  
      if(defined $raddr) {
  	@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless @raddr;
      }
  
      while(1) {
  
  	$sock->socket(AF_INET, $type, $proto) or
  	    return _error($sock, $!, "$!");
  
          if (defined $arg->{Blocking}) {
  	    defined $sock->blocking($arg->{Blocking})
  		or return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Reuse} || $arg->{ReuseAddr}) {
  	    $sock->sockopt(SO_REUSEADDR,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{ReusePort}) {
  	    $sock->sockopt(SO_REUSEPORT,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Broadcast}) {
  		$sock->sockopt(SO_BROADCAST,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
  	    $sock->bind($lport || 0, $laddr) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if(exists $arg->{Listen}) {
  	    $sock->listen($arg->{Listen} || 5) or
  		return _error($sock, $!, "$!");
  	    last;
  	}
  
   	# don't try to connect unless we're given a PeerAddr
   	last unless exists($arg->{PeerAddr});
   
          $raddr = shift @raddr;
  
  	return _error($sock, $EINVAL, 'Cannot determine remote port')
  		unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);
  
  	last
  	    unless($type == SOCK_STREAM || defined $raddr);
  
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless defined $raddr;
  
  #        my $timeout = ${*$sock}{'io_socket_timeout'};
  #        my $before = time() if $timeout;
  
  	undef $@;
          if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
  #            ${*$sock}{'io_socket_timeout'} = $timeout;
              return $sock;
          }
  
  	return _error($sock, $!, $@ || "Timeout")
  	    unless @raddr;
  
  #	if ($timeout) {
  #	    my $new_timeout = $timeout - (time() - $before);
  #	    return _error($sock,
  #                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),
  #                         "Timeout") if $new_timeout <= 0;
  #	    ${*$sock}{'io_socket_timeout'} = $new_timeout;
  #        }
  
      }
  
      $sock;
  }
  
  sub connect {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));
  }
  
  sub bind {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))
  }
  
  sub sockaddr {
      @_ == 1 or croak 'usage: $sock->sockaddr()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub sockport {
      @_ == 1 or croak 'usage: $sock->sockport()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub sockhost {
      @_ == 1 or croak 'usage: $sock->sockhost()';
      my($sock) = @_;
      my $addr = $sock->sockaddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  sub peeraddr {
      @_ == 1 or croak 'usage: $sock->peeraddr()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub peerport {
      @_ == 1 or croak 'usage: $sock->peerport()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub peerhost {
      @_ == 1 or croak 'usage: $sock->peerhost()';
      my($sock) = @_;
      my $addr = $sock->peeraddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::INET - Object interface for AF_INET domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::INET;
  
  =head1 DESCRIPTION
  
  C<IO::Socket::INET> provides an object interface to creating and using sockets
  in the AF_INET domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::INET> object, which is a reference to a
  newly created symbol (see the C<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::INET> provides.
  
  
   PeerAddr    Remote host address          <hostname>[:<port>]
   PeerHost    Synonym for PeerAddr
   PeerPort    Remote port or service       <service>[(<no>)] | <no>
   LocalAddr   Local host bind address      hostname[:port]
   LocalHost   Synonym for LocalAddr
   LocalPort   Local host bind port         <service>[(<no>)] | <no>
   Proto       Protocol name (or number)    "tcp" | "udp" | ...
   Type        Socket type              SOCK_STREAM | SOCK_DGRAM | ...
   Listen      Queue size for listen
   ReuseAddr   Set SO_REUSEADDR before binding
   Reuse       Set SO_REUSEADDR before binding (deprecated,
                                                prefer ReuseAddr)
   ReusePort   Set SO_REUSEPORT before binding
   Broadcast   Set SO_BROADCAST before binding
   Timeout     Timeout value for various operations
   MultiHomed  Try all addresses for multi-homed hosts
   Blocking    Determine if connection will be blocking mode
  
  If C<Listen> is defined then a listen socket is created, else if the
  socket type, which is derived from the protocol, is SOCK_STREAM then
  connect() is called.  If the C<Listen> argument is given, but false,
  the queue size will be set to 5.
  
  Although it is not illegal, the use of C<MultiHomed> on a socket
  which is in non-blocking mode is of little use. This is because the
  first connect will never fail with a timeout as the connect call
  will not block.
  
  The C<PeerAddr> can be a hostname or the IP-address on the
  "xx.xx.xx.xx" form.  The C<PeerPort> can be a number or a symbolic
  service name.  The service name might be followed by a number in
  parenthesis which is used if the service is not known by the system.
  The C<PeerPort> specification can also be embedded in the C<PeerAddr>
  by preceding it with a ":".
  
  If C<Proto> is not given and you specify a symbolic C<PeerPort> port,
  then the constructor will try to derive C<Proto> from the service
  name.  As a last resort C<Proto> "tcp" is assumed.  The C<Type>
  parameter will be deduced from C<Proto> if not specified.
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<PeerAddr> specification.
  
  If C<Blocking> is set to 0, the connection will be in nonblocking mode.
  If not specified it defaults to 1 (blocking mode).
  
  Examples:
  
     $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.org',
                                   PeerPort => 'http(80)',
                                   Proto    => 'tcp');
  
     $sock = IO::Socket::INET->new(PeerAddr => 'localhost:smtp(25)');
  
     $sock = IO::Socket::INET->new(Listen    => 5,
                                   LocalAddr => 'localhost',
                                   LocalPort => 9000,
                                   Proto     => 'tcp');
  
     $sock = IO::Socket::INET->new('127.0.0.1:25');
  
     $sock = IO::Socket::INET->new(
                             PeerPort  => 9999,
                             PeerAddr  => inet_ntoa(INADDR_BROADCAST),
                             Proto     => udp,    
                             LocalAddr => 'localhost',
                             Broadcast => 1 ) 
                         or die "Can't bind : $@\n";
  
   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
  
  As of VERSION 1.18 all IO::Socket objects have autoflush turned on
  by default. This was not the case with earlier releases.
  
   NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
  
  =back
  
  =head2 METHODS
  
  =over 4
  
  =item sockaddr ()
  
  Return the address part of the sockaddr structure for the socket
  
  =item sockport ()
  
  Return the port number that the socket is using on the local host
  
  =item sockhost ()
  
  Return the address part of the sockaddr structure for the socket in a
  text form xx.xx.xx.xx
  
  =item peeraddr ()
  
  Return the address part of the sockaddr structure for the socket on
  the peer host
  
  =item peerport ()
  
  Return the port number for the socket on the peer host.
  
  =item peerhost ()
  
  Return the address part of the sockaddr structure for the socket on the
  peer host in a text form xx.xx.xx.xx
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs to <perlbug@perl.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_IO_SOCKET_INET

$fatpacked{"x86_64-linux/IO/Socket/UNIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_IO_SOCKET_UNIX';
  # IO::Socket::UNIX.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::UNIX;
  
  use strict;
  use IO::Socket;
  use Carp;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.39";
  
  IO::Socket::UNIX->register_domain( AF_UNIX );
  
  sub new {
      my $class = shift;
      unshift(@_, "Peer") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($bport,$cport);
  
      my $type = $arg->{Type} || SOCK_STREAM;
  
      $sock->socket(AF_UNIX, $type, 0) or
  	return undef;
  
      if(exists $arg->{Local}) {
  	my $addr = sockaddr_un($arg->{Local});
  	$sock->bind($addr) or
  	    return undef;
      }
      if(exists $arg->{Listen} && $type != SOCK_DGRAM) {
  	$sock->listen($arg->{Listen} || 5) or
  	    return undef;
      }
      elsif(exists $arg->{Peer}) {
  	my $addr = sockaddr_un($arg->{Peer});
  	$sock->connect($addr) or
  	    return undef;
      }
  
      $sock;
  }
  
  sub hostpath {
      @_ == 1 or croak 'usage: $sock->hostpath()';
      my $n = $_[0]->sockname || return undef;
      (sockaddr_un($n))[0];
  }
  
  sub peerpath {
      @_ == 1 or croak 'usage: $sock->peerpath()';
      my $n = $_[0]->peername || return undef;
      (sockaddr_un($n))[0];
  }
  
  1; # Keep require happy
  
  __END__
  
  =head1 NAME
  
  IO::Socket::UNIX - Object interface for AF_UNIX domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::UNIX;
  
      my $SOCK_PATH = "$ENV{HOME}/unix-domain-socket-test.sock";
  
      # Server:
      my $server = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Local => $SOCK_PATH,
          Listen => 1,
      );
  
      my $count = 1;
      while (my $conn = $server->accept()) {
          $conn->print("Hello " . ($count++) . "\n");
      }
  
      # Client:
      my $client = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Peer => $SOCK_PATH,
      );
  
      # Now read and write from $client
  
  =head1 DESCRIPTION
  
  C<IO::Socket::UNIX> provides an object interface to creating and using sockets
  in the AF_UNIX domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::UNIX> object, which is a reference to a
  newly created symbol (see the C<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::UNIX> provides.
  
      Type    	Type of socket (eg SOCK_STREAM or SOCK_DGRAM)
      Local   	Path to local fifo
      Peer    	Path to peer fifo
      Listen  	Queue size for listen
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<Peer> specification.
  
  If the C<Listen> argument is given, but false, the queue size will be set to 5.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item hostpath()
  
  Returns the pathname to the fifo at the local end
  
  =item peerpath()
  
  Returns the pathanme to the fifo at the peer end
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs to <perlbug@perl.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_IO_SOCKET_UNIX

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.53";
  our $XS_VERSION = $VERSION;
  $VERSION =~ tr/_//d;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  sub List::Util::_Pair::TO_JSON { [ @{+shift} ] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  Since version C<1.51> they also have a C<TO_JSON> method to ease
  serialisation.
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  I<Since version 1.50.>
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  I<Since version 1.50.>
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.53";       # FIXUP
  $VERSION =~ tr/_//d;         # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.53";
  $VERSION =~ tr/_//d;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself, if C<$fh> may be used as a filehandle and is open, or if
  it is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Storable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_STORABLE';
  #
  #  Copyright (c) 1995-2001, Raphael Manfredi
  #  Copyright (c) 2002-2014 by the Perl 5 Porters
  #  Copyright (c) 2015-2016 cPanel Inc
  #  Copyright (c) 2017 Reini Urban
  #
  #  You may redistribute only under the same terms as Perl 5, as specified
  #  in the README file that comes with the distribution.
  #
  
  require XSLoader;
  require Exporter;
  package Storable;
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(store retrieve);
  our @EXPORT_OK = qw(
  	nstore store_fd nstore_fd fd_retrieve
  	freeze nfreeze thaw
  	dclone
  	retrieve_fd
  	lock_store lock_nstore lock_retrieve
          file_magic read_magic
  	BLESS_OK TIE_OK FLAGS_COMPAT
          stack_depth stack_depth_hash
  );
  
  our ($canonical, $forgive_me);
  
  our $VERSION = '3.15';
  
  our $recursion_limit;
  our $recursion_limit_hash;
  
  $recursion_limit = 512
    unless defined $recursion_limit;
  $recursion_limit_hash = 256
    unless defined $recursion_limit_hash;
  
  use Carp;
  
  BEGIN {
      if (eval {
          local $SIG{__DIE__};
          local @INC = @INC;
          pop @INC if $INC[-1] eq '.';
          require Log::Agent;
          1;
      }) {
          Log::Agent->import;
      }
      #
      # Use of Log::Agent is optional. If it hasn't imported these subs then
      # provide a fallback implementation.
      #
      unless ($Storable::{logcroak} && *{$Storable::{logcroak}}{CODE}) {
          *logcroak = \&Carp::croak;
      }
      else {
          # Log::Agent's logcroak always adds a newline to the error it is
          # given.  This breaks refs getting thrown.  We can just discard what
          # it throws (but keep whatever logging it does) and throw the original
          # args.
          no warnings 'redefine';
          my $logcroak = \&logcroak;
          *logcroak = sub {
              my @args = @_;
              eval { &$logcroak };
              Carp::croak(@args);
          };
      }
      unless ($Storable::{logcarp} && *{$Storable::{logcarp}}{CODE}) {
          *logcarp = \&Carp::carp;
      }
  }
  
  #
  # They might miss :flock in Fcntl
  #
  
  BEGIN {
      if (eval { require Fcntl; 1 } && exists $Fcntl::EXPORT_TAGS{'flock'}) {
          Fcntl->import(':flock');
      } else {
          eval q{
  	          sub LOCK_SH () { 1 }
  		  sub LOCK_EX () { 2 }
  	      };
      }
  }
  
  sub CLONE {
      # clone context under threads
      Storable::init_perinterp();
  }
  
  sub BLESS_OK     () { 2 }
  sub TIE_OK       () { 4 }
  sub FLAGS_COMPAT () { BLESS_OK | TIE_OK }
  
  # By default restricted hashes are downgraded on earlier perls.
  
  $Storable::flags = FLAGS_COMPAT;
  $Storable::downgrade_restricted = 1;
  $Storable::accept_future_minor = 1;
  
  XSLoader::load('Storable');
  
  #
  # Determine whether locking is possible, but only when needed.
  #
  
  sub CAN_FLOCK { 1 } # computed by Storable.pm.PL
  
  sub show_file_magic {
      print <<EOM;
  #
  # To recognize the data files of the Perl module Storable,
  # the following lines need to be added to the local magic(5) file,
  # usually either /usr/share/misc/magic or /etc/magic.
  #
  0	string	perl-store	perl Storable(v0.6) data
  >4	byte	>0	(net-order %d)
  >>4	byte	&01	(network-ordered)
  >>4	byte	=3	(major 1)
  >>4	byte	=2	(major 1)
  
  0	string	pst0	perl Storable(v0.7) data
  >4	byte	>0
  >>4	byte	&01	(network-ordered)
  >>4	byte	=5	(major 2)
  >>4	byte	=4	(major 2)
  >>5	byte	>0	(minor %d)
  EOM
  }
  
  sub file_magic {
      require IO::File;
  
      my $file = shift;
      my $fh = IO::File->new;
      open($fh, "<", $file) || die "Can't open '$file': $!";
      binmode($fh);
      defined(sysread($fh, my $buf, 32)) || die "Can't read from '$file': $!";
      close($fh);
  
      $file = "./$file" unless $file;  # ensure TRUE value
  
      return read_magic($buf, $file);
  }
  
  sub read_magic {
      my($buf, $file) = @_;
      my %info;
  
      my $buflen = length($buf);
      my $magic;
      if ($buf =~ s/^(pst0|perl-store)//) {
  	$magic = $1;
  	$info{file} = $file || 1;
      }
      else {
  	return undef if $file;
  	$magic = "";
      }
  
      return undef unless length($buf);
  
      my $net_order;
      if ($magic eq "perl-store" && ord(substr($buf, 0, 1)) > 1) {
  	$info{version} = -1;
  	$net_order = 0;
      }
      else {
  	$buf =~ s/(.)//s;
  	my $major = (ord $1) >> 1;
  	return undef if $major > 4; # sanity (assuming we never go that high)
  	$info{major} = $major;
  	$net_order = (ord $1) & 0x01;
  	if ($major > 1) {
  	    return undef unless $buf =~ s/(.)//s;
  	    my $minor = ord $1;
  	    $info{minor} = $minor;
  	    $info{version} = "$major.$minor";
  	    $info{version_nv} = sprintf "%d.%03d", $major, $minor;
  	}
  	else {
  	    $info{version} = $major;
  	}
      }
      $info{version_nv} ||= $info{version};
      $info{netorder} = $net_order;
  
      unless ($net_order) {
  	return undef unless $buf =~ s/(.)//s;
  	my $len = ord $1;
  	return undef unless length($buf) >= $len;
  	return undef unless $len == 4 || $len == 8;  # sanity
  	@info{qw(byteorder intsize longsize ptrsize)}
  	    = unpack "a${len}CCC", $buf;
  	(substr $buf, 0, $len + 3) = '';
  	if ($info{version_nv} >= 2.002) {
  	    return undef unless $buf =~ s/(.)//s;
  	    $info{nvsize} = ord $1;
  	}
      }
      $info{hdrsize} = $buflen - length($buf);
  
      return \%info;
  }
  
  sub BIN_VERSION_NV {
      sprintf "%d.%03d", BIN_MAJOR(), BIN_MINOR();
  }
  
  sub BIN_WRITE_VERSION_NV {
      sprintf "%d.%03d", BIN_MAJOR(), BIN_WRITE_MINOR();
  }
  
  #
  # store
  #
  # Store target object hierarchy, identified by a reference to its root.
  # The stored object tree may later be retrieved to memory via retrieve.
  # Returns undef if an I/O error occurred, in which case the file is
  # removed.
  #
  sub store {
      return _store(\&pstore, @_, 0);
  }
  
  #
  # nstore
  #
  # Same as store, but in network order.
  #
  sub nstore {
      return _store(\&net_pstore, @_, 0);
  }
  
  #
  # lock_store
  #
  # Same as store, but flock the file first (advisory locking).
  #
  sub lock_store {
      return _store(\&pstore, @_, 1);
  }
  
  #
  # lock_nstore
  #
  # Same as nstore, but flock the file first (advisory locking).
  #
  sub lock_nstore {
      return _store(\&net_pstore, @_, 1);
  }
  
  # Internal store to file routine
  sub _store {
      my $xsptr = shift;
      my $self = shift;
      my ($file, $use_locking) = @_;
      logcroak "not a reference" unless ref($self);
      logcroak "wrong argument number" unless @_ == 2;	# No @foo in arglist
      local *FILE;
      if ($use_locking) {
          open(FILE, ">>", $file) || logcroak "can't write into $file: $!";
          unless (1) {
              logcarp
                "Storable::lock_store: fcntl/flock emulation broken on $^O";
              return undef;
          }
          flock(FILE, LOCK_EX) ||
            logcroak "can't get exclusive lock on $file: $!";
          truncate FILE, 0;
          # Unlocking will happen when FILE is closed
      } else {
          open(FILE, ">", $file) || logcroak "can't create $file: $!";
      }
      binmode FILE;	# Archaic systems...
      my $da = $@;	# Don't mess if called from exception handler
      my $ret;
      # Call C routine nstore or pstore, depending on network order
      eval { $ret = &$xsptr(*FILE, $self) };
      # close will return true on success, so the or short-circuits, the ()
      # expression is true, and for that case the block will only be entered
      # if $@ is true (ie eval failed)
      # if close fails, it returns false, $ret is altered, *that* is (also)
      # false, so the () expression is false, !() is true, and the block is
      # entered.
      if (!(close(FILE) or undef $ret) || $@) {
          unlink($file) or warn "Can't unlink $file: $!\n";
      }
      if ($@) {
          $@ =~ s/\.?\n$/,/ unless ref $@;
          logcroak $@;
      }
      $@ = $da;
      return $ret;
  }
  
  #
  # store_fd
  #
  # Same as store, but perform on an already opened file descriptor instead.
  # Returns undef if an I/O error occurred.
  #
  sub store_fd {
      return _store_fd(\&pstore, @_);
  }
  
  #
  # nstore_fd
  #
  # Same as store_fd, but in network order.
  #
  sub nstore_fd {
      my ($self, $file) = @_;
      return _store_fd(\&net_pstore, @_);
  }
  
  # Internal store routine on opened file descriptor
  sub _store_fd {
      my $xsptr = shift;
      my $self = shift;
      my ($file) = @_;
      logcroak "not a reference" unless ref($self);
      logcroak "too many arguments" unless @_ == 1;	# No @foo in arglist
      my $fd = fileno($file);
      logcroak "not a valid file descriptor" unless defined $fd;
      my $da = $@;		# Don't mess if called from exception handler
      my $ret;
      # Call C routine nstore or pstore, depending on network order
      eval { $ret = &$xsptr($file, $self) };
      logcroak $@ if $@ =~ s/\.?\n$/,/;
      local $\; print $file '';	# Autoflush the file if wanted
      $@ = $da;
      return $ret;
  }
  
  #
  # freeze
  #
  # Store object and its hierarchy in memory and return a scalar
  # containing the result.
  #
  sub freeze {
      _freeze(\&mstore, @_);
  }
  
  #
  # nfreeze
  #
  # Same as freeze but in network order.
  #
  sub nfreeze {
      _freeze(\&net_mstore, @_);
  }
  
  # Internal freeze routine
  sub _freeze {
      my $xsptr = shift;
      my $self = shift;
      logcroak "not a reference" unless ref($self);
      logcroak "too many arguments" unless @_ == 0;	# No @foo in arglist
      my $da = $@;	        # Don't mess if called from exception handler
      my $ret;
      # Call C routine mstore or net_mstore, depending on network order
      eval { $ret = &$xsptr($self) };
      if ($@) {
          $@ =~ s/\.?\n$/,/ unless ref $@;
          logcroak $@;
      }
      $@ = $da;
      return $ret ? $ret : undef;
  }
  
  #
  # retrieve
  #
  # Retrieve object hierarchy from disk, returning a reference to the root
  # object of that tree.
  #
  # retrieve(file, flags)
  # flags include by default BLESS_OK=2 | TIE_OK=4
  # with flags=0 or the global $Storable::flags set to 0, no resulting object
  # will be blessed nor tied.
  #
  sub retrieve {
      _retrieve(shift, 0, @_);
  }
  
  #
  # lock_retrieve
  #
  # Same as retrieve, but with advisory locking.
  #
  sub lock_retrieve {
      _retrieve(shift, 1, @_);
  }
  
  # Internal retrieve routine
  sub _retrieve {
      my ($file, $use_locking, $flags) = @_;
      $flags = $Storable::flags unless defined $flags;
      my $FILE;
      open($FILE, "<", $file) || logcroak "can't open $file: $!";
      binmode $FILE;			# Archaic systems...
      my $self;
      my $da = $@;			# Could be from exception handler
      if ($use_locking) {
          unless (1) {
              logcarp
                "Storable::lock_store: fcntl/flock emulation broken on $^O";
              return undef;
          }
          flock($FILE, LOCK_SH) || logcroak "can't get shared lock on $file: $!";
          # Unlocking will happen when FILE is closed
      }
      eval { $self = pretrieve($FILE, $flags) };		# Call C routine
      close($FILE);
      if ($@) {
          $@ =~ s/\.?\n$/,/ unless ref $@;
          logcroak $@;
      }
      $@ = $da;
      return $self;
  }
  
  #
  # fd_retrieve
  #
  # Same as retrieve, but perform from an already opened file descriptor instead.
  #
  sub fd_retrieve {
      my ($file, $flags) = @_;
      $flags = $Storable::flags unless defined $flags;
      my $fd = fileno($file);
      logcroak "not a valid file descriptor" unless defined $fd;
      my $self;
      my $da = $@;				# Could be from exception handler
      eval { $self = pretrieve($file, $flags) };	# Call C routine
      if ($@) {
          $@ =~ s/\.?\n$/,/ unless ref $@;
          logcroak $@;
      }
      $@ = $da;
      return $self;
  }
  
  sub retrieve_fd { &fd_retrieve }		# Backward compatibility
  
  #
  # thaw
  #
  # Recreate objects in memory from an existing frozen image created
  # by freeze.  If the frozen image passed is undef, return undef.
  #
  # thaw(frozen_obj, flags)
  # flags include by default BLESS_OK=2 | TIE_OK=4
  # with flags=0 or the global $Storable::flags set to 0, no resulting object
  # will be blessed nor tied.
  #
  sub thaw {
      my ($frozen, $flags) = @_;
      $flags = $Storable::flags unless defined $flags;
      return undef unless defined $frozen;
      my $self;
      my $da = $@;			        # Could be from exception handler
      eval { $self = mretrieve($frozen, $flags) };# Call C routine
      if ($@) {
          $@ =~ s/\.?\n$/,/ unless ref $@;
          logcroak $@;
      }
      $@ = $da;
      return $self;
  }
  
  #
  # _make_re($re, $flags)
  #
  # Internal function used to thaw a regular expression.
  #
  
  my $re_flags;
  BEGIN {
      if ($] < 5.010) {
          $re_flags = qr/\A[imsx]*\z/;
      }
      elsif ($] < 5.014) {
          $re_flags = qr/\A[msixp]*\z/;
      }
      elsif ($] < 5.022) {
          $re_flags = qr/\A[msixpdual]*\z/;
      }
      else {
          $re_flags = qr/\A[msixpdualn]*\z/;
      }
  }
  
  sub _make_re {
      my ($re, $flags) = @_;
  
      $flags =~ $re_flags
          or die "regexp flags invalid";
  
      my $qr = eval "qr/\$re/$flags";
      die $@ if $@;
  
      $qr;
  }
  
  if ($] < 5.012) {
      eval <<'EOS'
  sub _regexp_pattern {
      my $re = "" . shift;
      $re =~ /\A\(\?([xism]*)(?:-[xism]*)?:(.*)\)\z/s
          or die "Cannot parse regexp /$re/";
      return ($2, $1);
  }
  1
  EOS
        or die "Cannot define _regexp_pattern: $@";
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Storable - persistence for Perl data structures
  
  =head1 SYNOPSIS
  
   use Storable;
   store \%table, 'file';
   $hashref = retrieve('file');
  
   use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);
  
   # Network order
   nstore \%table, 'file';
   $hashref = retrieve('file');	# There is NO nretrieve()
  
   # Storing to and retrieving from an already opened file
   store_fd \@array, \*STDOUT;
   nstore_fd \%table, \*STDOUT;
   $aryref = fd_retrieve(\*SOCKET);
   $hashref = fd_retrieve(\*SOCKET);
  
   # Serializing to memory
   $serialized = freeze \%table;
   %table_clone = %{ thaw($serialized) };
  
   # Deep (recursive) cloning
   $cloneref = dclone($ref);
  
   # Advisory locking
   use Storable qw(lock_store lock_nstore lock_retrieve)
   lock_store \%table, 'file';
   lock_nstore \%table, 'file';
   $hashref = lock_retrieve('file');
  
  =head1 DESCRIPTION
  
  The Storable package brings persistence to your Perl data structures
  containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be
  conveniently stored to disk and retrieved at a later time.
  
  It can be used in the regular procedural way by calling C<store> with
  a reference to the object to be stored, along with the file name where
  the image should be written.
  
  The routine returns C<undef> for I/O problems or other internal error,
  a true value otherwise. Serious errors are propagated as a C<die> exception.
  
  To retrieve data stored to disk, use C<retrieve> with a file name.
  The objects stored into that file are recreated into memory for you,
  and a I<reference> to the root object is returned. In case an I/O error
  occurs while reading, C<undef> is returned instead. Other serious
  errors are propagated via C<die>.
  
  Since storage is performed recursively, you might want to stuff references
  to objects that share a lot of common data into a single array or hash
  table, and then store that object. That way, when you retrieve back the
  whole thing, the objects will continue to share what they originally shared.
  
  At the cost of a slight header overhead, you may store to an already
  opened file descriptor using the C<store_fd> routine, and retrieve
  from a file via C<fd_retrieve>. Those names aren't imported by default,
  so you will have to do that explicitly if you need those routines.
  The file descriptor you supply must be already opened, for read
  if you're going to retrieve and for write if you wish to store.
  
  	store_fd(\%table, *STDOUT) || die "can't store to stdout\n";
  	$hashref = fd_retrieve(*STDIN);
  
  You can also store data in network order to allow easy sharing across
  multiple platforms, or when storing on a socket known to be remotely
  connected. The routines to call have an initial C<n> prefix for I<network>,
  as in C<nstore> and C<nstore_fd>. At retrieval time, your data will be
  correctly restored so you don't have to know whether you're restoring
  from native or network ordered data.  Double values are stored stringified
  to ensure portability as well, at the slight risk of loosing some precision
  in the last decimals.
  
  When using C<fd_retrieve>, objects are retrieved in sequence, one
  object (i.e. one recursive tree) per associated C<store_fd>.
  
  If you're more from the object-oriented camp, you can inherit from
  Storable and directly store your objects by invoking C<store> as
  a method. The fact that the root of the to-be-stored tree is a
  blessed reference (i.e. an object) is special-cased so that the
  retrieve does not provide a reference to that object but rather the
  blessed object reference itself. (Otherwise, you'd get a reference
  to that blessed object).
  
  =head1 MEMORY STORE
  
  The Storable engine can also store data into a Perl scalar instead, to
  later retrieve them. This is mainly used to freeze a complex structure in
  some safe compact memory place (where it can possibly be sent to another
  process via some IPC, since freezing the structure also serializes it in
  effect). Later on, and maybe somewhere else, you can thaw the Perl scalar
  out and recreate the original complex structure in memory.
  
  Surprisingly, the routines to be called are named C<freeze> and C<thaw>.
  If you wish to send out the frozen scalar to another machine, use
  C<nfreeze> instead to get a portable image.
  
  Note that freezing an object structure and immediately thawing it
  actually achieves a deep cloning of that structure:
  
      dclone(.) = thaw(freeze(.))
  
  Storable provides you with a C<dclone> interface which does not create
  that intermediary scalar but instead freezes the structure in some
  internal memory space and then immediately thaws it out.
  
  =head1 ADVISORY LOCKING
  
  The C<lock_store> and C<lock_nstore> routine are equivalent to
  C<store> and C<nstore>, except that they get an exclusive lock on
  the file before writing.  Likewise, C<lock_retrieve> does the same
  as C<retrieve>, but also gets a shared lock on the file before reading.
  
  As with any advisory locking scheme, the protection only works if you
  systematically use C<lock_store> and C<lock_retrieve>.  If one side of
  your application uses C<store> whilst the other uses C<lock_retrieve>,
  you will get no protection at all.
  
  The internal advisory locking is implemented using Perl's flock()
  routine.  If your system does not support any form of flock(), or if
  you share your files across NFS, you might wish to use other forms
  of locking by using modules such as LockFile::Simple which lock a
  file using a filesystem entry, instead of locking the file descriptor.
  
  =head1 SPEED
  
  The heart of Storable is written in C for decent speed. Extra low-level
  optimizations have been made when manipulating perl internals, to
  sacrifice encapsulation for the benefit of greater speed.
  
  =head1 CANONICAL REPRESENTATION
  
  Normally, Storable stores elements of hashes in the order they are
  stored internally by Perl, i.e. pseudo-randomly.  If you set
  C<$Storable::canonical> to some C<TRUE> value, Storable will store
  hashes with the elements sorted by their key.  This allows you to
  compare data structures by comparing their frozen representations (or
  even the compressed frozen representations), which can be useful for
  creating lookup tables for complicated queries.
  
  Canonical order does not imply network order; those are two orthogonal
  settings.
  
  =head1 CODE REFERENCES
  
  Since Storable version 2.05, CODE references may be serialized with
  the help of L<B::Deparse>. To enable this feature, set
  C<$Storable::Deparse> to a true value. To enable deserialization,
  C<$Storable::Eval> should be set to a true value. Be aware that
  deserialization is done through C<eval>, which is dangerous if the
  Storable file contains malicious data. You can set C<$Storable::Eval>
  to a subroutine reference which would be used instead of C<eval>. See
  below for an example using a L<Safe> compartment for deserialization
  of CODE references.
  
  If C<$Storable::Deparse> and/or C<$Storable::Eval> are set to false
  values, then the value of C<$Storable::forgive_me> (see below) is
  respected while serializing and deserializing.
  
  =head1 FORWARD COMPATIBILITY
  
  This release of Storable can be used on a newer version of Perl to
  serialize data which is not supported by earlier Perls.  By default,
  Storable will attempt to do the right thing, by C<croak()>ing if it
  encounters data that it cannot deserialize.  However, the defaults
  can be changed as follows:
  
  =over 4
  
  =item utf8 data
  
  Perl 5.6 added support for Unicode characters with code points > 255,
  and Perl 5.8 has full support for Unicode characters in hash keys.
  Perl internally encodes strings with these characters using utf8, and
  Storable serializes them as utf8.  By default, if an older version of
  Perl encounters a utf8 value it cannot represent, it will C<croak()>.
  To change this behaviour so that Storable deserializes utf8 encoded
  values as the string of bytes (effectively dropping the I<is_utf8> flag)
  set C<$Storable::drop_utf8> to some C<TRUE> value.  This is a form of
  data loss, because with C<$drop_utf8> true, it becomes impossible to tell
  whether the original data was the Unicode string, or a series of bytes
  that happen to be valid utf8.
  
  =item restricted hashes
  
  Perl 5.8 adds support for restricted hashes, which have keys
  restricted to a given set, and can have values locked to be read only.
  By default, when Storable encounters a restricted hash on a perl
  that doesn't support them, it will deserialize it as a normal hash,
  silently discarding any placeholder keys and leaving the keys and
  all values unlocked.  To make Storable C<croak()> instead, set
  C<$Storable::downgrade_restricted> to a C<FALSE> value.  To restore
  the default set it back to some C<TRUE> value.
  
  The cperl PERL_PERTURB_KEYS_TOP hash strategy has a known problem with
  restricted hashes.
  
  =item huge objects
  
  On 64bit systems some data structures may exceed the 2G (i.e. I32_MAX)
  limit. On 32bit systems also strings between I32 and U32 (2G-4G).
  Since Storable 3.00 (not in perl5 core) we are able to store and
  retrieve these objects, even if perl5 itself is not able to handle
  them.  These are strings longer then 4G, arrays with more then 2G
  elements and hashes with more then 2G elements. cperl forbids hashes
  with more than 2G elements, but this fail in cperl then. perl5 itself
  at least until 5.26 allows it, but cannot iterate over them.
  Note that creating those objects might cause out of memory
  exceptions by the operating system before perl has a chance to abort.
  
  =item files from future versions of Storable
  
  Earlier versions of Storable would immediately croak if they encountered
  a file with a higher internal version number than the reading Storable
  knew about.  Internal version numbers are increased each time new data
  types (such as restricted hashes) are added to the vocabulary of the file
  format.  This meant that a newer Storable module had no way of writing a
  file readable by an older Storable, even if the writer didn't store newer
  data types.
  
  This version of Storable will defer croaking until it encounters a data
  type in the file that it does not recognize.  This means that it will
  continue to read files generated by newer Storable modules which are careful
  in what they write out, making it easier to upgrade Storable modules in a
  mixed environment.
  
  The old behaviour of immediate croaking can be re-instated by setting
  C<$Storable::accept_future_minor> to some C<FALSE> value.
  
  =back
  
  All these variables have no effect on a newer Perl which supports the
  relevant feature.
  
  =head1 ERROR REPORTING
  
  Storable uses the "exception" paradigm, in that it does not try to
  workaround failures: if something bad happens, an exception is
  generated from the caller's perspective (see L<Carp> and C<croak()>).
  Use eval {} to trap those exceptions.
  
  When Storable croaks, it tries to report the error via the C<logcroak()>
  routine from the C<Log::Agent> package, if it is available.
  
  Normal errors are reported by having store() or retrieve() return C<undef>.
  Such errors are usually I/O errors (or truncated stream errors at retrieval).
  
  When Storable throws the "Max. recursion depth with nested structures
  exceeded" error we are already out of stack space. Unfortunately on
  some earlier perl versions cleaning up a recursive data structure
  recurses into the free calls, which will lead to stack overflows in
  the cleanup. This data structure is not properly cleaned up then, it
  will only be destroyed during global destruction.
  
  =head1 WIZARDS ONLY
  
  =head2 Hooks
  
  Any class may define hooks that will be called during the serialization
  and deserialization process on objects that are instances of that class.
  Those hooks can redefine the way serialization is performed (and therefore,
  how the symmetrical deserialization should be conducted).
  
  Since we said earlier:
  
      dclone(.) = thaw(freeze(.))
  
  everything we say about hooks should also hold for deep cloning. However,
  hooks get to know whether the operation is a mere serialization, or a cloning.
  
  Therefore, when serializing hooks are involved,
  
      dclone(.) <> thaw(freeze(.))
  
  Well, you could keep them in sync, but there's no guarantee it will always
  hold on classes somebody else wrote.  Besides, there is little to gain in
  doing so: a serializing hook could keep only one attribute of an object,
  which is probably not what should happen during a deep cloning of that
  same object.
  
  Here is the hooking interface:
  
  =over 4
  
  =item C<STORABLE_freeze> I<obj>, I<cloning>
  
  The serializing hook, called on the object during serialization.  It can be
  inherited, or defined in the class itself, like any other method.
  
  Arguments: I<obj> is the object to serialize, I<cloning> is a flag indicating
  whether we're in a dclone() or a regular serialization via store() or freeze().
  
  Returned value: A LIST C<($serialized, $ref1, $ref2, ...)> where $serialized
  is the serialized form to be used, and the optional $ref1, $ref2, etc... are
  extra references that you wish to let the Storable engine serialize.
  
  At deserialization time, you will be given back the same LIST, but all the
  extra references will be pointing into the deserialized structure.
  
  The B<first time> the hook is hit in a serialization flow, you may have it
  return an empty list.  That will signal the Storable engine to further
  discard that hook for this class and to therefore revert to the default
  serialization of the underlying Perl data.  The hook will again be normally
  processed in the next serialization.
  
  Unless you know better, serializing hook should always say:
  
      sub STORABLE_freeze {
          my ($self, $cloning) = @_;
          return if $cloning;         # Regular default serialization
          ....
      }
  
  in order to keep reasonable dclone() semantics.
  
  =item C<STORABLE_thaw> I<obj>, I<cloning>, I<serialized>, ...
  
  The deserializing hook called on the object during deserialization.
  But wait: if we're deserializing, there's no object yet... right?
  
  Wrong: the Storable engine creates an empty one for you.  If you know Eiffel,
  you can view C<STORABLE_thaw> as an alternate creation routine.
  
  This means the hook can be inherited like any other method, and that
  I<obj> is your blessed reference for this particular instance.
  
  The other arguments should look familiar if you know C<STORABLE_freeze>:
  I<cloning> is true when we're part of a deep clone operation, I<serialized>
  is the serialized string you returned to the engine in C<STORABLE_freeze>,
  and there may be an optional list of references, in the same order you gave
  them at serialization time, pointing to the deserialized objects (which
  have been processed courtesy of the Storable engine).
  
  When the Storable engine does not find any C<STORABLE_thaw> hook routine,
  it tries to load the class by requiring the package dynamically (using
  the blessed package name), and then re-attempts the lookup.  If at that
  time the hook cannot be located, the engine croaks.  Note that this mechanism
  will fail if you define several classes in the same file, but L<perlmod>
  warned you.
  
  It is up to you to use this information to populate I<obj> the way you want.
  
  Returned value: none.
  
  =item C<STORABLE_attach> I<class>, I<cloning>, I<serialized>
  
  While C<STORABLE_freeze> and C<STORABLE_thaw> are useful for classes where
  each instance is independent, this mechanism has difficulty (or is
  incompatible) with objects that exist as common process-level or
  system-level resources, such as singleton objects, database pools, caches
  or memoized objects.
  
  The alternative C<STORABLE_attach> method provides a solution for these
  shared objects. Instead of C<STORABLE_freeze> --E<gt> C<STORABLE_thaw>,
  you implement C<STORABLE_freeze> --E<gt> C<STORABLE_attach> instead.
  
  Arguments: I<class> is the class we are attaching to, I<cloning> is a flag
  indicating whether we're in a dclone() or a regular de-serialization via
  thaw(), and I<serialized> is the stored string for the resource object.
  
  Because these resource objects are considered to be owned by the entire
  process/system, and not the "property" of whatever is being serialized,
  no references underneath the object should be included in the serialized
  string. Thus, in any class that implements C<STORABLE_attach>, the
  C<STORABLE_freeze> method cannot return any references, and C<Storable>
  will throw an error if C<STORABLE_freeze> tries to return references.
  
  All information required to "attach" back to the shared resource object
  B<must> be contained B<only> in the C<STORABLE_freeze> return string.
  Otherwise, C<STORABLE_freeze> behaves as normal for C<STORABLE_attach>
  classes.
  
  Because C<STORABLE_attach> is passed the class (rather than an object),
  it also returns the object directly, rather than modifying the passed
  object.
  
  Returned value: object of type C<class>
  
  =back
  
  =head2 Predicates
  
  Predicates are not exportable.  They must be called by explicitly prefixing
  them with the Storable package name.
  
  =over 4
  
  =item C<Storable::last_op_in_netorder>
  
  The C<Storable::last_op_in_netorder()> predicate will tell you whether
  network order was used in the last store or retrieve operation.  If you
  don't know how to use this, just forget about it.
  
  =item C<Storable::is_storing>
  
  Returns true if within a store operation (via STORABLE_freeze hook).
  
  =item C<Storable::is_retrieving>
  
  Returns true if within a retrieve operation (via STORABLE_thaw hook).
  
  =back
  
  =head2 Recursion
  
  With hooks comes the ability to recurse back to the Storable engine.
  Indeed, hooks are regular Perl code, and Storable is convenient when
  it comes to serializing and deserializing things, so why not use it
  to handle the serialization string?
  
  There are a few things you need to know, however:
  
  =over 4
  
  =item *
  
  From Storable 3.05 to 3.13 we probed for the stack recursion limit for references,
  arrays and hashes to a maximal depth of ~1200-35000, otherwise we might
  fall into a stack-overflow.  On JSON::XS this limit is 512 btw.  With
  references not immediately referencing each other there's no such
  limit yet, so you might fall into such a stack-overflow segfault.
  
  This probing and the checks we performed have some limitations:
  
  =over
  
  =item *
  
  the stack size at build time might be different at run time, eg. the
  stack size may have been modified with ulimit(1).  If it's larger at
  run time Storable may fail the freeze() or thaw() unnecessarily.  If
  it's larger at build time Storable may segmentation fault when
  processing a deep structure at run time.
  
  =item *
  
  the stack size might be different in a thread.
  
  =item *
  
  array and hash recursion limits are checked separately against the
  same recursion depth, a frozen structure with a large sequence of
  nested arrays within many nested hashes may exhaust the processor
  stack without triggering Storable's recursion protection.
  
  =back
  
  So these now have simple defaults rather than probing at build-time.
  
  You can control the maximum array and hash recursion depths by
  modifying C<$Storable::recursion_limit> and
  C<$Storable::recursion_limit_hash> respectively.  Either can be set to
  C<-1> to prevent any depth checks, though this isn't recommended.
  
  =item *
  
  You can create endless loops if the things you serialize via freeze()
  (for instance) point back to the object we're trying to serialize in
  the hook.
  
  =item *
  
  Shared references among objects will not stay shared: if we're serializing
  the list of object [A, C] where both object A and C refer to the SAME object
  B, and if there is a serializing hook in A that says freeze(B), then when
  deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D,
  a deep clone of B'.  The topology was not preserved.
  
  =item *
  
  The maximal stack recursion limit for your system is returned by
  C<stack_depth()> and C<stack_depth_hash()>. The hash limit is usually
  half the size of the array and ref limit, as the Perl hash API is not optimal.
  
  =back
  
  That's why C<STORABLE_freeze> lets you provide a list of references
  to serialize.  The engine guarantees that those will be serialized in the
  same context as the other objects, and therefore that shared objects will
  stay shared.
  
  In the above [A, C] example, the C<STORABLE_freeze> hook could return:
  
  	("something", $self->{B})
  
  and the B part would be serialized by the engine.  In C<STORABLE_thaw>, you
  would get back the reference to the B' object, deserialized for you.
  
  Therefore, recursion should normally be avoided, but is nonetheless supported.
  
  =head2 Deep Cloning
  
  There is a Clone module available on CPAN which implements deep cloning
  natively, i.e. without freezing to memory and thawing the result.  It is
  aimed to replace Storable's dclone() some day.  However, it does not currently
  support Storable hooks to redefine the way deep cloning is performed.
  
  =head1 Storable magic
  
  Yes, there's a lot of that :-) But more precisely, in UNIX systems
  there's a utility called C<file>, which recognizes data files based on
  their contents (usually their first few bytes).  For this to work,
  a certain file called F<magic> needs to taught about the I<signature>
  of the data.  Where that configuration file lives depends on the UNIX
  flavour; often it's something like F</usr/share/misc/magic> or
  F</etc/magic>.  Your system administrator needs to do the updating of
  the F<magic> file.  The necessary signature information is output to
  STDOUT by invoking Storable::show_file_magic().  Note that the GNU
  implementation of the C<file> utility, version 3.38 or later,
  is expected to contain support for recognising Storable files
  out-of-the-box, in addition to other kinds of Perl files.
  
  You can also use the following functions to extract the file header
  information from Storable images:
  
  =over
  
  =item $info = Storable::file_magic( $filename )
  
  If the given file is a Storable image return a hash describing it.  If
  the file is readable, but not a Storable image return C<undef>.  If
  the file does not exist or is unreadable then croak.
  
  The hash returned has the following elements:
  
  =over
  
  =item C<version>
  
  This returns the file format version.  It is a string like "2.7".
  
  Note that this version number is not the same as the version number of
  the Storable module itself.  For instance Storable v0.7 create files
  in format v2.0 and Storable v2.15 create files in format v2.7.  The
  file format version number only increment when additional features
  that would confuse older versions of the module are added.
  
  Files older than v2.0 will have the one of the version numbers "-1",
  "0" or "1".  No minor number was used at that time.
  
  =item C<version_nv>
  
  This returns the file format version as number.  It is a string like
  "2.007".  This value is suitable for numeric comparisons.
  
  The constant function C<Storable::BIN_VERSION_NV> returns a comparable
  number that represents the highest file version number that this
  version of Storable fully supports (but see discussion of
  C<$Storable::accept_future_minor> above).  The constant
  C<Storable::BIN_WRITE_VERSION_NV> function returns what file version
  is written and might be less than C<Storable::BIN_VERSION_NV> in some
  configurations.
  
  =item C<major>, C<minor>
  
  This also returns the file format version.  If the version is "2.7"
  then major would be 2 and minor would be 7.  The minor element is
  missing for when major is less than 2.
  
  =item C<hdrsize>
  
  The is the number of bytes that the Storable header occupies.
  
  =item C<netorder>
  
  This is TRUE if the image store data in network order.  This means
  that it was created with nstore() or similar.
  
  =item C<byteorder>
  
  This is only present when C<netorder> is FALSE.  It is the
  $Config{byteorder} string of the perl that created this image.  It is
  a string like "1234" (32 bit little endian) or "87654321" (64 bit big
  endian).  This must match the current perl for the image to be
  readable by Storable.
  
  =item C<intsize>, C<longsize>, C<ptrsize>, C<nvsize>
  
  These are only present when C<netorder> is FALSE. These are the sizes of
  various C datatypes of the perl that created this image.  These must
  match the current perl for the image to be readable by Storable.
  
  The C<nvsize> element is only present for file format v2.2 and
  higher.
  
  =item C<file>
  
  The name of the file.
  
  =back
  
  =item $info = Storable::read_magic( $buffer )
  
  =item $info = Storable::read_magic( $buffer, $must_be_file )
  
  The $buffer should be a Storable image or the first few bytes of it.
  If $buffer starts with a Storable header, then a hash describing the
  image is returned, otherwise C<undef> is returned.
  
  The hash has the same structure as the one returned by
  Storable::file_magic().  The C<file> element is true if the image is a
  file image.
  
  If the $must_be_file argument is provided and is TRUE, then return
  C<undef> unless the image looks like it belongs to a file dump.
  
  The maximum size of a Storable header is currently 21 bytes.  If the
  provided $buffer is only the first part of a Storable image it should
  at least be this long to ensure that read_magic() will recognize it as
  such.
  
  =back
  
  =head1 EXAMPLES
  
  Here are some code samples showing a possible usage of Storable:
  
   use Storable qw(store retrieve freeze thaw dclone);
  
   %color = ('Blue' => 0.1, 'Red' => 0.8, 'Black' => 0, 'White' => 1);
  
   store(\%color, 'mycolors') or die "Can't store %a in mycolors!\n";
  
   $colref = retrieve('mycolors');
   die "Unable to retrieve from mycolors!\n" unless defined $colref;
   printf "Blue is still %lf\n", $colref->{'Blue'};
  
   $colref2 = dclone(\%color);
  
   $str = freeze(\%color);
   printf "Serialization of %%color is %d bytes long.\n", length($str);
   $colref3 = thaw($str);
  
  which prints (on my machine):
  
   Blue is still 0.100000
   Serialization of %color is 102 bytes long.
  
  Serialization of CODE references and deserialization in a safe
  compartment:
  
  =for example begin
  
   use Storable qw(freeze thaw);
   use Safe;
   use strict;
   my $safe = new Safe;
          # because of opcodes used in "use strict":
   $safe->permit(qw(:default require));
   local $Storable::Deparse = 1;
   local $Storable::Eval = sub { $safe->reval($_[0]) };
   my $serialized = freeze(sub { 42 });
   my $code = thaw($serialized);
   $code->() == 42;
  
  =for example end
  
  =for example_testing
          is( $code->(), 42 );
  
  =head1 SECURITY WARNING
  
  B<Do not accept Storable documents from untrusted sources!>
  
  Some features of Storable can lead to security vulnerabilities if you
  accept Storable documents from untrusted sources with the default
  flags. Most obviously, the optional (off by default) CODE reference
  serialization feature allows transfer of code to the deserializing
  process. Furthermore, any serialized object will cause Storable to
  helpfully load the module corresponding to the class of the object in
  the deserializing module.  For manipulated module names, this can load
  almost arbitrary code.  Finally, the deserialized object's destructors
  will be invoked when the objects get destroyed in the deserializing
  process. Maliciously crafted Storable documents may put such objects
  in the value of a hash key that is overridden by another key/value
  pair in the same hash, thus causing immediate destructor execution.
  
  To disable blessing objects while thawing/retrieving remove the flag
  C<BLESS_OK> = 2 from C<$Storable::flags> or set the 2nd argument for
  thaw/retrieve to 0.
  
  To disable tieing data while thawing/retrieving remove the flag C<TIE_OK>
  = 4 from C<$Storable::flags> or set the 2nd argument for thaw/retrieve
  to 0.
  
  With the default setting of C<$Storable::flags> = 6, creating or destroying
  random objects, even renamed objects can be controlled by an attacker.
  See CVE-2015-1592 and its metasploit module.
  
  If your application requires accepting data from untrusted sources,
  you are best off with a less powerful and more-likely safe
  serialization format and implementation. If your data is sufficiently
  simple, Cpanel::JSON::XS, Data::MessagePack or Serial are the best
  choices and offers maximum interoperability, but note that Serial is
  unsafe by default.
  
  =head1 WARNING
  
  If you're using references as keys within your hash tables, you're bound
  to be disappointed when retrieving your data. Indeed, Perl stringifies
  references used as hash table keys. If you later wish to access the
  items via another reference stringification (i.e. using the same
  reference that was used for the key originally to record the value into
  the hash table), it will work because both references stringify to the
  same string.
  
  It won't work across a sequence of C<store> and C<retrieve> operations,
  however, because the addresses in the retrieved objects, which are
  part of the stringified references, will probably differ from the
  original addresses. The topology of your structure is preserved,
  but not hidden semantics like those.
  
  On platforms where it matters, be sure to call C<binmode()> on the
  descriptors that you pass to Storable functions.
  
  Storing data canonically that contains large hashes can be
  significantly slower than storing the same data normally, as
  temporary arrays to hold the keys for each hash have to be allocated,
  populated, sorted and freed.  Some tests have shown a halving of the
  speed of storing -- the exact penalty will depend on the complexity of
  your data.  There is no slowdown on retrieval.
  
  =head1 REGULAR EXPRESSIONS
  
  Storable now has experimental support for storing regular expressions,
  but there are significant limitations:
  
  =over
  
  =item *
  
  perl 5.8 or later is required.
  
  =item *
  
  regular expressions with code blocks, ie C</(?{ ... })/> or C</(??{
  ... })/> will throw an exception when thawed.
  
  =item *
  
  regular expression syntax and flags have changed over the history of
  perl, so a regular expression that you freeze in one version of perl
  may fail to thaw or behave differently in another version of perl.
  
  =item *
  
  depending on the version of perl, regular expressions can change in
  behaviour depending on the context, but later perls will bake that
  behaviour into the regexp.
  
  =back
  
  Storable will throw an exception if a frozen regular expression cannot
  be thawed.
  
  =head1 BUGS
  
  You can't store GLOB, FORMLINE, etc.... If you can define semantics
  for those operations, feel free to enhance Storable so that it can
  deal with them.
  
  The store functions will C<croak> if they run into such references
  unless you set C<$Storable::forgive_me> to some C<TRUE> value. In that
  case, the fatal message is converted to a warning and some meaningless
  string is stored instead.
  
  Setting C<$Storable::canonical> may not yield frozen strings that
  compare equal due to possible stringification of numbers. When the
  string version of a scalar exists, it is the form stored; therefore,
  if you happen to use your numbers as strings between two freezing
  operations on the same data structures, you will get different
  results.
  
  When storing doubles in network order, their value is stored as text.
  However, you should also not expect non-numeric floating-point values
  such as infinity and "not a number" to pass successfully through a
  nstore()/retrieve() pair.
  
  As Storable neither knows nor cares about character sets (although it
  does know that characters may be more than eight bits wide), any difference
  in the interpretation of character codes between a host and a target
  system is your problem.  In particular, if host and target use different
  code points to represent the characters used in the text representation
  of floating-point numbers, you will not be able be able to exchange
  floating-point data, even with nstore().
  
  C<Storable::drop_utf8> is a blunt tool.  There is no facility either to
  return B<all> strings as utf8 sequences, or to attempt to convert utf8
  data back to 8 bit and C<croak()> if the conversion fails.
  
  Prior to Storable 2.01, no distinction was made between signed and
  unsigned integers on storing.  By default Storable prefers to store a
  scalars string representation (if it has one) so this would only cause
  problems when storing large unsigned integers that had never been converted
  to string or floating point.  In other words values that had been generated
  by integer operations such as logic ops and then not used in any string or
  arithmetic context before storing.
  
  =head2 64 bit data in perl 5.6.0 and 5.6.1
  
  This section only applies to you if you have existing data written out
  by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which
  has been configured with 64 bit integer support (not the default)
  If you got a precompiled perl, rather than running Configure to build
  your own perl from source, then it almost certainly does not affect you,
  and you can stop reading now (unless you're curious). If you're using perl
  on Windows it does not affect you.
  
  Storable writes a file header which contains the sizes of various C
  language types for the C compiler that built Storable (when not writing in
  network order), and will refuse to load files written by a Storable not
  on the same (or compatible) architecture.  This check and a check on
  machine byteorder is needed because the size of various fields in the file
  are given by the sizes of the C language types, and so files written on
  different architectures are incompatible.  This is done for increased speed.
  (When writing in network order, all fields are written out as standard
  lengths, which allows full interworking, but takes longer to read and write)
  
  Perl 5.6.x introduced the ability to optional configure the perl interpreter
  to use C's C<long long> type to allow scalars to store 64 bit integers on 32
  bit systems.  However, due to the way the Perl configuration system
  generated the C configuration files on non-Windows platforms, and the way
  Storable generates its header, nothing in the Storable file header reflected
  whether the perl writing was using 32 or 64 bit integers, despite the fact
  that Storable was storing some data differently in the file.  Hence Storable
  running on perl with 64 bit integers will read the header from a file
  written by a 32 bit perl, not realise that the data is actually in a subtly
  incompatible format, and then go horribly wrong (possibly crashing) if it
  encountered a stored integer.  This is a design failure.
  
  Storable has now been changed to write out and read in a file header with
  information about the size of integers.  It's impossible to detect whether
  an old file being read in was written with 32 or 64 bit integers (they have
  the same header) so it's impossible to automatically switch to a correct
  backwards compatibility mode.  Hence this Storable defaults to the new,
  correct behaviour.
  
  What this means is that if you have data written by Storable 1.x running
  on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux
  then by default this Storable will refuse to read it, giving the error
  I<Byte order is not compatible>.  If you have such data then you
  should set C<$Storable::interwork_56_64bit> to a true value to make this
  Storable read and write files with the old header.  You should also
  migrate your data, or any older perl you are communicating with, to this
  current version of Storable.
  
  If you don't have data written with specific configuration of perl described
  above, then you do not and should not do anything.  Don't set the flag -
  not only will Storable on an identically configured perl refuse to load them,
  but Storable a differently configured perl will load them believing them
  to be correct for it, and then may well fail or crash part way through
  reading them.
  
  =head1 CREDITS
  
  Thank you to (in chronological order):
  
  	Jarkko Hietaniemi <jhi@iki.fi>
  	Ulrich Pfeifer <pfeifer@charly.informatik.uni-dortmund.de>
  	Benjamin A. Holzman <bholzman@earthlink.net>
  	Andrew Ford <A.Ford@ford-mason.co.uk>
  	Gisle Aas <gisle@aas.no>
  	Jeff Gresham <gresham_jeffrey@jpmorgan.com>
  	Murray Nesbitt <murray@activestate.com>
  	Marc Lehmann <pcg@opengroup.org>
  	Justin Banks <justinb@wamnet.com>
  	Jarkko Hietaniemi <jhi@iki.fi> (AGAIN, as perl 5.7.0 Pumpkin!)
  	Salvador Ortiz Garcia <sog@msg.com.mx>
  	Dominic Dunlop <domo@computer.org>
  	Erik Haugan <erik@solbors.no>
  	Benjamin A. Holzman <ben.holzman@grantstreet.com>
  	Reini Urban <rurban@cpan.org>
  	Todd Rinaldo <toddr@cpanel.net>
  	Aaron Crane <arc@cpan.org>
  
  for their bug reports, suggestions and contributions.
  
  Benjamin Holzman contributed the tied variable support, Andrew Ford
  contributed the canonical order for hashes, and Gisle Aas fixed
  a few misunderstandings of mine regarding the perl internals,
  and optimized the emission of "tags" in the output streams by
  simply counting the objects instead of tagging them (leading to
  a binary incompatibility for the Storable image starting at version
  0.6--older images are, of course, still properly understood).
  Murray Nesbitt made Storable thread-safe.  Marc Lehmann added overloading
  and references to tied items support.  Benjamin Holzman added a performance
  improvement for overloaded classes; thanks to Grant Street Group for footing
  the bill.
  Reini Urban took over maintainance from p5p, and added security fixes
  and huge object support.
  
  =head1 AUTHOR
  
  Storable was written by Raphael Manfredi
  F<E<lt>Raphael_Manfredi@pobox.comE<gt>>
  Maintenance is now done by cperl L<http://perl11.org/cperl>
  
  Please e-mail us with problems, bug fixes, comments and complaints,
  although if you have compliments you should send them to Raphael.
  Please don't e-mail Raphael with problems, as he no longer works on
  Storable, and your message will be delayed while he forwards it to us.
  
  =head1 SEE ALSO
  
  L<Clone>.
  
  =cut
X86_64-LINUX_STORABLE

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.53";
  $VERSION =~ tr/_//d;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If the package the code was compiled in has been deleted
  (e.g. using C<delete_package> from L<Symbol>), C<__ANON__> will be returned as
  the package name. If a name has been set using L</set_subname>, this name will be
  returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_ENCODING';
  # $Id: encoding.pm,v 2.22 2018/02/11 05:32:03 dankogai Exp $
  package encoding;
  our $VERSION = sprintf "%d.%02d", q$Revision: 2.22 $ =~ /(\d+)/g;
  
  use Encode;
  use strict;
  use warnings;
  use Config;
  
  use constant {
      DEBUG => !!$ENV{PERL_ENCODE_DEBUG},
      HAS_PERLIO => eval { require PerlIO::encoding; PerlIO::encoding->VERSION(0.02) },
      PERL_5_21_7 => $^V && $^V ge v5.21.7, # lexically scoped
  };
  
  sub _exception {
      my $name = shift;
      $] > 5.008 and return 0;    # 5.8.1 or higher then no
      my %utfs = map { $_ => 1 }
        qw(utf8 UCS-2BE UCS-2LE UTF-16 UTF-16BE UTF-16LE
        UTF-32 UTF-32BE UTF-32LE);
      $utfs{$name} or return 0;    # UTFs or no
      require Config;
      Config->import();
      our %Config;
      return $Config{perl_patchlevel} ? 0 : 1    # maintperl then no
  }
  
  sub in_locale { $^H & ( $locale::hint_bits || 0 ) }
  
  sub _get_locale_encoding {
      my $locale_encoding;
  
      if ($^O eq 'MSWin32') {
          my @tries = (
              # First try to get the OutputCP. This will work only if we
              # are attached to a console
              'Win32.pm' => 'Win32::GetConsoleOutputCP',
              'Win32/Console.pm' => 'Win32::Console::OutputCP',
              # If above failed, this means that we are a GUI app
              # Let's assume that the ANSI codepage is what matters
              'Win32.pm' => 'Win32::GetACP',
          );
          while (@tries) {
              my $cp = eval {
                  require $tries[0];
                  no strict 'refs';
                  &{$tries[1]}()
              };
              if ($cp) {
                  if ($cp == 65001) { # Code page for UTF-8
                      $locale_encoding = 'UTF-8';
                  } else {
                      $locale_encoding = 'cp' . $cp;
                  }
                  return $locale_encoding;
              }
              splice(@tries, 0, 2)
          }
      }
  
      # I18N::Langinfo isn't available everywhere
      $locale_encoding = eval {
          require I18N::Langinfo;
          find_encoding(
              I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() )
          )->name
      };
      return $locale_encoding if defined $locale_encoding;
  
      eval {
          require POSIX;
          # Get the current locale
          # Remember that MSVCRT impl is quite different from Unixes
          my $locale = POSIX::setlocale(POSIX::LC_CTYPE());
          if ( $locale =~ /^([^.]+)\.([^.@]+)(?:@.*)?$/ ) {
              my $country_language;
              ( $country_language, $locale_encoding ) = ( $1, $2 );
  
              # Could do more heuristics based on the country and language
              # since we have Locale::Country and Locale::Language available.
              # TODO: get a database of Language -> Encoding mappings
              # (the Estonian database at http://www.eki.ee/letter/
              # would be excellent!) --jhi
              if (lc($locale_encoding) eq 'euc') {
                  if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-jp';
                  }
                  elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
                      $locale_encoding = 'euc-kr';
                  }
                  elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)$/i ) {
                      $locale_encoding = 'euc-cn';
                  }
                  elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-tw';
                  }
                  else {
                      require Carp;
                      Carp::croak(
                          "encoding: Locale encoding '$locale_encoding' too ambiguous"
                      );
                  }
              }
          }
      };
  
      return $locale_encoding;
  }
  
  sub import {
  
      if ( ord("A") == 193 ) {
          require Carp;
          Carp::croak("encoding: pragma does not support EBCDIC platforms");
      }
  
      my $deprecate =
          ($] >= 5.017 and !$Config{usecperl})
          ? "Use of the encoding pragma is deprecated" : 0;
  
      my $class = shift;
      my $name  = shift;
      if (!$name){
  	require Carp;
          Carp::croak("encoding: no encoding specified.");
      }
      if ( $name eq ':_get_locale_encoding' ) {    # used by lib/open.pm
          my $caller = caller();
          {
              no strict 'refs';
              *{"${caller}::_get_locale_encoding"} = \&_get_locale_encoding;
          }
          return;
      }
      $name = _get_locale_encoding() if $name eq ':locale';
      BEGIN { strict->unimport('hashpairs') if $] >= 5.027 and $^V =~ /c$/; }
      my %arg = @_;
      $name = $ENV{PERL_ENCODING} unless defined $name;
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("encoding: Unknown encoding '$name'");
      }
      $name = $enc->name;    # canonize
      unless ( $arg{Filter} ) {
          if ($] >= 5.025003 and !$Config{usecperl}) {
              require Carp;
              Carp::croak("The encoding pragma is no longer supported. Check cperl");
          }
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          DEBUG and warn "_exception($name) = ", _exception($name);
          if (! _exception($name)) {
              if (!PERL_5_21_7) {
                  ${^ENCODING} = $enc;
              }
              else {
                  # Starting with 5.21.7, this pragma uses a shadow variable
                  # designed explicitly for it, ${^E_NCODING}, to enforce
                  # lexical scope; instead of ${^ENCODING}.
                  $^H{'encoding'} = 1;
                  ${^E_NCODING} = $enc;
              }
          }
          if (! HAS_PERLIO ) {
              return 1;
          }
      }
      else {
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          defined( ${^ENCODING} ) and undef ${^ENCODING};
          undef ${^E_NCODING} if PERL_5_21_7;
  
          # implicitly 'use utf8'
          require utf8;      # to fetch $utf8::hint_bits;
          $^H |= $utf8::hint_bits;
  
              require Filter::Util::Call;
              Filter::Util::Call->import;
              filter_add(
                  sub {
                      my $status = filter_read();
                      if ( $status > 0 ) {
                          $_ = $enc->decode( $_, 1 );
                          DEBUG and warn $_;
                      }
                      $status;
                  }
              );
      }
      defined ${^UNICODE} and ${^UNICODE} != 0 and return 1;
      for my $h (qw(STDIN STDOUT)) {
          if ( $arg{$h} ) {
              unless ( defined find_encoding( $arg{$h} ) ) {
                  require Carp;
                  Carp::croak(
                      "encoding: Unknown encoding for $h, '$arg{$h}'");
              }
              binmode( $h, ":raw :encoding($arg{$h})" );
          }
          else {
              unless ( exists $arg{$h} ) {
                      no warnings 'uninitialized';
                      binmode( $h, ":raw :encoding($name)" );
              }
          }
      }
      return 1;    # I doubt if we need it, though
  }
  
  sub unimport {
      no warnings;
      undef ${^ENCODING};
      undef ${^E_NCODING} if PERL_5_21_7;
      if (HAS_PERLIO) {
          binmode( STDIN,  ":raw" );
          binmode( STDOUT, ":raw" );
      }
      else {
          binmode(STDIN);
          binmode(STDOUT);
      }
      if ( $INC{"Filter/Util/Call.pm"} ) {
          eval { filter_del() };
      }
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  encoding - allows you to write your script in non-ASCII and non-UTF-8
  
  =head1 WARNING
  
  This module has been deprecated since perl v5.18.  See L</DESCRIPTION> and
  L</BUGS>.
  
  =head1 SYNOPSIS
  
    use encoding "greek";  # Perl like Greek to you?
    use encoding "euc-jp"; # Jperl!
  
    # or you can even do this if your shell supports your native encoding
  
    perl -Mencoding=latin2 -e'...' # Feeling centrally European?
    perl -Mencoding=euc-kr -e'...' # Or Korean?
  
    # more control
  
    # A simple euc-cn => utf-8 converter
    use encoding "euc-cn", STDOUT => "utf8";  while(<>){print};
  
    # "no encoding;" supported
    no encoding;
  
    # an alternate way, Filter
    use encoding "euc-jp", Filter=>1;
    # now you can use kanji identifiers -- in euc-jp!
  
    # encode based on the current locale - specialized purposes only;
    # fraught with danger!!
    use encoding ':locale';
  
  =head1 DESCRIPTION
  
  This pragma is used to enable a Perl script to be written in encodings that
  aren't strictly ASCII nor UTF-8.  It translates all or portions of the Perl
  program script from a given encoding into UTF-8, and changes the PerlIO layers
  of C<STDIN> and C<STDOUT> to the encoding specified.
  
  This pragma dates from the days when UTF-8-enabled editors were uncommon.  But
  that was long ago, and the need for it is greatly diminished.  That, coupled
  with the fact that it doesn't work with threads, along with other problems,
  (see L</BUGS>) have led to its being deprecated.  It is planned to remove this
  pragma in a future Perl version.  New code should be written in UTF-8, and the
  C<use utf8> pragma used instead (see L<perluniintro> and L<utf8> for details).
  Old code should be converted to UTF-8, via something like the recipe in the
  L</SYNOPSIS> (though this simple approach may require manual adjustments
  afterwards).
  
  If UTF-8 is not an option, it is recommended that one use a simple source
  filter, such as that provided by L<Filter::Encoding> on CPAN or this
  pragma's own C<Filter> option (see below).
  
  The only legitimate use of this pragma is almost certainly just one per file,
  near the top, with file scope, as the file is likely going to only be written
  in one encoding.  Further restrictions apply in Perls before v5.22 (see
  L</Prior to Perl v5.22>).
  
  There are two basic modes of operation (plus turning if off):
  
  =over 4
  
  =item C<use encoding ['I<ENCNAME>'] ;>
  
  Please note: This mode of operation is no longer supported as of Perl
  v5.26.
  
  This is the normal operation.  It translates various literals encountered in
  the Perl source file from the encoding I<ENCNAME> into UTF-8, and similarly
  converts character code points.  This is used when the script is a combination
  of ASCII (for the variable names and punctuation, I<etc>), but the literal
  data is in the specified encoding.
  
  I<ENCNAME> is optional.  If omitted, the encoding specified in the environment
  variable L<C<PERL_ENCODING>|perlrun/PERL_ENCODING> is used.  If this isn't
  set, or the resolved-to encoding is not known to C<L<Encode>>, the error
  C<Unknown encoding 'I<ENCNAME>'> will be thrown.
  
  Starting in Perl v5.8.6 (C<Encode> version 2.0.1), I<ENCNAME> may be the
  name C<:locale>.  This is for very specialized applications, and is documented
  in L</The C<:locale> sub-pragma> below.
  
  The literals that are converted are C<q//, qq//, qr//, qw///, qx//>, and
  starting in v5.8.1, C<tr///>.  Operations that do conversions include C<chr>,
  C<ord>, C<utf8::upgrade> (but not C<utf8::downgrade>), and C<chomp>.
  
  Also starting in v5.8.1, the C<DATA> pseudo-filehandle is translated from the
  encoding into UTF-8.
  
  For example, you can write code in EUC-JP as follows:
  
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
                 #<-char-><-char->   # 4 octets
    s/\bCamel\b/$Rakuda/;
  
  And with C<use encoding "euc-jp"> in effect, it is the same thing as
  that code in UTF-8:
  
    my $Rakuda = "\x{99F1}\x{99DD}"; # two Unicode Characters
    s/\bCamel\b/$Rakuda/;
  
  See L</EXAMPLE> below for a more complete example.
  
  Unless C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero, the
  PerlIO layers of C<STDIN> and C<STDOUT> are set to "C<:encoding(I<ENCNAME>)>".
  Therefore,
  
    use encoding "euc-jp";
    my $message = "Camel is the symbol of perl.\n";
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
    $message =~ s/\bCamel\b/$Rakuda/;
    print $message;
  
  will print
  
   "\xF1\xD1\xF1\xCC is the symbol of perl.\n"
  
  not
  
   "\x{99F1}\x{99DD} is the symbol of perl.\n"
  
  You can override this by giving extra arguments; see below.
  
  Note that C<STDERR> WILL NOT be changed, regardless.
  
  Also note that non-STD file handles remain unaffected.  Use C<use
  open> or C<binmode> to change the layers of those.
  
  =item C<use encoding I<ENCNAME>, Filter=E<gt>1;>
  
  This operates as above, but the C<Filter> argument with a non-zero
  value causes the entire script, and not just literals, to be translated from
  the encoding into UTF-8.  This allows identifiers in the source to be in that
  encoding as well.  (Problems may occur if the encoding is not a superset of
  ASCII; imagine all your semi-colons being translated into something
  different.)  One can use this form to make
  
   ${"\x{4eba}"}++
  
  work.  (This is equivalent to C<$I<human>++>, where I<human> is a single Han
  ideograph).
  
  This effectively means that your source code behaves as if it were written in
  UTF-8 with C<'use utf8>' in effect.  So even if your editor only supports
  Shift_JIS, for example, you can still try examples in Chapter 15 of
  C<Programming Perl, 3rd Ed.>.
  
  This option is significantly slower than the other one.
  
  =item C<no encoding;>
  
  Unsets the script encoding. The layers of C<STDIN>, C<STDOUT> are
  reset to "C<:raw>" (the default unprocessed raw stream of bytes).
  
  =back
  
  =head1 OPTIONS
  
  =head2 Setting C<STDIN> and/or C<STDOUT> individually
  
  The encodings of C<STDIN> and C<STDOUT> are individually settable by parameters to
  the pragma:
  
   use encoding 'euc-tw', STDIN => 'greek'  ...;
  
  In this case, you cannot omit the first I<ENCNAME>.  C<< STDIN => undef >>
  turns the I/O transcoding completely off for that filehandle.
  
  When C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero,
  these options will be completely ignored.  See L<perlvar/C<${^UNICODE}>> and
  L<"C<-C>" in perlrun|perlrun/-C [numberE<sol>list]> for details.
  
  =head2 The C<:locale> sub-pragma
  
  Starting in v5.8.6, the encoding name may be C<:locale>.  This means that the
  encoding is taken from the current locale, and not hard-coded by the pragma.
  Since a script really can only be encoded in exactly one encoding, this option
  is dangerous.  It makes sense only if the script itself is written in ASCII,
  and all the possible locales that will be in use when the script is executed
  are supersets of ASCII.  That means that the script itself doesn't get
  changed, but the I/O handles have the specified encoding added, and the
  operations like C<chr> and C<ord> use that encoding.
  
  The logic of finding which locale C<:locale> uses is as follows:
  
  =over 4
  
  =item 1.
  
  If the platform supports the C<langinfo(CODESET)> interface, the codeset
  returned is used as the default encoding for the open pragma.
  
  =item 2.
  
  If 1. didn't work but we are under the locale pragma, the environment
  variables C<LC_ALL> and C<LANG> (in that order) are matched for encodings
  (the part after "C<.>", if any), and if any found, that is used
  as the default encoding for the open pragma.
  
  =item 3.
  
  If 1. and 2. didn't work, the environment variables C<LC_ALL> and C<LANG>
  (in that order) are matched for anything looking like UTF-8, and if
  any found, C<:utf8> is used as the default encoding for the open
  pragma.
  
  =back
  
  If your locale environment variables (C<LC_ALL>, C<LC_CTYPE>, C<LANG>)
  contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
  the default encoding of your C<STDIN>, C<STDOUT>, and C<STDERR>, and of
  B<any subsequent file open>, is UTF-8.
  
  =head1 CAVEATS
  
  =head2 SIDE EFFECTS
  
  =over
  
  =item *
  
  If the C<encoding> pragma is in scope then the lengths returned are
  calculated from the length of C<$/> in Unicode characters, which is not
  always the same as the length of C<$/> in the native encoding.
  
  =item *
  
  Without this pragma, if strings operating under byte semantics and strings
  with Unicode character data are concatenated, the new string will
  be created by decoding the byte strings as I<ISO 8859-1 (Latin-1)>.
  
  The B<encoding> pragma changes this to use the specified encoding
  instead.  For example:
  
      use encoding 'utf8';
      my $string = chr(20000); # a Unicode string
      utf8::encode($string);   # now it's a UTF-8 encoded byte string
      # concatenate with another Unicode string
      print length($string . chr(20000));
  
  Will print C<2>, because C<$string> is upgraded as UTF-8.  Without
  C<use encoding 'utf8';>, it will print C<4> instead, since C<$string>
  is three octets when interpreted as Latin-1.
  
  =back
  
  =head2 DO NOT MIX MULTIPLE ENCODINGS
  
  Notice that only literals (string or regular expression) having only
  legacy code points are affected: if you mix data like this
  
      \x{100}\xDF
      \xDF\x{100}
  
  the data is assumed to be in (Latin 1 and) Unicode, not in your native
  encoding.  In other words, this will match in "greek":
  
      "\xDF" =~ /\x{3af}/
  
  but this will not
  
      "\xDF\x{100}" =~ /\x{3af}\x{100}/
  
  since the C<\xDF> (ISO 8859-7 GREEK SMALL LETTER IOTA WITH TONOS) on
  the left will B<not> be upgraded to C<\x{3af}> (Unicode GREEK SMALL
  LETTER IOTA WITH TONOS) because of the C<\x{100}> on the left.  You
  should not be mixing your legacy data and Unicode in the same string.
  
  This pragma also affects encoding of the 0x80..0xFF code point range:
  normally characters in that range are left as eight-bit bytes (unless
  they are combined with characters with code points 0x100 or larger,
  in which case all characters need to become UTF-8 encoded), but if
  the C<encoding> pragma is present, even the 0x80..0xFF range always
  gets UTF-8 encoded.
  
  After all, the best thing about this pragma is that you don't have to
  resort to \x{....} just to spell your name in a native encoding.
  So feel free to put your strings in your encoding in quotes and
  regexes.
  
  =head2 Prior to Perl v5.22
  
  The pragma was a per script, not a per block lexical.  Only the last
  C<use encoding> or C<no encoding> mattered, and it affected
  B<the whole script>.  However, the C<no encoding> pragma was supported and
  C<use encoding> could appear as many times as you want in a given script
  (though only the last was effective).
  
  Since the scope wasn't lexical, other modules' use of C<chr>, C<ord>, I<etc.>
  were affected.  This leads to spooky, incorrect action at a distance that is
  hard to debug.
  
  This means you would have to be very careful of the load order:
  
    # called module
    package Module_IN_BAR;
    use encoding "bar";
    # stuff in "bar" encoding here
    1;
  
    # caller script
    use encoding "foo"
    use Module_IN_BAR;
    # surprise! use encoding "bar" is in effect.
  
  The best way to avoid this oddity is to use this pragma RIGHT AFTER
  other modules are loaded.  i.e.
  
    use Module_IN_BAR;
    use encoding "foo";
  
  =head2 Prior to Encode version 1.87
  
  =over
  
  =item *
  
  C<STDIN> and C<STDOUT> were not set under the filter option.
  And C<< STDIN=>I<ENCODING> >> and C<< STDOUT=>I<ENCODING> >> didn't work like
  non-filter version.
  
  =item *
  
  C<use utf8> wasn't implicitly declared so you have to C<use utf8> to do
  
   ${"\x{4eba}"}++
  
  =back
  
  =head2 Prior to Perl v5.8.1
  
  =over
  
  =item "NON-EUC" doublebyte encodings
  
  Because perl needs to parse the script before applying this pragma, such
  encodings as Shift_JIS and Big-5 that may contain C<'\'> (BACKSLASH;
  C<\x5c>) in the second byte fail because the second byte may
  accidentally escape the quoting character that follows.
  
  =item C<tr///>
  
  The B<encoding> pragma works by decoding string literals in
  C<q//,qq//,qr//,qw///, qx//> and so forth.  In perl v5.8.0, this
  does not apply to C<tr///>.  Therefore,
  
    use encoding 'euc-jp';
    #....
    $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
    #           -------- -------- -------- --------
  
  Does not work as
  
    $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;
  
  =over
  
  =item Legend of characters above
  
    utf8     euc-jp   charnames::viacode()
    -----------------------------------------
    \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
    \x{3093} \xA4\xF3 HIRAGANA LETTER N
    \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
    \x{30f3} \xA5\xF3 KATAKANA LETTER N
  
  =back
  
  This counterintuitive behavior has been fixed in perl v5.8.1.
  
  In perl v5.8.0, you can work around this as follows;
  
    use encoding 'euc-jp';
    #  ....
    eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };
  
  Note the C<tr//> expression is surrounded by C<qq{}>.  The idea behind
  this is the same as the classic idiom that makes C<tr///> 'interpolate':
  
     tr/$from/$to/;            # wrong!
     eval qq{ tr/$from/$to/ }; # workaround.
  
  =back
  
  =head1 EXAMPLE - Greekperl
  
      use encoding "iso 8859-7";
  
      # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.
  
      $a = "\xDF";
      $b = "\x{100}";
  
      printf "%#x\n", ord($a); # will print 0x3af, not 0xdf
  
      $c = $a . $b;
  
      # $c will be "\x{3af}\x{100}", not "\x{df}\x{100}".
  
      # chr() is affected, and ...
  
      print "mega\n"  if ord(chr(0xdf)) == 0x3af;
  
      # ... ord() is affected by the encoding pragma ...
  
      print "tera\n" if ord(pack("C", 0xdf)) == 0x3af;
  
      # ... as are eq and cmp ...
  
      print "peta\n" if "\x{3af}" eq  pack("C", 0xdf);
      print "exa\n"  if "\x{3af}" cmp pack("C", 0xdf) == 0;
  
      # ... but pack/unpack C are not affected, in case you still
      # want to go back to your native encoding
  
      print "zetta\n" if unpack("C", (pack("C", 0xdf))) == 0xdf;
  
  =head1 BUGS
  
  =over
  
  =item Thread safety
  
  C<use encoding ...> is not thread-safe (i.e., do not use in threaded
  applications).
  
  =item Can't be used by more than one module in a single program.
  
  Only one encoding is allowed.  If you combine modules in a program that have
  different encodings, only one will be actually used.
  
  =item Other modules using C<STDIN> and C<STDOUT> get the encoded stream
  
  They may be expecting something completely different.
  
  =item literals in regex that are longer than 127 bytes
  
  For native multibyte encodings (either fixed or variable length),
  the current implementation of the regular expressions may introduce
  recoding errors for regular expression literals longer than 127 bytes.
  
  =item EBCDIC
  
  The encoding pragma is not supported on EBCDIC platforms.
  
  =item C<format>
  
  This pragma doesn't work well with C<format> because PerlIO does not
  get along very well with it.  When C<format> contains non-ASCII
  characters it prints funny or gets "wide character warnings".
  To understand it, try the code below.
  
    # Save this one in utf8
    # replace *non-ascii* with a non-ascii string
    my $camel;
    format STDOUT =
    *non-ascii*@>>>>>>>
    $camel
    .
    $camel = "*non-ascii*";
    binmode(STDOUT=>':encoding(utf8)'); # bang!
    write;              # funny
    print $camel, "\n"; # fine
  
  Without binmode this happens to work but without binmode, print()
  fails instead of write().
  
  At any rate, the very use of C<format> is questionable when it comes to
  unicode characters since you have to consider such things as character
  width (i.e. double-width for ideographs) and directions (i.e. BIDI for
  Arabic and Hebrew).
  
  =item See also L</CAVEATS>
  
  =back
  
  =head1 HISTORY
  
  This pragma first appeared in Perl v5.8.0.  It has been enhanced in later
  releases as specified above.
  
  =head1 SEE ALSO
  
  L<perlunicode>, L<Encode>, L<open>, L<Filter::Util::Call>,
  
  Ch. 15 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
X86_64-LINUX_ENCODING

$fatpacked{"x86_64-linux/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  our $VERSION = 0.9924;
  our $CLASS = 'version';
  our (@ISA, $STRICT, $LAX);
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
X86_64-LINUX_VERSION

$fatpacked{"x86_64-linux/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  our $VERSION = 0.9924;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  our $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  our $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  our $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  our $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  our $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  our $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
X86_64-LINUX_VERSION_REGEX

$fatpacked{"x86_64-linux/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vpp';
  our ($LAX, $STRICT, $WARN_CATEGORY);
  
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
X86_64-LINUX_VERSION_VPP

$fatpacked{"x86_64-linux/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  our $VERSION = 0.9924;
  our $CLASS = 'version::vxs';
  our @ISA;
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
X86_64-LINUX_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/home/autarch/perl5/perlbrew/perls/perl-5.26.2/bin/perl

package
  patchperl;
# ABSTRACT: patch a perl source tree

use strict;
use warnings;
use Devel::PatchPerl;

Devel::PatchPerl->patch_source($ARGV[1], $ARGV[0]);

__END__

=pod

=encoding UTF-8

=head1 NAME

patchperl - patch a perl source tree

=head1 VERSION

version 1.78

=head1 AUTHOR

Chris Williams <chris@bingosnet.co.uk>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2019 by Chris Williams and Marcus Holland-Moritz.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
